{"ast":null,"code":"import Cartesian4 from \"../Core/Cartesian4.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport mergeSort from \"../Core/mergeSort.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMagnificationFilter from \"../Renderer/TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\nimport Material from \"./Material.js\";\nvar scratchColor = new Color();\nvar scratchColorAbove = new Color();\nvar scratchColorBelow = new Color();\nvar scratchColorBlend = new Color();\nvar scratchPackedFloat = new Cartesian4();\nvar scratchColorBytes = new Uint8Array(4);\n\nfunction lerpEntryColor(height, entryBefore, entryAfter, result) {\n  var lerpFactor = entryBefore.height === entryAfter.height ? 0.0 : (height - entryBefore.height) / (entryAfter.height - entryBefore.height);\n  return Color.lerp(entryBefore.color, entryAfter.color, lerpFactor, result);\n}\n\nfunction createNewEntry(height, color) {\n  return {\n    height: height,\n    color: Color.clone(color)\n  };\n}\n\nfunction removeDuplicates(entries) {\n  // This function expects entries to be sorted from lowest to highest.\n  // Remove entries that have the same height as before and after.\n  entries = entries.filter(function (entry, index, array) {\n    var hasPrev = index > 0;\n    var hasNext = index < array.length - 1;\n    var sameHeightAsPrev = hasPrev ? entry.height === array[index - 1].height : true;\n    var sameHeightAsNext = hasNext ? entry.height === array[index + 1].height : true;\n    var keep = !sameHeightAsPrev || !sameHeightAsNext;\n    return keep;\n  }); // Remove entries that have the same color as before and after.\n\n  entries = entries.filter(function (entry, index, array) {\n    var hasPrev = index > 0;\n    var hasNext = index < array.length - 1;\n    var sameColorAsPrev = hasPrev ? Color.equals(entry.color, array[index - 1].color) : false;\n    var sameColorAsNext = hasNext ? Color.equals(entry.color, array[index + 1].color) : false;\n    var keep = !sameColorAsPrev || !sameColorAsNext;\n    return keep;\n  }); // Also remove entries that have the same height AND color as the entry before.\n\n  entries = entries.filter(function (entry, index, array) {\n    var hasPrev = index > 0;\n    var sameColorAsPrev = hasPrev ? Color.equals(entry.color, array[index - 1].color) : false;\n    var sameHeightAsPrev = hasPrev ? entry.height === array[index - 1].height : true;\n    var keep = !sameColorAsPrev || !sameHeightAsPrev;\n    return keep;\n  });\n  return entries;\n}\n\nfunction preprocess(layers) {\n  var i, j;\n  var layeredEntries = [];\n  var layersLength = layers.length;\n\n  for (i = 0; i < layersLength; i++) {\n    var layer = layers[i];\n    var entriesOrig = layer.entries;\n    var entriesLength = entriesOrig.length; //>>includeStart('debug', pragmas.debug);\n\n    if (!Array.isArray(entriesOrig) || entriesLength === 0) {\n      throw new DeveloperError(\"entries must be an array with size > 0.\");\n    } //>>includeEnd('debug');\n\n\n    var entries = [];\n\n    for (j = 0; j < entriesLength; j++) {\n      var entryOrig = entriesOrig[j]; //>>includeStart('debug', pragmas.debug);\n\n      if (!defined(entryOrig.height)) {\n        throw new DeveloperError(\"entry requires a height.\");\n      }\n\n      if (!defined(entryOrig.color)) {\n        throw new DeveloperError(\"entry requires a color.\");\n      } //>>includeEnd('debug');\n\n\n      var height = CesiumMath.clamp(entryOrig.height, createElevationBandMaterial._minimumHeight, createElevationBandMaterial._maximumHeight); // premultiplied alpha\n\n      var color = Color.clone(entryOrig.color, scratchColor);\n      color.red *= color.alpha;\n      color.green *= color.alpha;\n      color.blue *= color.alpha;\n      entries.push(createNewEntry(height, color));\n    }\n\n    var sortedAscending = true;\n    var sortedDescending = true;\n\n    for (j = 0; j < entriesLength - 1; j++) {\n      var currEntry = entries[j + 0];\n      var nextEntry = entries[j + 1];\n      sortedAscending = sortedAscending && currEntry.height <= nextEntry.height;\n      sortedDescending = sortedDescending && currEntry.height >= nextEntry.height;\n    } // When the array is fully descending, reverse it.\n\n\n    if (sortedDescending) {\n      entries = entries.reverse();\n    } else if (!sortedAscending) {\n      // Stable sort from lowest to greatest height.\n      mergeSort(entries, function (a, b) {\n        return CesiumMath.sign(a.height - b.height);\n      });\n    }\n\n    var extendDownwards = defaultValue(layer.extendDownwards, false);\n    var extendUpwards = defaultValue(layer.extendUpwards, false); // Interpret a single entry to extend all the way up and down.\n\n    if (entries.length === 1 && !extendDownwards && !extendUpwards) {\n      extendDownwards = true;\n      extendUpwards = true;\n    }\n\n    if (extendDownwards) {\n      entries.splice(0, 0, createNewEntry(createElevationBandMaterial._minimumHeight, entries[0].color));\n    }\n\n    if (extendUpwards) {\n      entries.splice(entries.length, 0, createNewEntry(createElevationBandMaterial._maximumHeight, entries[entries.length - 1].color));\n    }\n\n    entries = removeDuplicates(entries);\n    layeredEntries.push(entries);\n  }\n\n  return layeredEntries;\n}\n\nfunction createLayeredEntries(layers) {\n  // clean up the input data and check for errors\n  var layeredEntries = preprocess(layers);\n  var entriesAccumNext = [];\n  var entriesAccumCurr = [];\n  var i;\n\n  function addEntry(height, color) {\n    entriesAccumNext.push(createNewEntry(height, color));\n  }\n\n  function addBlendEntry(height, a, b) {\n    var result = Color.multiplyByScalar(b, 1.0 - a.alpha, scratchColorBlend);\n    result = Color.add(result, a, result);\n    addEntry(height, result);\n  } // alpha blend new layers on top of old ones\n\n\n  var layerLength = layeredEntries.length;\n\n  for (i = 0; i < layerLength; i++) {\n    var entries = layeredEntries[i];\n    var idx = 0;\n    var accumIdx = 0; // swap the arrays\n\n    entriesAccumCurr = entriesAccumNext;\n    entriesAccumNext = [];\n    var entriesLength = entries.length;\n    var entriesAccumLength = entriesAccumCurr.length;\n\n    while (idx < entriesLength || accumIdx < entriesAccumLength) {\n      var entry = idx < entriesLength ? entries[idx] : undefined;\n      var prevEntry = idx > 0 ? entries[idx - 1] : undefined;\n      var nextEntry = idx < entriesLength - 1 ? entries[idx + 1] : undefined;\n      var entryAccum = accumIdx < entriesAccumLength ? entriesAccumCurr[accumIdx] : undefined;\n      var prevEntryAccum = accumIdx > 0 ? entriesAccumCurr[accumIdx - 1] : undefined;\n      var nextEntryAccum = accumIdx < entriesAccumLength - 1 ? entriesAccumCurr[accumIdx + 1] : undefined;\n\n      if (defined(entry) && defined(entryAccum) && entry.height === entryAccum.height) {\n        // New entry directly on top of accum entry\n        var isSplitAccum = defined(nextEntryAccum) && entryAccum.height === nextEntryAccum.height;\n        var isStartAccum = !defined(prevEntryAccum);\n        var isEndAccum = !defined(nextEntryAccum);\n        var isSplit = defined(nextEntry) && entry.height === nextEntry.height;\n        var isStart = !defined(prevEntry);\n        var isEnd = !defined(nextEntry);\n\n        if (isSplitAccum) {\n          if (isSplit) {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n            addBlendEntry(entry.height, nextEntry.color, nextEntryAccum.color);\n          } else if (isStart) {\n            addEntry(entry.height, entryAccum.color);\n            addBlendEntry(entry.height, entry.color, nextEntryAccum.color);\n          } else if (isEnd) {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n            addEntry(entry.height, nextEntryAccum.color);\n          } else {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n            addBlendEntry(entry.height, entry.color, nextEntryAccum.color);\n          }\n        } else if (isStartAccum) {\n          if (isSplit) {\n            addEntry(entry.height, entry.color);\n            addBlendEntry(entry.height, nextEntry.color, entryAccum.color);\n          } else if (isEnd) {\n            addEntry(entry.height, entry.color);\n            addEntry(entry.height, entryAccum.color);\n          } else if (isStart) {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n          } else {\n            addEntry(entry.height, entry.color);\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n          }\n        } else if (isEndAccum) {\n          if (isSplit) {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n            addEntry(entry.height, nextEntry.color);\n          } else if (isStart) {\n            addEntry(entry.height, entryAccum.color);\n            addEntry(entry.height, entry.color);\n          } else if (isEnd) {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n          } else {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n            addEntry(entry.height, entry.color);\n          }\n        } else {\n          // eslint-disable-next-line no-lonely-if\n          if (isSplit) {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n            addBlendEntry(entry.height, nextEntry.color, entryAccum.color);\n          } else if (isStart) {\n            addEntry(entry.height, entryAccum.color);\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n          } else if (isEnd) {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n            addEntry(entry.height, entryAccum.color);\n          } else {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n          }\n        }\n\n        idx += isSplit ? 2 : 1;\n        accumIdx += isSplitAccum ? 2 : 1;\n      } else if (defined(entry) && defined(entryAccum) && defined(prevEntryAccum) && entry.height < entryAccum.height) {\n        // New entry between two accum entries\n        var colorBelow = lerpEntryColor(entry.height, prevEntryAccum, entryAccum, scratchColorBelow);\n\n        if (!defined(prevEntry)) {\n          addEntry(entry.height, colorBelow);\n          addBlendEntry(entry.height, entry.color, colorBelow);\n        } else if (!defined(nextEntry)) {\n          addBlendEntry(entry.height, entry.color, colorBelow);\n          addEntry(entry.height, colorBelow);\n        } else {\n          addBlendEntry(entry.height, entry.color, colorBelow);\n        }\n\n        idx++;\n      } else if (defined(entryAccum) && defined(entry) && defined(prevEntry) && entryAccum.height < entry.height) {\n        // Accum entry between two new entries\n        var colorAbove = lerpEntryColor(entryAccum.height, prevEntry, entry, scratchColorAbove);\n\n        if (!defined(prevEntryAccum)) {\n          addEntry(entryAccum.height, colorAbove);\n          addBlendEntry(entryAccum.height, colorAbove, entryAccum.color);\n        } else if (!defined(nextEntryAccum)) {\n          addBlendEntry(entryAccum.height, colorAbove, entryAccum.color);\n          addEntry(entryAccum.height, colorAbove);\n        } else {\n          addBlendEntry(entryAccum.height, colorAbove, entryAccum.color);\n        }\n\n        accumIdx++;\n      } else if (defined(entry) && (!defined(entryAccum) || entry.height < entryAccum.height)) {\n        // New entry completely before or completely after accum entries\n        if (defined(entryAccum) && !defined(prevEntryAccum) && !defined(nextEntry)) {\n          // Insert blank gap between last entry and first accum entry\n          addEntry(entry.height, entry.color);\n          addEntry(entry.height, createElevationBandMaterial._emptyColor);\n          addEntry(entryAccum.height, createElevationBandMaterial._emptyColor);\n        } else if (!defined(entryAccum) && defined(prevEntryAccum) && !defined(prevEntry)) {\n          // Insert blank gap between last accum entry and first entry\n          addEntry(prevEntryAccum.height, createElevationBandMaterial._emptyColor);\n          addEntry(entry.height, createElevationBandMaterial._emptyColor);\n          addEntry(entry.height, entry.color);\n        } else {\n          addEntry(entry.height, entry.color);\n        }\n\n        idx++;\n      } else if (defined(entryAccum) && (!defined(entry) || entryAccum.height < entry.height)) {\n        // Accum entry completely before or completely after new entries\n        addEntry(entryAccum.height, entryAccum.color);\n        accumIdx++;\n      }\n    }\n  } // one final cleanup pass in case duplicate colors show up in the final result\n\n\n  var allEntries = removeDuplicates(entriesAccumNext);\n  return allEntries;\n}\n/**\n * @typedef createElevationBandMaterialEntry\n *\n * @property {Number} height The height.\n * @property {Color} color The color at this height.\n */\n\n/**\n * @typedef createElevationBandMaterialBand\n *\n * @property {createElevationBandMaterialEntry[]} entries A list of elevation entries. They will automatically be sorted from lowest to highest. If there is only one entry and <code>extendsDownards</code> and <code>extendUpwards</code> are both <code>false</code>, they will both be set to <code>true</code>.\n * @property {Boolean} [extendDownwards=false] If <code>true</code>, the band's minimum elevation color will extend infinitely downwards.\n * @property {Boolean} [extendUpwards=false] If <code>true</code>, the band's maximum elevation color will extend infinitely upwards.\n */\n\n/**\n * Creates a {@link Material} that combines multiple layers of color/gradient bands and maps them to terrain heights.\n *\n * The shader does a binary search over all the heights to find out which colors are above and below a given height, and\n * interpolates between them for the final color. This material supports hundreds of entries relatively cheaply.\n *\n * @function createElevationBandMaterial\n *\n * @param {Object} options Object with the following properties:\n * @param {Scene} options.scene The scene where the visualization is taking place.\n * @param {createElevationBandMaterialBand[]} options.layers A list of bands ordered from lowest to highest precedence.\n * @returns {Material} A new {@link Material} instance.\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Elevation%20Band%20Material.html|Cesium Sandcastle Elevation Band Demo}\n *\n * @example\n * scene.globe.material = Cesium.createElevationBandMaterial({\n *     scene : scene,\n *     layers : [{\n *         entries : [{\n *             height : 4200.0,\n *             color : new Cesium.Color(0.0, 0.0, 0.0, 1.0)\n *         }, {\n *             height : 8848.0,\n *             color : new Cesium.Color(1.0, 1.0, 1.0, 1.0)\n *         }],\n *         extendDownwards : true,\n *         extendUpwards : true,\n *     }, {\n *         entries : [{\n *             height : 7000.0,\n *             color : new Cesium.Color(1.0, 0.0, 0.0, 0.5)\n *         }, {\n *             height : 7100.0,\n *             color : new Cesium.Color(1.0, 0.0, 0.0, 0.5)\n *         }]\n *     }]\n * });\n */\n\n\nfunction createElevationBandMaterial(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var scene = options.scene;\n  var layers = options.layers; //>>includeStart('debug', pragmas.debug);\n\n  Check.typeOf.object(\"options.scene\", scene);\n  Check.defined(\"options.layers\", layers);\n  Check.typeOf.number.greaterThan(\"options.layers.length\", layers.length, 0); //>>includeEnd('debug');\n\n  var entries = createLayeredEntries(layers);\n  var entriesLength = entries.length;\n  var i;\n  var heightTexBuffer;\n  var heightTexDatatype;\n  var heightTexFormat;\n  var isPackedHeight = !createElevationBandMaterial._useFloatTexture(scene.context);\n\n  if (isPackedHeight) {\n    heightTexDatatype = PixelDatatype.UNSIGNED_BYTE;\n    heightTexFormat = PixelFormat.RGBA;\n    heightTexBuffer = new Uint8Array(entriesLength * 4);\n\n    for (i = 0; i < entriesLength; i++) {\n      Cartesian4.packFloat(entries[i].height, scratchPackedFloat);\n      Cartesian4.pack(scratchPackedFloat, heightTexBuffer, i * 4);\n    }\n  } else {\n    heightTexDatatype = PixelDatatype.FLOAT;\n    heightTexFormat = PixelFormat.LUMINANCE;\n    heightTexBuffer = new Float32Array(entriesLength);\n\n    for (i = 0; i < entriesLength; i++) {\n      heightTexBuffer[i] = entries[i].height;\n    }\n  }\n\n  var heightsTex = Texture.create({\n    context: scene.context,\n    pixelFormat: heightTexFormat,\n    pixelDatatype: heightTexDatatype,\n    source: {\n      arrayBufferView: heightTexBuffer,\n      width: entriesLength,\n      height: 1\n    },\n    sampler: new Sampler({\n      wrapS: TextureWrap.CLAMP_TO_EDGE,\n      wrapT: TextureWrap.CLAMP_TO_EDGE,\n      minificationFilter: TextureMinificationFilter.NEAREST,\n      magnificationFilter: TextureMagnificationFilter.NEAREST\n    })\n  });\n  var colorsArray = new Uint8Array(entriesLength * 4);\n\n  for (i = 0; i < entriesLength; i++) {\n    var color = entries[i].color;\n    color.toBytes(scratchColorBytes);\n    colorsArray[i * 4 + 0] = scratchColorBytes[0];\n    colorsArray[i * 4 + 1] = scratchColorBytes[1];\n    colorsArray[i * 4 + 2] = scratchColorBytes[2];\n    colorsArray[i * 4 + 3] = scratchColorBytes[3];\n  }\n\n  var colorsTex = Texture.create({\n    context: scene.context,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n    source: {\n      arrayBufferView: colorsArray,\n      width: entriesLength,\n      height: 1\n    },\n    sampler: new Sampler({\n      wrapS: TextureWrap.CLAMP_TO_EDGE,\n      wrapT: TextureWrap.CLAMP_TO_EDGE,\n      minificationFilter: TextureMinificationFilter.LINEAR,\n      magnificationFilter: TextureMagnificationFilter.LINEAR\n    })\n  });\n  var material = Material.fromType(\"ElevationBand\", {\n    heights: heightsTex,\n    colors: colorsTex\n  });\n  return material;\n}\n/**\n * Function for checking if the context will allow floating point textures for heights.\n *\n * @param {Context} context The {@link Context}.\n * @returns {Boolean} <code>true</code> if floating point textures can be used for heights.\n * @private\n */\n\n\ncreateElevationBandMaterial._useFloatTexture = function (context) {\n  return context.floatingPointTexture;\n};\n/**\n * This is the height that gets stored in the texture when using extendUpwards.\n * There's nothing special about it, it's just a really big number.\n * @private\n */\n\n\ncreateElevationBandMaterial._maximumHeight = +5906376425472;\n/**\n * This is the height that gets stored in the texture when using extendDownwards.\n * There's nothing special about it, it's just a really big number.\n * @private\n */\n\ncreateElevationBandMaterial._minimumHeight = -5906376425472;\n/**\n * Color used to create empty space in the color texture\n * @private\n */\n\ncreateElevationBandMaterial._emptyColor = new Color(0.0, 0.0, 0.0, 0.0);\nexport default createElevationBandMaterial;","map":{"version":3,"sources":["/home/usuario/davi/thalamus/wms/3dmaptestes/leaflet_cesium/client/node_modules/cesium/Source/Scene/createElevationBandMaterial.js"],"names":["Cartesian4","CesiumMath","Check","Color","defaultValue","defined","DeveloperError","mergeSort","PixelFormat","PixelDatatype","Sampler","Texture","TextureMagnificationFilter","TextureMinificationFilter","TextureWrap","Material","scratchColor","scratchColorAbove","scratchColorBelow","scratchColorBlend","scratchPackedFloat","scratchColorBytes","Uint8Array","lerpEntryColor","height","entryBefore","entryAfter","result","lerpFactor","lerp","color","createNewEntry","clone","removeDuplicates","entries","filter","entry","index","array","hasPrev","hasNext","length","sameHeightAsPrev","sameHeightAsNext","keep","sameColorAsPrev","equals","sameColorAsNext","preprocess","layers","i","j","layeredEntries","layersLength","layer","entriesOrig","entriesLength","Array","isArray","entryOrig","clamp","createElevationBandMaterial","_minimumHeight","_maximumHeight","red","alpha","green","blue","push","sortedAscending","sortedDescending","currEntry","nextEntry","reverse","a","b","sign","extendDownwards","extendUpwards","splice","createLayeredEntries","entriesAccumNext","entriesAccumCurr","addEntry","addBlendEntry","multiplyByScalar","add","layerLength","idx","accumIdx","entriesAccumLength","undefined","prevEntry","entryAccum","prevEntryAccum","nextEntryAccum","isSplitAccum","isStartAccum","isEndAccum","isSplit","isStart","isEnd","colorBelow","colorAbove","_emptyColor","allEntries","options","EMPTY_OBJECT","scene","typeOf","object","number","greaterThan","heightTexBuffer","heightTexDatatype","heightTexFormat","isPackedHeight","_useFloatTexture","context","UNSIGNED_BYTE","RGBA","packFloat","pack","FLOAT","LUMINANCE","Float32Array","heightsTex","create","pixelFormat","pixelDatatype","source","arrayBufferView","width","sampler","wrapS","CLAMP_TO_EDGE","wrapT","minificationFilter","NEAREST","magnificationFilter","colorsArray","toBytes","colorsTex","LINEAR","material","fromType","heights","colors","floatingPointTexture"],"mappings":"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","sourcesContent":["import Cartesian4 from \"../Core/Cartesian4.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Check from \"../Core/Check.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport mergeSort from \"../Core/mergeSort.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport PixelDatatype from \"../Renderer/PixelDatatype.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMagnificationFilter from \"../Renderer/TextureMagnificationFilter.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\nimport Material from \"./Material.js\";\n\nvar scratchColor = new Color();\nvar scratchColorAbove = new Color();\nvar scratchColorBelow = new Color();\nvar scratchColorBlend = new Color();\nvar scratchPackedFloat = new Cartesian4();\nvar scratchColorBytes = new Uint8Array(4);\n\nfunction lerpEntryColor(height, entryBefore, entryAfter, result) {\n  var lerpFactor =\n    entryBefore.height === entryAfter.height\n      ? 0.0\n      : (height - entryBefore.height) /\n        (entryAfter.height - entryBefore.height);\n  return Color.lerp(entryBefore.color, entryAfter.color, lerpFactor, result);\n}\n\nfunction createNewEntry(height, color) {\n  return {\n    height: height,\n    color: Color.clone(color),\n  };\n}\n\nfunction removeDuplicates(entries) {\n  // This function expects entries to be sorted from lowest to highest.\n\n  // Remove entries that have the same height as before and after.\n  entries = entries.filter(function (entry, index, array) {\n    var hasPrev = index > 0;\n    var hasNext = index < array.length - 1;\n\n    var sameHeightAsPrev = hasPrev\n      ? entry.height === array[index - 1].height\n      : true;\n    var sameHeightAsNext = hasNext\n      ? entry.height === array[index + 1].height\n      : true;\n\n    var keep = !sameHeightAsPrev || !sameHeightAsNext;\n    return keep;\n  });\n\n  // Remove entries that have the same color as before and after.\n  entries = entries.filter(function (entry, index, array) {\n    var hasPrev = index > 0;\n    var hasNext = index < array.length - 1;\n\n    var sameColorAsPrev = hasPrev\n      ? Color.equals(entry.color, array[index - 1].color)\n      : false;\n    var sameColorAsNext = hasNext\n      ? Color.equals(entry.color, array[index + 1].color)\n      : false;\n\n    var keep = !sameColorAsPrev || !sameColorAsNext;\n    return keep;\n  });\n\n  // Also remove entries that have the same height AND color as the entry before.\n  entries = entries.filter(function (entry, index, array) {\n    var hasPrev = index > 0;\n\n    var sameColorAsPrev = hasPrev\n      ? Color.equals(entry.color, array[index - 1].color)\n      : false;\n\n    var sameHeightAsPrev = hasPrev\n      ? entry.height === array[index - 1].height\n      : true;\n\n    var keep = !sameColorAsPrev || !sameHeightAsPrev;\n    return keep;\n  });\n\n  return entries;\n}\n\nfunction preprocess(layers) {\n  var i, j;\n\n  var layeredEntries = [];\n\n  var layersLength = layers.length;\n  for (i = 0; i < layersLength; i++) {\n    var layer = layers[i];\n    var entriesOrig = layer.entries;\n    var entriesLength = entriesOrig.length;\n\n    //>>includeStart('debug', pragmas.debug);\n    if (!Array.isArray(entriesOrig) || entriesLength === 0) {\n      throw new DeveloperError(\"entries must be an array with size > 0.\");\n    }\n    //>>includeEnd('debug');\n\n    var entries = [];\n\n    for (j = 0; j < entriesLength; j++) {\n      var entryOrig = entriesOrig[j];\n\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(entryOrig.height)) {\n        throw new DeveloperError(\"entry requires a height.\");\n      }\n      if (!defined(entryOrig.color)) {\n        throw new DeveloperError(\"entry requires a color.\");\n      }\n      //>>includeEnd('debug');\n\n      var height = CesiumMath.clamp(\n        entryOrig.height,\n        createElevationBandMaterial._minimumHeight,\n        createElevationBandMaterial._maximumHeight\n      );\n\n      // premultiplied alpha\n      var color = Color.clone(entryOrig.color, scratchColor);\n      color.red *= color.alpha;\n      color.green *= color.alpha;\n      color.blue *= color.alpha;\n\n      entries.push(createNewEntry(height, color));\n    }\n\n    var sortedAscending = true;\n    var sortedDescending = true;\n    for (j = 0; j < entriesLength - 1; j++) {\n      var currEntry = entries[j + 0];\n      var nextEntry = entries[j + 1];\n\n      sortedAscending = sortedAscending && currEntry.height <= nextEntry.height;\n      sortedDescending =\n        sortedDescending && currEntry.height >= nextEntry.height;\n    }\n\n    // When the array is fully descending, reverse it.\n    if (sortedDescending) {\n      entries = entries.reverse();\n    } else if (!sortedAscending) {\n      // Stable sort from lowest to greatest height.\n      mergeSort(entries, function (a, b) {\n        return CesiumMath.sign(a.height - b.height);\n      });\n    }\n\n    var extendDownwards = defaultValue(layer.extendDownwards, false);\n    var extendUpwards = defaultValue(layer.extendUpwards, false);\n\n    // Interpret a single entry to extend all the way up and down.\n    if (entries.length === 1 && !extendDownwards && !extendUpwards) {\n      extendDownwards = true;\n      extendUpwards = true;\n    }\n\n    if (extendDownwards) {\n      entries.splice(\n        0,\n        0,\n        createNewEntry(\n          createElevationBandMaterial._minimumHeight,\n          entries[0].color\n        )\n      );\n    }\n    if (extendUpwards) {\n      entries.splice(\n        entries.length,\n        0,\n        createNewEntry(\n          createElevationBandMaterial._maximumHeight,\n          entries[entries.length - 1].color\n        )\n      );\n    }\n\n    entries = removeDuplicates(entries);\n\n    layeredEntries.push(entries);\n  }\n\n  return layeredEntries;\n}\n\nfunction createLayeredEntries(layers) {\n  // clean up the input data and check for errors\n  var layeredEntries = preprocess(layers);\n\n  var entriesAccumNext = [];\n  var entriesAccumCurr = [];\n  var i;\n\n  function addEntry(height, color) {\n    entriesAccumNext.push(createNewEntry(height, color));\n  }\n  function addBlendEntry(height, a, b) {\n    var result = Color.multiplyByScalar(b, 1.0 - a.alpha, scratchColorBlend);\n    result = Color.add(result, a, result);\n    addEntry(height, result);\n  }\n\n  // alpha blend new layers on top of old ones\n  var layerLength = layeredEntries.length;\n  for (i = 0; i < layerLength; i++) {\n    var entries = layeredEntries[i];\n    var idx = 0;\n    var accumIdx = 0;\n\n    // swap the arrays\n    entriesAccumCurr = entriesAccumNext;\n    entriesAccumNext = [];\n\n    var entriesLength = entries.length;\n    var entriesAccumLength = entriesAccumCurr.length;\n    while (idx < entriesLength || accumIdx < entriesAccumLength) {\n      var entry = idx < entriesLength ? entries[idx] : undefined;\n      var prevEntry = idx > 0 ? entries[idx - 1] : undefined;\n      var nextEntry = idx < entriesLength - 1 ? entries[idx + 1] : undefined;\n\n      var entryAccum =\n        accumIdx < entriesAccumLength ? entriesAccumCurr[accumIdx] : undefined;\n      var prevEntryAccum =\n        accumIdx > 0 ? entriesAccumCurr[accumIdx - 1] : undefined;\n      var nextEntryAccum =\n        accumIdx < entriesAccumLength - 1\n          ? entriesAccumCurr[accumIdx + 1]\n          : undefined;\n\n      if (\n        defined(entry) &&\n        defined(entryAccum) &&\n        entry.height === entryAccum.height\n      ) {\n        // New entry directly on top of accum entry\n        var isSplitAccum =\n          defined(nextEntryAccum) &&\n          entryAccum.height === nextEntryAccum.height;\n        var isStartAccum = !defined(prevEntryAccum);\n        var isEndAccum = !defined(nextEntryAccum);\n\n        var isSplit = defined(nextEntry) && entry.height === nextEntry.height;\n        var isStart = !defined(prevEntry);\n        var isEnd = !defined(nextEntry);\n\n        if (isSplitAccum) {\n          if (isSplit) {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n            addBlendEntry(entry.height, nextEntry.color, nextEntryAccum.color);\n          } else if (isStart) {\n            addEntry(entry.height, entryAccum.color);\n            addBlendEntry(entry.height, entry.color, nextEntryAccum.color);\n          } else if (isEnd) {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n            addEntry(entry.height, nextEntryAccum.color);\n          } else {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n            addBlendEntry(entry.height, entry.color, nextEntryAccum.color);\n          }\n        } else if (isStartAccum) {\n          if (isSplit) {\n            addEntry(entry.height, entry.color);\n            addBlendEntry(entry.height, nextEntry.color, entryAccum.color);\n          } else if (isEnd) {\n            addEntry(entry.height, entry.color);\n            addEntry(entry.height, entryAccum.color);\n          } else if (isStart) {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n          } else {\n            addEntry(entry.height, entry.color);\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n          }\n        } else if (isEndAccum) {\n          if (isSplit) {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n            addEntry(entry.height, nextEntry.color);\n          } else if (isStart) {\n            addEntry(entry.height, entryAccum.color);\n            addEntry(entry.height, entry.color);\n          } else if (isEnd) {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n          } else {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n            addEntry(entry.height, entry.color);\n          }\n        } else {\n          // eslint-disable-next-line no-lonely-if\n          if (isSplit) {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n            addBlendEntry(entry.height, nextEntry.color, entryAccum.color);\n          } else if (isStart) {\n            addEntry(entry.height, entryAccum.color);\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n          } else if (isEnd) {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n            addEntry(entry.height, entryAccum.color);\n          } else {\n            addBlendEntry(entry.height, entry.color, entryAccum.color);\n          }\n        }\n        idx += isSplit ? 2 : 1;\n        accumIdx += isSplitAccum ? 2 : 1;\n      } else if (\n        defined(entry) &&\n        defined(entryAccum) &&\n        defined(prevEntryAccum) &&\n        entry.height < entryAccum.height\n      ) {\n        // New entry between two accum entries\n        var colorBelow = lerpEntryColor(\n          entry.height,\n          prevEntryAccum,\n          entryAccum,\n          scratchColorBelow\n        );\n\n        if (!defined(prevEntry)) {\n          addEntry(entry.height, colorBelow);\n          addBlendEntry(entry.height, entry.color, colorBelow);\n        } else if (!defined(nextEntry)) {\n          addBlendEntry(entry.height, entry.color, colorBelow);\n          addEntry(entry.height, colorBelow);\n        } else {\n          addBlendEntry(entry.height, entry.color, colorBelow);\n        }\n        idx++;\n      } else if (\n        defined(entryAccum) &&\n        defined(entry) &&\n        defined(prevEntry) &&\n        entryAccum.height < entry.height\n      ) {\n        // Accum entry between two new entries\n        var colorAbove = lerpEntryColor(\n          entryAccum.height,\n          prevEntry,\n          entry,\n          scratchColorAbove\n        );\n\n        if (!defined(prevEntryAccum)) {\n          addEntry(entryAccum.height, colorAbove);\n          addBlendEntry(entryAccum.height, colorAbove, entryAccum.color);\n        } else if (!defined(nextEntryAccum)) {\n          addBlendEntry(entryAccum.height, colorAbove, entryAccum.color);\n          addEntry(entryAccum.height, colorAbove);\n        } else {\n          addBlendEntry(entryAccum.height, colorAbove, entryAccum.color);\n        }\n        accumIdx++;\n      } else if (\n        defined(entry) &&\n        (!defined(entryAccum) || entry.height < entryAccum.height)\n      ) {\n        // New entry completely before or completely after accum entries\n        if (\n          defined(entryAccum) &&\n          !defined(prevEntryAccum) &&\n          !defined(nextEntry)\n        ) {\n          // Insert blank gap between last entry and first accum entry\n          addEntry(entry.height, entry.color);\n          addEntry(entry.height, createElevationBandMaterial._emptyColor);\n          addEntry(entryAccum.height, createElevationBandMaterial._emptyColor);\n        } else if (\n          !defined(entryAccum) &&\n          defined(prevEntryAccum) &&\n          !defined(prevEntry)\n        ) {\n          // Insert blank gap between last accum entry and first entry\n          addEntry(\n            prevEntryAccum.height,\n            createElevationBandMaterial._emptyColor\n          );\n          addEntry(entry.height, createElevationBandMaterial._emptyColor);\n          addEntry(entry.height, entry.color);\n        } else {\n          addEntry(entry.height, entry.color);\n        }\n        idx++;\n      } else if (\n        defined(entryAccum) &&\n        (!defined(entry) || entryAccum.height < entry.height)\n      ) {\n        // Accum entry completely before or completely after new entries\n        addEntry(entryAccum.height, entryAccum.color);\n        accumIdx++;\n      }\n    }\n  }\n\n  // one final cleanup pass in case duplicate colors show up in the final result\n  var allEntries = removeDuplicates(entriesAccumNext);\n  return allEntries;\n}\n\n/**\n * @typedef createElevationBandMaterialEntry\n *\n * @property {Number} height The height.\n * @property {Color} color The color at this height.\n */\n/**\n * @typedef createElevationBandMaterialBand\n *\n * @property {createElevationBandMaterialEntry[]} entries A list of elevation entries. They will automatically be sorted from lowest to highest. If there is only one entry and <code>extendsDownards</code> and <code>extendUpwards</code> are both <code>false</code>, they will both be set to <code>true</code>.\n * @property {Boolean} [extendDownwards=false] If <code>true</code>, the band's minimum elevation color will extend infinitely downwards.\n * @property {Boolean} [extendUpwards=false] If <code>true</code>, the band's maximum elevation color will extend infinitely upwards.\n */\n\n/**\n * Creates a {@link Material} that combines multiple layers of color/gradient bands and maps them to terrain heights.\n *\n * The shader does a binary search over all the heights to find out which colors are above and below a given height, and\n * interpolates between them for the final color. This material supports hundreds of entries relatively cheaply.\n *\n * @function createElevationBandMaterial\n *\n * @param {Object} options Object with the following properties:\n * @param {Scene} options.scene The scene where the visualization is taking place.\n * @param {createElevationBandMaterialBand[]} options.layers A list of bands ordered from lowest to highest precedence.\n * @returns {Material} A new {@link Material} instance.\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Elevation%20Band%20Material.html|Cesium Sandcastle Elevation Band Demo}\n *\n * @example\n * scene.globe.material = Cesium.createElevationBandMaterial({\n *     scene : scene,\n *     layers : [{\n *         entries : [{\n *             height : 4200.0,\n *             color : new Cesium.Color(0.0, 0.0, 0.0, 1.0)\n *         }, {\n *             height : 8848.0,\n *             color : new Cesium.Color(1.0, 1.0, 1.0, 1.0)\n *         }],\n *         extendDownwards : true,\n *         extendUpwards : true,\n *     }, {\n *         entries : [{\n *             height : 7000.0,\n *             color : new Cesium.Color(1.0, 0.0, 0.0, 0.5)\n *         }, {\n *             height : 7100.0,\n *             color : new Cesium.Color(1.0, 0.0, 0.0, 0.5)\n *         }]\n *     }]\n * });\n */\nfunction createElevationBandMaterial(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var scene = options.scene;\n  var layers = options.layers;\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.scene\", scene);\n  Check.defined(\"options.layers\", layers);\n  Check.typeOf.number.greaterThan(\"options.layers.length\", layers.length, 0);\n  //>>includeEnd('debug');\n\n  var entries = createLayeredEntries(layers);\n  var entriesLength = entries.length;\n  var i;\n\n  var heightTexBuffer;\n  var heightTexDatatype;\n  var heightTexFormat;\n\n  var isPackedHeight = !createElevationBandMaterial._useFloatTexture(\n    scene.context\n  );\n  if (isPackedHeight) {\n    heightTexDatatype = PixelDatatype.UNSIGNED_BYTE;\n    heightTexFormat = PixelFormat.RGBA;\n    heightTexBuffer = new Uint8Array(entriesLength * 4);\n    for (i = 0; i < entriesLength; i++) {\n      Cartesian4.packFloat(entries[i].height, scratchPackedFloat);\n      Cartesian4.pack(scratchPackedFloat, heightTexBuffer, i * 4);\n    }\n  } else {\n    heightTexDatatype = PixelDatatype.FLOAT;\n    heightTexFormat = PixelFormat.LUMINANCE;\n    heightTexBuffer = new Float32Array(entriesLength);\n    for (i = 0; i < entriesLength; i++) {\n      heightTexBuffer[i] = entries[i].height;\n    }\n  }\n\n  var heightsTex = Texture.create({\n    context: scene.context,\n    pixelFormat: heightTexFormat,\n    pixelDatatype: heightTexDatatype,\n    source: {\n      arrayBufferView: heightTexBuffer,\n      width: entriesLength,\n      height: 1,\n    },\n    sampler: new Sampler({\n      wrapS: TextureWrap.CLAMP_TO_EDGE,\n      wrapT: TextureWrap.CLAMP_TO_EDGE,\n      minificationFilter: TextureMinificationFilter.NEAREST,\n      magnificationFilter: TextureMagnificationFilter.NEAREST,\n    }),\n  });\n\n  var colorsArray = new Uint8Array(entriesLength * 4);\n  for (i = 0; i < entriesLength; i++) {\n    var color = entries[i].color;\n    color.toBytes(scratchColorBytes);\n    colorsArray[i * 4 + 0] = scratchColorBytes[0];\n    colorsArray[i * 4 + 1] = scratchColorBytes[1];\n    colorsArray[i * 4 + 2] = scratchColorBytes[2];\n    colorsArray[i * 4 + 3] = scratchColorBytes[3];\n  }\n\n  var colorsTex = Texture.create({\n    context: scene.context,\n    pixelFormat: PixelFormat.RGBA,\n    pixelDatatype: PixelDatatype.UNSIGNED_BYTE,\n    source: {\n      arrayBufferView: colorsArray,\n      width: entriesLength,\n      height: 1,\n    },\n    sampler: new Sampler({\n      wrapS: TextureWrap.CLAMP_TO_EDGE,\n      wrapT: TextureWrap.CLAMP_TO_EDGE,\n      minificationFilter: TextureMinificationFilter.LINEAR,\n      magnificationFilter: TextureMagnificationFilter.LINEAR,\n    }),\n  });\n\n  var material = Material.fromType(\"ElevationBand\", {\n    heights: heightsTex,\n    colors: colorsTex,\n  });\n  return material;\n}\n\n/**\n * Function for checking if the context will allow floating point textures for heights.\n *\n * @param {Context} context The {@link Context}.\n * @returns {Boolean} <code>true</code> if floating point textures can be used for heights.\n * @private\n */\ncreateElevationBandMaterial._useFloatTexture = function (context) {\n  return context.floatingPointTexture;\n};\n\n/**\n * This is the height that gets stored in the texture when using extendUpwards.\n * There's nothing special about it, it's just a really big number.\n * @private\n */\ncreateElevationBandMaterial._maximumHeight = +5906376425472;\n\n/**\n * This is the height that gets stored in the texture when using extendDownwards.\n * There's nothing special about it, it's just a really big number.\n * @private\n */\ncreateElevationBandMaterial._minimumHeight = -5906376425472;\n\n/**\n * Color used to create empty space in the color texture\n * @private\n */\ncreateElevationBandMaterial._emptyColor = new Color(0.0, 0.0, 0.0, 0.0);\n\nexport default createElevationBandMaterial;\n"]},"metadata":{},"sourceType":"module"}