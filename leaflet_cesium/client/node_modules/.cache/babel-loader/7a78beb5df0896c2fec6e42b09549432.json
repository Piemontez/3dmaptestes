{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport Credit from \"../Core/Credit.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport getAbsoluteUri from \"../Core/getAbsoluteUri.js\";\nimport getJsonFromTypedArray from \"../Core/getJsonFromTypedArray.js\";\nimport getMagic from \"../Core/getMagic.js\";\nimport getStringFromTypedArray from \"../Core/getStringFromTypedArray.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport loadCRN from \"../Core/loadCRN.js\";\nimport loadImageFromTypedArray from \"../Core/loadImageFromTypedArray.js\";\nimport loadKTX from \"../Core/loadKTX.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport Resource from \"../Core/Resource.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport addDefaults from \"../ThirdParty/GltfPipeline/addDefaults.js\";\nimport addPipelineExtras from \"../ThirdParty/GltfPipeline/addPipelineExtras.js\";\nimport ForEach from \"../ThirdParty/GltfPipeline/ForEach.js\";\nimport getAccessorByteStride from \"../ThirdParty/GltfPipeline/getAccessorByteStride.js\";\nimport hasExtension from \"../ThirdParty/GltfPipeline/hasExtension.js\";\nimport numberOfComponentsForType from \"../ThirdParty/GltfPipeline/numberOfComponentsForType.js\";\nimport parseGlb from \"../ThirdParty/GltfPipeline/parseGlb.js\";\nimport updateVersion from \"../ThirdParty/GltfPipeline/updateVersion.js\";\nimport when from \"../ThirdParty/when.js\";\nimport Axis from \"./Axis.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport ClippingPlaneCollection from \"./ClippingPlaneCollection.js\";\nimport ColorBlendMode from \"./ColorBlendMode.js\";\nimport DepthFunction from \"./DepthFunction.js\";\nimport DracoLoader from \"./DracoLoader.js\";\nimport getClipAndStyleCode from \"./getClipAndStyleCode.js\";\nimport getClippingFunction from \"./getClippingFunction.js\";\nimport HeightReference from \"./HeightReference.js\";\nimport JobType from \"./JobType.js\";\nimport ModelAnimationCache from \"./ModelAnimationCache.js\";\nimport ModelAnimationCollection from \"./ModelAnimationCollection.js\";\nimport ModelLoadResources from \"./ModelLoadResources.js\";\nimport ModelMaterial from \"./ModelMaterial.js\";\nimport ModelMesh from \"./ModelMesh.js\";\nimport ModelNode from \"./ModelNode.js\";\nimport ModelOutlineLoader from \"./ModelOutlineLoader.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport OctahedralProjectedCubeMap from \"./OctahedralProjectedCubeMap.js\";\nimport processModelMaterialsCommon from \"./processModelMaterialsCommon.js\";\nimport processPbrMaterials from \"./processPbrMaterials.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\nvar boundingSphereCartesian3Scratch = new Cartesian3();\nvar ModelState = ModelUtility.ModelState; // glTF MIME types discussed in https://github.com/KhronosGroup/glTF/issues/412 and https://github.com/KhronosGroup/glTF/issues/943\n\nvar defaultModelAccept = \"model/gltf-binary,model/gltf+json;q=0.8,application/json;q=0.2,*/*;q=0.01\";\nvar articulationEpsilon = CesiumMath.EPSILON16; ///////////////////////////////////////////////////////////////////////////\n\nfunction setCachedGltf(model, cachedGltf) {\n  model._cachedGltf = cachedGltf;\n} // glTF JSON can be big given embedded geometry, textures, and animations, so we\n// cache it across all models using the same url/cache-key.  This also reduces the\n// slight overhead in assigning defaults to missing values.\n//\n// Note that this is a global cache, compared to renderer resources, which\n// are cached per context.\n\n\nfunction CachedGltf(options) {\n  this._gltf = options.gltf;\n  this.ready = options.ready;\n  this.modelsToLoad = [];\n  this.count = 0;\n}\n\nObject.defineProperties(CachedGltf.prototype, {\n  gltf: {\n    set: function (value) {\n      this._gltf = value;\n    },\n    get: function () {\n      return this._gltf;\n    }\n  }\n});\n\nCachedGltf.prototype.makeReady = function (gltfJson) {\n  this.gltf = gltfJson;\n  var models = this.modelsToLoad;\n  var length = models.length;\n\n  for (var i = 0; i < length; ++i) {\n    var m = models[i];\n\n    if (!m.isDestroyed()) {\n      setCachedGltf(m, this);\n    }\n  }\n\n  this.modelsToLoad = undefined;\n  this.ready = true;\n};\n\nvar gltfCache = {};\nvar uriToGuid = {}; ///////////////////////////////////////////////////////////////////////////\n\n/**\n * A 3D model based on glTF, the runtime asset format for WebGL, OpenGL ES, and OpenGL.\n * <p>\n * Cesium includes support for geometry and materials, glTF animations, and glTF skinning.\n * In addition, individual glTF nodes are pickable with {@link Scene#pick} and animatable\n * with {@link Model#getNode}.  glTF cameras and lights are not currently supported.\n * </p>\n * <p>\n * An external glTF asset is created with {@link Model.fromGltf}.  glTF JSON can also be\n * created at runtime and passed to this constructor function.  In either case, the\n * {@link Model#readyPromise} is resolved when the model is ready to render, i.e.,\n * when the external binary, image, and shader files are downloaded and the WebGL\n * resources are created.\n * </p>\n * <p>\n * Cesium supports glTF assets with the following extensions:\n * <ul>\n * <li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_binary_glTF/README.md|KHR_binary_glTF (glTF 1.0)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_materials_common/README.md|KHR_materials_common (glTF 1.0)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Vendor/WEB3D_quantized_attributes/README.md|WEB3D_quantized_attributes (glTF 1.0)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/AGI_articulations/README.md|AGI_articulations}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/pull/1302|KHR_blend (draft)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_draco_mesh_compression/README.md|KHR_draco_mesh_compression}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/README.md|KHR_materials_pbrSpecularGlossiness}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit/README.md|KHR_materials_unlit}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_techniques_webgl/README.md|KHR_techniques_webgl}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_texture_transform/README.md|KHR_texture_transform}\n * </li>\n * </ul>\n * </p>\n * <p>\n * For high-precision rendering, Cesium supports the {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Vendor/CESIUM_RTC/README.md|CESIUM_RTC} extension, which introduces the\n * CESIUM_RTC_MODELVIEW parameter semantic that says the node is in WGS84 coordinates translated\n * relative to a local origin.\n * </p>\n *\n * @alias Model\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Object|ArrayBuffer|Uint8Array} [options.gltf] A glTF JSON object, or a binary glTF buffer.\n * @param {Resource|String} [options.basePath=''] The base path that paths in the glTF JSON are relative to.\n * @param {Boolean} [options.show=true] Determines if the model primitive will be shown.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms the model from model to world coordinates.\n * @param {Number} [options.scale=1.0] A uniform scale applied to this model.\n * @param {Number} [options.minimumPixelSize=0.0] The approximate minimum pixel size of the model regardless of zoom.\n * @param {Number} [options.maximumScale] The maximum scale size of a model. An upper limit for minimumPixelSize.\n * @param {Object} [options.id] A user-defined object to return when the model is picked with {@link Scene#pick}.\n * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each glTF mesh and primitive is pickable with {@link Scene#pick}.\n * @param {Boolean} [options.incrementallyLoadTextures=true] Determine if textures may continue to stream in after the model is loaded.\n * @param {Boolean} [options.asynchronous=true] Determines if model WebGL resource creation will be spread out over several frames or block until completion once all glTF files are loaded.\n * @param {Boolean} [options.clampAnimations=true] Determines if the model's animations should hold a pose over frames where no keyframes are specified.\n * @param {ShadowMode} [options.shadows=ShadowMode.ENABLED] Determines whether the model casts or receives shadows from light sources.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Draws the bounding sphere for each draw command in the model.\n * @param {Boolean} [options.debugWireframe=false] For debugging only. Draws the model in wireframe.\n * @param {HeightReference} [options.heightReference=HeightReference.NONE] Determines how the model is drawn relative to terrain.\n * @param {Scene} [options.scene] Must be passed in for models that use the height reference property.\n * @param {DistanceDisplayCondition} [options.distanceDisplayCondition] The condition specifying at what distance from the camera that this model will be displayed.\n * @param {Color} [options.color=Color.WHITE] A color that blends with the model's rendered color.\n * @param {ColorBlendMode} [options.colorBlendMode=ColorBlendMode.HIGHLIGHT] Defines how the color blends with the model.\n * @param {Number} [options.colorBlendAmount=0.5] Value used to determine the color strength when the <code>colorBlendMode</code> is <code>MIX</code>. A value of 0.0 results in the model's rendered color while a value of 1.0 results in a solid color, with any value in-between resulting in a mix of the two.\n * @param {Color} [options.silhouetteColor=Color.RED] The silhouette color. If more than 256 models have silhouettes enabled, there is a small chance that overlapping models will have minor artifacts.\n * @param {Number} [options.silhouetteSize=0.0] The size of the silhouette in pixels.\n * @param {ClippingPlaneCollection} [options.clippingPlanes] The {@link ClippingPlaneCollection} used to selectively disable rendering the model.\n * @param {Boolean} [options.dequantizeInShader=true] Determines if a {@link https://github.com/google/draco|Draco} encoded model is dequantized on the GPU. This decreases total memory usage for encoded models.\n * @param {Cartesian2} [options.imageBasedLightingFactor=Cartesian2(1.0, 1.0)] Scales diffuse and specular image-based lighting from the earth, sky, atmosphere and star skybox.\n * @param {Cartesian3} [options.lightColor] The light color when shading the model. When <code>undefined</code> the scene's light color is used instead.\n * @param {Number} [options.luminanceAtZenith=0.2] The sun's luminance at the zenith in kilo candela per meter squared to use for this model's procedural environment map.\n * @param {Cartesian3[]} [options.sphericalHarmonicCoefficients] The third order spherical harmonic coefficients used for the diffuse color of image-based lighting.\n * @param {String} [options.specularEnvironmentMaps] A URL to a KTX file that contains a cube map of the specular lighting and the convoluted specular mipmaps.\n * @param {Credit|String} [options.credit] A credit for the data source, which is displayed on the canvas.\n * @param {Boolean} [options.backFaceCulling=true] Whether to cull back-facing geometry. When true, back face culling is determined by the material's doubleSided property; when false, back face culling is disabled. Back faces are not culled if {@link Model#color} is translucent or {@link Model#silhouetteSize} is greater than 0.0.\n *\n * @see Model.fromGltf\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=3D%20Models.html|Cesium Sandcastle Models Demo}\n */\n\nfunction Model(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var cacheKey = options.cacheKey;\n  this._cacheKey = cacheKey;\n  this._cachedGltf = undefined;\n  this._releaseGltfJson = defaultValue(options.releaseGltfJson, false);\n  var cachedGltf;\n\n  if (defined(cacheKey) && defined(gltfCache[cacheKey]) && gltfCache[cacheKey].ready) {\n    // glTF JSON is in cache and ready\n    cachedGltf = gltfCache[cacheKey];\n    ++cachedGltf.count;\n  } else {\n    // glTF was explicitly provided, e.g., when a user uses the Model constructor directly\n    var gltf = options.gltf;\n\n    if (defined(gltf)) {\n      if (gltf instanceof ArrayBuffer) {\n        gltf = new Uint8Array(gltf);\n      }\n\n      if (gltf instanceof Uint8Array) {\n        // Binary glTF\n        var parsedGltf = parseGlb(gltf);\n        cachedGltf = new CachedGltf({\n          gltf: parsedGltf,\n          ready: true\n        });\n      } else {\n        // Normal glTF (JSON)\n        cachedGltf = new CachedGltf({\n          gltf: options.gltf,\n          ready: true\n        });\n      }\n\n      cachedGltf.count = 1;\n\n      if (defined(cacheKey)) {\n        gltfCache[cacheKey] = cachedGltf;\n      }\n    }\n  }\n\n  setCachedGltf(this, cachedGltf);\n  var basePath = defaultValue(options.basePath, \"\");\n  this._resource = Resource.createIfNeeded(basePath); // User specified credit\n\n  var credit = options.credit;\n\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n\n  this._credit = credit; // Create a list of Credit's so they can be added from the Resource later\n\n  this._resourceCredits = [];\n  /**\n   * Determines if the model primitive will be shown.\n   *\n   * @type {Boolean}\n   *\n   * @default true\n   */\n\n  this.show = defaultValue(options.show, true);\n  /**\n   * The silhouette color.\n   *\n   * @type {Color}\n   *\n   * @default Color.RED\n   */\n\n  this.silhouetteColor = defaultValue(options.silhouetteColor, Color.RED);\n  this._silhouetteColor = new Color();\n  this._silhouetteColorPreviousAlpha = 1.0;\n  this._normalAttributeName = undefined;\n  /**\n   * The size of the silhouette in pixels.\n   *\n   * @type {Number}\n   *\n   * @default 0.0\n   */\n\n  this.silhouetteSize = defaultValue(options.silhouetteSize, 0.0);\n  /**\n   * The 4x4 transformation matrix that transforms the model from model to world coordinates.\n   * When this is the identity matrix, the model is drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * @type {Matrix4}\n   *\n   * @default {@link Matrix4.IDENTITY}\n   *\n   * @example\n   * var origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);\n   * m.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);\n   */\n\n  this.modelMatrix = Matrix4.clone(defaultValue(options.modelMatrix, Matrix4.IDENTITY));\n  this._modelMatrix = Matrix4.clone(this.modelMatrix);\n  this._clampedModelMatrix = undefined;\n  /**\n   * A uniform scale applied to this model before the {@link Model#modelMatrix}.\n   * Values greater than <code>1.0</code> increase the size of the model; values\n   * less than <code>1.0</code> decrease.\n   *\n   * @type {Number}\n   *\n   * @default 1.0\n   */\n\n  this.scale = defaultValue(options.scale, 1.0);\n  this._scale = this.scale;\n  /**\n   * The approximate minimum pixel size of the model regardless of zoom.\n   * This can be used to ensure that a model is visible even when the viewer\n   * zooms out.  When <code>0.0</code>, no minimum size is enforced.\n   *\n   * @type {Number}\n   *\n   * @default 0.0\n   */\n\n  this.minimumPixelSize = defaultValue(options.minimumPixelSize, 0.0);\n  this._minimumPixelSize = this.minimumPixelSize;\n  /**\n   * The maximum scale size for a model. This can be used to give\n   * an upper limit to the {@link Model#minimumPixelSize}, ensuring that the model\n   * is never an unreasonable scale.\n   *\n   * @type {Number}\n   */\n\n  this.maximumScale = options.maximumScale;\n  this._maximumScale = this.maximumScale;\n  /**\n   * User-defined object returned when the model is picked.\n   *\n   * @type Object\n   *\n   * @default undefined\n   *\n   * @see Scene#pick\n   */\n\n  this.id = options.id;\n  this._id = options.id;\n  /**\n   * Returns the height reference of the model\n   *\n   * @type {HeightReference}\n   *\n   * @default HeightReference.NONE\n   */\n\n  this.heightReference = defaultValue(options.heightReference, HeightReference.NONE);\n  this._heightReference = this.heightReference;\n  this._heightChanged = false;\n  this._removeUpdateHeightCallback = undefined;\n  var scene = options.scene;\n  this._scene = scene;\n\n  if (defined(scene) && defined(scene.terrainProviderChanged)) {\n    this._terrainProviderChangedCallback = scene.terrainProviderChanged.addEventListener(function () {\n      this._heightChanged = true;\n    }, this);\n  }\n  /**\n   * Used for picking primitives that wrap a model.\n   *\n   * @private\n   */\n\n\n  this._pickObject = options.pickObject;\n  this._allowPicking = defaultValue(options.allowPicking, true);\n  this._ready = false;\n  this._readyPromise = when.defer();\n  /**\n   * The currently playing glTF animations.\n   *\n   * @type {ModelAnimationCollection}\n   */\n\n  this.activeAnimations = new ModelAnimationCollection(this);\n  /**\n   * Determines if the model's animations should hold a pose over frames where no keyframes are specified.\n   *\n   * @type {Boolean}\n   */\n\n  this.clampAnimations = defaultValue(options.clampAnimations, true);\n  this._defaultTexture = undefined;\n  this._incrementallyLoadTextures = defaultValue(options.incrementallyLoadTextures, true);\n  this._asynchronous = defaultValue(options.asynchronous, true);\n  /**\n   * Determines whether the model casts or receives shadows from light sources.\n   *\n   * @type {ShadowMode}\n   *\n   * @default ShadowMode.ENABLED\n   */\n\n  this.shadows = defaultValue(options.shadows, ShadowMode.ENABLED);\n  this._shadows = this.shadows;\n  /**\n   * A color that blends with the model's rendered color.\n   *\n   * @type {Color}\n   *\n   * @default Color.WHITE\n   */\n\n  this.color = Color.clone(defaultValue(options.color, Color.WHITE));\n  this._colorPreviousAlpha = 1.0;\n  /**\n   * Defines how the color blends with the model.\n   *\n   * @type {ColorBlendMode}\n   *\n   * @default ColorBlendMode.HIGHLIGHT\n   */\n\n  this.colorBlendMode = defaultValue(options.colorBlendMode, ColorBlendMode.HIGHLIGHT);\n  /**\n   * Value used to determine the color strength when the <code>colorBlendMode</code> is <code>MIX</code>.\n   * A value of 0.0 results in the model's rendered color while a value of 1.0 results in a solid color, with\n   * any value in-between resulting in a mix of the two.\n   *\n   * @type {Number}\n   *\n   * @default 0.5\n   */\n\n  this.colorBlendAmount = defaultValue(options.colorBlendAmount, 0.5);\n  this._colorShadingEnabled = false;\n  this._clippingPlanes = undefined;\n  this.clippingPlanes = options.clippingPlanes; // Used for checking if shaders need to be regenerated due to clipping plane changes.\n\n  this._clippingPlanesState = 0; // If defined, use this matrix to transform miscellaneous properties like\n  // clipping planes and IBL instead of the modelMatrix. This is so that when\n  // models are part of a tileset these properties get transformed relative to\n  // a common reference (such as the root).\n\n  this.referenceMatrix = undefined;\n  /**\n   * Whether to cull back-facing geometry. When true, back face culling is\n   * determined by the material's doubleSided property; when false, back face\n   * culling is disabled. Back faces are not culled if {@link Model#color} is\n   * translucent or {@link Model#silhouetteSize} is greater than 0.0.\n   *\n   * @type {Boolean}\n   *\n   * @default true\n   */\n\n  this.backFaceCulling = defaultValue(options.backFaceCulling, true);\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the model.  A glTF primitive corresponds\n   * to one draw command.  A glTF mesh has an array of primitives, often of length one.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n\n  this.debugShowBoundingVolume = defaultValue(options.debugShowBoundingVolume, false);\n  this._debugShowBoundingVolume = false;\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the model in wireframe.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n\n  this.debugWireframe = defaultValue(options.debugWireframe, false);\n  this._debugWireframe = false;\n  this._distanceDisplayCondition = options.distanceDisplayCondition; // Undocumented options\n\n  this._addBatchIdToGeneratedShaders = options.addBatchIdToGeneratedShaders;\n  this._precreatedAttributes = options.precreatedAttributes;\n  this._vertexShaderLoaded = options.vertexShaderLoaded;\n  this._fragmentShaderLoaded = options.fragmentShaderLoaded;\n  this._uniformMapLoaded = options.uniformMapLoaded;\n  this._pickIdLoaded = options.pickIdLoaded;\n  this._ignoreCommands = defaultValue(options.ignoreCommands, false);\n  this._requestType = options.requestType;\n  this._upAxis = defaultValue(options.upAxis, Axis.Y);\n  this._gltfForwardAxis = Axis.Z;\n  this._forwardAxis = options.forwardAxis;\n  /**\n   * @private\n   * @readonly\n   */\n\n  this.cull = defaultValue(options.cull, true);\n  /**\n   * @private\n   * @readonly\n   */\n\n  this.opaquePass = defaultValue(options.opaquePass, Pass.OPAQUE);\n  this._computedModelMatrix = new Matrix4(); // Derived from modelMatrix and scale\n\n  this._clippingPlanesMatrix = Matrix4.clone(Matrix4.IDENTITY); // Derived from reference matrix and the current view matrix\n\n  this._iblReferenceFrameMatrix = Matrix3.clone(Matrix3.IDENTITY); // Derived from reference matrix and the current view matrix\n\n  this._initialRadius = undefined; // Radius without model's scale property, model-matrix scale, animations, or skins\n\n  this._boundingSphere = undefined;\n  this._scaledBoundingSphere = new BoundingSphere();\n  this._state = ModelState.NEEDS_LOAD;\n  this._loadResources = undefined;\n  this._mode = undefined;\n  this._perNodeShowDirty = false; // true when the Cesium API was used to change a node's show property\n\n  this._cesiumAnimationsDirty = false; // true when the Cesium API, not a glTF animation, changed a node transform\n\n  this._dirty = false; // true when the model was transformed this frame\n\n  this._maxDirtyNumber = 0; // Used in place of a dirty boolean flag to avoid an extra graph traversal\n\n  this._runtime = {\n    animations: undefined,\n    articulationsByName: undefined,\n    articulationsByStageKey: undefined,\n    stagesByKey: undefined,\n    rootNodes: undefined,\n    nodes: undefined,\n    // Indexed with the node's index\n    nodesByName: undefined,\n    // Indexed with name property in the node\n    skinnedNodes: undefined,\n    meshesByName: undefined,\n    // Indexed with the name property in the mesh\n    materialsByName: undefined,\n    // Indexed with the name property in the material\n    materialsById: undefined // Indexed with the material's index\n\n  };\n  this._uniformMaps = {}; // Not cached since it can be targeted by glTF animation\n\n  this._extensionsUsed = undefined; // Cached used glTF extensions\n\n  this._extensionsRequired = undefined; // Cached required glTF extensions\n\n  this._quantizedUniforms = {}; // Quantized uniforms for each program for WEB3D_quantized_attributes\n\n  this._programPrimitives = {};\n  this._rendererResources = {\n    // Cached between models with the same url/cache-key\n    buffers: {},\n    vertexArrays: {},\n    programs: {},\n    sourceShaders: {},\n    silhouettePrograms: {},\n    textures: {},\n    samplers: {},\n    renderStates: {}\n  };\n  this._cachedRendererResources = undefined;\n  this._loadRendererResourcesFromCache = false;\n  this._dequantizeInShader = defaultValue(options.dequantizeInShader, true);\n  this._decodedData = {};\n  this._cachedGeometryByteLength = 0;\n  this._cachedTexturesByteLength = 0;\n  this._geometryByteLength = 0;\n  this._texturesByteLength = 0;\n  this._trianglesLength = 0; // Hold references for shader reconstruction.\n  // Hold these separately because _cachedGltf may get released (this.releaseGltfJson)\n\n  this._sourceTechniques = {};\n  this._sourcePrograms = {};\n  this._quantizedVertexShaders = {};\n  this._nodeCommands = [];\n  this._pickIds = []; // CESIUM_RTC extension\n\n  this._rtcCenter = undefined; // reference to either 3D or 2D\n\n  this._rtcCenterEye = undefined; // in eye coordinates\n\n  this._rtcCenter3D = undefined; // in world coordinates\n\n  this._rtcCenter2D = undefined; // in projected world coordinates\n\n  this._sourceVersion = undefined;\n  this._sourceKHRTechniquesWebGL = undefined;\n  this._imageBasedLightingFactor = new Cartesian2(1.0, 1.0);\n  Cartesian2.clone(options.imageBasedLightingFactor, this._imageBasedLightingFactor);\n  this._lightColor = Cartesian3.clone(options.lightColor);\n  this._luminanceAtZenith = undefined;\n  this.luminanceAtZenith = defaultValue(options.luminanceAtZenith, 0.2);\n  this._sphericalHarmonicCoefficients = options.sphericalHarmonicCoefficients;\n  this._specularEnvironmentMaps = options.specularEnvironmentMaps;\n  this._shouldUpdateSpecularMapAtlas = true;\n  this._specularEnvironmentMapAtlas = undefined;\n  this._useDefaultSphericalHarmonics = false;\n  this._useDefaultSpecularMaps = false;\n  this._shouldRegenerateShaders = false;\n}\n\nObject.defineProperties(Model.prototype, {\n  /**\n   * The object for the glTF JSON, including properties with default values omitted\n   * from the JSON provided to this model.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Object}\n   * @readonly\n   *\n   * @default undefined\n   */\n  gltf: {\n    get: function () {\n      return defined(this._cachedGltf) ? this._cachedGltf.gltf : undefined;\n    }\n  },\n\n  /**\n   * When <code>true</code>, the glTF JSON is not stored with the model once the model is\n   * loaded (when {@link Model#ready} is <code>true</code>).  This saves memory when\n   * geometry, textures, and animations are embedded in the .gltf file.\n   * This is especially useful for cases like 3D buildings, where each .gltf model is unique\n   * and caching the glTF JSON is not effective.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   *\n   * @private\n   */\n  releaseGltfJson: {\n    get: function () {\n      return this._releaseGltfJson;\n    }\n  },\n\n  /**\n   * The key identifying this model in the model cache for glTF JSON, renderer resources, and animations.\n   * Caching saves memory and improves loading speed when several models with the same url are created.\n   * <p>\n   * This key is automatically generated when the model is created with {@link Model.fromGltf}.  If the model\n   * is created directly from glTF JSON using the {@link Model} constructor, this key can be manually\n   * provided; otherwise, the model will not be changed.\n   * </p>\n   *\n   * @memberof Model.prototype\n   *\n   * @type {String}\n   * @readonly\n   *\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return this._cacheKey;\n    }\n  },\n\n  /**\n   * The base path that paths in the glTF JSON are relative to.  The base\n   * path is the same path as the path containing the .gltf file\n   * minus the .gltf file, when binary, image, and shader files are\n   * in the same directory as the .gltf.  When this is <code>''</code>,\n   * the app's base path is used.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {String}\n   * @readonly\n   *\n   * @default ''\n   */\n  basePath: {\n    get: function () {\n      return this._resource.url;\n    }\n  },\n\n  /**\n   * The model's bounding sphere in its local coordinate system.  This does not take into\n   * account glTF animations and skins nor does it take into account {@link Model#minimumPixelSize}.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   *\n   * @default undefined\n   *\n   * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\n   *\n   * @example\n   * // Center in WGS84 coordinates\n   * var center = Cesium.Matrix4.multiplyByPoint(model.modelMatrix, model.boundingSphere.center, new Cesium.Cartesian3());\n   */\n  boundingSphere: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (this._state !== ModelState.LOADED) {\n        throw new DeveloperError(\"The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\");\n      } //>>includeEnd('debug');\n\n\n      var modelMatrix = this.modelMatrix;\n\n      if (this.heightReference !== HeightReference.NONE && this._clampedModelMatrix) {\n        modelMatrix = this._clampedModelMatrix;\n      }\n\n      var nonUniformScale = Matrix4.getScale(modelMatrix, boundingSphereCartesian3Scratch);\n      var scale = defined(this.maximumScale) ? Math.min(this.maximumScale, this.scale) : this.scale;\n      Cartesian3.multiplyByScalar(nonUniformScale, scale, nonUniformScale);\n      var scaledBoundingSphere = this._scaledBoundingSphere;\n      scaledBoundingSphere.center = Cartesian3.multiplyComponents(this._boundingSphere.center, nonUniformScale, scaledBoundingSphere.center);\n      scaledBoundingSphere.radius = Cartesian3.maximumComponent(nonUniformScale) * this._initialRadius;\n\n      if (defined(this._rtcCenter)) {\n        Cartesian3.add(this._rtcCenter, scaledBoundingSphere.center, scaledBoundingSphere.center);\n      }\n\n      return scaledBoundingSphere;\n    }\n  },\n\n  /**\n   * When <code>true</code>, this model is ready to render, i.e., the external binary, image,\n   * and shader files were downloaded and the WebGL resources were created.  This is set to\n   * <code>true</code> right before {@link Model#readyPromise} is resolved.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    }\n  },\n\n  /**\n   * Gets the promise that will be resolved when this model is ready to render, i.e., when the external binary, image,\n   * and shader files were downloaded and the WebGL resources were created.\n   * <p>\n   * This promise is resolved at the end of the frame before the first frame the model is rendered in.\n   * </p>\n   *\n   * @memberof Model.prototype\n   * @type {Promise.<Model>}\n   * @readonly\n   *\n   * @example\n   * // Play all animations at half-speed when the model is ready to render\n   * Cesium.when(model.readyPromise).then(function(model) {\n   *   model.activeAnimations.addAll({\n   *     multiplier : 0.5\n   *   });\n   * }).otherwise(function(error){\n   *   window.alert(error);\n   * });\n   *\n   * @see Model#ready\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    }\n  },\n\n  /**\n   * Determines if model WebGL resource creation will be spread out over several frames or\n   * block until completion once all glTF files are loaded.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  asynchronous: {\n    get: function () {\n      return this._asynchronous;\n    }\n  },\n\n  /**\n   * When <code>true</code>, each glTF mesh and primitive is pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  allowPicking: {\n    get: function () {\n      return this._allowPicking;\n    }\n  },\n\n  /**\n   * Determine if textures may continue to stream in after the model is loaded.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  incrementallyLoadTextures: {\n    get: function () {\n      return this._incrementallyLoadTextures;\n    }\n  },\n\n  /**\n   * Return the number of pending texture loads.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  pendingTextureLoads: {\n    get: function () {\n      return defined(this._loadResources) ? this._loadResources.pendingTextureLoads : 0;\n    }\n  },\n\n  /**\n   * Returns true if the model was transformed this frame\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @private\n   */\n  dirty: {\n    get: function () {\n      return this._dirty;\n    }\n  },\n\n  /**\n   * Gets or sets the condition specifying at what distance from the camera that this model will be displayed.\n   * @memberof Model.prototype\n   * @type {DistanceDisplayCondition}\n   * @default undefined\n   */\n  distanceDisplayCondition: {\n    get: function () {\n      return this._distanceDisplayCondition;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value.far <= value.near) {\n        throw new DeveloperError(\"far must be greater than near\");\n      } //>>includeEnd('debug');\n\n\n      this._distanceDisplayCondition = DistanceDisplayCondition.clone(value, this._distanceDisplayCondition);\n    }\n  },\n  extensionsUsed: {\n    get: function () {\n      if (!defined(this._extensionsUsed)) {\n        this._extensionsUsed = ModelUtility.getUsedExtensions(this.gltf);\n      }\n\n      return this._extensionsUsed;\n    }\n  },\n  extensionsRequired: {\n    get: function () {\n      if (!defined(this._extensionsRequired)) {\n        this._extensionsRequired = ModelUtility.getRequiredExtensions(this.gltf);\n      }\n\n      return this._extensionsRequired;\n    }\n  },\n\n  /**\n   * Gets the model's up-axis.\n   * By default models are y-up according to the glTF spec, however geo-referenced models will typically be z-up.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Number}\n   * @default Axis.Y\n   * @readonly\n   *\n   * @private\n   */\n  upAxis: {\n    get: function () {\n      return this._upAxis;\n    }\n  },\n\n  /**\n   * Gets the model's forward axis.\n   * By default, glTF 2.0 models are z-forward according to the glTF spec, however older\n   * glTF (1.0, 0.8) models used x-forward.  Note that only Axis.X and Axis.Z are supported.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Number}\n   * @default Axis.Z\n   * @readonly\n   *\n   * @private\n   */\n  forwardAxis: {\n    get: function () {\n      if (defined(this._forwardAxis)) {\n        return this._forwardAxis;\n      }\n\n      return this._gltfForwardAxis;\n    }\n  },\n\n  /**\n   * Gets the model's triangle count.\n   *\n   * @private\n   */\n  trianglesLength: {\n    get: function () {\n      return this._trianglesLength;\n    }\n  },\n\n  /**\n   * Gets the model's geometry memory in bytes. This includes all vertex and index buffers.\n   *\n   * @private\n   */\n  geometryByteLength: {\n    get: function () {\n      return this._geometryByteLength;\n    }\n  },\n\n  /**\n   * Gets the model's texture memory in bytes.\n   *\n   * @private\n   */\n  texturesByteLength: {\n    get: function () {\n      return this._texturesByteLength;\n    }\n  },\n\n  /**\n   * Gets the model's cached geometry memory in bytes. This includes all vertex and index buffers.\n   *\n   * @private\n   */\n  cachedGeometryByteLength: {\n    get: function () {\n      return this._cachedGeometryByteLength;\n    }\n  },\n\n  /**\n   * Gets the model's cached texture memory in bytes.\n   *\n   * @private\n   */\n  cachedTexturesByteLength: {\n    get: function () {\n      return this._cachedTexturesByteLength;\n    }\n  },\n\n  /**\n   * The {@link ClippingPlaneCollection} used to selectively disable rendering the model.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {ClippingPlaneCollection}\n   */\n  clippingPlanes: {\n    get: function () {\n      return this._clippingPlanes;\n    },\n    set: function (value) {\n      if (value === this._clippingPlanes) {\n        return;\n      } // Handle destroying, checking of unknown, checking for existing ownership\n\n\n      ClippingPlaneCollection.setOwner(value, this, \"_clippingPlanes\");\n    }\n  },\n\n  /**\n   * @private\n   */\n  pickIds: {\n    get: function () {\n      return this._pickIds;\n    }\n  },\n\n  /**\n   * Cesium adds lighting from the earth, sky, atmosphere, and star skybox. This cartesian is used to scale the final\n   * diffuse and specular lighting contribution from those sources to the final color. A value of 0.0 will disable those light sources.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Cartesian2}\n   * @default Cartesian2(1.0, 1.0)\n   */\n  imageBasedLightingFactor: {\n    get: function () {\n      return this._imageBasedLightingFactor;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.object(\"imageBasedLightingFactor\", value);\n      Check.typeOf.number.greaterThanOrEquals(\"imageBasedLightingFactor.x\", value.x, 0.0);\n      Check.typeOf.number.lessThanOrEquals(\"imageBasedLightingFactor.x\", value.x, 1.0);\n      Check.typeOf.number.greaterThanOrEquals(\"imageBasedLightingFactor.y\", value.y, 0.0);\n      Check.typeOf.number.lessThanOrEquals(\"imageBasedLightingFactor.y\", value.y, 1.0); //>>includeEnd('debug');\n\n      var imageBasedLightingFactor = this._imageBasedLightingFactor;\n\n      if (value === imageBasedLightingFactor || Cartesian2.equals(value, imageBasedLightingFactor)) {\n        return;\n      }\n\n      this._shouldRegenerateShaders = this._shouldRegenerateShaders || this._imageBasedLightingFactor.x > 0.0 && value.x === 0.0 || this._imageBasedLightingFactor.x === 0.0 && value.x > 0.0;\n      this._shouldRegenerateShaders = this._shouldRegenerateShaders || this._imageBasedLightingFactor.y > 0.0 && value.y === 0.0 || this._imageBasedLightingFactor.y === 0.0 && value.y > 0.0;\n      Cartesian2.clone(value, this._imageBasedLightingFactor);\n    }\n  },\n\n  /**\n   * The light color when shading the model. When <code>undefined</code> the scene's light color is used instead.\n   * <p>\n   * For example, disabling additional light sources by setting <code>model.imageBasedLightingFactor = new Cesium.Cartesian2(0.0, 0.0)</code> will make the\n   * model much darker. Here, increasing the intensity of the light source will make the model brighter.\n   * </p>\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Cartesian3}\n   * @default undefined\n   */\n  lightColor: {\n    get: function () {\n      return this._lightColor;\n    },\n    set: function (value) {\n      var lightColor = this._lightColor;\n\n      if (value === lightColor || Cartesian3.equals(value, lightColor)) {\n        return;\n      }\n\n      this._shouldRegenerateShaders = this._shouldRegenerateShaders || defined(lightColor) && !defined(value) || defined(value) && !defined(lightColor);\n      this._lightColor = Cartesian3.clone(value, lightColor);\n    }\n  },\n\n  /**\n   * The sun's luminance at the zenith in kilo candela per meter squared to use for this model's procedural environment map.\n   * This is used when {@link Model#specularEnvironmentMaps} and {@link Model#sphericalHarmonicCoefficients} are not defined.\n   *\n   * @memberof Model.prototype\n   *\n   * @demo {@link https://sandcastle.cesium.com/index.html?src=Image-Based Lighting.html|Sandcastle Image Based Lighting Demo}\n   * @type {Number}\n   * @default 0.2\n   */\n  luminanceAtZenith: {\n    get: function () {\n      return this._luminanceAtZenith;\n    },\n    set: function (value) {\n      var lum = this._luminanceAtZenith;\n\n      if (value === lum) {\n        return;\n      }\n\n      this._shouldRegenerateShaders = this._shouldRegenerateShaders || defined(lum) && !defined(value) || defined(value) && !defined(lum);\n      this._luminanceAtZenith = value;\n    }\n  },\n\n  /**\n   * The third order spherical harmonic coefficients used for the diffuse color of image-based lighting. When <code>undefined</code>, a diffuse irradiance\n   * computed from the atmosphere color is used.\n   * <p>\n   * There are nine <code>Cartesian3</code> coefficients.\n   * The order of the coefficients is: L<sub>00</sub>, L<sub>1-1</sub>, L<sub>10</sub>, L<sub>11</sub>, L<sub>2-2</sub>, L<sub>2-1</sub>, L<sub>20</sub>, L<sub>21</sub>, L<sub>22</sub>\n   * </p>\n   *\n   * These values can be obtained by preprocessing the environment map using the <code>cmgen</code> tool of\n   * {@link https://github.com/google/filament/releases|Google's Filament project}. This will also generate a KTX file that can be\n   * supplied to {@link Model#specularEnvironmentMaps}.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Cartesian3[]}\n   * @demo {@link https://sandcastle.cesium.com/index.html?src=Image-Based Lighting.html|Sandcastle Image Based Lighting Demo}\n   * @see {@link https://graphics.stanford.edu/papers/envmap/envmap.pdf|An Efficient Representation for Irradiance Environment Maps}\n   */\n  sphericalHarmonicCoefficients: {\n    get: function () {\n      return this._sphericalHarmonicCoefficients;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && (!Array.isArray(value) || value.length !== 9)) {\n        throw new DeveloperError(\"sphericalHarmonicCoefficients must be an array of 9 Cartesian3 values.\");\n      } //>>includeEnd('debug');\n\n\n      if (value === this._sphericalHarmonicCoefficients) {\n        return;\n      }\n\n      this._sphericalHarmonicCoefficients = value;\n      this._shouldRegenerateShaders = true;\n    }\n  },\n\n  /**\n   * A URL to a KTX file that contains a cube map of the specular lighting and the convoluted specular mipmaps.\n   *\n   * @memberof Model.prototype\n   * @demo {@link https://sandcastle.cesium.com/index.html?src=Image-Based Lighting.html|Sandcastle Image Based Lighting Demo}\n   * @type {String}\n   * @see Model#sphericalHarmonicCoefficients\n   */\n  specularEnvironmentMaps: {\n    get: function () {\n      return this._specularEnvironmentMaps;\n    },\n    set: function (value) {\n      this._shouldUpdateSpecularMapAtlas = this._shouldUpdateSpecularMapAtlas || value !== this._specularEnvironmentMaps;\n      this._specularEnvironmentMaps = value;\n    }\n  },\n\n  /**\n   * Gets the credit that will be displayed for the model\n   * @memberof Model.prototype\n   * @type {Credit}\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    }\n  }\n});\n\nfunction silhouetteSupported(context) {\n  return context.stencilBuffer;\n}\n\nfunction isColorShadingEnabled(model) {\n  return !Color.equals(model.color, Color.WHITE) || model.colorBlendMode !== ColorBlendMode.HIGHLIGHT;\n}\n\nfunction isClippingEnabled(model) {\n  var clippingPlanes = model._clippingPlanes;\n  return defined(clippingPlanes) && clippingPlanes.enabled && clippingPlanes.length !== 0;\n}\n/**\n * Determines if silhouettes are supported.\n *\n * @param {Scene} scene The scene.\n * @returns {Boolean} <code>true</code> if silhouettes are supported; otherwise, returns <code>false</code>\n */\n\n\nModel.silhouetteSupported = function (scene) {\n  return silhouetteSupported(scene.context);\n};\n\nfunction containsGltfMagic(uint8Array) {\n  var magic = getMagic(uint8Array);\n  return magic === \"glTF\";\n}\n/**\n * <p>\n * Creates a model from a glTF asset.  When the model is ready to render, i.e., when the external binary, image,\n * and shader files are downloaded and the WebGL resources are created, the {@link Model#readyPromise} is resolved.\n * </p>\n * <p>\n * The model can be a traditional glTF asset with a .gltf extension or a Binary glTF using the .glb extension.\n * </p>\n * <p>\n * Cesium supports glTF assets with the following extensions:\n * <ul>\n * <li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_binary_glTF/README.md|KHR_binary_glTF (glTF 1.0)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_materials_common/README.md|KHR_materials_common (glTF 1.0)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Vendor/WEB3D_quantized_attributes/README.md|WEB3D_quantized_attributes (glTF 1.0)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/AGI_articulations/README.md|AGI_articulations}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/pull/1302|KHR_blend (draft)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_draco_mesh_compression/README.md|KHR_draco_mesh_compression}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/README.md|KHR_materials_pbrSpecularGlossiness}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit/README.md|KHR_materials_unlit}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_techniques_webgl/README.md|KHR_techniques_webgl}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_texture_transform/README.md|KHR_texture_transform}\n * </li>\n * </ul>\n * </p>\n * <p>\n * For high-precision rendering, Cesium supports the {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Vendor/CESIUM_RTC/README.md|CESIUM_RTC} extension, which introduces the\n * CESIUM_RTC_MODELVIEW parameter semantic that says the node is in WGS84 coordinates translated\n * relative to a local origin.\n * </p>\n *\n * @param {Object} options Object with the following properties:\n * @param {Resource|String} options.url The url to the .gltf file.\n * @param {Resource|String} [options.basePath] The base path that paths in the glTF JSON are relative to.\n * @param {Boolean} [options.show=true] Determines if the model primitive will be shown.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms the model from model to world coordinates.\n * @param {Number} [options.scale=1.0] A uniform scale applied to this model.\n * @param {Number} [options.minimumPixelSize=0.0] The approximate minimum pixel size of the model regardless of zoom.\n * @param {Number} [options.maximumScale] The maximum scale for the model.\n * @param {Object} [options.id] A user-defined object to return when the model is picked with {@link Scene#pick}.\n * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each glTF mesh and primitive is pickable with {@link Scene#pick}.\n * @param {Boolean} [options.incrementallyLoadTextures=true] Determine if textures may continue to stream in after the model is loaded.\n * @param {Boolean} [options.asynchronous=true] Determines if model WebGL resource creation will be spread out over several frames or block until completion once all glTF files are loaded.\n * @param {Boolean} [options.clampAnimations=true] Determines if the model's animations should hold a pose over frames where no keyframes are specified.\n * @param {ShadowMode} [options.shadows=ShadowMode.ENABLED] Determines whether the model casts or receives shadows from light sources.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Draws the bounding sphere for each draw command in the model.\n * @param {Boolean} [options.debugWireframe=false] For debugging only. Draws the model in wireframe.\n * @param {HeightReference} [options.heightReference=HeightReference.NONE] Determines how the model is drawn relative to terrain.\n * @param {Scene} [options.scene] Must be passed in for models that use the height reference property.\n * @param {DistanceDisplayCondition} [options.distanceDisplayCondition] The condition specifying at what distance from the camera that this model will be displayed.\n * @param {Color} [options.color=Color.WHITE] A color that blends with the model's rendered color.\n * @param {ColorBlendMode} [options.colorBlendMode=ColorBlendMode.HIGHLIGHT] Defines how the color blends with the model.\n * @param {Number} [options.colorBlendAmount=0.5] Value used to determine the color strength when the <code>colorBlendMode</code> is <code>MIX</code>. A value of 0.0 results in the model's rendered color while a value of 1.0 results in a solid color, with any value in-between resulting in a mix of the two.\n * @param {Color} [options.silhouetteColor=Color.RED] The silhouette color. If more than 256 models have silhouettes enabled, there is a small chance that overlapping models will have minor artifacts.\n * @param {Number} [options.silhouetteSize=0.0] The size of the silhouette in pixels.\n * @param {ClippingPlaneCollection} [options.clippingPlanes] The {@link ClippingPlaneCollection} used to selectively disable rendering the model.\n * @param {Boolean} [options.dequantizeInShader=true] Determines if a {@link https://github.com/google/draco|Draco} encoded model is dequantized on the GPU. This decreases total memory usage for encoded models.\n * @param {Credit|String} [options.credit] A credit for the model, which is displayed on the canvas.\n * @param {Boolean} [options.backFaceCulling=true] Whether to cull back-facing geometry. When true, back face culling is determined by the material's doubleSided property; when false, back face culling is disabled. Back faces are not culled if {@link Model#color} is translucent or {@link Model#silhouetteSize} is greater than 0.0.\n *\n * @returns {Model} The newly created model.\n *\n * @example\n * // Example 1. Create a model from a glTF asset\n * var model = scene.primitives.add(Cesium.Model.fromGltf({\n *   url : './duck/duck.gltf'\n * }));\n *\n * @example\n * // Example 2. Create model and provide all properties and events\n * var origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);\n * var modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);\n *\n * var model = scene.primitives.add(Cesium.Model.fromGltf({\n *   url : './duck/duck.gltf',\n *   show : true,                     // default\n *   modelMatrix : modelMatrix,\n *   scale : 2.0,                     // double size\n *   minimumPixelSize : 128,          // never smaller than 128 pixels\n *   maximumScale: 20000,             // never larger than 20000 * model size (overrides minimumPixelSize)\n *   allowPicking : false,            // not pickable\n *   debugShowBoundingVolume : false, // default\n *   debugWireframe : false\n * }));\n *\n * model.readyPromise.then(function(model) {\n *   // Play all animations when the model is ready to render\n *   model.activeAnimations.addAll();\n * });\n */\n\n\nModel.fromGltf = function (options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options) || !defined(options.url)) {\n    throw new DeveloperError(\"options.url is required\");\n  } //>>includeEnd('debug');\n\n\n  var url = options.url;\n  options = clone(options); // Create resource for the model file\n\n  var modelResource = Resource.createIfNeeded(url); // Setup basePath to get dependent files\n\n  var basePath = defaultValue(options.basePath, modelResource.clone());\n  var resource = Resource.createIfNeeded(basePath); // If no cache key is provided, use a GUID.\n  // Check using a URI to GUID dictionary that we have not already added this model.\n\n  var cacheKey = defaultValue(options.cacheKey, uriToGuid[getAbsoluteUri(modelResource.url)]);\n\n  if (!defined(cacheKey)) {\n    cacheKey = createGuid();\n    uriToGuid[getAbsoluteUri(modelResource.url)] = cacheKey;\n  }\n\n  if (defined(options.basePath) && !defined(options.cacheKey)) {\n    cacheKey += resource.url;\n  }\n\n  options.cacheKey = cacheKey;\n  options.basePath = resource;\n  var model = new Model(options);\n  var cachedGltf = gltfCache[cacheKey];\n\n  if (!defined(cachedGltf)) {\n    cachedGltf = new CachedGltf({\n      ready: false\n    });\n    cachedGltf.count = 1;\n    cachedGltf.modelsToLoad.push(model);\n    setCachedGltf(model, cachedGltf);\n    gltfCache[cacheKey] = cachedGltf; // Add Accept header if we need it\n\n    if (!defined(modelResource.headers.Accept)) {\n      modelResource.headers.Accept = defaultModelAccept;\n    }\n\n    modelResource.fetchArrayBuffer().then(function (arrayBuffer) {\n      var array = new Uint8Array(arrayBuffer);\n\n      if (containsGltfMagic(array)) {\n        // Load binary glTF\n        var parsedGltf = parseGlb(array);\n        cachedGltf.makeReady(parsedGltf);\n      } else {\n        // Load text (JSON) glTF\n        var json = getJsonFromTypedArray(array);\n        cachedGltf.makeReady(json);\n      }\n\n      var resourceCredits = model._resourceCredits;\n      var credits = modelResource.credits;\n\n      if (defined(credits)) {\n        var length = credits.length;\n\n        for (var i = 0; i < length; i++) {\n          resourceCredits.push(credits[i]);\n        }\n      }\n    }).otherwise(ModelUtility.getFailedLoadFunction(model, \"model\", modelResource.url));\n  } else if (!cachedGltf.ready) {\n    // Cache hit but the fetchArrayBuffer() or fetchText() request is still pending\n    ++cachedGltf.count;\n    cachedGltf.modelsToLoad.push(model);\n  } // else if the cached glTF is defined and ready, the\n  // model constructor will pick it up using the cache key.\n\n\n  return model;\n};\n/**\n * For the unit tests to verify model caching.\n *\n * @private\n */\n\n\nModel._gltfCache = gltfCache;\n\nfunction getRuntime(model, runtimeName, name) {\n  //>>includeStart('debug', pragmas.debug);\n  if (model._state !== ModelState.LOADED) {\n    throw new DeveloperError(\"The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\");\n  }\n\n  if (!defined(name)) {\n    throw new DeveloperError(\"name is required.\");\n  } //>>includeEnd('debug');\n\n\n  return model._runtime[runtimeName][name];\n}\n/**\n * Returns the glTF node with the given <code>name</code> property.  This is used to\n * modify a node's transform for animation outside of glTF animations.\n *\n * @param {String} name The glTF name of the node.\n * @returns {ModelNode} The node or <code>undefined</code> if no node with <code>name</code> exists.\n *\n * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\n *\n * @example\n * // Apply non-uniform scale to node LOD3sp\n * var node = model.getNode('LOD3sp');\n * node.matrix = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(5.0, 1.0, 1.0), node.matrix);\n */\n\n\nModel.prototype.getNode = function (name) {\n  var node = getRuntime(this, \"nodesByName\", name);\n  return defined(node) ? node.publicNode : undefined;\n};\n/**\n * Returns the glTF mesh with the given <code>name</code> property.\n *\n * @param {String} name The glTF name of the mesh.\n *\n * @returns {ModelMesh} The mesh or <code>undefined</code> if no mesh with <code>name</code> exists.\n *\n * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\n */\n\n\nModel.prototype.getMesh = function (name) {\n  return getRuntime(this, \"meshesByName\", name);\n};\n/**\n * Returns the glTF material with the given <code>name</code> property.\n *\n * @param {String} name The glTF name of the material.\n * @returns {ModelMaterial} The material or <code>undefined</code> if no material with <code>name</code> exists.\n *\n * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\n */\n\n\nModel.prototype.getMaterial = function (name) {\n  return getRuntime(this, \"materialsByName\", name);\n};\n/**\n * Sets the current value of an articulation stage.  After setting one or multiple stage values, call\n * Model.applyArticulations() to cause the node matrices to be recalculated.\n *\n * @param {String} articulationStageKey The name of the articulation, a space, and the name of the stage.\n * @param {Number} value The numeric value of this stage of the articulation.\n *\n * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\n *\n * @see Model#applyArticulations\n */\n\n\nModel.prototype.setArticulationStage = function (articulationStageKey, value) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"value\", value); //>>includeEnd('debug');\n\n  var stage = getRuntime(this, \"stagesByKey\", articulationStageKey);\n  var articulation = getRuntime(this, \"articulationsByStageKey\", articulationStageKey);\n\n  if (defined(stage) && defined(articulation)) {\n    value = CesiumMath.clamp(value, stage.minimumValue, stage.maximumValue);\n\n    if (!CesiumMath.equalsEpsilon(stage.currentValue, value, articulationEpsilon)) {\n      stage.currentValue = value;\n      articulation.isDirty = true;\n    }\n  }\n};\n\nvar scratchArticulationCartesian = new Cartesian3();\nvar scratchArticulationRotation = new Matrix3();\n/**\n * Modifies a Matrix4 by applying a transformation for a given value of a stage.  Note this is different usage\n * from the typical <code>result</code> parameter, in that the incoming value of <code>result</code> is\n * meaningful.  Various stages of an articulation can be multiplied together, so their\n * transformations are all merged into a composite Matrix4 representing them all.\n *\n * @param {object} stage The stage of an articulation that is being evaluated.\n * @param {Matrix4} result The matrix to be modified.\n * @returns {Matrix4} A matrix transformed as requested by the articulation stage.\n *\n * @private\n */\n\nfunction applyArticulationStageMatrix(stage, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"stage\", stage);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  var value = stage.currentValue;\n  var cartesian = scratchArticulationCartesian;\n  var rotation;\n\n  switch (stage.type) {\n    case \"xRotate\":\n      rotation = Matrix3.fromRotationX(CesiumMath.toRadians(value), scratchArticulationRotation);\n      Matrix4.multiplyByMatrix3(result, rotation, result);\n      break;\n\n    case \"yRotate\":\n      rotation = Matrix3.fromRotationY(CesiumMath.toRadians(value), scratchArticulationRotation);\n      Matrix4.multiplyByMatrix3(result, rotation, result);\n      break;\n\n    case \"zRotate\":\n      rotation = Matrix3.fromRotationZ(CesiumMath.toRadians(value), scratchArticulationRotation);\n      Matrix4.multiplyByMatrix3(result, rotation, result);\n      break;\n\n    case \"xTranslate\":\n      cartesian.x = value;\n      cartesian.y = 0.0;\n      cartesian.z = 0.0;\n      Matrix4.multiplyByTranslation(result, cartesian, result);\n      break;\n\n    case \"yTranslate\":\n      cartesian.x = 0.0;\n      cartesian.y = value;\n      cartesian.z = 0.0;\n      Matrix4.multiplyByTranslation(result, cartesian, result);\n      break;\n\n    case \"zTranslate\":\n      cartesian.x = 0.0;\n      cartesian.y = 0.0;\n      cartesian.z = value;\n      Matrix4.multiplyByTranslation(result, cartesian, result);\n      break;\n\n    case \"xScale\":\n      cartesian.x = value;\n      cartesian.y = 1.0;\n      cartesian.z = 1.0;\n      Matrix4.multiplyByScale(result, cartesian, result);\n      break;\n\n    case \"yScale\":\n      cartesian.x = 1.0;\n      cartesian.y = value;\n      cartesian.z = 1.0;\n      Matrix4.multiplyByScale(result, cartesian, result);\n      break;\n\n    case \"zScale\":\n      cartesian.x = 1.0;\n      cartesian.y = 1.0;\n      cartesian.z = value;\n      Matrix4.multiplyByScale(result, cartesian, result);\n      break;\n\n    case \"uniformScale\":\n      Matrix4.multiplyByUniformScale(result, value, result);\n      break;\n\n    default:\n      break;\n  }\n\n  return result;\n}\n\nvar scratchApplyArticulationTransform = new Matrix4();\n/**\n * Applies any modified articulation stages to the matrix of each node that participates\n * in any articulation.  Note that this will overwrite any nodeTransformations on participating nodes.\n *\n * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\n */\n\nModel.prototype.applyArticulations = function () {\n  var articulationsByName = this._runtime.articulationsByName;\n\n  for (var articulationName in articulationsByName) {\n    if (articulationsByName.hasOwnProperty(articulationName)) {\n      var articulation = articulationsByName[articulationName];\n\n      if (articulation.isDirty) {\n        articulation.isDirty = false;\n        var numNodes = articulation.nodes.length;\n\n        for (var n = 0; n < numNodes; ++n) {\n          var node = articulation.nodes[n];\n          var transform = Matrix4.clone(node.originalMatrix, scratchApplyArticulationTransform);\n          var numStages = articulation.stages.length;\n\n          for (var s = 0; s < numStages; ++s) {\n            var stage = articulation.stages[s];\n            transform = applyArticulationStageMatrix(stage, transform);\n          }\n\n          node.matrix = transform;\n        }\n      }\n    }\n  }\n}; ///////////////////////////////////////////////////////////////////////////\n\n\nfunction addBuffersToLoadResources(model) {\n  var gltf = model.gltf;\n  var loadResources = model._loadResources;\n  ForEach.buffer(gltf, function (buffer, id) {\n    loadResources.buffers[id] = buffer.extras._pipeline.source;\n  });\n}\n\nfunction bufferLoad(model, id) {\n  return function (arrayBuffer) {\n    var loadResources = model._loadResources;\n    var buffer = new Uint8Array(arrayBuffer);\n    --loadResources.pendingBufferLoads;\n    model.gltf.buffers[id].extras._pipeline.source = buffer;\n  };\n}\n\nfunction parseBufferViews(model) {\n  var bufferViews = model.gltf.bufferViews;\n  var vertexBuffersToCreate = model._loadResources.vertexBuffersToCreate; // Only ARRAY_BUFFER here.  ELEMENT_ARRAY_BUFFER created below.\n\n  ForEach.bufferView(model.gltf, function (bufferView, id) {\n    if (bufferView.target === WebGLConstants.ARRAY_BUFFER) {\n      vertexBuffersToCreate.enqueue(id);\n    }\n  });\n  var indexBuffersToCreate = model._loadResources.indexBuffersToCreate;\n  var indexBufferIds = {}; // The Cesium Renderer requires knowing the datatype for an index buffer\n  // at creation type, which is not part of the glTF bufferview so loop\n  // through glTF accessors to create the bufferview's index buffer.\n\n  ForEach.accessor(model.gltf, function (accessor) {\n    var bufferViewId = accessor.bufferView;\n\n    if (!defined(bufferViewId)) {\n      return;\n    }\n\n    var bufferView = bufferViews[bufferViewId];\n\n    if (bufferView.target === WebGLConstants.ELEMENT_ARRAY_BUFFER && !defined(indexBufferIds[bufferViewId])) {\n      indexBufferIds[bufferViewId] = true;\n      indexBuffersToCreate.enqueue({\n        id: bufferViewId,\n        componentType: accessor.componentType\n      });\n    }\n  });\n}\n\nfunction parseTechniques(model) {\n  // retain references to gltf techniques\n  var gltf = model.gltf;\n\n  if (!hasExtension(gltf, \"KHR_techniques_webgl\")) {\n    return;\n  }\n\n  var sourcePrograms = model._sourcePrograms;\n  var sourceTechniques = model._sourceTechniques;\n  var programs = gltf.extensions.KHR_techniques_webgl.programs;\n  ForEach.technique(gltf, function (technique, techniqueId) {\n    sourceTechniques[techniqueId] = clone(technique);\n    var programId = technique.program;\n\n    if (!defined(sourcePrograms[programId])) {\n      sourcePrograms[programId] = clone(programs[programId]);\n    }\n  });\n}\n\nfunction shaderLoad(model, type, id) {\n  return function (source) {\n    var loadResources = model._loadResources;\n    loadResources.shaders[id] = {\n      source: source,\n      type: type,\n      bufferView: undefined\n    };\n    --loadResources.pendingShaderLoads;\n    model._rendererResources.sourceShaders[id] = source;\n  };\n}\n\nfunction parseShaders(model) {\n  var gltf = model.gltf;\n  var buffers = gltf.buffers;\n  var bufferViews = gltf.bufferViews;\n  var sourceShaders = model._rendererResources.sourceShaders;\n  ForEach.shader(gltf, function (shader, id) {\n    // Shader references either uri (external or base64-encoded) or bufferView\n    if (defined(shader.bufferView)) {\n      var bufferViewId = shader.bufferView;\n      var bufferView = bufferViews[bufferViewId];\n      var bufferId = bufferView.buffer;\n      var buffer = buffers[bufferId];\n      var source = getStringFromTypedArray(buffer.extras._pipeline.source, bufferView.byteOffset, bufferView.byteLength);\n      sourceShaders[id] = source;\n    } else if (defined(shader.extras._pipeline.source)) {\n      sourceShaders[id] = shader.extras._pipeline.source;\n    } else {\n      ++model._loadResources.pendingShaderLoads;\n\n      var shaderResource = model._resource.getDerivedResource({\n        url: shader.uri\n      });\n\n      shaderResource.fetchText().then(shaderLoad(model, shader.type, id)).otherwise(ModelUtility.getFailedLoadFunction(model, \"shader\", shaderResource.url));\n    }\n  });\n}\n\nfunction parsePrograms(model) {\n  var sourceTechniques = model._sourceTechniques;\n\n  for (var techniqueId in sourceTechniques) {\n    if (sourceTechniques.hasOwnProperty(techniqueId)) {\n      var technique = sourceTechniques[techniqueId];\n\n      model._loadResources.programsToCreate.enqueue({\n        programId: technique.program,\n        techniqueId: techniqueId\n      });\n    }\n  }\n}\n\nfunction parseArticulations(model) {\n  var articulationsByName = {};\n  var articulationsByStageKey = {};\n  var runtimeStagesByKey = {};\n  model._runtime.articulationsByName = articulationsByName;\n  model._runtime.articulationsByStageKey = articulationsByStageKey;\n  model._runtime.stagesByKey = runtimeStagesByKey;\n  var gltf = model.gltf;\n\n  if (!hasExtension(gltf, \"AGI_articulations\") || !defined(gltf.extensions) || !defined(gltf.extensions.AGI_articulations)) {\n    return;\n  }\n\n  var gltfArticulations = gltf.extensions.AGI_articulations.articulations;\n\n  if (!defined(gltfArticulations)) {\n    return;\n  }\n\n  var numArticulations = gltfArticulations.length;\n\n  for (var i = 0; i < numArticulations; ++i) {\n    var articulation = clone(gltfArticulations[i]);\n    articulation.nodes = [];\n    articulation.isDirty = true;\n    articulationsByName[articulation.name] = articulation;\n    var numStages = articulation.stages.length;\n\n    for (var s = 0; s < numStages; ++s) {\n      var stage = articulation.stages[s];\n      stage.currentValue = stage.initialValue;\n      var stageKey = articulation.name + \" \" + stage.name;\n      articulationsByStageKey[stageKey] = articulation;\n      runtimeStagesByKey[stageKey] = stage;\n    }\n  }\n}\n\nfunction imageLoad(model, textureId) {\n  return function (image) {\n    var loadResources = model._loadResources;\n    --loadResources.pendingTextureLoads;\n    loadResources.texturesToCreate.enqueue({\n      id: textureId,\n      image: image,\n      bufferView: image.bufferView,\n      width: image.width,\n      height: image.height,\n      internalFormat: image.internalFormat\n    });\n  };\n}\n\nvar ktxRegex = /(^data:image\\/ktx)|(\\.ktx$)/i;\nvar crnRegex = /(^data:image\\/crn)|(\\.crn$)/i;\n\nfunction parseTextures(model, context, supportsWebP) {\n  var gltf = model.gltf;\n  var images = gltf.images;\n  var uri;\n  ForEach.texture(gltf, function (texture, id) {\n    var imageId = texture.source;\n\n    if (defined(texture.extensions) && defined(texture.extensions.EXT_texture_webp) && supportsWebP) {\n      imageId = texture.extensions.EXT_texture_webp.source;\n    }\n\n    var gltfImage = images[imageId];\n    var extras = gltfImage.extras;\n    var bufferViewId = gltfImage.bufferView;\n    var mimeType = gltfImage.mimeType;\n    uri = gltfImage.uri; // First check for a compressed texture\n\n    if (defined(extras) && defined(extras.compressedImage3DTiles)) {\n      var crunch = extras.compressedImage3DTiles.crunch;\n      var s3tc = extras.compressedImage3DTiles.s3tc;\n      var pvrtc = extras.compressedImage3DTiles.pvrtc1;\n      var etc1 = extras.compressedImage3DTiles.etc1;\n\n      if (context.s3tc && defined(crunch)) {\n        mimeType = crunch.mimeType;\n\n        if (defined(crunch.bufferView)) {\n          bufferViewId = crunch.bufferView;\n        } else {\n          uri = crunch.uri;\n        }\n      } else if (context.s3tc && defined(s3tc)) {\n        mimeType = s3tc.mimeType;\n\n        if (defined(s3tc.bufferView)) {\n          bufferViewId = s3tc.bufferView;\n        } else {\n          uri = s3tc.uri;\n        }\n      } else if (context.pvrtc && defined(pvrtc)) {\n        mimeType = pvrtc.mimeType;\n\n        if (defined(pvrtc.bufferView)) {\n          bufferViewId = pvrtc.bufferView;\n        } else {\n          uri = pvrtc.uri;\n        }\n      } else if (context.etc1 && defined(etc1)) {\n        mimeType = etc1.mimeType;\n\n        if (defined(etc1.bufferView)) {\n          bufferViewId = etc1.bufferView;\n        } else {\n          uri = etc1.uri;\n        }\n      }\n    } // Image references either uri (external or base64-encoded) or bufferView\n\n\n    if (defined(bufferViewId)) {\n      model._loadResources.texturesToCreateFromBufferView.enqueue({\n        id: id,\n        image: undefined,\n        bufferView: bufferViewId,\n        mimeType: mimeType\n      });\n    } else {\n      ++model._loadResources.pendingTextureLoads;\n\n      var imageResource = model._resource.getDerivedResource({\n        url: uri\n      });\n\n      var promise;\n\n      if (ktxRegex.test(uri)) {\n        promise = loadKTX(imageResource);\n      } else if (crnRegex.test(uri)) {\n        promise = loadCRN(imageResource);\n      } else {\n        promise = imageResource.fetchImage();\n      }\n\n      promise.then(imageLoad(model, id, imageId)).otherwise(ModelUtility.getFailedLoadFunction(model, \"image\", imageResource.url));\n    }\n  });\n}\n\nvar scratchArticulationStageInitialTransform = new Matrix4();\n\nfunction parseNodes(model) {\n  var runtimeNodes = {};\n  var runtimeNodesByName = {};\n  var skinnedNodes = [];\n  var skinnedNodesIds = model._loadResources.skinnedNodesIds;\n  var articulationsByName = model._runtime.articulationsByName;\n  ForEach.node(model.gltf, function (node, id) {\n    var runtimeNode = {\n      // Animation targets\n      matrix: undefined,\n      translation: undefined,\n      rotation: undefined,\n      scale: undefined,\n      // Per-node show inherited from parent\n      computedShow: true,\n      // Computed transforms\n      transformToRoot: new Matrix4(),\n      computedMatrix: new Matrix4(),\n      dirtyNumber: 0,\n      // The frame this node was made dirty by an animation; for graph traversal\n      // Rendering\n      commands: [],\n      // empty for transform, light, and camera nodes\n      // Skinned node\n      inverseBindMatrices: undefined,\n      // undefined when node is not skinned\n      bindShapeMatrix: undefined,\n      // undefined when node is not skinned or identity\n      joints: [],\n      // empty when node is not skinned\n      computedJointMatrices: [],\n      // empty when node is not skinned\n      // Joint node\n      jointName: node.jointName,\n      // undefined when node is not a joint\n      weights: [],\n      // Graph pointers\n      children: [],\n      // empty for leaf nodes\n      parents: [],\n      // empty for root nodes\n      // Publicly-accessible ModelNode instance to modify animation targets\n      publicNode: undefined\n    };\n    runtimeNode.publicNode = new ModelNode(model, node, runtimeNode, id, ModelUtility.getTransform(node));\n    runtimeNodes[id] = runtimeNode;\n    runtimeNodesByName[node.name] = runtimeNode;\n\n    if (defined(node.skin)) {\n      skinnedNodesIds.push(id);\n      skinnedNodes.push(runtimeNode);\n    }\n\n    if (defined(node.extensions) && defined(node.extensions.AGI_articulations)) {\n      var articulationName = node.extensions.AGI_articulations.articulationName;\n\n      if (defined(articulationName)) {\n        var transform = Matrix4.clone(runtimeNode.publicNode.originalMatrix, scratchArticulationStageInitialTransform);\n        var articulation = articulationsByName[articulationName];\n        articulation.nodes.push(runtimeNode.publicNode);\n        var numStages = articulation.stages.length;\n\n        for (var s = 0; s < numStages; ++s) {\n          var stage = articulation.stages[s];\n          transform = applyArticulationStageMatrix(stage, transform);\n        }\n\n        runtimeNode.publicNode.matrix = transform;\n      }\n    }\n  });\n  model._runtime.nodes = runtimeNodes;\n  model._runtime.nodesByName = runtimeNodesByName;\n  model._runtime.skinnedNodes = skinnedNodes;\n}\n\nfunction parseMaterials(model) {\n  var gltf = model.gltf;\n  var techniques = model._sourceTechniques;\n  var runtimeMaterialsByName = {};\n  var runtimeMaterialsById = {};\n  var uniformMaps = model._uniformMaps;\n  ForEach.material(gltf, function (material, materialId) {\n    // Allocated now so ModelMaterial can keep a reference to it.\n    uniformMaps[materialId] = {\n      uniformMap: undefined,\n      values: undefined,\n      jointMatrixUniformName: undefined,\n      morphWeightsUniformName: undefined\n    };\n    var modelMaterial = new ModelMaterial(model, material, materialId);\n\n    if (defined(material.extensions) && defined(material.extensions.KHR_techniques_webgl)) {\n      var techniqueId = material.extensions.KHR_techniques_webgl.technique;\n      modelMaterial._technique = techniqueId;\n      modelMaterial._program = techniques[techniqueId].program;\n      ForEach.materialValue(material, function (value, uniformName) {\n        if (!defined(modelMaterial._values)) {\n          modelMaterial._values = {};\n        }\n\n        modelMaterial._values[uniformName] = clone(value);\n      });\n    }\n\n    runtimeMaterialsByName[material.name] = modelMaterial;\n    runtimeMaterialsById[materialId] = modelMaterial;\n  });\n  model._runtime.materialsByName = runtimeMaterialsByName;\n  model._runtime.materialsById = runtimeMaterialsById;\n}\n\nfunction parseMeshes(model) {\n  var runtimeMeshesByName = {};\n  var runtimeMaterialsById = model._runtime.materialsById;\n  ForEach.mesh(model.gltf, function (mesh, meshId) {\n    runtimeMeshesByName[mesh.name] = new ModelMesh(mesh, runtimeMaterialsById, meshId);\n\n    if (defined(model.extensionsUsed.WEB3D_quantized_attributes) || model._dequantizeInShader) {\n      // Cache primitives according to their program\n      ForEach.meshPrimitive(mesh, function (primitive, primitiveId) {\n        var programId = getProgramForPrimitive(model, primitive);\n        var programPrimitives = model._programPrimitives[programId];\n\n        if (!defined(programPrimitives)) {\n          programPrimitives = {};\n          model._programPrimitives[programId] = programPrimitives;\n        }\n\n        programPrimitives[meshId + \".primitive.\" + primitiveId] = primitive;\n      });\n    }\n  });\n  model._runtime.meshesByName = runtimeMeshesByName;\n} ///////////////////////////////////////////////////////////////////////////\n\n\nvar CreateVertexBufferJob = function () {\n  this.id = undefined;\n  this.model = undefined;\n  this.context = undefined;\n};\n\nCreateVertexBufferJob.prototype.set = function (id, model, context) {\n  this.id = id;\n  this.model = model;\n  this.context = context;\n};\n\nCreateVertexBufferJob.prototype.execute = function () {\n  createVertexBuffer(this.id, this.model, this.context);\n}; ///////////////////////////////////////////////////////////////////////////\n\n\nfunction createVertexBuffer(bufferViewId, model, context) {\n  var loadResources = model._loadResources;\n  var bufferViews = model.gltf.bufferViews;\n  var bufferView = bufferViews[bufferViewId]; // Use bufferView created at runtime\n\n  if (!defined(bufferView)) {\n    bufferView = loadResources.createdBufferViews[bufferViewId];\n  }\n\n  var vertexBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: loadResources.getBuffer(bufferView),\n    usage: BufferUsage.STATIC_DRAW\n  });\n  vertexBuffer.vertexArrayDestroyable = false;\n  model._rendererResources.buffers[bufferViewId] = vertexBuffer;\n  model._geometryByteLength += vertexBuffer.sizeInBytes;\n} ///////////////////////////////////////////////////////////////////////////\n\n\nvar CreateIndexBufferJob = function () {\n  this.id = undefined;\n  this.componentType = undefined;\n  this.model = undefined;\n  this.context = undefined;\n};\n\nCreateIndexBufferJob.prototype.set = function (id, componentType, model, context) {\n  this.id = id;\n  this.componentType = componentType;\n  this.model = model;\n  this.context = context;\n};\n\nCreateIndexBufferJob.prototype.execute = function () {\n  createIndexBuffer(this.id, this.componentType, this.model, this.context);\n}; ///////////////////////////////////////////////////////////////////////////\n\n\nfunction createIndexBuffer(bufferViewId, componentType, model, context) {\n  var loadResources = model._loadResources;\n  var bufferViews = model.gltf.bufferViews;\n  var bufferView = bufferViews[bufferViewId]; // Use bufferView created at runtime\n\n  if (!defined(bufferView)) {\n    bufferView = loadResources.createdBufferViews[bufferViewId];\n  }\n\n  var indexBuffer = Buffer.createIndexBuffer({\n    context: context,\n    typedArray: loadResources.getBuffer(bufferView),\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: componentType\n  });\n  indexBuffer.vertexArrayDestroyable = false;\n  model._rendererResources.buffers[bufferViewId] = indexBuffer;\n  model._geometryByteLength += indexBuffer.sizeInBytes;\n}\n\nvar scratchVertexBufferJob = new CreateVertexBufferJob();\nvar scratchIndexBufferJob = new CreateIndexBufferJob();\n\nfunction createBuffers(model, frameState) {\n  var loadResources = model._loadResources;\n\n  if (loadResources.pendingBufferLoads !== 0) {\n    return;\n  }\n\n  var context = frameState.context;\n  var vertexBuffersToCreate = loadResources.vertexBuffersToCreate;\n  var indexBuffersToCreate = loadResources.indexBuffersToCreate;\n  var i;\n\n  if (model.asynchronous) {\n    while (vertexBuffersToCreate.length > 0) {\n      scratchVertexBufferJob.set(vertexBuffersToCreate.peek(), model, context);\n\n      if (!frameState.jobScheduler.execute(scratchVertexBufferJob, JobType.BUFFER)) {\n        break;\n      }\n\n      vertexBuffersToCreate.dequeue();\n    }\n\n    while (indexBuffersToCreate.length > 0) {\n      i = indexBuffersToCreate.peek();\n      scratchIndexBufferJob.set(i.id, i.componentType, model, context);\n\n      if (!frameState.jobScheduler.execute(scratchIndexBufferJob, JobType.BUFFER)) {\n        break;\n      }\n\n      indexBuffersToCreate.dequeue();\n    }\n  } else {\n    while (vertexBuffersToCreate.length > 0) {\n      createVertexBuffer(vertexBuffersToCreate.dequeue(), model, context);\n    }\n\n    while (indexBuffersToCreate.length > 0) {\n      i = indexBuffersToCreate.dequeue();\n      createIndexBuffer(i.id, i.componentType, model, context);\n    }\n  }\n}\n\nfunction getProgramForPrimitive(model, primitive) {\n  var material = model._runtime.materialsById[primitive.material];\n\n  if (!defined(material)) {\n    return;\n  }\n\n  return material._program;\n}\n\nfunction modifyShaderForQuantizedAttributes(shader, programName, model) {\n  var primitive;\n  var primitives = model._programPrimitives[programName]; // If no primitives were cached for this program, there's no need to modify the shader\n\n  if (!defined(primitives)) {\n    return shader;\n  }\n\n  var primitiveId;\n\n  for (primitiveId in primitives) {\n    if (primitives.hasOwnProperty(primitiveId)) {\n      primitive = primitives[primitiveId];\n\n      if (getProgramForPrimitive(model, primitive) === programName) {\n        break;\n      }\n    }\n  } // This is not needed after the program is processed, free the memory\n\n\n  model._programPrimitives[programName] = undefined;\n  var result;\n\n  if (model.extensionsUsed.WEB3D_quantized_attributes) {\n    result = ModelUtility.modifyShaderForQuantizedAttributes(model.gltf, primitive, shader);\n    model._quantizedUniforms[programName] = result.uniforms;\n  } else {\n    var decodedData = model._decodedData[primitiveId];\n\n    if (defined(decodedData)) {\n      result = ModelUtility.modifyShaderForDracoQuantizedAttributes(model.gltf, primitive, shader, decodedData.attributes);\n    } else {\n      return shader;\n    }\n  }\n\n  return result.shader;\n}\n\nfunction modifyShaderForColor(shader) {\n  shader = ShaderSource.replaceMain(shader, \"gltf_blend_main\");\n  shader += \"uniform vec4 gltf_color; \\n\" + \"uniform float gltf_colorBlend; \\n\" + \"void main() \\n\" + \"{ \\n\" + \"    gltf_blend_main(); \\n\" + \"    gl_FragColor.rgb = mix(gl_FragColor.rgb, gltf_color.rgb, gltf_colorBlend); \\n\" + \"    float highlight = ceil(gltf_colorBlend); \\n\" + \"    gl_FragColor.rgb *= mix(gltf_color.rgb, vec3(1.0), highlight); \\n\" + \"    gl_FragColor.a *= gltf_color.a; \\n\" + \"} \\n\";\n  return shader;\n}\n\nfunction modifyShader(shader, programName, callback) {\n  if (defined(callback)) {\n    shader = callback(shader, programName);\n  }\n\n  return shader;\n}\n\nvar CreateProgramJob = function () {\n  this.programToCreate = undefined;\n  this.model = undefined;\n  this.context = undefined;\n};\n\nCreateProgramJob.prototype.set = function (programToCreate, model, context) {\n  this.programToCreate = programToCreate;\n  this.model = model;\n  this.context = context;\n};\n\nCreateProgramJob.prototype.execute = function () {\n  createProgram(this.programToCreate, this.model, this.context);\n}; ///////////////////////////////////////////////////////////////////////////\n// When building programs for the first time, do not include modifiers for clipping planes and color\n// since this is the version of the program that will be cached for use with other Models.\n\n\nfunction createProgram(programToCreate, model, context) {\n  var programId = programToCreate.programId;\n  var techniqueId = programToCreate.techniqueId;\n  var program = model._sourcePrograms[programId];\n  var shaders = model._rendererResources.sourceShaders;\n  var vs = shaders[program.vertexShader];\n  var fs = shaders[program.fragmentShader];\n  var quantizedVertexShaders = model._quantizedVertexShaders;\n\n  if (model.extensionsUsed.WEB3D_quantized_attributes || model._dequantizeInShader) {\n    var quantizedVS = quantizedVertexShaders[programId];\n\n    if (!defined(quantizedVS)) {\n      quantizedVS = modifyShaderForQuantizedAttributes(vs, programId, model);\n      quantizedVertexShaders[programId] = quantizedVS;\n    }\n\n    vs = quantizedVS;\n  }\n\n  var drawVS = modifyShader(vs, programId, model._vertexShaderLoaded);\n  var drawFS = modifyShader(fs, programId, model._fragmentShaderLoaded);\n\n  if (!defined(model._uniformMapLoaded)) {\n    drawFS = \"uniform vec4 czm_pickColor;\\n\" + drawFS;\n  }\n\n  var useIBL = model._imageBasedLightingFactor.x > 0.0 || model._imageBasedLightingFactor.y > 0.0;\n\n  if (useIBL) {\n    drawFS = \"#define USE_IBL_LIGHTING \\n\\n\" + drawFS;\n  }\n\n  if (defined(model._lightColor)) {\n    drawFS = \"#define USE_CUSTOM_LIGHT_COLOR \\n\\n\" + drawFS;\n  }\n\n  if (model._sourceVersion !== \"2.0\" || model._sourceKHRTechniquesWebGL) {\n    drawFS = ShaderSource.replaceMain(drawFS, \"non_gamma_corrected_main\");\n    drawFS = drawFS + \"\\n\" + \"void main() { \\n\" + \"    non_gamma_corrected_main(); \\n\" + \"    gl_FragColor = czm_gammaCorrect(gl_FragColor); \\n\" + \"} \\n\";\n  }\n\n  if (OctahedralProjectedCubeMap.isSupported(context)) {\n    var usesSH = defined(model._sphericalHarmonicCoefficients) || model._useDefaultSphericalHarmonics;\n\n    var usesSM = defined(model._specularEnvironmentMapAtlas) && model._specularEnvironmentMapAtlas.ready || model._useDefaultSpecularMaps;\n\n    var addMatrix = usesSH || usesSM || useIBL;\n\n    if (addMatrix) {\n      drawFS = \"uniform mat3 gltf_iblReferenceFrameMatrix; \\n\" + drawFS;\n    }\n\n    if (defined(model._sphericalHarmonicCoefficients)) {\n      drawFS = \"#define DIFFUSE_IBL \\n\" + \"#define CUSTOM_SPHERICAL_HARMONICS \\n\" + \"uniform vec3 gltf_sphericalHarmonicCoefficients[9]; \\n\" + drawFS;\n    } else if (model._useDefaultSphericalHarmonics) {\n      drawFS = \"#define DIFFUSE_IBL \\n\" + drawFS;\n    }\n\n    if (defined(model._specularEnvironmentMapAtlas) && model._specularEnvironmentMapAtlas.ready) {\n      drawFS = \"#define SPECULAR_IBL \\n\" + \"#define CUSTOM_SPECULAR_IBL \\n\" + \"uniform sampler2D gltf_specularMap; \\n\" + \"uniform vec2 gltf_specularMapSize; \\n\" + \"uniform float gltf_maxSpecularLOD; \\n\" + drawFS;\n    } else if (model._useDefaultSpecularMaps) {\n      drawFS = \"#define SPECULAR_IBL \\n\" + drawFS;\n    }\n  }\n\n  if (defined(model._luminanceAtZenith)) {\n    drawFS = \"#define USE_SUN_LUMINANCE \\n\" + \"uniform float gltf_luminanceAtZenith;\\n\" + drawFS;\n  }\n\n  createAttributesAndProgram(programId, techniqueId, drawFS, drawVS, model, context);\n}\n\nfunction recreateProgram(programToCreate, model, context) {\n  var programId = programToCreate.programId;\n  var techniqueId = programToCreate.techniqueId;\n  var program = model._sourcePrograms[programId];\n  var shaders = model._rendererResources.sourceShaders;\n  var quantizedVertexShaders = model._quantizedVertexShaders;\n  var clippingPlaneCollection = model.clippingPlanes;\n  var addClippingPlaneCode = isClippingEnabled(model);\n  var vs = shaders[program.vertexShader];\n  var fs = shaders[program.fragmentShader];\n\n  if (model.extensionsUsed.WEB3D_quantized_attributes || model._dequantizeInShader) {\n    vs = quantizedVertexShaders[programId];\n  }\n\n  var finalFS = fs;\n\n  if (isColorShadingEnabled(model)) {\n    finalFS = Model._modifyShaderForColor(finalFS);\n  }\n\n  if (addClippingPlaneCode) {\n    finalFS = modifyShaderForClippingPlanes(finalFS, clippingPlaneCollection, context);\n  }\n\n  var drawVS = modifyShader(vs, programId, model._vertexShaderLoaded);\n  var drawFS = modifyShader(finalFS, programId, model._fragmentShaderLoaded);\n\n  if (!defined(model._uniformMapLoaded)) {\n    drawFS = \"uniform vec4 czm_pickColor;\\n\" + drawFS;\n  }\n\n  var useIBL = model._imageBasedLightingFactor.x > 0.0 || model._imageBasedLightingFactor.y > 0.0;\n\n  if (useIBL) {\n    drawFS = \"#define USE_IBL_LIGHTING \\n\\n\" + drawFS;\n  }\n\n  if (defined(model._lightColor)) {\n    drawFS = \"#define USE_CUSTOM_LIGHT_COLOR \\n\\n\" + drawFS;\n  }\n\n  if (model._sourceVersion !== \"2.0\" || model._sourceKHRTechniquesWebGL) {\n    drawFS = ShaderSource.replaceMain(drawFS, \"non_gamma_corrected_main\");\n    drawFS = drawFS + \"\\n\" + \"void main() { \\n\" + \"    non_gamma_corrected_main(); \\n\" + \"    gl_FragColor = czm_gammaCorrect(gl_FragColor); \\n\" + \"} \\n\";\n  }\n\n  if (OctahedralProjectedCubeMap.isSupported(context)) {\n    var usesSH = defined(model._sphericalHarmonicCoefficients) || model._useDefaultSphericalHarmonics;\n\n    var usesSM = defined(model._specularEnvironmentMapAtlas) && model._specularEnvironmentMapAtlas.ready || model._useDefaultSpecularMaps;\n\n    var addMatrix = usesSH || usesSM || useIBL;\n\n    if (addMatrix) {\n      drawFS = \"uniform mat3 gltf_iblReferenceFrameMatrix; \\n\" + drawFS;\n    }\n\n    if (defined(model._sphericalHarmonicCoefficients)) {\n      drawFS = \"#define DIFFUSE_IBL \\n\" + \"#define CUSTOM_SPHERICAL_HARMONICS \\n\" + \"uniform vec3 gltf_sphericalHarmonicCoefficients[9]; \\n\" + drawFS;\n    } else if (model._useDefaultSphericalHarmonics) {\n      drawFS = \"#define DIFFUSE_IBL \\n\" + drawFS;\n    }\n\n    if (defined(model._specularEnvironmentMapAtlas) && model._specularEnvironmentMapAtlas.ready) {\n      drawFS = \"#define SPECULAR_IBL \\n\" + \"#define CUSTOM_SPECULAR_IBL \\n\" + \"uniform sampler2D gltf_specularMap; \\n\" + \"uniform vec2 gltf_specularMapSize; \\n\" + \"uniform float gltf_maxSpecularLOD; \\n\" + drawFS;\n    } else if (model._useDefaultSpecularMaps) {\n      drawFS = \"#define SPECULAR_IBL \\n\" + drawFS;\n    }\n  }\n\n  if (defined(model._luminanceAtZenith)) {\n    drawFS = \"#define USE_SUN_LUMINANCE \\n\" + \"uniform float gltf_luminanceAtZenith;\\n\" + drawFS;\n  }\n\n  createAttributesAndProgram(programId, techniqueId, drawFS, drawVS, model, context);\n}\n\nfunction createAttributesAndProgram(programId, techniqueId, drawFS, drawVS, model, context) {\n  var technique = model._sourceTechniques[techniqueId];\n  var attributeLocations = ModelUtility.createAttributeLocations(technique, model._precreatedAttributes);\n  model._rendererResources.programs[programId] = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: drawVS,\n    fragmentShaderSource: drawFS,\n    attributeLocations: attributeLocations\n  });\n}\n\nvar scratchCreateProgramJob = new CreateProgramJob();\n\nfunction createPrograms(model, frameState) {\n  var loadResources = model._loadResources;\n  var programsToCreate = loadResources.programsToCreate;\n\n  if (loadResources.pendingShaderLoads !== 0) {\n    return;\n  } // PERFORMANCE_IDEA: this could be more fine-grained by looking\n  // at the shader's bufferView's to determine the buffer dependencies.\n\n\n  if (loadResources.pendingBufferLoads !== 0) {\n    return;\n  }\n\n  var context = frameState.context;\n\n  if (model.asynchronous) {\n    while (programsToCreate.length > 0) {\n      scratchCreateProgramJob.set(programsToCreate.peek(), model, context);\n\n      if (!frameState.jobScheduler.execute(scratchCreateProgramJob, JobType.PROGRAM)) {\n        break;\n      }\n\n      programsToCreate.dequeue();\n    }\n  } else {\n    // Create all loaded programs this frame\n    while (programsToCreate.length > 0) {\n      createProgram(programsToCreate.dequeue(), model, context);\n    }\n  }\n}\n\nfunction getOnImageCreatedFromTypedArray(loadResources, gltfTexture) {\n  return function (image) {\n    loadResources.texturesToCreate.enqueue({\n      id: gltfTexture.id,\n      image: image,\n      bufferView: undefined\n    });\n    --loadResources.pendingBufferViewToImage;\n  };\n}\n\nfunction loadTexturesFromBufferViews(model) {\n  var loadResources = model._loadResources;\n\n  if (loadResources.pendingBufferLoads !== 0) {\n    return;\n  }\n\n  while (loadResources.texturesToCreateFromBufferView.length > 0) {\n    var gltfTexture = loadResources.texturesToCreateFromBufferView.dequeue();\n    var gltf = model.gltf;\n    var bufferView = gltf.bufferViews[gltfTexture.bufferView];\n    var imageId = gltf.textures[gltfTexture.id].source;\n    var onerror = ModelUtility.getFailedLoadFunction(model, \"image\", \"id: \" + gltfTexture.id + \", bufferView: \" + gltfTexture.bufferView);\n\n    if (gltfTexture.mimeType === \"image/ktx\") {\n      loadKTX(loadResources.getBuffer(bufferView)).then(imageLoad(model, gltfTexture.id, imageId)).otherwise(onerror);\n      ++model._loadResources.pendingTextureLoads;\n    } else if (gltfTexture.mimeType === \"image/crn\") {\n      loadCRN(loadResources.getBuffer(bufferView)).then(imageLoad(model, gltfTexture.id, imageId)).otherwise(onerror);\n      ++model._loadResources.pendingTextureLoads;\n    } else {\n      var onload = getOnImageCreatedFromTypedArray(loadResources, gltfTexture);\n      loadImageFromTypedArray({\n        uint8Array: loadResources.getBuffer(bufferView),\n        format: gltfTexture.mimeType,\n        flipY: false\n      }).then(onload).otherwise(onerror);\n      ++loadResources.pendingBufferViewToImage;\n    }\n  }\n}\n\nfunction createSamplers(model) {\n  var loadResources = model._loadResources;\n\n  if (loadResources.createSamplers) {\n    loadResources.createSamplers = false;\n    var rendererSamplers = model._rendererResources.samplers;\n    ForEach.sampler(model.gltf, function (sampler, samplerId) {\n      rendererSamplers[samplerId] = new Sampler({\n        wrapS: sampler.wrapS,\n        wrapT: sampler.wrapT,\n        minificationFilter: sampler.minFilter,\n        magnificationFilter: sampler.magFilter\n      });\n    });\n  }\n} ///////////////////////////////////////////////////////////////////////////\n\n\nvar CreateTextureJob = function () {\n  this.gltfTexture = undefined;\n  this.model = undefined;\n  this.context = undefined;\n};\n\nCreateTextureJob.prototype.set = function (gltfTexture, model, context) {\n  this.gltfTexture = gltfTexture;\n  this.model = model;\n  this.context = context;\n};\n\nCreateTextureJob.prototype.execute = function () {\n  createTexture(this.gltfTexture, this.model, this.context);\n}; ///////////////////////////////////////////////////////////////////////////\n\n\nfunction createTexture(gltfTexture, model, context) {\n  var textures = model.gltf.textures;\n  var texture = textures[gltfTexture.id];\n  var rendererSamplers = model._rendererResources.samplers;\n  var sampler = rendererSamplers[texture.sampler];\n\n  if (!defined(sampler)) {\n    sampler = new Sampler({\n      wrapS: TextureWrap.REPEAT,\n      wrapT: TextureWrap.REPEAT\n    });\n  }\n\n  var usesTextureTransform = false;\n  var materials = model.gltf.materials;\n  var materialsLength = materials.length;\n\n  for (var i = 0; i < materialsLength; ++i) {\n    var material = materials[i];\n\n    if (defined(material.extensions) && defined(material.extensions.KHR_techniques_webgl)) {\n      var values = material.extensions.KHR_techniques_webgl.values;\n\n      for (var valueName in values) {\n        if (values.hasOwnProperty(valueName) && valueName.indexOf(\"Texture\") !== -1) {\n          var value = values[valueName];\n\n          if (value.index === gltfTexture.id && defined(value.extensions) && defined(value.extensions.KHR_texture_transform)) {\n            usesTextureTransform = true;\n            break;\n          }\n        }\n      }\n    }\n\n    if (usesTextureTransform) {\n      break;\n    }\n  }\n\n  var wrapS = sampler.wrapS;\n  var wrapT = sampler.wrapT;\n  var minFilter = sampler.minificationFilter;\n\n  if (usesTextureTransform && minFilter !== TextureMinificationFilter.LINEAR && minFilter !== TextureMinificationFilter.NEAREST) {\n    if (minFilter === TextureMinificationFilter.NEAREST_MIPMAP_NEAREST || minFilter === TextureMinificationFilter.NEAREST_MIPMAP_LINEAR) {\n      minFilter = TextureMinificationFilter.NEAREST;\n    } else {\n      minFilter = TextureMinificationFilter.LINEAR;\n    }\n\n    sampler = new Sampler({\n      wrapS: sampler.wrapS,\n      wrapT: sampler.wrapT,\n      textureMinificationFilter: minFilter,\n      textureMagnificationFilter: sampler.magnificationFilter\n    });\n  }\n\n  var internalFormat = gltfTexture.internalFormat;\n  var mipmap = !(defined(internalFormat) && PixelFormat.isCompressedFormat(internalFormat)) && (minFilter === TextureMinificationFilter.NEAREST_MIPMAP_NEAREST || minFilter === TextureMinificationFilter.NEAREST_MIPMAP_LINEAR || minFilter === TextureMinificationFilter.LINEAR_MIPMAP_NEAREST || minFilter === TextureMinificationFilter.LINEAR_MIPMAP_LINEAR);\n  var requiresNpot = mipmap || wrapS === TextureWrap.REPEAT || wrapS === TextureWrap.MIRRORED_REPEAT || wrapT === TextureWrap.REPEAT || wrapT === TextureWrap.MIRRORED_REPEAT;\n  var tx;\n  var source = gltfTexture.image;\n\n  if (defined(internalFormat)) {\n    tx = new Texture({\n      context: context,\n      source: {\n        arrayBufferView: gltfTexture.bufferView\n      },\n      width: gltfTexture.width,\n      height: gltfTexture.height,\n      pixelFormat: internalFormat,\n      sampler: sampler\n    });\n  } else if (defined(source)) {\n    var npot = !CesiumMath.isPowerOfTwo(source.width) || !CesiumMath.isPowerOfTwo(source.height);\n\n    if (requiresNpot && npot) {\n      // WebGL requires power-of-two texture dimensions for mipmapping and REPEAT/MIRRORED_REPEAT wrap modes.\n      var canvas = document.createElement(\"canvas\");\n      canvas.width = CesiumMath.nextPowerOfTwo(source.width);\n      canvas.height = CesiumMath.nextPowerOfTwo(source.height);\n      var canvasContext = canvas.getContext(\"2d\");\n      canvasContext.drawImage(source, 0, 0, source.width, source.height, 0, 0, canvas.width, canvas.height);\n      source = canvas;\n    }\n\n    tx = new Texture({\n      context: context,\n      source: source,\n      pixelFormat: texture.internalFormat,\n      pixelDatatype: texture.type,\n      sampler: sampler,\n      flipY: false\n    }); // GLTF_SPEC: Support TEXTURE_CUBE_MAP.  https://github.com/KhronosGroup/glTF/issues/40\n\n    if (mipmap) {\n      tx.generateMipmap();\n    }\n  }\n\n  if (defined(tx)) {\n    model._rendererResources.textures[gltfTexture.id] = tx;\n    model._texturesByteLength += tx.sizeInBytes;\n  }\n}\n\nvar scratchCreateTextureJob = new CreateTextureJob();\n\nfunction createTextures(model, frameState) {\n  var context = frameState.context;\n  var texturesToCreate = model._loadResources.texturesToCreate;\n\n  if (model.asynchronous) {\n    while (texturesToCreate.length > 0) {\n      scratchCreateTextureJob.set(texturesToCreate.peek(), model, context);\n\n      if (!frameState.jobScheduler.execute(scratchCreateTextureJob, JobType.TEXTURE)) {\n        break;\n      }\n\n      texturesToCreate.dequeue();\n    }\n  } else {\n    // Create all loaded textures this frame\n    while (texturesToCreate.length > 0) {\n      createTexture(texturesToCreate.dequeue(), model, context);\n    }\n  }\n}\n\nfunction getAttributeLocations(model, primitive) {\n  var techniques = model._sourceTechniques; // Retrieve the compiled shader program to assign index values to attributes\n\n  var attributeLocations = {};\n  var location;\n  var index;\n  var material = model._runtime.materialsById[primitive.material];\n\n  if (!defined(material)) {\n    return attributeLocations;\n  }\n\n  var technique = techniques[material._technique];\n\n  if (!defined(technique)) {\n    return attributeLocations;\n  }\n\n  var attributes = technique.attributes;\n  var program = model._rendererResources.programs[technique.program];\n  var programAttributeLocations = program._attributeLocations;\n\n  for (location in programAttributeLocations) {\n    if (programAttributeLocations.hasOwnProperty(location)) {\n      var attribute = attributes[location];\n\n      if (defined(attribute)) {\n        index = programAttributeLocations[location];\n        attributeLocations[attribute.semantic] = index;\n      }\n    }\n  } // Add pre-created attributes.\n\n\n  var precreatedAttributes = model._precreatedAttributes;\n\n  if (defined(precreatedAttributes)) {\n    for (location in precreatedAttributes) {\n      if (precreatedAttributes.hasOwnProperty(location)) {\n        index = programAttributeLocations[location];\n        attributeLocations[location] = index;\n      }\n    }\n  }\n\n  return attributeLocations;\n}\n\nfunction createJoints(model, runtimeSkins) {\n  var gltf = model.gltf;\n  var skins = gltf.skins;\n  var nodes = gltf.nodes;\n  var runtimeNodes = model._runtime.nodes;\n  var skinnedNodesIds = model._loadResources.skinnedNodesIds;\n  var length = skinnedNodesIds.length;\n\n  for (var j = 0; j < length; ++j) {\n    var id = skinnedNodesIds[j];\n    var skinnedNode = runtimeNodes[id];\n    var node = nodes[id];\n    var runtimeSkin = runtimeSkins[node.skin];\n    skinnedNode.inverseBindMatrices = runtimeSkin.inverseBindMatrices;\n    skinnedNode.bindShapeMatrix = runtimeSkin.bindShapeMatrix;\n    var gltfJoints = skins[node.skin].joints;\n    var jointsLength = gltfJoints.length;\n\n    for (var i = 0; i < jointsLength; ++i) {\n      var nodeId = gltfJoints[i];\n      var jointNode = runtimeNodes[nodeId];\n      skinnedNode.joints.push(jointNode);\n    }\n  }\n}\n\nfunction createSkins(model) {\n  var loadResources = model._loadResources;\n\n  if (loadResources.pendingBufferLoads !== 0) {\n    return;\n  }\n\n  if (!loadResources.createSkins) {\n    return;\n  }\n\n  loadResources.createSkins = false;\n  var gltf = model.gltf;\n  var accessors = gltf.accessors;\n  var runtimeSkins = {};\n  ForEach.skin(gltf, function (skin, id) {\n    var accessor = accessors[skin.inverseBindMatrices];\n    var bindShapeMatrix;\n\n    if (!Matrix4.equals(skin.bindShapeMatrix, Matrix4.IDENTITY)) {\n      bindShapeMatrix = Matrix4.clone(skin.bindShapeMatrix);\n    }\n\n    runtimeSkins[id] = {\n      inverseBindMatrices: ModelAnimationCache.getSkinInverseBindMatrices(model, accessor),\n      bindShapeMatrix: bindShapeMatrix // not used when undefined\n\n    };\n  });\n  createJoints(model, runtimeSkins);\n}\n\nfunction getChannelEvaluator(model, runtimeNode, targetPath, spline) {\n  return function (localAnimationTime) {\n    if (defined(spline)) {\n      localAnimationTime = model.clampAnimations ? spline.clampTime(localAnimationTime) : spline.wrapTime(localAnimationTime);\n      runtimeNode[targetPath] = spline.evaluate(localAnimationTime, runtimeNode[targetPath]);\n      runtimeNode.dirtyNumber = model._maxDirtyNumber;\n    }\n  };\n}\n\nfunction createRuntimeAnimations(model) {\n  var loadResources = model._loadResources;\n\n  if (!loadResources.finishedPendingBufferLoads()) {\n    return;\n  }\n\n  if (!loadResources.createRuntimeAnimations) {\n    return;\n  }\n\n  loadResources.createRuntimeAnimations = false;\n  model._runtime.animations = [];\n  var runtimeNodes = model._runtime.nodes;\n  var accessors = model.gltf.accessors;\n  ForEach.animation(model.gltf, function (animation, i) {\n    var channels = animation.channels;\n    var samplers = animation.samplers; // Find start and stop time for the entire animation\n\n    var startTime = Number.MAX_VALUE;\n    var stopTime = -Number.MAX_VALUE;\n    var channelsLength = channels.length;\n    var channelEvaluators = new Array(channelsLength);\n\n    for (var j = 0; j < channelsLength; ++j) {\n      var channel = channels[j];\n      var target = channel.target;\n      var path = target.path;\n      var sampler = samplers[channel.sampler];\n      var input = ModelAnimationCache.getAnimationParameterValues(model, accessors[sampler.input]);\n      var output = ModelAnimationCache.getAnimationParameterValues(model, accessors[sampler.output]);\n      startTime = Math.min(startTime, input[0]);\n      stopTime = Math.max(stopTime, input[input.length - 1]);\n      var spline = ModelAnimationCache.getAnimationSpline(model, i, animation, channel.sampler, sampler, input, path, output);\n      channelEvaluators[j] = getChannelEvaluator(model, runtimeNodes[target.node], target.path, spline);\n    }\n\n    model._runtime.animations[i] = {\n      name: animation.name,\n      startTime: startTime,\n      stopTime: stopTime,\n      channelEvaluators: channelEvaluators\n    };\n  });\n}\n\nfunction createVertexArrays(model, context) {\n  var loadResources = model._loadResources;\n\n  if (!loadResources.finishedBuffersCreation() || !loadResources.finishedProgramCreation() || !loadResources.createVertexArrays) {\n    return;\n  }\n\n  loadResources.createVertexArrays = false;\n  var rendererBuffers = model._rendererResources.buffers;\n  var rendererVertexArrays = model._rendererResources.vertexArrays;\n  var gltf = model.gltf;\n  var accessors = gltf.accessors;\n  ForEach.mesh(gltf, function (mesh, meshId) {\n    ForEach.meshPrimitive(mesh, function (primitive, primitiveId) {\n      var attributes = [];\n      var attributeLocation;\n      var attributeLocations = getAttributeLocations(model, primitive);\n      var decodedData = model._decodedData[meshId + \".primitive.\" + primitiveId];\n      ForEach.meshPrimitiveAttribute(primitive, function (accessorId, attributeName) {\n        // Skip if the attribute is not used by the material, e.g., because the asset\n        // was exported with an attribute that wasn't used and the asset wasn't optimized.\n        attributeLocation = attributeLocations[attributeName];\n\n        if (defined(attributeLocation)) {\n          // Use attributes of previously decoded draco geometry\n          if (defined(decodedData)) {\n            var decodedAttributes = decodedData.attributes;\n\n            if (decodedAttributes.hasOwnProperty(attributeName)) {\n              var decodedAttribute = decodedAttributes[attributeName];\n              attributes.push({\n                index: attributeLocation,\n                vertexBuffer: rendererBuffers[decodedAttribute.bufferView],\n                componentsPerAttribute: decodedAttribute.componentsPerAttribute,\n                componentDatatype: decodedAttribute.componentDatatype,\n                normalize: decodedAttribute.normalized,\n                offsetInBytes: decodedAttribute.byteOffset,\n                strideInBytes: decodedAttribute.byteStride\n              });\n              return;\n            }\n          }\n\n          var a = accessors[accessorId];\n          var normalize = defined(a.normalized) && a.normalized;\n          attributes.push({\n            index: attributeLocation,\n            vertexBuffer: rendererBuffers[a.bufferView],\n            componentsPerAttribute: numberOfComponentsForType(a.type),\n            componentDatatype: a.componentType,\n            normalize: normalize,\n            offsetInBytes: a.byteOffset,\n            strideInBytes: getAccessorByteStride(gltf, a)\n          });\n        }\n      }); // Add pre-created attributes\n\n      var attribute;\n      var attributeName;\n      var precreatedAttributes = model._precreatedAttributes;\n\n      if (defined(precreatedAttributes)) {\n        for (attributeName in precreatedAttributes) {\n          if (precreatedAttributes.hasOwnProperty(attributeName)) {\n            attributeLocation = attributeLocations[attributeName];\n\n            if (defined(attributeLocation)) {\n              attribute = precreatedAttributes[attributeName];\n              attribute.index = attributeLocation;\n              attributes.push(attribute);\n            }\n          }\n        }\n      }\n\n      var indexBuffer;\n\n      if (defined(primitive.indices)) {\n        var accessor = accessors[primitive.indices];\n        var bufferView = accessor.bufferView; // Use buffer of previously decoded draco geometry\n\n        if (defined(decodedData)) {\n          bufferView = decodedData.bufferView;\n        }\n\n        indexBuffer = rendererBuffers[bufferView];\n      }\n\n      rendererVertexArrays[meshId + \".primitive.\" + primitiveId] = new VertexArray({\n        context: context,\n        attributes: attributes,\n        indexBuffer: indexBuffer\n      });\n    });\n  });\n}\n\nfunction createRenderStates(model) {\n  var loadResources = model._loadResources;\n\n  if (loadResources.createRenderStates) {\n    loadResources.createRenderStates = false;\n    ForEach.material(model.gltf, function (material, materialId) {\n      createRenderStateForMaterial(model, material, materialId);\n    });\n  }\n}\n\nfunction createRenderStateForMaterial(model, material, materialId) {\n  var rendererRenderStates = model._rendererResources.renderStates;\n  var blendEquationSeparate = [WebGLConstants.FUNC_ADD, WebGLConstants.FUNC_ADD];\n  var blendFuncSeparate = [WebGLConstants.ONE, WebGLConstants.ONE_MINUS_SRC_ALPHA, WebGLConstants.ONE, WebGLConstants.ONE_MINUS_SRC_ALPHA];\n\n  if (defined(material.extensions) && defined(material.extensions.KHR_blend)) {\n    blendEquationSeparate = material.extensions.KHR_blend.blendEquation;\n    blendFuncSeparate = material.extensions.KHR_blend.blendFactors;\n  }\n\n  var enableCulling = !material.doubleSided;\n  var blendingEnabled = material.alphaMode === \"BLEND\";\n  rendererRenderStates[materialId] = RenderState.fromCache({\n    cull: {\n      enabled: enableCulling\n    },\n    depthTest: {\n      enabled: true,\n      func: DepthFunction.LESS_OR_EQUAL\n    },\n    depthMask: !blendingEnabled,\n    blending: {\n      enabled: blendingEnabled,\n      equationRgb: blendEquationSeparate[0],\n      equationAlpha: blendEquationSeparate[1],\n      functionSourceRgb: blendFuncSeparate[0],\n      functionDestinationRgb: blendFuncSeparate[1],\n      functionSourceAlpha: blendFuncSeparate[2],\n      functionDestinationAlpha: blendFuncSeparate[3]\n    }\n  });\n} ///////////////////////////////////////////////////////////////////////////\n\n\nvar gltfUniformsFromNode = {\n  MODEL: function (uniformState, model, runtimeNode) {\n    return function () {\n      return runtimeNode.computedMatrix;\n    };\n  },\n  VIEW: function (uniformState, model, runtimeNode) {\n    return function () {\n      return uniformState.view;\n    };\n  },\n  PROJECTION: function (uniformState, model, runtimeNode) {\n    return function () {\n      return uniformState.projection;\n    };\n  },\n  MODELVIEW: function (uniformState, model, runtimeNode) {\n    var mv = new Matrix4();\n    return function () {\n      return Matrix4.multiplyTransformation(uniformState.view, runtimeNode.computedMatrix, mv);\n    };\n  },\n  CESIUM_RTC_MODELVIEW: function (uniformState, model, runtimeNode) {\n    // CESIUM_RTC extension\n    var mvRtc = new Matrix4();\n    return function () {\n      Matrix4.multiplyTransformation(uniformState.view, runtimeNode.computedMatrix, mvRtc);\n      return Matrix4.setTranslation(mvRtc, model._rtcCenterEye, mvRtc);\n    };\n  },\n  MODELVIEWPROJECTION: function (uniformState, model, runtimeNode) {\n    var mvp = new Matrix4();\n    return function () {\n      Matrix4.multiplyTransformation(uniformState.view, runtimeNode.computedMatrix, mvp);\n      return Matrix4.multiply(uniformState._projection, mvp, mvp);\n    };\n  },\n  MODELINVERSE: function (uniformState, model, runtimeNode) {\n    var mInverse = new Matrix4();\n    return function () {\n      return Matrix4.inverse(runtimeNode.computedMatrix, mInverse);\n    };\n  },\n  VIEWINVERSE: function (uniformState, model) {\n    return function () {\n      return uniformState.inverseView;\n    };\n  },\n  PROJECTIONINVERSE: function (uniformState, model, runtimeNode) {\n    return function () {\n      return uniformState.inverseProjection;\n    };\n  },\n  MODELVIEWINVERSE: function (uniformState, model, runtimeNode) {\n    var mv = new Matrix4();\n    var mvInverse = new Matrix4();\n    return function () {\n      Matrix4.multiplyTransformation(uniformState.view, runtimeNode.computedMatrix, mv);\n      return Matrix4.inverse(mv, mvInverse);\n    };\n  },\n  MODELVIEWPROJECTIONINVERSE: function (uniformState, model, runtimeNode) {\n    var mvp = new Matrix4();\n    var mvpInverse = new Matrix4();\n    return function () {\n      Matrix4.multiplyTransformation(uniformState.view, runtimeNode.computedMatrix, mvp);\n      Matrix4.multiply(uniformState._projection, mvp, mvp);\n      return Matrix4.inverse(mvp, mvpInverse);\n    };\n  },\n  MODELINVERSETRANSPOSE: function (uniformState, model, runtimeNode) {\n    var mInverse = new Matrix4();\n    var mInverseTranspose = new Matrix3();\n    return function () {\n      Matrix4.inverse(runtimeNode.computedMatrix, mInverse);\n      Matrix4.getMatrix3(mInverse, mInverseTranspose);\n      return Matrix3.transpose(mInverseTranspose, mInverseTranspose);\n    };\n  },\n  MODELVIEWINVERSETRANSPOSE: function (uniformState, model, runtimeNode) {\n    var mv = new Matrix4();\n    var mvInverse = new Matrix4();\n    var mvInverseTranspose = new Matrix3();\n    return function () {\n      Matrix4.multiplyTransformation(uniformState.view, runtimeNode.computedMatrix, mv);\n      Matrix4.inverse(mv, mvInverse);\n      Matrix4.getMatrix3(mvInverse, mvInverseTranspose);\n      return Matrix3.transpose(mvInverseTranspose, mvInverseTranspose);\n    };\n  },\n  VIEWPORT: function (uniformState, model, runtimeNode) {\n    return function () {\n      return uniformState.viewportCartesian4;\n    };\n  }\n};\n\nfunction getUniformFunctionFromSource(source, model, semantic, uniformState) {\n  var runtimeNode = model._runtime.nodes[source];\n  return gltfUniformsFromNode[semantic](uniformState, model, runtimeNode);\n}\n\nfunction createUniformsForMaterial(model, material, technique, instanceValues, context, textures, defaultTexture) {\n  var uniformMap = {};\n  var uniformValues = {};\n  var jointMatrixUniformName;\n  var morphWeightsUniformName;\n  ForEach.techniqueUniform(technique, function (uniform, uniformName) {\n    // GLTF_SPEC: This does not take into account uniform arrays,\n    // indicated by uniforms with a count property.\n    //\n    // https://github.com/KhronosGroup/glTF/issues/258\n    // GLTF_SPEC: In this implementation, material parameters with a\n    // semantic or targeted via a source (for animation) are not\n    // targetable for material animations.  Is this too strict?\n    //\n    // https://github.com/KhronosGroup/glTF/issues/142\n    var uv;\n\n    if (defined(instanceValues) && defined(instanceValues[uniformName])) {\n      // Parameter overrides by the instance technique\n      uv = ModelUtility.createUniformFunction(uniform.type, instanceValues[uniformName], textures, defaultTexture);\n      uniformMap[uniformName] = uv.func;\n      uniformValues[uniformName] = uv;\n    } else if (defined(uniform.node)) {\n      uniformMap[uniformName] = getUniformFunctionFromSource(uniform.node, model, uniform.semantic, context.uniformState);\n    } else if (defined(uniform.semantic)) {\n      if (uniform.semantic === \"JOINTMATRIX\") {\n        jointMatrixUniformName = uniformName;\n      } else if (uniform.semantic === \"MORPHWEIGHTS\") {\n        morphWeightsUniformName = uniformName;\n      } else if (uniform.semantic === \"ALPHACUTOFF\") {\n        // The material's alphaCutoff value uses a uniform with semantic ALPHACUTOFF.\n        // A uniform with this semantic will ignore the instance or default values.\n        var alphaMode = material.alphaMode;\n\n        if (defined(alphaMode) && alphaMode === \"MASK\") {\n          var alphaCutoffValue = defaultValue(material.alphaCutoff, 0.5);\n          uv = ModelUtility.createUniformFunction(uniform.type, alphaCutoffValue, textures, defaultTexture);\n          uniformMap[uniformName] = uv.func;\n          uniformValues[uniformName] = uv;\n        }\n      } else {\n        // Map glTF semantic to Cesium automatic uniform\n        uniformMap[uniformName] = ModelUtility.getGltfSemanticUniforms()[uniform.semantic](context.uniformState, model);\n      }\n    } else if (defined(uniform.value)) {\n      // Technique value that isn't overridden by a material\n      var uv2 = ModelUtility.createUniformFunction(uniform.type, uniform.value, textures, defaultTexture);\n      uniformMap[uniformName] = uv2.func;\n      uniformValues[uniformName] = uv2;\n    }\n  });\n  return {\n    map: uniformMap,\n    values: uniformValues,\n    jointMatrixUniformName: jointMatrixUniformName,\n    morphWeightsUniformName: morphWeightsUniformName\n  };\n}\n\nfunction createUniformMaps(model, context) {\n  var loadResources = model._loadResources;\n\n  if (!loadResources.finishedProgramCreation()) {\n    return;\n  }\n\n  if (!loadResources.createUniformMaps) {\n    return;\n  }\n\n  loadResources.createUniformMaps = false;\n  var gltf = model.gltf;\n  var techniques = model._sourceTechniques;\n  var uniformMaps = model._uniformMaps;\n  var textures = model._rendererResources.textures;\n  var defaultTexture = model._defaultTexture;\n  ForEach.material(gltf, function (material, materialId) {\n    var modelMaterial = model._runtime.materialsById[materialId];\n    var technique = techniques[modelMaterial._technique];\n    var instanceValues = modelMaterial._values;\n    var uniforms = createUniformsForMaterial(model, material, technique, instanceValues, context, textures, defaultTexture);\n    var u = uniformMaps[materialId];\n    u.uniformMap = uniforms.map; // uniform name -> function for the renderer\n\n    u.values = uniforms.values; // material parameter name -> ModelMaterial for modifying the parameter at runtime\n\n    u.jointMatrixUniformName = uniforms.jointMatrixUniformName;\n    u.morphWeightsUniformName = uniforms.morphWeightsUniformName;\n\n    if (defined(technique.attributes.a_outlineCoordinates)) {\n      var outlineTexture = ModelOutlineLoader.createTexture(model, context);\n\n      u.uniformMap.u_outlineTexture = function () {\n        return outlineTexture;\n      };\n    }\n  });\n}\n\nfunction createUniformsForDracoQuantizedAttributes(decodedData) {\n  return ModelUtility.createUniformsForDracoQuantizedAttributes(decodedData.attributes);\n}\n\nfunction createUniformsForQuantizedAttributes(model, primitive) {\n  var programId = getProgramForPrimitive(model, primitive);\n  var quantizedUniforms = model._quantizedUniforms[programId];\n  return ModelUtility.createUniformsForQuantizedAttributes(model.gltf, primitive, quantizedUniforms);\n}\n\nfunction createPickColorFunction(color) {\n  return function () {\n    return color;\n  };\n}\n\nfunction createJointMatricesFunction(runtimeNode) {\n  return function () {\n    return runtimeNode.computedJointMatrices;\n  };\n}\n\nfunction createMorphWeightsFunction(runtimeNode) {\n  return function () {\n    return runtimeNode.weights;\n  };\n}\n\nfunction createSilhouetteColorFunction(model) {\n  return function () {\n    return model.silhouetteColor;\n  };\n}\n\nfunction createSilhouetteSizeFunction(model) {\n  return function () {\n    return model.silhouetteSize;\n  };\n}\n\nfunction createColorFunction(model) {\n  return function () {\n    return model.color;\n  };\n}\n\nfunction createClippingPlanesMatrixFunction(model) {\n  return function () {\n    return model._clippingPlanesMatrix;\n  };\n}\n\nfunction createIBLReferenceFrameMatrixFunction(model) {\n  return function () {\n    return model._iblReferenceFrameMatrix;\n  };\n}\n\nfunction createClippingPlanesFunction(model) {\n  return function () {\n    var clippingPlanes = model.clippingPlanes;\n    return !defined(clippingPlanes) || !clippingPlanes.enabled ? model._defaultTexture : clippingPlanes.texture;\n  };\n}\n\nfunction createClippingPlanesEdgeStyleFunction(model) {\n  return function () {\n    var clippingPlanes = model.clippingPlanes;\n\n    if (!defined(clippingPlanes)) {\n      return Color.WHITE.withAlpha(0.0);\n    }\n\n    var style = Color.clone(clippingPlanes.edgeColor);\n    style.alpha = clippingPlanes.edgeWidth;\n    return style;\n  };\n}\n\nfunction createColorBlendFunction(model) {\n  return function () {\n    return ColorBlendMode.getColorBlend(model.colorBlendMode, model.colorBlendAmount);\n  };\n}\n\nfunction createIBLFactorFunction(model) {\n  return function () {\n    return model._imageBasedLightingFactor;\n  };\n}\n\nfunction createLightColorFunction(model) {\n  return function () {\n    return model._lightColor;\n  };\n}\n\nfunction createLuminanceAtZenithFunction(model) {\n  return function () {\n    return model.luminanceAtZenith;\n  };\n}\n\nfunction createSphericalHarmonicCoefficientsFunction(model) {\n  return function () {\n    return model._sphericalHarmonicCoefficients;\n  };\n}\n\nfunction createSpecularEnvironmentMapFunction(model) {\n  return function () {\n    return model._specularEnvironmentMapAtlas.texture;\n  };\n}\n\nfunction createSpecularEnvironmentMapSizeFunction(model) {\n  return function () {\n    return model._specularEnvironmentMapAtlas.texture.dimensions;\n  };\n}\n\nfunction createSpecularEnvironmentMapLOD(model) {\n  return function () {\n    return model._specularEnvironmentMapAtlas.maximumMipmapLevel;\n  };\n}\n\nfunction triangleCountFromPrimitiveIndices(primitive, indicesCount) {\n  switch (primitive.mode) {\n    case PrimitiveType.TRIANGLES:\n      return indicesCount / 3;\n\n    case PrimitiveType.TRIANGLE_STRIP:\n    case PrimitiveType.TRIANGLE_FAN:\n      return Math.max(indicesCount - 2, 0);\n\n    default:\n      return 0;\n  }\n}\n\nfunction createCommand(model, gltfNode, runtimeNode, context, scene3DOnly) {\n  var nodeCommands = model._nodeCommands;\n  var pickIds = model._pickIds;\n  var allowPicking = model.allowPicking;\n  var runtimeMeshesByName = model._runtime.meshesByName;\n  var resources = model._rendererResources;\n  var rendererVertexArrays = resources.vertexArrays;\n  var rendererPrograms = resources.programs;\n  var rendererRenderStates = resources.renderStates;\n  var uniformMaps = model._uniformMaps;\n  var gltf = model.gltf;\n  var accessors = gltf.accessors;\n  var gltfMeshes = gltf.meshes;\n  var id = gltfNode.mesh;\n  var mesh = gltfMeshes[id];\n  var primitives = mesh.primitives;\n  var length = primitives.length; // The glTF node hierarchy is a DAG so a node can have more than one\n  // parent, so a node may already have commands.  If so, append more\n  // since they will have a different model matrix.\n\n  for (var i = 0; i < length; ++i) {\n    var primitive = primitives[i];\n    var ix = accessors[primitive.indices];\n    var material = model._runtime.materialsById[primitive.material];\n    var programId = material._program;\n    var decodedData = model._decodedData[id + \".primitive.\" + i];\n    var boundingSphere;\n    var positionAccessor = primitive.attributes.POSITION;\n\n    if (defined(positionAccessor)) {\n      var minMax = ModelUtility.getAccessorMinMax(gltf, positionAccessor);\n      boundingSphere = BoundingSphere.fromCornerPoints(Cartesian3.fromArray(minMax.min), Cartesian3.fromArray(minMax.max));\n    }\n\n    var vertexArray = rendererVertexArrays[id + \".primitive.\" + i];\n    var offset;\n    var count; // Use indices of the previously decoded Draco geometry.\n\n    if (defined(decodedData)) {\n      count = decodedData.numberOfIndices;\n      offset = 0;\n    } else if (defined(ix)) {\n      count = ix.count;\n      offset = ix.byteOffset / IndexDatatype.getSizeInBytes(ix.componentType); // glTF has offset in bytes.  Cesium has offsets in indices\n    } else {\n      var positions = accessors[primitive.attributes.POSITION];\n      count = positions.count;\n      offset = 0;\n    } // Update model triangle count using number of indices\n\n\n    model._trianglesLength += triangleCountFromPrimitiveIndices(primitive, count);\n    var um = uniformMaps[primitive.material];\n    var uniformMap = um.uniformMap;\n\n    if (defined(um.jointMatrixUniformName)) {\n      var jointUniformMap = {};\n      jointUniformMap[um.jointMatrixUniformName] = createJointMatricesFunction(runtimeNode);\n      uniformMap = combine(uniformMap, jointUniformMap);\n    }\n\n    if (defined(um.morphWeightsUniformName)) {\n      var morphWeightsUniformMap = {};\n      morphWeightsUniformMap[um.morphWeightsUniformName] = createMorphWeightsFunction(runtimeNode);\n      uniformMap = combine(uniformMap, morphWeightsUniformMap);\n    }\n\n    uniformMap = combine(uniformMap, {\n      gltf_color: createColorFunction(model),\n      gltf_colorBlend: createColorBlendFunction(model),\n      gltf_clippingPlanes: createClippingPlanesFunction(model),\n      gltf_clippingPlanesEdgeStyle: createClippingPlanesEdgeStyleFunction(model),\n      gltf_clippingPlanesMatrix: createClippingPlanesMatrixFunction(model),\n      gltf_iblReferenceFrameMatrix: createIBLReferenceFrameMatrixFunction(model),\n      gltf_iblFactor: createIBLFactorFunction(model),\n      gltf_lightColor: createLightColorFunction(model),\n      gltf_sphericalHarmonicCoefficients: createSphericalHarmonicCoefficientsFunction(model),\n      gltf_specularMap: createSpecularEnvironmentMapFunction(model),\n      gltf_specularMapSize: createSpecularEnvironmentMapSizeFunction(model),\n      gltf_maxSpecularLOD: createSpecularEnvironmentMapLOD(model),\n      gltf_luminanceAtZenith: createLuminanceAtZenithFunction(model)\n    }); // Allow callback to modify the uniformMap\n\n    if (defined(model._uniformMapLoaded)) {\n      uniformMap = model._uniformMapLoaded(uniformMap, programId, runtimeNode);\n    } // Add uniforms for decoding quantized attributes if used\n\n\n    var quantizedUniformMap = {};\n\n    if (model.extensionsUsed.WEB3D_quantized_attributes) {\n      quantizedUniformMap = createUniformsForQuantizedAttributes(model, primitive);\n    } else if (model._dequantizeInShader && defined(decodedData)) {\n      quantizedUniformMap = createUniformsForDracoQuantizedAttributes(decodedData);\n    }\n\n    uniformMap = combine(uniformMap, quantizedUniformMap);\n    var rs = rendererRenderStates[primitive.material];\n    var isTranslucent = rs.blending.enabled;\n    var owner = model._pickObject;\n\n    if (!defined(owner)) {\n      owner = {\n        primitive: model,\n        id: model.id,\n        node: runtimeNode.publicNode,\n        mesh: runtimeMeshesByName[mesh.name]\n      };\n    }\n\n    var castShadows = ShadowMode.castShadows(model._shadows);\n    var receiveShadows = ShadowMode.receiveShadows(model._shadows);\n    var pickId;\n\n    if (allowPicking && !defined(model._uniformMapLoaded)) {\n      pickId = context.createPickId(owner);\n      pickIds.push(pickId);\n      var pickUniforms = {\n        czm_pickColor: createPickColorFunction(pickId.color)\n      };\n      uniformMap = combine(uniformMap, pickUniforms);\n    }\n\n    if (allowPicking) {\n      if (defined(model._pickIdLoaded) && defined(model._uniformMapLoaded)) {\n        pickId = model._pickIdLoaded();\n      } else {\n        pickId = \"czm_pickColor\";\n      }\n    }\n\n    var command = new DrawCommand({\n      boundingVolume: new BoundingSphere(),\n      // updated in update()\n      cull: model.cull,\n      modelMatrix: new Matrix4(),\n      // computed in update()\n      primitiveType: primitive.mode,\n      vertexArray: vertexArray,\n      count: count,\n      offset: offset,\n      shaderProgram: rendererPrograms[programId],\n      castShadows: castShadows,\n      receiveShadows: receiveShadows,\n      uniformMap: uniformMap,\n      renderState: rs,\n      owner: owner,\n      pass: isTranslucent ? Pass.TRANSLUCENT : model.opaquePass,\n      pickId: pickId\n    });\n    var command2D;\n\n    if (!scene3DOnly) {\n      command2D = DrawCommand.shallowClone(command);\n      command2D.boundingVolume = new BoundingSphere(); // updated in update()\n\n      command2D.modelMatrix = new Matrix4(); // updated in update()\n    }\n\n    var nodeCommand = {\n      show: true,\n      boundingSphere: boundingSphere,\n      command: command,\n      command2D: command2D,\n      // Generated on demand when silhouette size is greater than 0.0 and silhouette alpha is greater than 0.0\n      silhouetteModelCommand: undefined,\n      silhouetteModelCommand2D: undefined,\n      silhouetteColorCommand: undefined,\n      silhouetteColorCommand2D: undefined,\n      // Generated on demand when color alpha is less than 1.0\n      translucentCommand: undefined,\n      translucentCommand2D: undefined,\n      // Generated on demand when back face culling is false\n      disableCullingCommand: undefined,\n      disableCullingCommand2D: undefined,\n      // For updating node commands on shader reconstruction\n      programId: programId\n    };\n    runtimeNode.commands.push(nodeCommand);\n    nodeCommands.push(nodeCommand);\n  }\n}\n\nfunction createRuntimeNodes(model, context, scene3DOnly) {\n  var loadResources = model._loadResources;\n\n  if (!loadResources.finishedEverythingButTextureCreation()) {\n    return;\n  }\n\n  if (!loadResources.createRuntimeNodes) {\n    return;\n  }\n\n  loadResources.createRuntimeNodes = false;\n  var rootNodes = [];\n  var runtimeNodes = model._runtime.nodes;\n  var gltf = model.gltf;\n  var nodes = gltf.nodes;\n  var scene = gltf.scenes[gltf.scene];\n  var sceneNodes = scene.nodes;\n  var length = sceneNodes.length;\n  var stack = [];\n  var seen = {};\n\n  for (var i = 0; i < length; ++i) {\n    stack.push({\n      parentRuntimeNode: undefined,\n      gltfNode: nodes[sceneNodes[i]],\n      id: sceneNodes[i]\n    });\n\n    while (stack.length > 0) {\n      var n = stack.pop();\n      seen[n.id] = true;\n      var parentRuntimeNode = n.parentRuntimeNode;\n      var gltfNode = n.gltfNode; // Node hierarchy is a DAG so a node can have more than one parent so it may already exist\n\n      var runtimeNode = runtimeNodes[n.id];\n\n      if (runtimeNode.parents.length === 0) {\n        if (defined(gltfNode.matrix)) {\n          runtimeNode.matrix = Matrix4.fromColumnMajorArray(gltfNode.matrix);\n        } else {\n          // TRS converted to Cesium types\n          var rotation = gltfNode.rotation;\n          runtimeNode.translation = Cartesian3.fromArray(gltfNode.translation);\n          runtimeNode.rotation = Quaternion.unpack(rotation);\n          runtimeNode.scale = Cartesian3.fromArray(gltfNode.scale);\n        }\n      }\n\n      if (defined(parentRuntimeNode)) {\n        parentRuntimeNode.children.push(runtimeNode);\n        runtimeNode.parents.push(parentRuntimeNode);\n      } else {\n        rootNodes.push(runtimeNode);\n      }\n\n      if (defined(gltfNode.mesh)) {\n        createCommand(model, gltfNode, runtimeNode, context, scene3DOnly);\n      }\n\n      var children = gltfNode.children;\n\n      if (defined(children)) {\n        var childrenLength = children.length;\n\n        for (var j = 0; j < childrenLength; j++) {\n          var childId = children[j];\n\n          if (!seen[childId]) {\n            stack.push({\n              parentRuntimeNode: runtimeNode,\n              gltfNode: nodes[childId],\n              id: children[j]\n            });\n          }\n        }\n      }\n    }\n  }\n\n  model._runtime.rootNodes = rootNodes;\n  model._runtime.nodes = runtimeNodes;\n}\n\nfunction getGeometryByteLength(buffers) {\n  var memory = 0;\n\n  for (var id in buffers) {\n    if (buffers.hasOwnProperty(id)) {\n      memory += buffers[id].sizeInBytes;\n    }\n  }\n\n  return memory;\n}\n\nfunction getTexturesByteLength(textures) {\n  var memory = 0;\n\n  for (var id in textures) {\n    if (textures.hasOwnProperty(id)) {\n      memory += textures[id].sizeInBytes;\n    }\n  }\n\n  return memory;\n}\n\nfunction createResources(model, frameState) {\n  var context = frameState.context;\n  var scene3DOnly = frameState.scene3DOnly;\n  var quantizedVertexShaders = model._quantizedVertexShaders;\n  var techniques = model._sourceTechniques;\n  var programs = model._sourcePrograms;\n  var resources = model._rendererResources;\n  var shaders = resources.sourceShaders;\n\n  if (model._loadRendererResourcesFromCache) {\n    shaders = resources.sourceShaders = model._cachedRendererResources.sourceShaders;\n  }\n\n  for (var techniqueId in techniques) {\n    if (techniques.hasOwnProperty(techniqueId)) {\n      var programId = techniques[techniqueId].program;\n      var program = programs[programId];\n      var shader = shaders[program.vertexShader];\n      ModelUtility.checkSupportedGlExtensions(program.glExtensions, context);\n\n      if (model.extensionsUsed.WEB3D_quantized_attributes || model._dequantizeInShader) {\n        var quantizedVS = quantizedVertexShaders[programId];\n\n        if (!defined(quantizedVS)) {\n          quantizedVS = modifyShaderForQuantizedAttributes(shader, programId, model);\n          quantizedVertexShaders[programId] = quantizedVS;\n        }\n\n        shader = quantizedVS;\n      }\n\n      shader = modifyShader(shader, programId, model._vertexShaderLoaded);\n    }\n  }\n\n  if (model._loadRendererResourcesFromCache) {\n    var cachedResources = model._cachedRendererResources;\n    resources.buffers = cachedResources.buffers;\n    resources.vertexArrays = cachedResources.vertexArrays;\n    resources.programs = cachedResources.programs;\n    resources.silhouettePrograms = cachedResources.silhouettePrograms;\n    resources.textures = cachedResources.textures;\n    resources.samplers = cachedResources.samplers;\n    resources.renderStates = cachedResources.renderStates; // Vertex arrays are unique to this model, create instead of using the cache.\n\n    if (defined(model._precreatedAttributes)) {\n      createVertexArrays(model, context);\n    }\n\n    model._cachedGeometryByteLength += getGeometryByteLength(cachedResources.buffers);\n    model._cachedTexturesByteLength += getTexturesByteLength(cachedResources.textures);\n  } else {\n    createBuffers(model, frameState); // using glTF bufferViews\n\n    createPrograms(model, frameState);\n    createSamplers(model, context);\n    loadTexturesFromBufferViews(model);\n    createTextures(model, frameState);\n  }\n\n  createSkins(model);\n  createRuntimeAnimations(model);\n\n  if (!model._loadRendererResourcesFromCache) {\n    createVertexArrays(model, context); // using glTF meshes\n\n    createRenderStates(model); // using glTF materials/techniques/states\n    // Long-term, we might not cache render states if they could change\n    // due to an animation, e.g., a uniform going from opaque to transparent.\n    // Could use copy-on-write if it is worth it.  Probably overkill.\n  }\n\n  createUniformMaps(model, context); // using glTF materials/techniques\n\n  createRuntimeNodes(model, context, scene3DOnly); // using glTF scene\n} ///////////////////////////////////////////////////////////////////////////\n\n\nfunction getNodeMatrix(node, result) {\n  var publicNode = node.publicNode;\n  var publicMatrix = publicNode.matrix;\n\n  if (publicNode.useMatrix && defined(publicMatrix)) {\n    // Public matrix overrides original glTF matrix and glTF animations\n    Matrix4.clone(publicMatrix, result);\n  } else if (defined(node.matrix)) {\n    Matrix4.clone(node.matrix, result);\n  } else {\n    Matrix4.fromTranslationQuaternionRotationScale(node.translation, node.rotation, node.scale, result); // Keep matrix returned by the node in-sync if the node is targeted by an animation.  Only TRS nodes can be targeted.\n\n    publicNode.setMatrix(result);\n  }\n}\n\nvar scratchNodeStack = [];\nvar scratchComputedTranslation = new Cartesian4();\nvar scratchComputedMatrixIn2D = new Matrix4();\n\nfunction updateNodeHierarchyModelMatrix(model, modelTransformChanged, justLoaded, projection) {\n  var maxDirtyNumber = model._maxDirtyNumber;\n  var rootNodes = model._runtime.rootNodes;\n  var length = rootNodes.length;\n  var nodeStack = scratchNodeStack;\n  var computedModelMatrix = model._computedModelMatrix;\n\n  if (model._mode !== SceneMode.SCENE3D && !model._ignoreCommands) {\n    var translation = Matrix4.getColumn(computedModelMatrix, 3, scratchComputedTranslation);\n\n    if (!Cartesian4.equals(translation, Cartesian4.UNIT_W)) {\n      computedModelMatrix = Transforms.basisTo2D(projection, computedModelMatrix, scratchComputedMatrixIn2D);\n      model._rtcCenter = model._rtcCenter3D;\n    } else {\n      var center = model.boundingSphere.center;\n      var to2D = Transforms.wgs84To2DModelMatrix(projection, center, scratchComputedMatrixIn2D);\n      computedModelMatrix = Matrix4.multiply(to2D, computedModelMatrix, scratchComputedMatrixIn2D);\n\n      if (defined(model._rtcCenter)) {\n        Matrix4.setTranslation(computedModelMatrix, Cartesian4.UNIT_W, computedModelMatrix);\n        model._rtcCenter = model._rtcCenter2D;\n      }\n    }\n  }\n\n  for (var i = 0; i < length; ++i) {\n    var n = rootNodes[i];\n    getNodeMatrix(n, n.transformToRoot);\n    nodeStack.push(n);\n\n    while (nodeStack.length > 0) {\n      n = nodeStack.pop();\n      var transformToRoot = n.transformToRoot;\n      var commands = n.commands;\n\n      if (n.dirtyNumber === maxDirtyNumber || modelTransformChanged || justLoaded) {\n        var nodeMatrix = Matrix4.multiplyTransformation(computedModelMatrix, transformToRoot, n.computedMatrix);\n        var commandsLength = commands.length;\n\n        if (commandsLength > 0) {\n          // Node has meshes, which has primitives.  Update their commands.\n          for (var j = 0; j < commandsLength; ++j) {\n            var primitiveCommand = commands[j];\n            var command = primitiveCommand.command;\n            Matrix4.clone(nodeMatrix, command.modelMatrix); // PERFORMANCE_IDEA: Can use transformWithoutScale if no node up to the root has scale (including animation)\n\n            BoundingSphere.transform(primitiveCommand.boundingSphere, command.modelMatrix, command.boundingVolume);\n\n            if (defined(model._rtcCenter)) {\n              Cartesian3.add(model._rtcCenter, command.boundingVolume.center, command.boundingVolume.center);\n            } // If the model crosses the IDL in 2D, it will be drawn in one viewport, but part of it\n            // will be clipped by the viewport. We create a second command that translates the model\n            // model matrix to the opposite side of the map so the part that was clipped in one viewport\n            // is drawn in the other.\n\n\n            command = primitiveCommand.command2D;\n\n            if (defined(command) && model._mode === SceneMode.SCENE2D) {\n              Matrix4.clone(nodeMatrix, command.modelMatrix);\n              command.modelMatrix[13] -= CesiumMath.sign(command.modelMatrix[13]) * 2.0 * CesiumMath.PI * projection.ellipsoid.maximumRadius;\n              BoundingSphere.transform(primitiveCommand.boundingSphere, command.modelMatrix, command.boundingVolume);\n            }\n          }\n        }\n      }\n\n      var children = n.children;\n\n      if (defined(children)) {\n        var childrenLength = children.length;\n\n        for (var k = 0; k < childrenLength; ++k) {\n          var child = children[k]; // A node's transform needs to be updated if\n          // - It was targeted for animation this frame, or\n          // - Any of its ancestors were targeted for animation this frame\n          // PERFORMANCE_IDEA: if a child has multiple parents and only one of the parents\n          // is dirty, all the subtrees for each child instance will be dirty; we probably\n          // won't see this in the wild often.\n\n          child.dirtyNumber = Math.max(child.dirtyNumber, n.dirtyNumber);\n\n          if (child.dirtyNumber === maxDirtyNumber || justLoaded) {\n            // Don't check for modelTransformChanged since if only the model's model matrix changed,\n            // we do not need to rebuild the local transform-to-root, only the final\n            // [model's-model-matrix][transform-to-root] above.\n            getNodeMatrix(child, child.transformToRoot);\n            Matrix4.multiplyTransformation(transformToRoot, child.transformToRoot, child.transformToRoot);\n          }\n\n          nodeStack.push(child);\n        }\n      }\n    }\n  }\n\n  ++model._maxDirtyNumber;\n}\n\nvar scratchObjectSpace = new Matrix4();\n\nfunction applySkins(model) {\n  var skinnedNodes = model._runtime.skinnedNodes;\n  var length = skinnedNodes.length;\n\n  for (var i = 0; i < length; ++i) {\n    var node = skinnedNodes[i];\n    scratchObjectSpace = Matrix4.inverseTransformation(node.transformToRoot, scratchObjectSpace);\n    var computedJointMatrices = node.computedJointMatrices;\n    var joints = node.joints;\n    var bindShapeMatrix = node.bindShapeMatrix;\n    var inverseBindMatrices = node.inverseBindMatrices;\n    var inverseBindMatricesLength = inverseBindMatrices.length;\n\n    for (var m = 0; m < inverseBindMatricesLength; ++m) {\n      // [joint-matrix] = [node-to-root^-1][joint-to-root][inverse-bind][bind-shape]\n      if (!defined(computedJointMatrices[m])) {\n        computedJointMatrices[m] = new Matrix4();\n      }\n\n      computedJointMatrices[m] = Matrix4.multiplyTransformation(scratchObjectSpace, joints[m].transformToRoot, computedJointMatrices[m]);\n      computedJointMatrices[m] = Matrix4.multiplyTransformation(computedJointMatrices[m], inverseBindMatrices[m], computedJointMatrices[m]);\n\n      if (defined(bindShapeMatrix)) {\n        // NOTE: bindShapeMatrix is glTF 1.0 only, removed in glTF 2.0.\n        computedJointMatrices[m] = Matrix4.multiplyTransformation(computedJointMatrices[m], bindShapeMatrix, computedJointMatrices[m]);\n      }\n    }\n  }\n}\n\nfunction updatePerNodeShow(model) {\n  // Totally not worth it, but we could optimize this:\n  // http://help.agi.com/AGIComponents/html/BlogDeletionInBoundingVolumeHierarchies.htm\n  var rootNodes = model._runtime.rootNodes;\n  var length = rootNodes.length;\n  var nodeStack = scratchNodeStack;\n\n  for (var i = 0; i < length; ++i) {\n    var n = rootNodes[i];\n    n.computedShow = n.publicNode.show;\n    nodeStack.push(n);\n\n    while (nodeStack.length > 0) {\n      n = nodeStack.pop();\n      var show = n.computedShow;\n      var nodeCommands = n.commands;\n      var nodeCommandsLength = nodeCommands.length;\n\n      for (var j = 0; j < nodeCommandsLength; ++j) {\n        nodeCommands[j].show = show;\n      } // if commandsLength is zero, the node has a light or camera\n\n\n      var children = n.children;\n\n      if (defined(children)) {\n        var childrenLength = children.length;\n\n        for (var k = 0; k < childrenLength; ++k) {\n          var child = children[k]; // Parent needs to be shown for child to be shown.\n\n          child.computedShow = show && child.publicNode.show;\n          nodeStack.push(child);\n        }\n      }\n    }\n  }\n}\n\nfunction updatePickIds(model, context) {\n  var id = model.id;\n\n  if (model._id !== id) {\n    model._id = id;\n    var pickIds = model._pickIds;\n    var length = pickIds.length;\n\n    for (var i = 0; i < length; ++i) {\n      pickIds[i].object.id = id;\n    }\n  }\n}\n\nfunction updateWireframe(model) {\n  if (model._debugWireframe !== model.debugWireframe) {\n    model._debugWireframe = model.debugWireframe; // This assumes the original primitive was TRIANGLES and that the triangles\n    // are connected for the wireframe to look perfect.\n\n    var primitiveType = model.debugWireframe ? PrimitiveType.LINES : PrimitiveType.TRIANGLES;\n    var nodeCommands = model._nodeCommands;\n    var length = nodeCommands.length;\n\n    for (var i = 0; i < length; ++i) {\n      nodeCommands[i].command.primitiveType = primitiveType;\n    }\n  }\n}\n\nfunction updateShowBoundingVolume(model) {\n  if (model.debugShowBoundingVolume !== model._debugShowBoundingVolume) {\n    model._debugShowBoundingVolume = model.debugShowBoundingVolume;\n    var debugShowBoundingVolume = model.debugShowBoundingVolume;\n    var nodeCommands = model._nodeCommands;\n    var length = nodeCommands.length;\n\n    for (var i = 0; i < length; ++i) {\n      nodeCommands[i].command.debugShowBoundingVolume = debugShowBoundingVolume;\n    }\n  }\n}\n\nfunction updateShadows(model) {\n  if (model.shadows !== model._shadows) {\n    model._shadows = model.shadows;\n    var castShadows = ShadowMode.castShadows(model.shadows);\n    var receiveShadows = ShadowMode.receiveShadows(model.shadows);\n    var nodeCommands = model._nodeCommands;\n    var length = nodeCommands.length;\n\n    for (var i = 0; i < length; i++) {\n      var nodeCommand = nodeCommands[i];\n      nodeCommand.command.castShadows = castShadows;\n      nodeCommand.command.receiveShadows = receiveShadows;\n    }\n  }\n}\n\nfunction getTranslucentRenderState(renderState) {\n  var rs = clone(renderState, true);\n  rs.cull.enabled = false;\n  rs.depthTest.enabled = true;\n  rs.depthMask = false;\n  rs.blending = BlendingState.ALPHA_BLEND;\n  return RenderState.fromCache(rs);\n}\n\nfunction deriveTranslucentCommand(command) {\n  var translucentCommand = DrawCommand.shallowClone(command);\n  translucentCommand.pass = Pass.TRANSLUCENT;\n  translucentCommand.renderState = getTranslucentRenderState(command.renderState);\n  return translucentCommand;\n}\n\nfunction updateColor(model, frameState, forceDerive) {\n  // Generate translucent commands when the blend color has an alpha in the range (0.0, 1.0) exclusive\n  var scene3DOnly = frameState.scene3DOnly;\n  var alpha = model.color.alpha;\n\n  if (alpha > 0.0 && alpha < 1.0) {\n    var nodeCommands = model._nodeCommands;\n    var length = nodeCommands.length;\n\n    if (length > 0 && (!defined(nodeCommands[0].translucentCommand) || forceDerive)) {\n      for (var i = 0; i < length; ++i) {\n        var nodeCommand = nodeCommands[i];\n        var command = nodeCommand.command;\n        nodeCommand.translucentCommand = deriveTranslucentCommand(command);\n\n        if (!scene3DOnly) {\n          var command2D = nodeCommand.command2D;\n          nodeCommand.translucentCommand2D = deriveTranslucentCommand(command2D);\n        }\n      }\n    }\n  }\n}\n\nfunction getDisableCullingRenderState(renderState) {\n  var rs = clone(renderState, true);\n  rs.cull.enabled = false;\n  return RenderState.fromCache(rs);\n}\n\nfunction deriveDisableCullingCommand(command) {\n  var disableCullingCommand = DrawCommand.shallowClone(command);\n  disableCullingCommand.renderState = getDisableCullingRenderState(command.renderState);\n  return disableCullingCommand;\n}\n\nfunction updateBackFaceCulling(model, frameState, forceDerive) {\n  var scene3DOnly = frameState.scene3DOnly;\n  var backFaceCulling = model.backFaceCulling;\n\n  if (!backFaceCulling) {\n    var nodeCommands = model._nodeCommands;\n    var length = nodeCommands.length;\n\n    if (length > 0 && (!defined(nodeCommands[0].disableCullingCommand) || forceDerive)) {\n      for (var i = 0; i < length; ++i) {\n        var nodeCommand = nodeCommands[i];\n        var command = nodeCommand.command;\n        nodeCommand.disableCullingCommand = deriveDisableCullingCommand(command);\n\n        if (!scene3DOnly) {\n          var command2D = nodeCommand.command2D;\n          nodeCommand.disableCullingCommand2D = deriveDisableCullingCommand(command2D);\n        }\n      }\n    }\n  }\n}\n\nfunction getProgramId(model, program) {\n  var programs = model._rendererResources.programs;\n\n  for (var id in programs) {\n    if (programs.hasOwnProperty(id)) {\n      if (programs[id] === program) {\n        return id;\n      }\n    }\n  }\n}\n\nfunction createSilhouetteProgram(model, program, frameState) {\n  var vs = program.vertexShaderSource.sources[0];\n  var attributeLocations = program._attributeLocations;\n  var normalAttributeName = model._normalAttributeName; // Modified from http://forum.unity3d.com/threads/toon-outline-but-with-diffuse-surface.24668/\n\n  vs = ShaderSource.replaceMain(vs, \"gltf_silhouette_main\");\n  vs += \"uniform float gltf_silhouetteSize; \\n\" + \"void main() \\n\" + \"{ \\n\" + \"    gltf_silhouette_main(); \\n\" + \"    vec3 n = normalize(czm_normal3D * \" + normalAttributeName + \"); \\n\" + \"    n.x *= czm_projection[0][0]; \\n\" + \"    n.y *= czm_projection[1][1]; \\n\" + \"    vec4 clip = gl_Position; \\n\" + \"    clip.xy += n.xy * clip.w * gltf_silhouetteSize * czm_pixelRatio / czm_viewport.z; \\n\" + \"    gl_Position = clip; \\n\" + \"}\";\n  var fs = \"uniform vec4 gltf_silhouetteColor; \\n\" + \"void main() \\n\" + \"{ \\n\" + \"    gl_FragColor = czm_gammaCorrect(gltf_silhouetteColor); \\n\" + \"}\";\n  return ShaderProgram.fromCache({\n    context: frameState.context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations\n  });\n}\n\nfunction hasSilhouette(model, frameState) {\n  return silhouetteSupported(frameState.context) && model.silhouetteSize > 0.0 && model.silhouetteColor.alpha > 0.0 && defined(model._normalAttributeName);\n}\n\nfunction hasTranslucentCommands(model) {\n  var nodeCommands = model._nodeCommands;\n  var length = nodeCommands.length;\n\n  for (var i = 0; i < length; ++i) {\n    var nodeCommand = nodeCommands[i];\n    var command = nodeCommand.command;\n\n    if (command.pass === Pass.TRANSLUCENT) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction isTranslucent(model) {\n  return model.color.alpha > 0.0 && model.color.alpha < 1.0;\n}\n\nfunction isInvisible(model) {\n  return model.color.alpha === 0.0;\n}\n\nfunction alphaDirty(currAlpha, prevAlpha) {\n  // Returns whether the alpha state has changed between invisible, translucent, or opaque\n  return Math.floor(currAlpha) !== Math.floor(prevAlpha) || Math.ceil(currAlpha) !== Math.ceil(prevAlpha);\n}\n\nvar silhouettesLength = 0;\n\nfunction createSilhouetteCommands(model, frameState) {\n  // Wrap around after exceeding the 8-bit stencil limit.\n  // The reference is unique to each model until this point.\n  var stencilReference = ++silhouettesLength % 255; // If the model is translucent the silhouette needs to be in the translucent pass.\n  // Otherwise the silhouette would be rendered before the model.\n\n  var silhouetteTranslucent = hasTranslucentCommands(model) || isTranslucent(model) || model.silhouetteColor.alpha < 1.0;\n  var silhouettePrograms = model._rendererResources.silhouettePrograms;\n  var scene3DOnly = frameState.scene3DOnly;\n  var nodeCommands = model._nodeCommands;\n  var length = nodeCommands.length;\n\n  for (var i = 0; i < length; ++i) {\n    var nodeCommand = nodeCommands[i];\n    var command = nodeCommand.command; // Create model command\n\n    var modelCommand = isTranslucent(model) ? nodeCommand.translucentCommand : command;\n    var silhouetteModelCommand = DrawCommand.shallowClone(modelCommand);\n    var renderState = clone(modelCommand.renderState); // Write the reference value into the stencil buffer.\n\n    renderState.stencilTest = {\n      enabled: true,\n      frontFunction: WebGLConstants.ALWAYS,\n      backFunction: WebGLConstants.ALWAYS,\n      reference: stencilReference,\n      mask: ~0,\n      frontOperation: {\n        fail: WebGLConstants.KEEP,\n        zFail: WebGLConstants.KEEP,\n        zPass: WebGLConstants.REPLACE\n      },\n      backOperation: {\n        fail: WebGLConstants.KEEP,\n        zFail: WebGLConstants.KEEP,\n        zPass: WebGLConstants.REPLACE\n      }\n    };\n\n    if (isInvisible(model)) {\n      // When the model is invisible disable color and depth writes but still write into the stencil buffer\n      renderState.colorMask = {\n        red: false,\n        green: false,\n        blue: false,\n        alpha: false\n      };\n      renderState.depthMask = false;\n    }\n\n    renderState = RenderState.fromCache(renderState);\n    silhouetteModelCommand.renderState = renderState;\n    nodeCommand.silhouetteModelCommand = silhouetteModelCommand; // Create color command\n\n    var silhouetteColorCommand = DrawCommand.shallowClone(command);\n    renderState = clone(command.renderState, true);\n    renderState.depthTest.enabled = true;\n    renderState.cull.enabled = false;\n\n    if (silhouetteTranslucent) {\n      silhouetteColorCommand.pass = Pass.TRANSLUCENT;\n      renderState.depthMask = false;\n      renderState.blending = BlendingState.ALPHA_BLEND;\n    } // Only render silhouette if the value in the stencil buffer equals the reference\n\n\n    renderState.stencilTest = {\n      enabled: true,\n      frontFunction: WebGLConstants.NOTEQUAL,\n      backFunction: WebGLConstants.NOTEQUAL,\n      reference: stencilReference,\n      mask: ~0,\n      frontOperation: {\n        fail: WebGLConstants.KEEP,\n        zFail: WebGLConstants.KEEP,\n        zPass: WebGLConstants.KEEP\n      },\n      backOperation: {\n        fail: WebGLConstants.KEEP,\n        zFail: WebGLConstants.KEEP,\n        zPass: WebGLConstants.KEEP\n      }\n    };\n    renderState = RenderState.fromCache(renderState); // If the silhouette program has already been cached use it\n\n    var program = command.shaderProgram;\n    var id = getProgramId(model, program);\n    var silhouetteProgram = silhouettePrograms[id];\n\n    if (!defined(silhouetteProgram)) {\n      silhouetteProgram = createSilhouetteProgram(model, program, frameState);\n      silhouettePrograms[id] = silhouetteProgram;\n    }\n\n    var silhouetteUniformMap = combine(command.uniformMap, {\n      gltf_silhouetteColor: createSilhouetteColorFunction(model),\n      gltf_silhouetteSize: createSilhouetteSizeFunction(model)\n    });\n    silhouetteColorCommand.renderState = renderState;\n    silhouetteColorCommand.shaderProgram = silhouetteProgram;\n    silhouetteColorCommand.uniformMap = silhouetteUniformMap;\n    silhouetteColorCommand.castShadows = false;\n    silhouetteColorCommand.receiveShadows = false;\n    nodeCommand.silhouetteColorCommand = silhouetteColorCommand;\n\n    if (!scene3DOnly) {\n      var command2D = nodeCommand.command2D;\n      var silhouetteModelCommand2D = DrawCommand.shallowClone(silhouetteModelCommand);\n      silhouetteModelCommand2D.boundingVolume = command2D.boundingVolume;\n      silhouetteModelCommand2D.modelMatrix = command2D.modelMatrix;\n      nodeCommand.silhouetteModelCommand2D = silhouetteModelCommand2D;\n      var silhouetteColorCommand2D = DrawCommand.shallowClone(silhouetteColorCommand);\n      silhouetteModelCommand2D.boundingVolume = command2D.boundingVolume;\n      silhouetteModelCommand2D.modelMatrix = command2D.modelMatrix;\n      nodeCommand.silhouetteColorCommand2D = silhouetteColorCommand2D;\n    }\n  }\n}\n\nfunction modifyShaderForClippingPlanes(shader, clippingPlaneCollection, context) {\n  shader = ShaderSource.replaceMain(shader, \"gltf_clip_main\");\n  shader += Model._getClippingFunction(clippingPlaneCollection, context) + \"\\n\";\n  shader += \"uniform highp sampler2D gltf_clippingPlanes; \\n\" + \"uniform mat4 gltf_clippingPlanesMatrix; \\n\" + \"uniform vec4 gltf_clippingPlanesEdgeStyle; \\n\" + \"void main() \\n\" + \"{ \\n\" + \"    gltf_clip_main(); \\n\" + getClipAndStyleCode(\"gltf_clippingPlanes\", \"gltf_clippingPlanesMatrix\", \"gltf_clippingPlanesEdgeStyle\") + \"} \\n\";\n  return shader;\n}\n\nfunction updateSilhouette(model, frameState, force) {\n  // Generate silhouette commands when the silhouette size is greater than 0.0 and the alpha is greater than 0.0\n  // There are two silhouette commands:\n  //     1. silhouetteModelCommand : render model normally while enabling stencil mask\n  //     2. silhouetteColorCommand : render enlarged model with a solid color while enabling stencil tests\n  if (!hasSilhouette(model, frameState)) {\n    return;\n  }\n\n  var nodeCommands = model._nodeCommands;\n  var dirty = nodeCommands.length > 0 && (alphaDirty(model.color.alpha, model._colorPreviousAlpha) || alphaDirty(model.silhouetteColor.alpha, model._silhouetteColorPreviousAlpha) || !defined(nodeCommands[0].silhouetteModelCommand));\n  model._colorPreviousAlpha = model.color.alpha;\n  model._silhouetteColorPreviousAlpha = model.silhouetteColor.alpha;\n\n  if (dirty || force) {\n    createSilhouetteCommands(model, frameState);\n  }\n}\n\nfunction updateClippingPlanes(model, frameState) {\n  var clippingPlanes = model._clippingPlanes;\n\n  if (defined(clippingPlanes) && clippingPlanes.owner === model) {\n    if (clippingPlanes.enabled) {\n      clippingPlanes.update(frameState);\n    }\n  }\n}\n\nvar scratchBoundingSphere = new BoundingSphere();\n\nfunction scaleInPixels(positionWC, radius, frameState) {\n  scratchBoundingSphere.center = positionWC;\n  scratchBoundingSphere.radius = radius;\n  return frameState.camera.getPixelSize(scratchBoundingSphere, frameState.context.drawingBufferWidth, frameState.context.drawingBufferHeight);\n}\n\nvar scratchPosition = new Cartesian3();\nvar scratchCartographic = new Cartographic();\n\nfunction getScale(model, frameState) {\n  var scale = model.scale;\n\n  if (model.minimumPixelSize !== 0.0) {\n    // Compute size of bounding sphere in pixels\n    var context = frameState.context;\n    var maxPixelSize = Math.max(context.drawingBufferWidth, context.drawingBufferHeight);\n    var m = defined(model._clampedModelMatrix) ? model._clampedModelMatrix : model.modelMatrix;\n    scratchPosition.x = m[12];\n    scratchPosition.y = m[13];\n    scratchPosition.z = m[14];\n\n    if (defined(model._rtcCenter)) {\n      Cartesian3.add(model._rtcCenter, scratchPosition, scratchPosition);\n    }\n\n    if (model._mode !== SceneMode.SCENE3D) {\n      var projection = frameState.mapProjection;\n      var cartographic = projection.ellipsoid.cartesianToCartographic(scratchPosition, scratchCartographic);\n      projection.project(cartographic, scratchPosition);\n      Cartesian3.fromElements(scratchPosition.z, scratchPosition.x, scratchPosition.y, scratchPosition);\n    }\n\n    var radius = model.boundingSphere.radius;\n    var metersPerPixel = scaleInPixels(scratchPosition, radius, frameState); // metersPerPixel is always > 0.0\n\n    var pixelsPerMeter = 1.0 / metersPerPixel;\n    var diameterInPixels = Math.min(pixelsPerMeter * (2.0 * radius), maxPixelSize); // Maintain model's minimum pixel size\n\n    if (diameterInPixels < model.minimumPixelSize) {\n      scale = model.minimumPixelSize * metersPerPixel / (2.0 * model._initialRadius);\n    }\n  }\n\n  return defined(model.maximumScale) ? Math.min(model.maximumScale, scale) : scale;\n}\n\nfunction releaseCachedGltf(model) {\n  if (defined(model._cacheKey) && defined(model._cachedGltf) && --model._cachedGltf.count === 0) {\n    delete gltfCache[model._cacheKey];\n  }\n\n  model._cachedGltf = undefined;\n} ///////////////////////////////////////////////////////////////////////////\n\n\nfunction CachedRendererResources(context, cacheKey) {\n  this.buffers = undefined;\n  this.vertexArrays = undefined;\n  this.programs = undefined;\n  this.sourceShaders = undefined;\n  this.silhouettePrograms = undefined;\n  this.textures = undefined;\n  this.samplers = undefined;\n  this.renderStates = undefined;\n  this.ready = false;\n  this.context = context;\n  this.cacheKey = cacheKey;\n  this.count = 0;\n}\n\nfunction destroy(property) {\n  for (var name in property) {\n    if (property.hasOwnProperty(name)) {\n      property[name].destroy();\n    }\n  }\n}\n\nfunction destroyCachedRendererResources(resources) {\n  destroy(resources.buffers);\n  destroy(resources.vertexArrays);\n  destroy(resources.programs);\n  destroy(resources.silhouettePrograms);\n  destroy(resources.textures);\n}\n\nCachedRendererResources.prototype.release = function () {\n  if (--this.count === 0) {\n    if (defined(this.cacheKey)) {\n      // Remove if this was cached\n      delete this.context.cache.modelRendererResourceCache[this.cacheKey];\n    }\n\n    destroyCachedRendererResources(this);\n    return destroyObject(this);\n  }\n\n  return undefined;\n}; ///////////////////////////////////////////////////////////////////////////\n\n\nfunction getUpdateHeightCallback(model, ellipsoid, cartoPosition) {\n  return function (clampedPosition) {\n    if (model.heightReference === HeightReference.RELATIVE_TO_GROUND) {\n      var clampedCart = ellipsoid.cartesianToCartographic(clampedPosition, scratchCartographic);\n      clampedCart.height += cartoPosition.height;\n      ellipsoid.cartographicToCartesian(clampedCart, clampedPosition);\n    }\n\n    var clampedModelMatrix = model._clampedModelMatrix; // Modify clamped model matrix to use new height\n\n    Matrix4.clone(model.modelMatrix, clampedModelMatrix);\n    clampedModelMatrix[12] = clampedPosition.x;\n    clampedModelMatrix[13] = clampedPosition.y;\n    clampedModelMatrix[14] = clampedPosition.z;\n    model._heightChanged = true;\n  };\n}\n\nfunction updateClamping(model) {\n  if (defined(model._removeUpdateHeightCallback)) {\n    model._removeUpdateHeightCallback();\n\n    model._removeUpdateHeightCallback = undefined;\n  }\n\n  var scene = model._scene;\n\n  if (!defined(scene) || !defined(scene.globe) || model.heightReference === HeightReference.NONE) {\n    //>>includeStart('debug', pragmas.debug);\n    if (model.heightReference !== HeightReference.NONE) {\n      throw new DeveloperError(\"Height reference is not supported without a scene and globe.\");\n    } //>>includeEnd('debug');\n\n\n    model._clampedModelMatrix = undefined;\n    return;\n  }\n\n  var globe = scene.globe;\n  var ellipsoid = globe.ellipsoid; // Compute cartographic position so we don't recompute every update\n\n  var modelMatrix = model.modelMatrix;\n  scratchPosition.x = modelMatrix[12];\n  scratchPosition.y = modelMatrix[13];\n  scratchPosition.z = modelMatrix[14];\n  var cartoPosition = ellipsoid.cartesianToCartographic(scratchPosition);\n\n  if (!defined(model._clampedModelMatrix)) {\n    model._clampedModelMatrix = Matrix4.clone(modelMatrix, new Matrix4());\n  } // Install callback to handle updating of terrain tiles\n\n\n  var surface = globe._surface;\n  model._removeUpdateHeightCallback = surface.updateHeight(cartoPosition, getUpdateHeightCallback(model, ellipsoid, cartoPosition)); // Set the correct height now\n\n  var height = globe.getHeight(cartoPosition);\n\n  if (defined(height)) {\n    // Get callback with cartoPosition being the non-clamped position\n    var cb = getUpdateHeightCallback(model, ellipsoid, cartoPosition); // Compute the clamped cartesian and call updateHeight callback\n\n    Cartographic.clone(cartoPosition, scratchCartographic);\n    scratchCartographic.height = height;\n    ellipsoid.cartographicToCartesian(scratchCartographic, scratchPosition);\n    cb(scratchPosition);\n  }\n}\n\nvar scratchDisplayConditionCartesian = new Cartesian3();\nvar scratchDistanceDisplayConditionCartographic = new Cartographic();\n\nfunction distanceDisplayConditionVisible(model, frameState) {\n  var distance2;\n  var ddc = model.distanceDisplayCondition;\n  var nearSquared = ddc.near * ddc.near;\n  var farSquared = ddc.far * ddc.far;\n\n  if (frameState.mode === SceneMode.SCENE2D) {\n    var frustum2DWidth = frameState.camera.frustum.right - frameState.camera.frustum.left;\n    distance2 = frustum2DWidth * 0.5;\n    distance2 = distance2 * distance2;\n  } else {\n    // Distance to center of primitive's reference frame\n    var position = Matrix4.getTranslation(model.modelMatrix, scratchDisplayConditionCartesian);\n\n    if (frameState.mode === SceneMode.COLUMBUS_VIEW) {\n      var projection = frameState.mapProjection;\n      var ellipsoid = projection.ellipsoid;\n      var cartographic = ellipsoid.cartesianToCartographic(position, scratchDistanceDisplayConditionCartographic);\n      position = projection.project(cartographic, position);\n      Cartesian3.fromElements(position.z, position.x, position.y, position);\n    }\n\n    distance2 = Cartesian3.distanceSquared(position, frameState.camera.positionWC);\n  }\n\n  return distance2 >= nearSquared && distance2 <= farSquared;\n}\n\nvar scratchClippingPlanesMatrix = new Matrix4();\nvar scratchIBLReferenceFrameMatrix4 = new Matrix4();\nvar scratchIBLReferenceFrameMatrix3 = new Matrix3();\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {RuntimeError} Failed to load external reference.\n */\n\nModel.prototype.update = function (frameState) {\n  if (frameState.mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  if (!FeatureDetection.supportsWebP.initialized) {\n    FeatureDetection.supportsWebP.initialize();\n    return;\n  }\n\n  var supportsWebP = FeatureDetection.supportsWebP();\n  var context = frameState.context;\n  this._defaultTexture = context.defaultTexture;\n\n  if (this._state === ModelState.NEEDS_LOAD && defined(this.gltf)) {\n    // Use renderer resources from cache instead of loading/creating them?\n    var cachedRendererResources;\n    var cacheKey = this.cacheKey;\n\n    if (defined(cacheKey)) {\n      // cache key given? this model will pull from or contribute to context level cache\n      context.cache.modelRendererResourceCache = defaultValue(context.cache.modelRendererResourceCache, {});\n      var modelCaches = context.cache.modelRendererResourceCache;\n      cachedRendererResources = modelCaches[this.cacheKey];\n\n      if (defined(cachedRendererResources)) {\n        if (!cachedRendererResources.ready) {\n          // Cached resources for the model are not loaded yet.  We'll\n          // try again every frame until they are.\n          return;\n        }\n\n        ++cachedRendererResources.count;\n        this._loadRendererResourcesFromCache = true;\n      } else {\n        cachedRendererResources = new CachedRendererResources(context, cacheKey);\n        cachedRendererResources.count = 1;\n        modelCaches[this.cacheKey] = cachedRendererResources;\n      }\n\n      this._cachedRendererResources = cachedRendererResources;\n    } else {\n      // cache key not given? this model doesn't care about context level cache at all. Cache is here to simplify freeing on destroy.\n      cachedRendererResources = new CachedRendererResources(context);\n      cachedRendererResources.count = 1;\n      this._cachedRendererResources = cachedRendererResources;\n    }\n\n    this._state = ModelState.LOADING;\n\n    if (this._state !== ModelState.FAILED) {\n      var extensions = this.gltf.extensions;\n\n      if (defined(extensions) && defined(extensions.CESIUM_RTC)) {\n        var center = Cartesian3.fromArray(extensions.CESIUM_RTC.center);\n\n        if (!Cartesian3.equals(center, Cartesian3.ZERO)) {\n          this._rtcCenter3D = center;\n          var projection = frameState.mapProjection;\n          var ellipsoid = projection.ellipsoid;\n          var cartographic = ellipsoid.cartesianToCartographic(this._rtcCenter3D);\n          var projectedCart = projection.project(cartographic);\n          Cartesian3.fromElements(projectedCart.z, projectedCart.x, projectedCart.y, projectedCart);\n          this._rtcCenter2D = projectedCart;\n          this._rtcCenterEye = new Cartesian3();\n          this._rtcCenter = this._rtcCenter3D;\n        }\n      }\n\n      addPipelineExtras(this.gltf);\n      this._loadResources = new ModelLoadResources();\n\n      if (!this._loadRendererResourcesFromCache) {\n        // Buffers are required to updateVersion\n        ModelUtility.parseBuffers(this, bufferLoad);\n      }\n    }\n  }\n\n  var loadResources = this._loadResources;\n  var incrementallyLoadTextures = this._incrementallyLoadTextures;\n  var justLoaded = false;\n\n  if (this._state === ModelState.LOADING) {\n    // Transition from LOADING -> LOADED once resources are downloaded and created.\n    // Textures may continue to stream in while in the LOADED state.\n    if (loadResources.pendingBufferLoads === 0) {\n      if (!loadResources.initialized) {\n        frameState.brdfLutGenerator.update(frameState);\n        ModelUtility.checkSupportedExtensions(this.extensionsRequired, supportsWebP);\n        ModelUtility.updateForwardAxis(this); // glTF pipeline updates, not needed if loading from cache\n\n        if (!defined(this.gltf.extras.sourceVersion)) {\n          var gltf = this.gltf; // Add the original version so it remains cached\n\n          gltf.extras.sourceVersion = ModelUtility.getAssetVersion(gltf);\n          gltf.extras.sourceKHRTechniquesWebGL = defined(ModelUtility.getUsedExtensions(gltf).KHR_techniques_webgl);\n          this._sourceVersion = gltf.extras.sourceVersion;\n          this._sourceKHRTechniquesWebGL = gltf.extras.sourceKHRTechniquesWebGL;\n          updateVersion(gltf);\n          addDefaults(gltf);\n          var options = {\n            addBatchIdToGeneratedShaders: this._addBatchIdToGeneratedShaders\n          };\n          processModelMaterialsCommon(gltf, options);\n          processPbrMaterials(gltf, options);\n        }\n\n        this._sourceVersion = this.gltf.extras.sourceVersion;\n        this._sourceKHRTechniquesWebGL = this.gltf.extras.sourceKHRTechniquesWebGL; // Skip dequantizing in the shader if not encoded\n\n        this._dequantizeInShader = this._dequantizeInShader && DracoLoader.hasExtension(this); // We do this after to make sure that the ids don't change\n\n        addBuffersToLoadResources(this);\n        parseArticulations(this);\n        parseTechniques(this);\n\n        if (!this._loadRendererResourcesFromCache) {\n          parseBufferViews(this);\n          parseShaders(this);\n          parsePrograms(this);\n          parseTextures(this, context, supportsWebP);\n        }\n\n        parseMaterials(this);\n        parseMeshes(this);\n        parseNodes(this); // Start draco decoding\n\n        DracoLoader.parse(this, context);\n        loadResources.initialized = true;\n      }\n\n      if (!loadResources.finishedDecoding()) {\n        DracoLoader.decodeModel(this, context).otherwise(ModelUtility.getFailedLoadFunction(this, \"model\", this.basePath));\n      }\n\n      if (loadResources.finishedDecoding() && !loadResources.resourcesParsed) {\n        this._boundingSphere = ModelUtility.computeBoundingSphere(this);\n        this._initialRadius = this._boundingSphere.radius;\n        DracoLoader.cacheDataForModel(this);\n        loadResources.resourcesParsed = true;\n      }\n\n      if (loadResources.resourcesParsed && loadResources.pendingShaderLoads === 0) {\n        ModelOutlineLoader.outlinePrimitives(this);\n        createResources(this, frameState);\n      }\n    }\n\n    if (loadResources.finished() || incrementallyLoadTextures && loadResources.finishedEverythingButTextureCreation()) {\n      this._state = ModelState.LOADED;\n      justLoaded = true;\n    }\n  } // Incrementally stream textures.\n\n\n  if (defined(loadResources) && this._state === ModelState.LOADED) {\n    if (incrementallyLoadTextures && !justLoaded) {\n      createResources(this, frameState);\n    }\n\n    if (loadResources.finished()) {\n      this._loadResources = undefined; // Clear CPU memory since WebGL resources were created.\n\n      var resources = this._rendererResources;\n      var cachedResources = this._cachedRendererResources;\n      cachedResources.buffers = resources.buffers;\n      cachedResources.vertexArrays = resources.vertexArrays;\n      cachedResources.programs = resources.programs;\n      cachedResources.sourceShaders = resources.sourceShaders;\n      cachedResources.silhouettePrograms = resources.silhouettePrograms;\n      cachedResources.textures = resources.textures;\n      cachedResources.samplers = resources.samplers;\n      cachedResources.renderStates = resources.renderStates;\n      cachedResources.ready = true; // The normal attribute name is required for silhouettes, so get it before the gltf JSON is released\n\n      this._normalAttributeName = ModelUtility.getAttributeOrUniformBySemantic(this.gltf, \"NORMAL\"); // Vertex arrays are unique to this model, do not store in cache.\n\n      if (defined(this._precreatedAttributes)) {\n        cachedResources.vertexArrays = {};\n      }\n\n      if (this.releaseGltfJson) {\n        releaseCachedGltf(this);\n      }\n    }\n  }\n\n  var iblSupported = OctahedralProjectedCubeMap.isSupported(context);\n\n  if (this._shouldUpdateSpecularMapAtlas && iblSupported) {\n    this._shouldUpdateSpecularMapAtlas = false;\n    this._specularEnvironmentMapAtlas = this._specularEnvironmentMapAtlas && this._specularEnvironmentMapAtlas.destroy();\n    this._specularEnvironmentMapAtlas = undefined;\n\n    if (defined(this._specularEnvironmentMaps)) {\n      this._specularEnvironmentMapAtlas = new OctahedralProjectedCubeMap(this._specularEnvironmentMaps);\n      var that = this;\n\n      this._specularEnvironmentMapAtlas.readyPromise.then(function () {\n        that._shouldRegenerateShaders = true;\n      }).otherwise(function (error) {\n        console.error(\"Error loading specularEnvironmentMaps: \" + error);\n      });\n    } // Regenerate shaders to not use an environment map. Will be set to true again if there was a new environment map and it is ready.\n\n\n    this._shouldRegenerateShaders = true;\n  }\n\n  if (defined(this._specularEnvironmentMapAtlas)) {\n    this._specularEnvironmentMapAtlas.update(frameState);\n  }\n\n  var recompileWithDefaultAtlas = !defined(this._specularEnvironmentMapAtlas) && defined(frameState.specularEnvironmentMaps) && !this._useDefaultSpecularMaps;\n  var recompileWithoutDefaultAtlas = !defined(frameState.specularEnvironmentMaps) && this._useDefaultSpecularMaps;\n  var recompileWithDefaultSHCoeffs = !defined(this._sphericalHarmonicCoefficients) && defined(frameState.sphericalHarmonicCoefficients) && !this._useDefaultSphericalHarmonics;\n  var recompileWithoutDefaultSHCoeffs = !defined(frameState.sphericalHarmonicCoefficients) && this._useDefaultSphericalHarmonics;\n  this._shouldRegenerateShaders = this._shouldRegenerateShaders || recompileWithDefaultAtlas || recompileWithoutDefaultAtlas || recompileWithDefaultSHCoeffs || recompileWithoutDefaultSHCoeffs;\n  this._useDefaultSpecularMaps = !defined(this._specularEnvironmentMapAtlas) && defined(frameState.specularEnvironmentMaps);\n  this._useDefaultSphericalHarmonics = !defined(this._sphericalHarmonicCoefficients) && defined(frameState.sphericalHarmonicCoefficients);\n  var silhouette = hasSilhouette(this, frameState);\n  var translucent = isTranslucent(this);\n  var invisible = isInvisible(this);\n  var backFaceCulling = this.backFaceCulling;\n  var displayConditionPassed = defined(this.distanceDisplayCondition) ? distanceDisplayConditionVisible(this, frameState) : true;\n  var show = this.show && displayConditionPassed && this.scale !== 0.0 && (!invisible || silhouette);\n\n  if (show && this._state === ModelState.LOADED || justLoaded) {\n    var animated = this.activeAnimations.update(frameState) || this._cesiumAnimationsDirty;\n\n    this._cesiumAnimationsDirty = false;\n    this._dirty = false;\n    var modelMatrix = this.modelMatrix;\n    var modeChanged = frameState.mode !== this._mode;\n    this._mode = frameState.mode; // Model's model matrix needs to be updated\n\n    var modelTransformChanged = !Matrix4.equals(this._modelMatrix, modelMatrix) || this._scale !== this.scale || this._minimumPixelSize !== this.minimumPixelSize || this.minimumPixelSize !== 0.0 || // Minimum pixel size changed or is enabled\n    this._maximumScale !== this.maximumScale || this._heightReference !== this.heightReference || this._heightChanged || modeChanged;\n\n    if (modelTransformChanged || justLoaded) {\n      Matrix4.clone(modelMatrix, this._modelMatrix);\n      updateClamping(this);\n\n      if (defined(this._clampedModelMatrix)) {\n        modelMatrix = this._clampedModelMatrix;\n      }\n\n      this._scale = this.scale;\n      this._minimumPixelSize = this.minimumPixelSize;\n      this._maximumScale = this.maximumScale;\n      this._heightReference = this.heightReference;\n      this._heightChanged = false;\n      var scale = getScale(this, frameState);\n      var computedModelMatrix = this._computedModelMatrix;\n      Matrix4.multiplyByUniformScale(modelMatrix, scale, computedModelMatrix);\n\n      if (this._upAxis === Axis.Y) {\n        Matrix4.multiplyTransformation(computedModelMatrix, Axis.Y_UP_TO_Z_UP, computedModelMatrix);\n      } else if (this._upAxis === Axis.X) {\n        Matrix4.multiplyTransformation(computedModelMatrix, Axis.X_UP_TO_Z_UP, computedModelMatrix);\n      }\n\n      if (this.forwardAxis === Axis.Z) {\n        // glTF 2.0 has a Z-forward convention that must be adapted here to X-forward.\n        Matrix4.multiplyTransformation(computedModelMatrix, Axis.Z_UP_TO_X_UP, computedModelMatrix);\n      }\n    } // Update modelMatrix throughout the graph as needed\n\n\n    if (animated || modelTransformChanged || justLoaded) {\n      updateNodeHierarchyModelMatrix(this, modelTransformChanged, justLoaded, frameState.mapProjection);\n      this._dirty = true;\n\n      if (animated || justLoaded) {\n        // Apply skins if animation changed any node transforms\n        applySkins(this);\n      }\n    }\n\n    if (this._perNodeShowDirty) {\n      this._perNodeShowDirty = false;\n      updatePerNodeShow(this);\n    }\n\n    updatePickIds(this, context);\n    updateWireframe(this);\n    updateShowBoundingVolume(this);\n    updateShadows(this);\n    updateClippingPlanes(this, frameState); // Regenerate shaders if ClippingPlaneCollection state changed or it was removed\n\n    var clippingPlanes = this._clippingPlanes;\n    var currentClippingPlanesState = 0;\n    var useClippingPlanes = defined(clippingPlanes) && clippingPlanes.enabled && clippingPlanes.length > 0; // If defined, use the reference matrix to transform miscellaneous properties like\n    // clipping planes and IBL instead of the modelMatrix. This is so that when\n    // models are part of a tileset these properties get transformed relative to\n    // a common reference (such as the root).\n\n    var referenceMatrix = defaultValue(this.referenceMatrix, modelMatrix);\n\n    if (useClippingPlanes) {\n      var clippingPlanesMatrix = scratchClippingPlanesMatrix;\n      clippingPlanesMatrix = Matrix4.multiply(context.uniformState.view3D, referenceMatrix, clippingPlanesMatrix);\n      clippingPlanesMatrix = Matrix4.multiply(clippingPlanesMatrix, clippingPlanes.modelMatrix, clippingPlanesMatrix);\n      this._clippingPlanesMatrix = Matrix4.inverseTranspose(clippingPlanesMatrix, this._clippingPlanesMatrix);\n      currentClippingPlanesState = clippingPlanes.clippingPlanesState;\n    }\n\n    var usesSH = defined(this._sphericalHarmonicCoefficients) || this._useDefaultSphericalHarmonics;\n\n    var usesSM = defined(this._specularEnvironmentMapAtlas) && this._specularEnvironmentMapAtlas.ready || this._useDefaultSpecularMaps;\n\n    if (usesSH || usesSM) {\n      var iblReferenceFrameMatrix3 = scratchIBLReferenceFrameMatrix3;\n      var iblReferenceFrameMatrix4 = scratchIBLReferenceFrameMatrix4;\n      iblReferenceFrameMatrix4 = Matrix4.multiply(context.uniformState.view3D, referenceMatrix, iblReferenceFrameMatrix4);\n      iblReferenceFrameMatrix3 = Matrix4.getMatrix3(iblReferenceFrameMatrix4, iblReferenceFrameMatrix3);\n      iblReferenceFrameMatrix3 = Matrix3.getRotation(iblReferenceFrameMatrix3, iblReferenceFrameMatrix3);\n      this._iblReferenceFrameMatrix = Matrix3.transpose(iblReferenceFrameMatrix3, this._iblReferenceFrameMatrix);\n    }\n\n    var shouldRegenerateShaders = this._shouldRegenerateShaders;\n    shouldRegenerateShaders = shouldRegenerateShaders || this._clippingPlanesState !== currentClippingPlanesState;\n    this._clippingPlanesState = currentClippingPlanesState; // Regenerate shaders if color shading changed from last update\n\n    var currentlyColorShadingEnabled = isColorShadingEnabled(this);\n\n    if (currentlyColorShadingEnabled !== this._colorShadingEnabled) {\n      this._colorShadingEnabled = currentlyColorShadingEnabled;\n      shouldRegenerateShaders = true;\n    }\n\n    if (shouldRegenerateShaders) {\n      regenerateShaders(this, frameState);\n    } else {\n      updateColor(this, frameState, false);\n      updateBackFaceCulling(this, frameState, false);\n      updateSilhouette(this, frameState, false);\n    }\n  }\n\n  if (justLoaded) {\n    // Called after modelMatrix update.\n    var model = this;\n    frameState.afterRender.push(function () {\n      model._ready = true;\n\n      model._readyPromise.resolve(model);\n    });\n    return;\n  } // We don't check show at the top of the function since we\n  // want to be able to progressively load models when they are not shown,\n  // and then have them visible immediately when show is set to true.\n\n\n  if (show && !this._ignoreCommands) {\n    // PERFORMANCE_IDEA: This is terrible\n    var commandList = frameState.commandList;\n    var passes = frameState.passes;\n    var nodeCommands = this._nodeCommands;\n    var length = nodeCommands.length;\n    var i;\n    var nc;\n    var idl2D = frameState.mapProjection.ellipsoid.maximumRadius * CesiumMath.PI;\n    var boundingVolume;\n\n    if (passes.render || passes.pick && this.allowPicking) {\n      for (i = 0; i < length; ++i) {\n        nc = nodeCommands[i];\n\n        if (nc.show) {\n          var command = nc.command;\n\n          if (silhouette) {\n            command = nc.silhouetteModelCommand;\n          } else if (translucent) {\n            command = nc.translucentCommand;\n          } else if (!backFaceCulling) {\n            command = nc.disableCullingCommand;\n          }\n\n          commandList.push(command);\n          boundingVolume = nc.command.boundingVolume;\n\n          if (frameState.mode === SceneMode.SCENE2D && (boundingVolume.center.y + boundingVolume.radius > idl2D || boundingVolume.center.y - boundingVolume.radius < idl2D)) {\n            var command2D = nc.command2D;\n\n            if (silhouette) {\n              command2D = nc.silhouetteModelCommand2D;\n            } else if (translucent) {\n              command2D = nc.translucentCommand2D;\n            } else if (!backFaceCulling) {\n              command2D = nc.disableCullingCommand2D;\n            }\n\n            commandList.push(command2D);\n          }\n        }\n      }\n\n      if (silhouette && !passes.pick) {\n        // Render second silhouette pass\n        for (i = 0; i < length; ++i) {\n          nc = nodeCommands[i];\n\n          if (nc.show) {\n            commandList.push(nc.silhouetteColorCommand);\n            boundingVolume = nc.command.boundingVolume;\n\n            if (frameState.mode === SceneMode.SCENE2D && (boundingVolume.center.y + boundingVolume.radius > idl2D || boundingVolume.center.y - boundingVolume.radius < idl2D)) {\n              commandList.push(nc.silhouetteColorCommand2D);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  var credit = this._credit;\n\n  if (defined(credit)) {\n    frameState.creditDisplay.addCredit(credit);\n  }\n\n  var resourceCredits = this._resourceCredits;\n  var creditCount = resourceCredits.length;\n\n  for (var c = 0; c < creditCount; c++) {\n    frameState.creditDisplay.addCredit(resourceCredits[c]);\n  }\n};\n\nfunction destroyIfNotCached(rendererResources, cachedRendererResources) {\n  if (rendererResources.programs !== cachedRendererResources.programs) {\n    destroy(rendererResources.programs);\n  }\n\n  if (rendererResources.silhouettePrograms !== cachedRendererResources.silhouettePrograms) {\n    destroy(rendererResources.silhouettePrograms);\n  }\n} // Run from update iff:\n// - everything is loaded\n// - clipping planes state change OR color state set\n// Run this from destructor after removing color state and clipping plane state\n\n\nfunction regenerateShaders(model, frameState) {\n  // In regards to _cachedRendererResources:\n  // Fair to assume that this is data that should just never get modified due to clipping planes or model color.\n  // So if clipping planes or model color active:\n  // - delink _rendererResources.*programs and create new dictionaries.\n  // - do NOT destroy any programs - might be used by copies of the model or by might be needed in the future if clipping planes/model color is deactivated\n  // If clipping planes and model color inactive:\n  // - destroy _rendererResources.*programs\n  // - relink _rendererResources.*programs to _cachedRendererResources\n  // In both cases, need to mark commands as dirty, re-run derived commands (elsewhere)\n  var rendererResources = model._rendererResources;\n  var cachedRendererResources = model._cachedRendererResources;\n  destroyIfNotCached(rendererResources, cachedRendererResources);\n  var programId;\n\n  if (isClippingEnabled(model) || isColorShadingEnabled(model) || model._shouldRegenerateShaders) {\n    model._shouldRegenerateShaders = false;\n    rendererResources.programs = {};\n    rendererResources.silhouettePrograms = {};\n    var visitedPrograms = {};\n    var techniques = model._sourceTechniques;\n    var technique;\n\n    for (var techniqueId in techniques) {\n      if (techniques.hasOwnProperty(techniqueId)) {\n        technique = techniques[techniqueId];\n        programId = technique.program;\n\n        if (!visitedPrograms[programId]) {\n          visitedPrograms[programId] = true;\n          recreateProgram({\n            programId: programId,\n            techniqueId: techniqueId\n          }, model, frameState.context);\n        }\n      }\n    }\n  } else {\n    rendererResources.programs = cachedRendererResources.programs;\n    rendererResources.silhouettePrograms = cachedRendererResources.silhouettePrograms;\n  } // Fix all the commands, marking them as dirty so everything that derives will re-derive\n\n\n  var rendererPrograms = rendererResources.programs;\n  var nodeCommands = model._nodeCommands;\n  var commandCount = nodeCommands.length;\n\n  for (var i = 0; i < commandCount; ++i) {\n    var nodeCommand = nodeCommands[i];\n    programId = nodeCommand.programId;\n    var renderProgram = rendererPrograms[programId];\n    nodeCommand.command.shaderProgram = renderProgram;\n\n    if (defined(nodeCommand.command2D)) {\n      nodeCommand.command2D.shaderProgram = renderProgram;\n    }\n  } // Force update silhouette commands/shaders\n\n\n  updateColor(model, frameState, true);\n  updateBackFaceCulling(model, frameState, true);\n  updateSilhouette(model, frameState, true);\n}\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see Model#destroy\n */\n\n\nModel.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * model = model && model.destroy();\n *\n * @see Model#isDestroyed\n */\n\n\nModel.prototype.destroy = function () {\n  // Vertex arrays are unique to this model, destroy here.\n  if (defined(this._precreatedAttributes)) {\n    destroy(this._rendererResources.vertexArrays);\n  }\n\n  if (defined(this._removeUpdateHeightCallback)) {\n    this._removeUpdateHeightCallback();\n\n    this._removeUpdateHeightCallback = undefined;\n  }\n\n  if (defined(this._terrainProviderChangedCallback)) {\n    this._terrainProviderChangedCallback();\n\n    this._terrainProviderChangedCallback = undefined;\n  } // Shaders modified for clipping and for color don't get cached, so destroy these manually\n\n\n  if (defined(this._cachedRendererResources)) {\n    destroyIfNotCached(this._rendererResources, this._cachedRendererResources);\n  }\n\n  this._rendererResources = undefined;\n  this._cachedRendererResources = this._cachedRendererResources && this._cachedRendererResources.release();\n  DracoLoader.destroyCachedDataForModel(this);\n  var pickIds = this._pickIds;\n  var length = pickIds.length;\n\n  for (var i = 0; i < length; ++i) {\n    pickIds[i].destroy();\n  }\n\n  releaseCachedGltf(this);\n  this._quantizedVertexShaders = undefined; // Only destroy the ClippingPlaneCollection if this is the owner - if this model is part of a Cesium3DTileset,\n  // _clippingPlanes references a ClippingPlaneCollection that this model does not own.\n\n  var clippingPlaneCollection = this._clippingPlanes;\n\n  if (defined(clippingPlaneCollection) && !clippingPlaneCollection.isDestroyed() && clippingPlaneCollection.owner === this) {\n    clippingPlaneCollection.destroy();\n  }\n\n  this._clippingPlanes = undefined;\n  this._specularEnvironmentMapAtlas = this._specularEnvironmentMapAtlas && this._specularEnvironmentMapAtlas.destroy();\n  return destroyObject(this);\n}; // exposed for testing\n\n\nModel._getClippingFunction = getClippingFunction;\nModel._modifyShaderForColor = modifyShaderForColor;\nexport default Model;","map":{"version":3,"sources":["/home/usuario/davi/thalamus/wms/3dmaptestes/leaflet_cesium/client/node_modules/cesium/Source/Scene/Model.js"],"names":["BoundingSphere","Cartesian2","Cartesian3","Cartesian4","Cartographic","Check","clone","Color","combine","createGuid","Credit","defaultValue","defined","destroyObject","DeveloperError","DistanceDisplayCondition","FeatureDetection","getAbsoluteUri","getJsonFromTypedArray","getMagic","getStringFromTypedArray","IndexDatatype","loadCRN","loadImageFromTypedArray","loadKTX","CesiumMath","Matrix3","Matrix4","PixelFormat","PrimitiveType","Quaternion","Resource","Transforms","WebGLConstants","Buffer","BufferUsage","DrawCommand","Pass","RenderState","Sampler","ShaderProgram","ShaderSource","Texture","TextureMinificationFilter","TextureWrap","VertexArray","addDefaults","addPipelineExtras","ForEach","getAccessorByteStride","hasExtension","numberOfComponentsForType","parseGlb","updateVersion","when","Axis","BlendingState","ClippingPlaneCollection","ColorBlendMode","DepthFunction","DracoLoader","getClipAndStyleCode","getClippingFunction","HeightReference","JobType","ModelAnimationCache","ModelAnimationCollection","ModelLoadResources","ModelMaterial","ModelMesh","ModelNode","ModelOutlineLoader","ModelUtility","OctahedralProjectedCubeMap","processModelMaterialsCommon","processPbrMaterials","SceneMode","ShadowMode","boundingSphereCartesian3Scratch","ModelState","defaultModelAccept","articulationEpsilon","EPSILON16","setCachedGltf","model","cachedGltf","_cachedGltf","CachedGltf","options","_gltf","gltf","ready","modelsToLoad","count","Object","defineProperties","prototype","set","value","get","makeReady","gltfJson","models","length","i","m","isDestroyed","undefined","gltfCache","uriToGuid","Model","EMPTY_OBJECT","cacheKey","_cacheKey","_releaseGltfJson","releaseGltfJson","ArrayBuffer","Uint8Array","parsedGltf","basePath","_resource","createIfNeeded","credit","_credit","_resourceCredits","show","silhouetteColor","RED","_silhouetteColor","_silhouetteColorPreviousAlpha","_normalAttributeName","silhouetteSize","modelMatrix","IDENTITY","_modelMatrix","_clampedModelMatrix","scale","_scale","minimumPixelSize","_minimumPixelSize","maximumScale","_maximumScale","id","_id","heightReference","NONE","_heightReference","_heightChanged","_removeUpdateHeightCallback","scene","_scene","terrainProviderChanged","_terrainProviderChangedCallback","addEventListener","_pickObject","pickObject","_allowPicking","allowPicking","_ready","_readyPromise","defer","activeAnimations","clampAnimations","_defaultTexture","_incrementallyLoadTextures","incrementallyLoadTextures","_asynchronous","asynchronous","shadows","ENABLED","_shadows","color","WHITE","_colorPreviousAlpha","colorBlendMode","HIGHLIGHT","colorBlendAmount","_colorShadingEnabled","_clippingPlanes","clippingPlanes","_clippingPlanesState","referenceMatrix","backFaceCulling","debugShowBoundingVolume","_debugShowBoundingVolume","debugWireframe","_debugWireframe","_distanceDisplayCondition","distanceDisplayCondition","_addBatchIdToGeneratedShaders","addBatchIdToGeneratedShaders","_precreatedAttributes","precreatedAttributes","_vertexShaderLoaded","vertexShaderLoaded","_fragmentShaderLoaded","fragmentShaderLoaded","_uniformMapLoaded","uniformMapLoaded","_pickIdLoaded","pickIdLoaded","_ignoreCommands","ignoreCommands","_requestType","requestType","_upAxis","upAxis","Y","_gltfForwardAxis","Z","_forwardAxis","forwardAxis","cull","opaquePass","OPAQUE","_computedModelMatrix","_clippingPlanesMatrix","_iblReferenceFrameMatrix","_initialRadius","_boundingSphere","_scaledBoundingSphere","_state","NEEDS_LOAD","_loadResources","_mode","_perNodeShowDirty","_cesiumAnimationsDirty","_dirty","_maxDirtyNumber","_runtime","animations","articulationsByName","articulationsByStageKey","stagesByKey","rootNodes","nodes","nodesByName","skinnedNodes","meshesByName","materialsByName","materialsById","_uniformMaps","_extensionsUsed","_extensionsRequired","_quantizedUniforms","_programPrimitives","_rendererResources","buffers","vertexArrays","programs","sourceShaders","silhouettePrograms","textures","samplers","renderStates","_cachedRendererResources","_loadRendererResourcesFromCache","_dequantizeInShader","dequantizeInShader","_decodedData","_cachedGeometryByteLength","_cachedTexturesByteLength","_geometryByteLength","_texturesByteLength","_trianglesLength","_sourceTechniques","_sourcePrograms","_quantizedVertexShaders","_nodeCommands","_pickIds","_rtcCenter","_rtcCenterEye","_rtcCenter3D","_rtcCenter2D","_sourceVersion","_sourceKHRTechniquesWebGL","_imageBasedLightingFactor","imageBasedLightingFactor","_lightColor","lightColor","_luminanceAtZenith","luminanceAtZenith","_sphericalHarmonicCoefficients","sphericalHarmonicCoefficients","_specularEnvironmentMaps","specularEnvironmentMaps","_shouldUpdateSpecularMapAtlas","_specularEnvironmentMapAtlas","_useDefaultSphericalHarmonics","_useDefaultSpecularMaps","_shouldRegenerateShaders","url","boundingSphere","LOADED","nonUniformScale","getScale","Math","min","multiplyByScalar","scaledBoundingSphere","center","multiplyComponents","radius","maximumComponent","add","readyPromise","promise","pendingTextureLoads","dirty","far","near","extensionsUsed","getUsedExtensions","extensionsRequired","getRequiredExtensions","trianglesLength","geometryByteLength","texturesByteLength","cachedGeometryByteLength","cachedTexturesByteLength","setOwner","pickIds","typeOf","object","number","greaterThanOrEquals","x","lessThanOrEquals","y","equals","lum","Array","isArray","silhouetteSupported","context","stencilBuffer","isColorShadingEnabled","isClippingEnabled","enabled","containsGltfMagic","uint8Array","magic","fromGltf","modelResource","resource","push","headers","Accept","fetchArrayBuffer","then","arrayBuffer","array","json","resourceCredits","credits","otherwise","getFailedLoadFunction","_gltfCache","getRuntime","runtimeName","name","getNode","node","publicNode","getMesh","getMaterial","setArticulationStage","articulationStageKey","stage","articulation","clamp","minimumValue","maximumValue","equalsEpsilon","currentValue","isDirty","scratchArticulationCartesian","scratchArticulationRotation","applyArticulationStageMatrix","result","cartesian","rotation","type","fromRotationX","toRadians","multiplyByMatrix3","fromRotationY","fromRotationZ","z","multiplyByTranslation","multiplyByScale","multiplyByUniformScale","scratchApplyArticulationTransform","applyArticulations","articulationName","hasOwnProperty","numNodes","n","transform","originalMatrix","numStages","stages","s","matrix","addBuffersToLoadResources","loadResources","buffer","extras","_pipeline","source","bufferLoad","pendingBufferLoads","parseBufferViews","bufferViews","vertexBuffersToCreate","bufferView","target","ARRAY_BUFFER","enqueue","indexBuffersToCreate","indexBufferIds","accessor","bufferViewId","ELEMENT_ARRAY_BUFFER","componentType","parseTechniques","sourcePrograms","sourceTechniques","extensions","KHR_techniques_webgl","technique","techniqueId","programId","program","shaderLoad","shaders","pendingShaderLoads","parseShaders","shader","bufferId","byteOffset","byteLength","shaderResource","getDerivedResource","uri","fetchText","parsePrograms","programsToCreate","parseArticulations","runtimeStagesByKey","AGI_articulations","gltfArticulations","articulations","numArticulations","initialValue","stageKey","imageLoad","textureId","image","texturesToCreate","width","height","internalFormat","ktxRegex","crnRegex","parseTextures","supportsWebP","images","texture","imageId","EXT_texture_webp","gltfImage","mimeType","compressedImage3DTiles","crunch","s3tc","pvrtc","pvrtc1","etc1","texturesToCreateFromBufferView","imageResource","test","fetchImage","scratchArticulationStageInitialTransform","parseNodes","runtimeNodes","runtimeNodesByName","skinnedNodesIds","runtimeNode","translation","computedShow","transformToRoot","computedMatrix","dirtyNumber","commands","inverseBindMatrices","bindShapeMatrix","joints","computedJointMatrices","jointName","weights","children","parents","getTransform","skin","parseMaterials","techniques","runtimeMaterialsByName","runtimeMaterialsById","uniformMaps","material","materialId","uniformMap","values","jointMatrixUniformName","morphWeightsUniformName","modelMaterial","_technique","_program","materialValue","uniformName","_values","parseMeshes","runtimeMeshesByName","mesh","meshId","WEB3D_quantized_attributes","meshPrimitive","primitive","primitiveId","getProgramForPrimitive","programPrimitives","CreateVertexBufferJob","execute","createVertexBuffer","createdBufferViews","vertexBuffer","typedArray","getBuffer","usage","STATIC_DRAW","vertexArrayDestroyable","sizeInBytes","CreateIndexBufferJob","createIndexBuffer","indexBuffer","indexDatatype","scratchVertexBufferJob","scratchIndexBufferJob","createBuffers","frameState","peek","jobScheduler","BUFFER","dequeue","modifyShaderForQuantizedAttributes","programName","primitives","uniforms","decodedData","modifyShaderForDracoQuantizedAttributes","attributes","modifyShaderForColor","replaceMain","modifyShader","callback","CreateProgramJob","programToCreate","createProgram","vs","vertexShader","fs","fragmentShader","quantizedVertexShaders","quantizedVS","drawVS","drawFS","useIBL","isSupported","usesSH","usesSM","addMatrix","createAttributesAndProgram","recreateProgram","clippingPlaneCollection","addClippingPlaneCode","finalFS","_modifyShaderForColor","modifyShaderForClippingPlanes","attributeLocations","createAttributeLocations","fromCache","vertexShaderSource","fragmentShaderSource","scratchCreateProgramJob","createPrograms","PROGRAM","getOnImageCreatedFromTypedArray","gltfTexture","pendingBufferViewToImage","loadTexturesFromBufferViews","onerror","onload","format","flipY","createSamplers","rendererSamplers","sampler","samplerId","wrapS","wrapT","minificationFilter","minFilter","magnificationFilter","magFilter","CreateTextureJob","createTexture","REPEAT","usesTextureTransform","materials","materialsLength","valueName","indexOf","index","KHR_texture_transform","LINEAR","NEAREST","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","textureMinificationFilter","textureMagnificationFilter","mipmap","isCompressedFormat","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","requiresNpot","MIRRORED_REPEAT","tx","arrayBufferView","pixelFormat","npot","isPowerOfTwo","canvas","document","createElement","nextPowerOfTwo","canvasContext","getContext","drawImage","pixelDatatype","generateMipmap","scratchCreateTextureJob","createTextures","TEXTURE","getAttributeLocations","location","programAttributeLocations","_attributeLocations","attribute","semantic","createJoints","runtimeSkins","skins","j","skinnedNode","runtimeSkin","gltfJoints","jointsLength","nodeId","jointNode","createSkins","accessors","getSkinInverseBindMatrices","getChannelEvaluator","targetPath","spline","localAnimationTime","clampTime","wrapTime","evaluate","createRuntimeAnimations","finishedPendingBufferLoads","animation","channels","startTime","Number","MAX_VALUE","stopTime","channelsLength","channelEvaluators","channel","path","input","getAnimationParameterValues","output","max","getAnimationSpline","createVertexArrays","finishedBuffersCreation","finishedProgramCreation","rendererBuffers","rendererVertexArrays","attributeLocation","meshPrimitiveAttribute","accessorId","attributeName","decodedAttributes","decodedAttribute","componentsPerAttribute","componentDatatype","normalize","normalized","offsetInBytes","strideInBytes","byteStride","a","indices","createRenderStates","createRenderStateForMaterial","rendererRenderStates","blendEquationSeparate","FUNC_ADD","blendFuncSeparate","ONE","ONE_MINUS_SRC_ALPHA","KHR_blend","blendEquation","blendFactors","enableCulling","doubleSided","blendingEnabled","alphaMode","depthTest","func","LESS_OR_EQUAL","depthMask","blending","equationRgb","equationAlpha","functionSourceRgb","functionDestinationRgb","functionSourceAlpha","functionDestinationAlpha","gltfUniformsFromNode","MODEL","uniformState","VIEW","view","PROJECTION","projection","MODELVIEW","mv","multiplyTransformation","CESIUM_RTC_MODELVIEW","mvRtc","setTranslation","MODELVIEWPROJECTION","mvp","multiply","_projection","MODELINVERSE","mInverse","inverse","VIEWINVERSE","inverseView","PROJECTIONINVERSE","inverseProjection","MODELVIEWINVERSE","mvInverse","MODELVIEWPROJECTIONINVERSE","mvpInverse","MODELINVERSETRANSPOSE","mInverseTranspose","getMatrix3","transpose","MODELVIEWINVERSETRANSPOSE","mvInverseTranspose","VIEWPORT","viewportCartesian4","getUniformFunctionFromSource","createUniformsForMaterial","instanceValues","defaultTexture","uniformValues","techniqueUniform","uniform","uv","createUniformFunction","alphaCutoffValue","alphaCutoff","getGltfSemanticUniforms","uv2","map","createUniformMaps","u","a_outlineCoordinates","outlineTexture","u_outlineTexture","createUniformsForDracoQuantizedAttributes","createUniformsForQuantizedAttributes","quantizedUniforms","createPickColorFunction","createJointMatricesFunction","createMorphWeightsFunction","createSilhouetteColorFunction","createSilhouetteSizeFunction","createColorFunction","createClippingPlanesMatrixFunction","createIBLReferenceFrameMatrixFunction","createClippingPlanesFunction","createClippingPlanesEdgeStyleFunction","withAlpha","style","edgeColor","alpha","edgeWidth","createColorBlendFunction","getColorBlend","createIBLFactorFunction","createLightColorFunction","createLuminanceAtZenithFunction","createSphericalHarmonicCoefficientsFunction","createSpecularEnvironmentMapFunction","createSpecularEnvironmentMapSizeFunction","dimensions","createSpecularEnvironmentMapLOD","maximumMipmapLevel","triangleCountFromPrimitiveIndices","indicesCount","mode","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","createCommand","gltfNode","scene3DOnly","nodeCommands","resources","rendererPrograms","gltfMeshes","meshes","ix","positionAccessor","POSITION","minMax","getAccessorMinMax","fromCornerPoints","fromArray","vertexArray","offset","numberOfIndices","getSizeInBytes","positions","um","jointUniformMap","morphWeightsUniformMap","gltf_color","gltf_colorBlend","gltf_clippingPlanes","gltf_clippingPlanesEdgeStyle","gltf_clippingPlanesMatrix","gltf_iblReferenceFrameMatrix","gltf_iblFactor","gltf_lightColor","gltf_sphericalHarmonicCoefficients","gltf_specularMap","gltf_specularMapSize","gltf_maxSpecularLOD","gltf_luminanceAtZenith","quantizedUniformMap","rs","isTranslucent","owner","castShadows","receiveShadows","pickId","createPickId","pickUniforms","czm_pickColor","command","boundingVolume","primitiveType","shaderProgram","renderState","pass","TRANSLUCENT","command2D","shallowClone","nodeCommand","silhouetteModelCommand","silhouetteModelCommand2D","silhouetteColorCommand","silhouetteColorCommand2D","translucentCommand","translucentCommand2D","disableCullingCommand","disableCullingCommand2D","createRuntimeNodes","finishedEverythingButTextureCreation","scenes","sceneNodes","stack","seen","parentRuntimeNode","pop","fromColumnMajorArray","unpack","childrenLength","childId","getGeometryByteLength","memory","getTexturesByteLength","createResources","checkSupportedGlExtensions","glExtensions","cachedResources","getNodeMatrix","publicMatrix","useMatrix","fromTranslationQuaternionRotationScale","setMatrix","scratchNodeStack","scratchComputedTranslation","scratchComputedMatrixIn2D","updateNodeHierarchyModelMatrix","modelTransformChanged","justLoaded","maxDirtyNumber","nodeStack","computedModelMatrix","SCENE3D","getColumn","UNIT_W","basisTo2D","to2D","wgs84To2DModelMatrix","nodeMatrix","commandsLength","primitiveCommand","SCENE2D","sign","PI","ellipsoid","maximumRadius","k","child","scratchObjectSpace","applySkins","inverseTransformation","inverseBindMatricesLength","updatePerNodeShow","nodeCommandsLength","updatePickIds","updateWireframe","LINES","updateShowBoundingVolume","updateShadows","getTranslucentRenderState","ALPHA_BLEND","deriveTranslucentCommand","updateColor","forceDerive","getDisableCullingRenderState","deriveDisableCullingCommand","updateBackFaceCulling","getProgramId","createSilhouetteProgram","sources","normalAttributeName","hasSilhouette","hasTranslucentCommands","isInvisible","alphaDirty","currAlpha","prevAlpha","floor","ceil","silhouettesLength","createSilhouetteCommands","stencilReference","silhouetteTranslucent","modelCommand","stencilTest","frontFunction","ALWAYS","backFunction","reference","mask","frontOperation","fail","KEEP","zFail","zPass","REPLACE","backOperation","colorMask","red","green","blue","NOTEQUAL","silhouetteProgram","silhouetteUniformMap","gltf_silhouetteColor","gltf_silhouetteSize","_getClippingFunction","updateSilhouette","force","updateClippingPlanes","update","scratchBoundingSphere","scaleInPixels","positionWC","camera","getPixelSize","drawingBufferWidth","drawingBufferHeight","scratchPosition","scratchCartographic","maxPixelSize","mapProjection","cartographic","cartesianToCartographic","project","fromElements","metersPerPixel","pixelsPerMeter","diameterInPixels","releaseCachedGltf","CachedRendererResources","destroy","property","destroyCachedRendererResources","release","cache","modelRendererResourceCache","getUpdateHeightCallback","cartoPosition","clampedPosition","RELATIVE_TO_GROUND","clampedCart","cartographicToCartesian","clampedModelMatrix","updateClamping","globe","surface","_surface","updateHeight","getHeight","cb","scratchDisplayConditionCartesian","scratchDistanceDisplayConditionCartographic","distanceDisplayConditionVisible","distance2","ddc","nearSquared","farSquared","frustum2DWidth","frustum","right","left","position","getTranslation","COLUMBUS_VIEW","distanceSquared","scratchClippingPlanesMatrix","scratchIBLReferenceFrameMatrix4","scratchIBLReferenceFrameMatrix3","MORPHING","initialized","initialize","cachedRendererResources","modelCaches","LOADING","FAILED","CESIUM_RTC","ZERO","projectedCart","parseBuffers","brdfLutGenerator","checkSupportedExtensions","updateForwardAxis","sourceVersion","getAssetVersion","sourceKHRTechniquesWebGL","parse","finishedDecoding","decodeModel","resourcesParsed","computeBoundingSphere","cacheDataForModel","outlinePrimitives","finished","getAttributeOrUniformBySemantic","iblSupported","that","error","console","recompileWithDefaultAtlas","recompileWithoutDefaultAtlas","recompileWithDefaultSHCoeffs","recompileWithoutDefaultSHCoeffs","silhouette","translucent","invisible","displayConditionPassed","animated","modeChanged","Y_UP_TO_Z_UP","X","X_UP_TO_Z_UP","Z_UP_TO_X_UP","currentClippingPlanesState","useClippingPlanes","clippingPlanesMatrix","view3D","inverseTranspose","clippingPlanesState","iblReferenceFrameMatrix3","iblReferenceFrameMatrix4","getRotation","shouldRegenerateShaders","currentlyColorShadingEnabled","regenerateShaders","afterRender","resolve","commandList","passes","nc","idl2D","render","pick","creditDisplay","addCredit","creditCount","c","destroyIfNotCached","rendererResources","visitedPrograms","commandCount","renderProgram","destroyCachedDataForModel"],"mappings":"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,cAAD,CAAP,IACAA,cAAc,CAAC+J,OADf,IAEA/J,cAAc,CAAC5E,MAAf,KAA0B,CAH5B;AAKD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACAO,KAAK,CAAC+N,mBAAN,GAA4B,UAAUxL,KAAV,EAAiB;AAC3C,SAAOwL,mBAAmB,CAACxL,KAAK,CAACyL,OAAP,CAA1B;AACD,CAFD;;AAIA,SAASK,iBAAT,CAA2BC,UAA3B,EAAuC;AACrC,MAAIC,KAAK,GAAGlU,QAAQ,CAACiU,UAAD,CAApB;AACA,SAAOC,KAAK,KAAK,MAAjB;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAvO,KAAK,CAACwO,QAAN,GAAiB,UAAU9P,OAAV,EAAmB;AAClC;AACA,MAAI,CAAC5E,OAAO,CAAC4E,OAAD,CAAR,IAAqB,CAAC5E,OAAO,CAAC4E,OAAO,CAAC2M,GAAT,CAAjC,EAAgD;AAC9C,UAAM,IAAIrR,cAAJ,CAAmB,yBAAnB,CAAN;AACD,GAJiC,CAKlC;;;AAEA,MAAIqR,GAAG,GAAG3M,OAAO,CAAC2M,GAAlB;AACA3M,EAAAA,OAAO,GAAGlF,KAAK,CAACkF,OAAD,CAAf,CARkC,CAUlC;;AACA,MAAI+P,aAAa,GAAGxT,QAAQ,CAAC0F,cAAT,CAAwB0K,GAAxB,CAApB,CAXkC,CAalC;;AACA,MAAI5K,QAAQ,GAAG5G,YAAY,CAAC6E,OAAO,CAAC+B,QAAT,EAAmBgO,aAAa,CAACjV,KAAd,EAAnB,CAA3B;AACA,MAAIkV,QAAQ,GAAGzT,QAAQ,CAAC0F,cAAT,CAAwBF,QAAxB,CAAf,CAfkC,CAiBlC;AACA;;AACA,MAAIP,QAAQ,GAAGrG,YAAY,CACzB6E,OAAO,CAACwB,QADiB,EAEzBH,SAAS,CAAC5F,cAAc,CAACsU,aAAa,CAACpD,GAAf,CAAf,CAFgB,CAA3B;;AAIA,MAAI,CAACvR,OAAO,CAACoG,QAAD,CAAZ,EAAwB;AACtBA,IAAAA,QAAQ,GAAGvG,UAAU,EAArB;AACAoG,IAAAA,SAAS,CAAC5F,cAAc,CAACsU,aAAa,CAACpD,GAAf,CAAf,CAAT,GAA+CnL,QAA/C;AACD;;AAED,MAAIpG,OAAO,CAAC4E,OAAO,CAAC+B,QAAT,CAAP,IAA6B,CAAC3G,OAAO,CAAC4E,OAAO,CAACwB,QAAT,CAAzC,EAA6D;AAC3DA,IAAAA,QAAQ,IAAIwO,QAAQ,CAACrD,GAArB;AACD;;AACD3M,EAAAA,OAAO,CAACwB,QAAR,GAAmBA,QAAnB;AACAxB,EAAAA,OAAO,CAAC+B,QAAR,GAAmBiO,QAAnB;AAEA,MAAIpQ,KAAK,GAAG,IAAI0B,KAAJ,CAAUtB,OAAV,CAAZ;AAEA,MAAIH,UAAU,GAAGuB,SAAS,CAACI,QAAD,CAA1B;;AACA,MAAI,CAACpG,OAAO,CAACyE,UAAD,CAAZ,EAA0B;AACxBA,IAAAA,UAAU,GAAG,IAAIE,UAAJ,CAAe;AAC1BI,MAAAA,KAAK,EAAE;AADmB,KAAf,CAAb;AAGAN,IAAAA,UAAU,CAACQ,KAAX,GAAmB,CAAnB;AACAR,IAAAA,UAAU,CAACO,YAAX,CAAwB6P,IAAxB,CAA6BrQ,KAA7B;AACAD,IAAAA,aAAa,CAACC,KAAD,EAAQC,UAAR,CAAb;AACAuB,IAAAA,SAAS,CAACI,QAAD,CAAT,GAAsB3B,UAAtB,CAPwB,CASxB;;AACA,QAAI,CAACzE,OAAO,CAAC2U,aAAa,CAACG,OAAd,CAAsBC,MAAvB,CAAZ,EAA4C;AAC1CJ,MAAAA,aAAa,CAACG,OAAd,CAAsBC,MAAtB,GAA+B3Q,kBAA/B;AACD;;AAEDuQ,IAAAA,aAAa,CACVK,gBADH,GAEGC,IAFH,CAEQ,UAAUC,WAAV,EAAuB;AAC3B,UAAIC,KAAK,GAAG,IAAI1O,UAAJ,CAAeyO,WAAf,CAAZ;;AACA,UAAIX,iBAAiB,CAACY,KAAD,CAArB,EAA8B;AAC5B;AACA,YAAIzO,UAAU,GAAGlE,QAAQ,CAAC2S,KAAD,CAAzB;AACA1Q,QAAAA,UAAU,CAACe,SAAX,CAAqBkB,UAArB;AACD,OAJD,MAIO;AACL;AACA,YAAI0O,IAAI,GAAG9U,qBAAqB,CAAC6U,KAAD,CAAhC;AACA1Q,QAAAA,UAAU,CAACe,SAAX,CAAqB4P,IAArB;AACD;;AAED,UAAIC,eAAe,GAAG7Q,KAAK,CAACwC,gBAA5B;AACA,UAAIsO,OAAO,GAAGX,aAAa,CAACW,OAA5B;;AACA,UAAItV,OAAO,CAACsV,OAAD,CAAX,EAAsB;AACpB,YAAI3P,MAAM,GAAG2P,OAAO,CAAC3P,MAArB;;AACA,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,MAApB,EAA4BC,CAAC,EAA7B,EAAiC;AAC/ByP,UAAAA,eAAe,CAACR,IAAhB,CAAqBS,OAAO,CAAC1P,CAAD,CAA5B;AACD;AACF;AACF,KAtBH,EAuBG2P,SAvBH,CAwBI3R,YAAY,CAAC4R,qBAAb,CAAmChR,KAAnC,EAA0C,OAA1C,EAAmDmQ,aAAa,CAACpD,GAAjE,CAxBJ;AA0BD,GAxCD,MAwCO,IAAI,CAAC9M,UAAU,CAACM,KAAhB,EAAuB;AAC5B;AACA,MAAEN,UAAU,CAACQ,KAAb;AACAR,IAAAA,UAAU,CAACO,YAAX,CAAwB6P,IAAxB,CAA6BrQ,KAA7B;AACD,GAjFiC,CAkFlC;AACA;;;AAEA,SAAOA,KAAP;AACD,CAtFD;AAwFA;AACA;AACA;AACA;AACA;;;AACA0B,KAAK,CAACuP,UAAN,GAAmBzP,SAAnB;;AAEA,SAAS0P,UAAT,CAAoBlR,KAApB,EAA2BmR,WAA3B,EAAwCC,IAAxC,EAA8C;AAC5C;AACA,MAAIpR,KAAK,CAACyI,MAAN,KAAiB9I,UAAU,CAACsN,MAAhC,EAAwC;AACtC,UAAM,IAAIvR,cAAJ,CACJ,sFADI,CAAN;AAGD;;AAED,MAAI,CAACF,OAAO,CAAC4V,IAAD,CAAZ,EAAoB;AAClB,UAAM,IAAI1V,cAAJ,CAAmB,mBAAnB,CAAN;AACD,GAV2C,CAW5C;;;AAEA,SAAOsE,KAAK,CAACiJ,QAAN,CAAekI,WAAf,EAA4BC,IAA5B,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA1P,KAAK,CAACd,SAAN,CAAgByQ,OAAhB,GAA0B,UAAUD,IAAV,EAAgB;AACxC,MAAIE,IAAI,GAAGJ,UAAU,CAAC,IAAD,EAAO,aAAP,EAAsBE,IAAtB,CAArB;AACA,SAAO5V,OAAO,CAAC8V,IAAD,CAAP,GAAgBA,IAAI,CAACC,UAArB,GAAkChQ,SAAzC;AACD,CAHD;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAG,KAAK,CAACd,SAAN,CAAgB4Q,OAAhB,GAA0B,UAAUJ,IAAV,EAAgB;AACxC,SAAOF,UAAU,CAAC,IAAD,EAAO,cAAP,EAAuBE,IAAvB,CAAjB;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA1P,KAAK,CAACd,SAAN,CAAgB6Q,WAAhB,GAA8B,UAAUL,IAAV,EAAgB;AAC5C,SAAOF,UAAU,CAAC,IAAD,EAAO,iBAAP,EAA0BE,IAA1B,CAAjB;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA1P,KAAK,CAACd,SAAN,CAAgB8Q,oBAAhB,GAAuC,UAAUC,oBAAV,EAAgC7Q,KAAhC,EAAuC;AAC5E;AACA7F,EAAAA,KAAK,CAAC6T,MAAN,CAAaE,MAAb,CAAoB,OAApB,EAA6BlO,KAA7B,EAF4E,CAG5E;;AAEA,MAAI8Q,KAAK,GAAGV,UAAU,CAAC,IAAD,EAAO,aAAP,EAAsBS,oBAAtB,CAAtB;AACA,MAAIE,YAAY,GAAGX,UAAU,CAC3B,IAD2B,EAE3B,yBAF2B,EAG3BS,oBAH2B,CAA7B;;AAKA,MAAInW,OAAO,CAACoW,KAAD,CAAP,IAAkBpW,OAAO,CAACqW,YAAD,CAA7B,EAA6C;AAC3C/Q,IAAAA,KAAK,GAAGzE,UAAU,CAACyV,KAAX,CAAiBhR,KAAjB,EAAwB8Q,KAAK,CAACG,YAA9B,EAA4CH,KAAK,CAACI,YAAlD,CAAR;;AACA,QACE,CAAC3V,UAAU,CAAC4V,aAAX,CAAyBL,KAAK,CAACM,YAA/B,EAA6CpR,KAA7C,EAAoDjB,mBAApD,CADH,EAEE;AACA+R,MAAAA,KAAK,CAACM,YAAN,GAAqBpR,KAArB;AACA+Q,MAAAA,YAAY,CAACM,OAAb,GAAuB,IAAvB;AACD;AACF;AACF,CApBD;;AAsBA,IAAIC,4BAA4B,GAAG,IAAItX,UAAJ,EAAnC;AACA,IAAIuX,2BAA2B,GAAG,IAAI/V,OAAJ,EAAlC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASgW,4BAAT,CAAsCV,KAAtC,EAA6CW,MAA7C,EAAqD;AACnD;AACAtX,EAAAA,KAAK,CAAC6T,MAAN,CAAaC,MAAb,CAAoB,OAApB,EAA6B6C,KAA7B;AACA3W,EAAAA,KAAK,CAAC6T,MAAN,CAAaC,MAAb,CAAoB,QAApB,EAA8BwD,MAA9B,EAHmD,CAInD;;AAEA,MAAIzR,KAAK,GAAG8Q,KAAK,CAACM,YAAlB;AACA,MAAIM,SAAS,GAAGJ,4BAAhB;AACA,MAAIK,QAAJ;;AACA,UAAQb,KAAK,CAACc,IAAd;AACE,SAAK,SAAL;AACED,MAAAA,QAAQ,GAAGnW,OAAO,CAACqW,aAAR,CACTtW,UAAU,CAACuW,SAAX,CAAqB9R,KAArB,CADS,EAETuR,2BAFS,CAAX;AAIA9V,MAAAA,OAAO,CAACsW,iBAAR,CAA0BN,MAA1B,EAAkCE,QAAlC,EAA4CF,MAA5C;AACA;;AACF,SAAK,SAAL;AACEE,MAAAA,QAAQ,GAAGnW,OAAO,CAACwW,aAAR,CACTzW,UAAU,CAACuW,SAAX,CAAqB9R,KAArB,CADS,EAETuR,2BAFS,CAAX;AAIA9V,MAAAA,OAAO,CAACsW,iBAAR,CAA0BN,MAA1B,EAAkCE,QAAlC,EAA4CF,MAA5C;AACA;;AACF,SAAK,SAAL;AACEE,MAAAA,QAAQ,GAAGnW,OAAO,CAACyW,aAAR,CACT1W,UAAU,CAACuW,SAAX,CAAqB9R,KAArB,CADS,EAETuR,2BAFS,CAAX;AAIA9V,MAAAA,OAAO,CAACsW,iBAAR,CAA0BN,MAA1B,EAAkCE,QAAlC,EAA4CF,MAA5C;AACA;;AACF,SAAK,YAAL;AACEC,MAAAA,SAAS,CAACtD,CAAV,GAAcpO,KAAd;AACA0R,MAAAA,SAAS,CAACpD,CAAV,GAAc,GAAd;AACAoD,MAAAA,SAAS,CAACQ,CAAV,GAAc,GAAd;AACAzW,MAAAA,OAAO,CAAC0W,qBAAR,CAA8BV,MAA9B,EAAsCC,SAAtC,EAAiDD,MAAjD;AACA;;AACF,SAAK,YAAL;AACEC,MAAAA,SAAS,CAACtD,CAAV,GAAc,GAAd;AACAsD,MAAAA,SAAS,CAACpD,CAAV,GAActO,KAAd;AACA0R,MAAAA,SAAS,CAACQ,CAAV,GAAc,GAAd;AACAzW,MAAAA,OAAO,CAAC0W,qBAAR,CAA8BV,MAA9B,EAAsCC,SAAtC,EAAiDD,MAAjD;AACA;;AACF,SAAK,YAAL;AACEC,MAAAA,SAAS,CAACtD,CAAV,GAAc,GAAd;AACAsD,MAAAA,SAAS,CAACpD,CAAV,GAAc,GAAd;AACAoD,MAAAA,SAAS,CAACQ,CAAV,GAAclS,KAAd;AACAvE,MAAAA,OAAO,CAAC0W,qBAAR,CAA8BV,MAA9B,EAAsCC,SAAtC,EAAiDD,MAAjD;AACA;;AACF,SAAK,QAAL;AACEC,MAAAA,SAAS,CAACtD,CAAV,GAAcpO,KAAd;AACA0R,MAAAA,SAAS,CAACpD,CAAV,GAAc,GAAd;AACAoD,MAAAA,SAAS,CAACQ,CAAV,GAAc,GAAd;AACAzW,MAAAA,OAAO,CAAC2W,eAAR,CAAwBX,MAAxB,EAAgCC,SAAhC,EAA2CD,MAA3C;AACA;;AACF,SAAK,QAAL;AACEC,MAAAA,SAAS,CAACtD,CAAV,GAAc,GAAd;AACAsD,MAAAA,SAAS,CAACpD,CAAV,GAActO,KAAd;AACA0R,MAAAA,SAAS,CAACQ,CAAV,GAAc,GAAd;AACAzW,MAAAA,OAAO,CAAC2W,eAAR,CAAwBX,MAAxB,EAAgCC,SAAhC,EAA2CD,MAA3C;AACA;;AACF,SAAK,QAAL;AACEC,MAAAA,SAAS,CAACtD,CAAV,GAAc,GAAd;AACAsD,MAAAA,SAAS,CAACpD,CAAV,GAAc,GAAd;AACAoD,MAAAA,SAAS,CAACQ,CAAV,GAAclS,KAAd;AACAvE,MAAAA,OAAO,CAAC2W,eAAR,CAAwBX,MAAxB,EAAgCC,SAAhC,EAA2CD,MAA3C;AACA;;AACF,SAAK,cAAL;AACEhW,MAAAA,OAAO,CAAC4W,sBAAR,CAA+BZ,MAA/B,EAAuCzR,KAAvC,EAA8CyR,MAA9C;AACA;;AACF;AACE;AA9DJ;;AAgEA,SAAOA,MAAP;AACD;;AAED,IAAIa,iCAAiC,GAAG,IAAI7W,OAAJ,EAAxC;AAEA;AACA;AACA;AACA;AACA;AACA;;AACAmF,KAAK,CAACd,SAAN,CAAgByS,kBAAhB,GAAqC,YAAY;AAC/C,MAAIlK,mBAAmB,GAAG,KAAKF,QAAL,CAAcE,mBAAxC;;AACA,OAAK,IAAImK,gBAAT,IAA6BnK,mBAA7B,EAAkD;AAChD,QAAIA,mBAAmB,CAACoK,cAApB,CAAmCD,gBAAnC,CAAJ,EAA0D;AACxD,UAAIzB,YAAY,GAAG1I,mBAAmB,CAACmK,gBAAD,CAAtC;;AACA,UAAIzB,YAAY,CAACM,OAAjB,EAA0B;AACxBN,QAAAA,YAAY,CAACM,OAAb,GAAuB,KAAvB;AACA,YAAIqB,QAAQ,GAAG3B,YAAY,CAACtI,KAAb,CAAmBpI,MAAlC;;AACA,aAAK,IAAIsS,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,QAApB,EAA8B,EAAEC,CAAhC,EAAmC;AACjC,cAAInC,IAAI,GAAGO,YAAY,CAACtI,KAAb,CAAmBkK,CAAnB,CAAX;AACA,cAAIC,SAAS,GAAGnX,OAAO,CAACrB,KAAR,CACdoW,IAAI,CAACqC,cADS,EAEdP,iCAFc,CAAhB;AAKA,cAAIQ,SAAS,GAAG/B,YAAY,CAACgC,MAAb,CAAoB1S,MAApC;;AACA,eAAK,IAAI2S,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,SAApB,EAA+B,EAAEE,CAAjC,EAAoC;AAClC,gBAAIlC,KAAK,GAAGC,YAAY,CAACgC,MAAb,CAAoBC,CAApB,CAAZ;AACAJ,YAAAA,SAAS,GAAGpB,4BAA4B,CAACV,KAAD,EAAQ8B,SAAR,CAAxC;AACD;;AACDpC,UAAAA,IAAI,CAACyC,MAAL,GAAcL,SAAd;AACD;AACF;AACF;AACF;AACF,CAzBD,C,CA2BA;;;AAEA,SAASM,yBAAT,CAAmChU,KAAnC,EAA0C;AACxC,MAAIM,IAAI,GAAGN,KAAK,CAACM,IAAjB;AACA,MAAI2T,aAAa,GAAGjU,KAAK,CAAC2I,cAA1B;AACA/K,EAAAA,OAAO,CAACsW,MAAR,CAAe5T,IAAf,EAAqB,UAAU4T,MAAV,EAAkBxQ,EAAlB,EAAsB;AACzCuQ,IAAAA,aAAa,CAAC9J,OAAd,CAAsBzG,EAAtB,IAA4BwQ,MAAM,CAACC,MAAP,CAAcC,SAAd,CAAwBC,MAApD;AACD,GAFD;AAGD;;AAED,SAASC,UAAT,CAAoBtU,KAApB,EAA2B0D,EAA3B,EAA+B;AAC7B,SAAO,UAAUgN,WAAV,EAAuB;AAC5B,QAAIuD,aAAa,GAAGjU,KAAK,CAAC2I,cAA1B;AACA,QAAIuL,MAAM,GAAG,IAAIjS,UAAJ,CAAeyO,WAAf,CAAb;AACA,MAAEuD,aAAa,CAACM,kBAAhB;AACAvU,IAAAA,KAAK,CAACM,IAAN,CAAW6J,OAAX,CAAmBzG,EAAnB,EAAuByQ,MAAvB,CAA8BC,SAA9B,CAAwCC,MAAxC,GAAiDH,MAAjD;AACD,GALD;AAMD;;AAED,SAASM,gBAAT,CAA0BxU,KAA1B,EAAiC;AAC/B,MAAIyU,WAAW,GAAGzU,KAAK,CAACM,IAAN,CAAWmU,WAA7B;AACA,MAAIC,qBAAqB,GAAG1U,KAAK,CAAC2I,cAAN,CAAqB+L,qBAAjD,CAF+B,CAI/B;;AACA9W,EAAAA,OAAO,CAAC+W,UAAR,CAAmB3U,KAAK,CAACM,IAAzB,EAA+B,UAAUqU,UAAV,EAAsBjR,EAAtB,EAA0B;AACvD,QAAIiR,UAAU,CAACC,MAAX,KAAsB/X,cAAc,CAACgY,YAAzC,EAAuD;AACrDH,MAAAA,qBAAqB,CAACI,OAAtB,CAA8BpR,EAA9B;AACD;AACF,GAJD;AAMA,MAAIqR,oBAAoB,GAAG/U,KAAK,CAAC2I,cAAN,CAAqBoM,oBAAhD;AACA,MAAIC,cAAc,GAAG,EAArB,CAZ+B,CAc/B;AACA;AACA;;AACApX,EAAAA,OAAO,CAACqX,QAAR,CAAiBjV,KAAK,CAACM,IAAvB,EAA6B,UAAU2U,QAAV,EAAoB;AAC/C,QAAIC,YAAY,GAAGD,QAAQ,CAACN,UAA5B;;AACA,QAAI,CAACnZ,OAAO,CAAC0Z,YAAD,CAAZ,EAA4B;AAC1B;AACD;;AAED,QAAIP,UAAU,GAAGF,WAAW,CAACS,YAAD,CAA5B;;AACA,QACEP,UAAU,CAACC,MAAX,KAAsB/X,cAAc,CAACsY,oBAArC,IACA,CAAC3Z,OAAO,CAACwZ,cAAc,CAACE,YAAD,CAAf,CAFV,EAGE;AACAF,MAAAA,cAAc,CAACE,YAAD,CAAd,GAA+B,IAA/B;AACAH,MAAAA,oBAAoB,CAACD,OAArB,CAA6B;AAC3BpR,QAAAA,EAAE,EAAEwR,YADuB;AAE3BE,QAAAA,aAAa,EAAEH,QAAQ,CAACG;AAFG,OAA7B;AAID;AACF,GAjBD;AAkBD;;AAED,SAASC,eAAT,CAAyBrV,KAAzB,EAAgC;AAC9B;AACA,MAAIM,IAAI,GAAGN,KAAK,CAACM,IAAjB;;AACA,MAAI,CAACxC,YAAY,CAACwC,IAAD,EAAO,sBAAP,CAAjB,EAAiD;AAC/C;AACD;;AAED,MAAIgV,cAAc,GAAGtV,KAAK,CAACsL,eAA3B;AACA,MAAIiK,gBAAgB,GAAGvV,KAAK,CAACqL,iBAA7B;AACA,MAAIhB,QAAQ,GAAG/J,IAAI,CAACkV,UAAL,CAAgBC,oBAAhB,CAAqCpL,QAApD;AAEAzM,EAAAA,OAAO,CAAC8X,SAAR,CAAkBpV,IAAlB,EAAwB,UAAUoV,SAAV,EAAqBC,WAArB,EAAkC;AACxDJ,IAAAA,gBAAgB,CAACI,WAAD,CAAhB,GAAgCza,KAAK,CAACwa,SAAD,CAArC;AAEA,QAAIE,SAAS,GAAGF,SAAS,CAACG,OAA1B;;AACA,QAAI,CAACra,OAAO,CAAC8Z,cAAc,CAACM,SAAD,CAAf,CAAZ,EAAyC;AACvCN,MAAAA,cAAc,CAACM,SAAD,CAAd,GAA4B1a,KAAK,CAACmP,QAAQ,CAACuL,SAAD,CAAT,CAAjC;AACD;AACF,GAPD;AAQD;;AAED,SAASE,UAAT,CAAoB9V,KAApB,EAA2B0S,IAA3B,EAAiChP,EAAjC,EAAqC;AACnC,SAAO,UAAU2Q,MAAV,EAAkB;AACvB,QAAIJ,aAAa,GAAGjU,KAAK,CAAC2I,cAA1B;AACAsL,IAAAA,aAAa,CAAC8B,OAAd,CAAsBrS,EAAtB,IAA4B;AAC1B2Q,MAAAA,MAAM,EAAEA,MADkB;AAE1B3B,MAAAA,IAAI,EAAEA,IAFoB;AAG1BiC,MAAAA,UAAU,EAAEpT;AAHc,KAA5B;AAKA,MAAE0S,aAAa,CAAC+B,kBAAhB;AACAhW,IAAAA,KAAK,CAACkK,kBAAN,CAAyBI,aAAzB,CAAuC5G,EAAvC,IAA6C2Q,MAA7C;AACD,GATD;AAUD;;AAED,SAAS4B,YAAT,CAAsBjW,KAAtB,EAA6B;AAC3B,MAAIM,IAAI,GAAGN,KAAK,CAACM,IAAjB;AACA,MAAI6J,OAAO,GAAG7J,IAAI,CAAC6J,OAAnB;AACA,MAAIsK,WAAW,GAAGnU,IAAI,CAACmU,WAAvB;AACA,MAAInK,aAAa,GAAGtK,KAAK,CAACkK,kBAAN,CAAyBI,aAA7C;AACA1M,EAAAA,OAAO,CAACsY,MAAR,CAAe5V,IAAf,EAAqB,UAAU4V,MAAV,EAAkBxS,EAAlB,EAAsB;AACzC;AACA,QAAIlI,OAAO,CAAC0a,MAAM,CAACvB,UAAR,CAAX,EAAgC;AAC9B,UAAIO,YAAY,GAAGgB,MAAM,CAACvB,UAA1B;AACA,UAAIA,UAAU,GAAGF,WAAW,CAACS,YAAD,CAA5B;AACA,UAAIiB,QAAQ,GAAGxB,UAAU,CAACT,MAA1B;AACA,UAAIA,MAAM,GAAG/J,OAAO,CAACgM,QAAD,CAApB;AACA,UAAI9B,MAAM,GAAGrY,uBAAuB,CAClCkY,MAAM,CAACC,MAAP,CAAcC,SAAd,CAAwBC,MADU,EAElCM,UAAU,CAACyB,UAFuB,EAGlCzB,UAAU,CAAC0B,UAHuB,CAApC;AAKA/L,MAAAA,aAAa,CAAC5G,EAAD,CAAb,GAAoB2Q,MAApB;AACD,KAXD,MAWO,IAAI7Y,OAAO,CAAC0a,MAAM,CAAC/B,MAAP,CAAcC,SAAd,CAAwBC,MAAzB,CAAX,EAA6C;AAClD/J,MAAAA,aAAa,CAAC5G,EAAD,CAAb,GAAoBwS,MAAM,CAAC/B,MAAP,CAAcC,SAAd,CAAwBC,MAA5C;AACD,KAFM,MAEA;AACL,QAAErU,KAAK,CAAC2I,cAAN,CAAqBqN,kBAAvB;;AAEA,UAAIM,cAAc,GAAGtW,KAAK,CAACoC,SAAN,CAAgBmU,kBAAhB,CAAmC;AACtDxJ,QAAAA,GAAG,EAAEmJ,MAAM,CAACM;AAD0C,OAAnC,CAArB;;AAIAF,MAAAA,cAAc,CACXG,SADH,GAEGhG,IAFH,CAEQqF,UAAU,CAAC9V,KAAD,EAAQkW,MAAM,CAACxD,IAAf,EAAqBhP,EAArB,CAFlB,EAGGqN,SAHH,CAII3R,YAAY,CAAC4R,qBAAb,CACEhR,KADF,EAEE,QAFF,EAGEsW,cAAc,CAACvJ,GAHjB,CAJJ;AAUD;AACF,GAjCD;AAkCD;;AAED,SAAS2J,aAAT,CAAuB1W,KAAvB,EAA8B;AAC5B,MAAIuV,gBAAgB,GAAGvV,KAAK,CAACqL,iBAA7B;;AACA,OAAK,IAAIsK,WAAT,IAAwBJ,gBAAxB,EAA0C;AACxC,QAAIA,gBAAgB,CAAChC,cAAjB,CAAgCoC,WAAhC,CAAJ,EAAkD;AAChD,UAAID,SAAS,GAAGH,gBAAgB,CAACI,WAAD,CAAhC;;AACA3V,MAAAA,KAAK,CAAC2I,cAAN,CAAqBgO,gBAArB,CAAsC7B,OAAtC,CAA8C;AAC5Cc,QAAAA,SAAS,EAAEF,SAAS,CAACG,OADuB;AAE5CF,QAAAA,WAAW,EAAEA;AAF+B,OAA9C;AAID;AACF;AACF;;AAED,SAASiB,kBAAT,CAA4B5W,KAA5B,EAAmC;AACjC,MAAImJ,mBAAmB,GAAG,EAA1B;AACA,MAAIC,uBAAuB,GAAG,EAA9B;AACA,MAAIyN,kBAAkB,GAAG,EAAzB;AAEA7W,EAAAA,KAAK,CAACiJ,QAAN,CAAeE,mBAAf,GAAqCA,mBAArC;AACAnJ,EAAAA,KAAK,CAACiJ,QAAN,CAAeG,uBAAf,GAAyCA,uBAAzC;AACApJ,EAAAA,KAAK,CAACiJ,QAAN,CAAeI,WAAf,GAA6BwN,kBAA7B;AAEA,MAAIvW,IAAI,GAAGN,KAAK,CAACM,IAAjB;;AACA,MACE,CAACxC,YAAY,CAACwC,IAAD,EAAO,mBAAP,CAAb,IACA,CAAC9E,OAAO,CAAC8E,IAAI,CAACkV,UAAN,CADR,IAEA,CAACha,OAAO,CAAC8E,IAAI,CAACkV,UAAL,CAAgBsB,iBAAjB,CAHV,EAIE;AACA;AACD;;AAED,MAAIC,iBAAiB,GAAGzW,IAAI,CAACkV,UAAL,CAAgBsB,iBAAhB,CAAkCE,aAA1D;;AACA,MAAI,CAACxb,OAAO,CAACub,iBAAD,CAAZ,EAAiC;AAC/B;AACD;;AAED,MAAIE,gBAAgB,GAAGF,iBAAiB,CAAC5V,MAAzC;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG6V,gBAApB,EAAsC,EAAE7V,CAAxC,EAA2C;AACzC,QAAIyQ,YAAY,GAAG3W,KAAK,CAAC6b,iBAAiB,CAAC3V,CAAD,CAAlB,CAAxB;AACAyQ,IAAAA,YAAY,CAACtI,KAAb,GAAqB,EAArB;AACAsI,IAAAA,YAAY,CAACM,OAAb,GAAuB,IAAvB;AACAhJ,IAAAA,mBAAmB,CAAC0I,YAAY,CAACT,IAAd,CAAnB,GAAyCS,YAAzC;AAEA,QAAI+B,SAAS,GAAG/B,YAAY,CAACgC,MAAb,CAAoB1S,MAApC;;AACA,SAAK,IAAI2S,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,SAApB,EAA+B,EAAEE,CAAjC,EAAoC;AAClC,UAAIlC,KAAK,GAAGC,YAAY,CAACgC,MAAb,CAAoBC,CAApB,CAAZ;AACAlC,MAAAA,KAAK,CAACM,YAAN,GAAqBN,KAAK,CAACsF,YAA3B;AAEA,UAAIC,QAAQ,GAAGtF,YAAY,CAACT,IAAb,GAAoB,GAApB,GAA0BQ,KAAK,CAACR,IAA/C;AACAhI,MAAAA,uBAAuB,CAAC+N,QAAD,CAAvB,GAAoCtF,YAApC;AACAgF,MAAAA,kBAAkB,CAACM,QAAD,CAAlB,GAA+BvF,KAA/B;AACD;AACF;AACF;;AAED,SAASwF,SAAT,CAAmBpX,KAAnB,EAA0BqX,SAA1B,EAAqC;AACnC,SAAO,UAAUC,KAAV,EAAiB;AACtB,QAAIrD,aAAa,GAAGjU,KAAK,CAAC2I,cAA1B;AACA,MAAEsL,aAAa,CAAClG,mBAAhB;AACAkG,IAAAA,aAAa,CAACsD,gBAAd,CAA+BzC,OAA/B,CAAuC;AACrCpR,MAAAA,EAAE,EAAE2T,SADiC;AAErCC,MAAAA,KAAK,EAAEA,KAF8B;AAGrC3C,MAAAA,UAAU,EAAE2C,KAAK,CAAC3C,UAHmB;AAIrC6C,MAAAA,KAAK,EAAEF,KAAK,CAACE,KAJwB;AAKrCC,MAAAA,MAAM,EAAEH,KAAK,CAACG,MALuB;AAMrCC,MAAAA,cAAc,EAAEJ,KAAK,CAACI;AANe,KAAvC;AAQD,GAXD;AAYD;;AAED,IAAIC,QAAQ,GAAG,8BAAf;AACA,IAAIC,QAAQ,GAAG,8BAAf;;AAEA,SAASC,aAAT,CAAuB7X,KAAvB,EAA8B0P,OAA9B,EAAuCoI,YAAvC,EAAqD;AACnD,MAAIxX,IAAI,GAAGN,KAAK,CAACM,IAAjB;AACA,MAAIyX,MAAM,GAAGzX,IAAI,CAACyX,MAAlB;AACA,MAAIvB,GAAJ;AACA5Y,EAAAA,OAAO,CAACoa,OAAR,CAAgB1X,IAAhB,EAAsB,UAAU0X,OAAV,EAAmBtU,EAAnB,EAAuB;AAC3C,QAAIuU,OAAO,GAAGD,OAAO,CAAC3D,MAAtB;;AAEA,QACE7Y,OAAO,CAACwc,OAAO,CAACxC,UAAT,CAAP,IACAha,OAAO,CAACwc,OAAO,CAACxC,UAAR,CAAmB0C,gBAApB,CADP,IAEAJ,YAHF,EAIE;AACAG,MAAAA,OAAO,GAAGD,OAAO,CAACxC,UAAR,CAAmB0C,gBAAnB,CAAoC7D,MAA9C;AACD;;AAED,QAAI8D,SAAS,GAAGJ,MAAM,CAACE,OAAD,CAAtB;AACA,QAAI9D,MAAM,GAAGgE,SAAS,CAAChE,MAAvB;AAEA,QAAIe,YAAY,GAAGiD,SAAS,CAACxD,UAA7B;AACA,QAAIyD,QAAQ,GAAGD,SAAS,CAACC,QAAzB;AACA5B,IAAAA,GAAG,GAAG2B,SAAS,CAAC3B,GAAhB,CAhB2C,CAkB3C;;AACA,QAAIhb,OAAO,CAAC2Y,MAAD,CAAP,IAAmB3Y,OAAO,CAAC2Y,MAAM,CAACkE,sBAAR,CAA9B,EAA+D;AAC7D,UAAIC,MAAM,GAAGnE,MAAM,CAACkE,sBAAP,CAA8BC,MAA3C;AACA,UAAIC,IAAI,GAAGpE,MAAM,CAACkE,sBAAP,CAA8BE,IAAzC;AACA,UAAIC,KAAK,GAAGrE,MAAM,CAACkE,sBAAP,CAA8BI,MAA1C;AACA,UAAIC,IAAI,GAAGvE,MAAM,CAACkE,sBAAP,CAA8BK,IAAzC;;AAEA,UAAIhJ,OAAO,CAAC6I,IAAR,IAAgB/c,OAAO,CAAC8c,MAAD,CAA3B,EAAqC;AACnCF,QAAAA,QAAQ,GAAGE,MAAM,CAACF,QAAlB;;AACA,YAAI5c,OAAO,CAAC8c,MAAM,CAAC3D,UAAR,CAAX,EAAgC;AAC9BO,UAAAA,YAAY,GAAGoD,MAAM,CAAC3D,UAAtB;AACD,SAFD,MAEO;AACL6B,UAAAA,GAAG,GAAG8B,MAAM,CAAC9B,GAAb;AACD;AACF,OAPD,MAOO,IAAI9G,OAAO,CAAC6I,IAAR,IAAgB/c,OAAO,CAAC+c,IAAD,CAA3B,EAAmC;AACxCH,QAAAA,QAAQ,GAAGG,IAAI,CAACH,QAAhB;;AACA,YAAI5c,OAAO,CAAC+c,IAAI,CAAC5D,UAAN,CAAX,EAA8B;AAC5BO,UAAAA,YAAY,GAAGqD,IAAI,CAAC5D,UAApB;AACD,SAFD,MAEO;AACL6B,UAAAA,GAAG,GAAG+B,IAAI,CAAC/B,GAAX;AACD;AACF,OAPM,MAOA,IAAI9G,OAAO,CAAC8I,KAAR,IAAiBhd,OAAO,CAACgd,KAAD,CAA5B,EAAqC;AAC1CJ,QAAAA,QAAQ,GAAGI,KAAK,CAACJ,QAAjB;;AACA,YAAI5c,OAAO,CAACgd,KAAK,CAAC7D,UAAP,CAAX,EAA+B;AAC7BO,UAAAA,YAAY,GAAGsD,KAAK,CAAC7D,UAArB;AACD,SAFD,MAEO;AACL6B,UAAAA,GAAG,GAAGgC,KAAK,CAAChC,GAAZ;AACD;AACF,OAPM,MAOA,IAAI9G,OAAO,CAACgJ,IAAR,IAAgBld,OAAO,CAACkd,IAAD,CAA3B,EAAmC;AACxCN,QAAAA,QAAQ,GAAGM,IAAI,CAACN,QAAhB;;AACA,YAAI5c,OAAO,CAACkd,IAAI,CAAC/D,UAAN,CAAX,EAA8B;AAC5BO,UAAAA,YAAY,GAAGwD,IAAI,CAAC/D,UAApB;AACD,SAFD,MAEO;AACL6B,UAAAA,GAAG,GAAGkC,IAAI,CAAClC,GAAX;AACD;AACF;AACF,KAtD0C,CAwD3C;;;AACA,QAAIhb,OAAO,CAAC0Z,YAAD,CAAX,EAA2B;AACzBlV,MAAAA,KAAK,CAAC2I,cAAN,CAAqBgQ,8BAArB,CAAoD7D,OAApD,CAA4D;AAC1DpR,QAAAA,EAAE,EAAEA,EADsD;AAE1D4T,QAAAA,KAAK,EAAE/V,SAFmD;AAG1DoT,QAAAA,UAAU,EAAEO,YAH8C;AAI1DkD,QAAAA,QAAQ,EAAEA;AAJgD,OAA5D;AAMD,KAPD,MAOO;AACL,QAAEpY,KAAK,CAAC2I,cAAN,CAAqBoF,mBAAvB;;AAEA,UAAI6K,aAAa,GAAG5Y,KAAK,CAACoC,SAAN,CAAgBmU,kBAAhB,CAAmC;AACrDxJ,QAAAA,GAAG,EAAEyJ;AADgD,OAAnC,CAApB;;AAIA,UAAI1I,OAAJ;;AACA,UAAI6J,QAAQ,CAACkB,IAAT,CAAcrC,GAAd,CAAJ,EAAwB;AACtB1I,QAAAA,OAAO,GAAG1R,OAAO,CAACwc,aAAD,CAAjB;AACD,OAFD,MAEO,IAAIhB,QAAQ,CAACiB,IAAT,CAAcrC,GAAd,CAAJ,EAAwB;AAC7B1I,QAAAA,OAAO,GAAG5R,OAAO,CAAC0c,aAAD,CAAjB;AACD,OAFM,MAEA;AACL9K,QAAAA,OAAO,GAAG8K,aAAa,CAACE,UAAd,EAAV;AACD;;AACDhL,MAAAA,OAAO,CACJ2C,IADH,CACQ2G,SAAS,CAACpX,KAAD,EAAQ0D,EAAR,EAAYuU,OAAZ,CADjB,EAEGlH,SAFH,CAGI3R,YAAY,CAAC4R,qBAAb,CAAmChR,KAAnC,EAA0C,OAA1C,EAAmD4Y,aAAa,CAAC7L,GAAjE,CAHJ;AAKD;AACF,GArFD;AAsFD;;AAED,IAAIgM,wCAAwC,GAAG,IAAIxc,OAAJ,EAA/C;;AAEA,SAASyc,UAAT,CAAoBhZ,KAApB,EAA2B;AACzB,MAAIiZ,YAAY,GAAG,EAAnB;AACA,MAAIC,kBAAkB,GAAG,EAAzB;AACA,MAAIzP,YAAY,GAAG,EAAnB;AAEA,MAAI0P,eAAe,GAAGnZ,KAAK,CAAC2I,cAAN,CAAqBwQ,eAA3C;AACA,MAAIhQ,mBAAmB,GAAGnJ,KAAK,CAACiJ,QAAN,CAAeE,mBAAzC;AAEAvL,EAAAA,OAAO,CAAC0T,IAAR,CAAatR,KAAK,CAACM,IAAnB,EAAyB,UAAUgR,IAAV,EAAgB5N,EAAhB,EAAoB;AAC3C,QAAI0V,WAAW,GAAG;AAChB;AACArF,MAAAA,MAAM,EAAExS,SAFQ;AAGhB8X,MAAAA,WAAW,EAAE9X,SAHG;AAIhBkR,MAAAA,QAAQ,EAAElR,SAJM;AAKhB6B,MAAAA,KAAK,EAAE7B,SALS;AAOhB;AACA+X,MAAAA,YAAY,EAAE,IARE;AAUhB;AACAC,MAAAA,eAAe,EAAE,IAAIhd,OAAJ,EAXD;AAYhBid,MAAAA,cAAc,EAAE,IAAIjd,OAAJ,EAZA;AAahBkd,MAAAA,WAAW,EAAE,CAbG;AAaA;AAEhB;AACAC,MAAAA,QAAQ,EAAE,EAhBM;AAgBF;AAEd;AACAC,MAAAA,mBAAmB,EAAEpY,SAnBL;AAmBgB;AAChCqY,MAAAA,eAAe,EAAErY,SApBD;AAoBY;AAC5BsY,MAAAA,MAAM,EAAE,EArBQ;AAqBJ;AACZC,MAAAA,qBAAqB,EAAE,EAtBP;AAsBW;AAE3B;AACAC,MAAAA,SAAS,EAAEzI,IAAI,CAACyI,SAzBA;AAyBW;AAE3BC,MAAAA,OAAO,EAAE,EA3BO;AA6BhB;AACAC,MAAAA,QAAQ,EAAE,EA9BM;AA8BF;AACdC,MAAAA,OAAO,EAAE,EA/BO;AA+BH;AAEb;AACA3I,MAAAA,UAAU,EAAEhQ;AAlCI,KAAlB;AAoCA6X,IAAAA,WAAW,CAAC7H,UAAZ,GAAyB,IAAIrS,SAAJ,CACvBc,KADuB,EAEvBsR,IAFuB,EAGvB8H,WAHuB,EAIvB1V,EAJuB,EAKvBtE,YAAY,CAAC+a,YAAb,CAA0B7I,IAA1B,CALuB,CAAzB;AAQA2H,IAAAA,YAAY,CAACvV,EAAD,CAAZ,GAAmB0V,WAAnB;AACAF,IAAAA,kBAAkB,CAAC5H,IAAI,CAACF,IAAN,CAAlB,GAAgCgI,WAAhC;;AAEA,QAAI5d,OAAO,CAAC8V,IAAI,CAAC8I,IAAN,CAAX,EAAwB;AACtBjB,MAAAA,eAAe,CAAC9I,IAAhB,CAAqB3M,EAArB;AACA+F,MAAAA,YAAY,CAAC4G,IAAb,CAAkB+I,WAAlB;AACD;;AAED,QACE5d,OAAO,CAAC8V,IAAI,CAACkE,UAAN,CAAP,IACAha,OAAO,CAAC8V,IAAI,CAACkE,UAAL,CAAgBsB,iBAAjB,CAFT,EAGE;AACA,UAAIxD,gBAAgB,GAAGhC,IAAI,CAACkE,UAAL,CAAgBsB,iBAAhB,CAAkCxD,gBAAzD;;AACA,UAAI9X,OAAO,CAAC8X,gBAAD,CAAX,EAA+B;AAC7B,YAAII,SAAS,GAAGnX,OAAO,CAACrB,KAAR,CACdke,WAAW,CAAC7H,UAAZ,CAAuBoC,cADT,EAEdoF,wCAFc,CAAhB;AAIA,YAAIlH,YAAY,GAAG1I,mBAAmB,CAACmK,gBAAD,CAAtC;AACAzB,QAAAA,YAAY,CAACtI,KAAb,CAAmB8G,IAAnB,CAAwB+I,WAAW,CAAC7H,UAApC;AAEA,YAAIqC,SAAS,GAAG/B,YAAY,CAACgC,MAAb,CAAoB1S,MAApC;;AACA,aAAK,IAAI2S,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,SAApB,EAA+B,EAAEE,CAAjC,EAAoC;AAClC,cAAIlC,KAAK,GAAGC,YAAY,CAACgC,MAAb,CAAoBC,CAApB,CAAZ;AACAJ,UAAAA,SAAS,GAAGpB,4BAA4B,CAACV,KAAD,EAAQ8B,SAAR,CAAxC;AACD;;AACD0F,QAAAA,WAAW,CAAC7H,UAAZ,CAAuBwC,MAAvB,GAAgCL,SAAhC;AACD;AACF;AACF,GA1ED;AA4EA1T,EAAAA,KAAK,CAACiJ,QAAN,CAAeM,KAAf,GAAuB0P,YAAvB;AACAjZ,EAAAA,KAAK,CAACiJ,QAAN,CAAeO,WAAf,GAA6B0P,kBAA7B;AACAlZ,EAAAA,KAAK,CAACiJ,QAAN,CAAeQ,YAAf,GAA8BA,YAA9B;AACD;;AAED,SAAS4Q,cAAT,CAAwBra,KAAxB,EAA+B;AAC7B,MAAIM,IAAI,GAAGN,KAAK,CAACM,IAAjB;AACA,MAAIga,UAAU,GAAGta,KAAK,CAACqL,iBAAvB;AAEA,MAAIkP,sBAAsB,GAAG,EAA7B;AACA,MAAIC,oBAAoB,GAAG,EAA3B;AACA,MAAIC,WAAW,GAAGza,KAAK,CAAC6J,YAAxB;AAEAjM,EAAAA,OAAO,CAAC8c,QAAR,CAAiBpa,IAAjB,EAAuB,UAAUoa,QAAV,EAAoBC,UAApB,EAAgC;AACrD;AACAF,IAAAA,WAAW,CAACE,UAAD,CAAX,GAA0B;AACxBC,MAAAA,UAAU,EAAErZ,SADY;AAExBsZ,MAAAA,MAAM,EAAEtZ,SAFgB;AAGxBuZ,MAAAA,sBAAsB,EAAEvZ,SAHA;AAIxBwZ,MAAAA,uBAAuB,EAAExZ;AAJD,KAA1B;AAOA,QAAIyZ,aAAa,GAAG,IAAIhc,aAAJ,CAAkBgB,KAAlB,EAAyB0a,QAAzB,EAAmCC,UAAnC,CAApB;;AAEA,QACEnf,OAAO,CAACkf,QAAQ,CAAClF,UAAV,CAAP,IACAha,OAAO,CAACkf,QAAQ,CAAClF,UAAT,CAAoBC,oBAArB,CAFT,EAGE;AACA,UAAIE,WAAW,GAAG+E,QAAQ,CAAClF,UAAT,CAAoBC,oBAApB,CAAyCC,SAA3D;AACAsF,MAAAA,aAAa,CAACC,UAAd,GAA2BtF,WAA3B;AACAqF,MAAAA,aAAa,CAACE,QAAd,GAAyBZ,UAAU,CAAC3E,WAAD,CAAV,CAAwBE,OAAjD;AAEAjY,MAAAA,OAAO,CAACud,aAAR,CAAsBT,QAAtB,EAAgC,UAAU5Z,KAAV,EAAiBsa,WAAjB,EAA8B;AAC5D,YAAI,CAAC5f,OAAO,CAACwf,aAAa,CAACK,OAAf,CAAZ,EAAqC;AACnCL,UAAAA,aAAa,CAACK,OAAd,GAAwB,EAAxB;AACD;;AAEDL,QAAAA,aAAa,CAACK,OAAd,CAAsBD,WAAtB,IAAqClgB,KAAK,CAAC4F,KAAD,CAA1C;AACD,OAND;AAOD;;AAEDyZ,IAAAA,sBAAsB,CAACG,QAAQ,CAACtJ,IAAV,CAAtB,GAAwC4J,aAAxC;AACAR,IAAAA,oBAAoB,CAACG,UAAD,CAApB,GAAmCK,aAAnC;AACD,GA9BD;AAgCAhb,EAAAA,KAAK,CAACiJ,QAAN,CAAeU,eAAf,GAAiC4Q,sBAAjC;AACAva,EAAAA,KAAK,CAACiJ,QAAN,CAAeW,aAAf,GAA+B4Q,oBAA/B;AACD;;AAED,SAASc,WAAT,CAAqBtb,KAArB,EAA4B;AAC1B,MAAIub,mBAAmB,GAAG,EAA1B;AACA,MAAIf,oBAAoB,GAAGxa,KAAK,CAACiJ,QAAN,CAAeW,aAA1C;AAEAhM,EAAAA,OAAO,CAAC4d,IAAR,CAAaxb,KAAK,CAACM,IAAnB,EAAyB,UAAUkb,IAAV,EAAgBC,MAAhB,EAAwB;AAC/CF,IAAAA,mBAAmB,CAACC,IAAI,CAACpK,IAAN,CAAnB,GAAiC,IAAInS,SAAJ,CAC/Buc,IAD+B,EAE/BhB,oBAF+B,EAG/BiB,MAH+B,CAAjC;;AAKA,QACEjgB,OAAO,CAACwE,KAAK,CAACmO,cAAN,CAAqBuN,0BAAtB,CAAP,IACA1b,KAAK,CAAC6K,mBAFR,EAGE;AACA;AACAjN,MAAAA,OAAO,CAAC+d,aAAR,CAAsBH,IAAtB,EAA4B,UAAUI,SAAV,EAAqBC,WAArB,EAAkC;AAC5D,YAAIjG,SAAS,GAAGkG,sBAAsB,CAAC9b,KAAD,EAAQ4b,SAAR,CAAtC;AACA,YAAIG,iBAAiB,GAAG/b,KAAK,CAACiK,kBAAN,CAAyB2L,SAAzB,CAAxB;;AACA,YAAI,CAACpa,OAAO,CAACugB,iBAAD,CAAZ,EAAiC;AAC/BA,UAAAA,iBAAiB,GAAG,EAApB;AACA/b,UAAAA,KAAK,CAACiK,kBAAN,CAAyB2L,SAAzB,IAAsCmG,iBAAtC;AACD;;AACDA,QAAAA,iBAAiB,CAACN,MAAM,GAAG,aAAT,GAAyBI,WAA1B,CAAjB,GAA0DD,SAA1D;AACD,OARD;AASD;AACF,GArBD;AAuBA5b,EAAAA,KAAK,CAACiJ,QAAN,CAAeS,YAAf,GAA8B6R,mBAA9B;AACD,C,CAED;;;AAEA,IAAIS,qBAAqB,GAAG,YAAY;AACtC,OAAKtY,EAAL,GAAUnC,SAAV;AACA,OAAKvB,KAAL,GAAauB,SAAb;AACA,OAAKmO,OAAL,GAAenO,SAAf;AACD,CAJD;;AAMAya,qBAAqB,CAACpb,SAAtB,CAAgCC,GAAhC,GAAsC,UAAU6C,EAAV,EAAc1D,KAAd,EAAqB0P,OAArB,EAA8B;AAClE,OAAKhM,EAAL,GAAUA,EAAV;AACA,OAAK1D,KAAL,GAAaA,KAAb;AACA,OAAK0P,OAAL,GAAeA,OAAf;AACD,CAJD;;AAMAsM,qBAAqB,CAACpb,SAAtB,CAAgCqb,OAAhC,GAA0C,YAAY;AACpDC,EAAAA,kBAAkB,CAAC,KAAKxY,EAAN,EAAU,KAAK1D,KAAf,EAAsB,KAAK0P,OAA3B,CAAlB;AACD,CAFD,C,CAIA;;;AAEA,SAASwM,kBAAT,CAA4BhH,YAA5B,EAA0ClV,KAA1C,EAAiD0P,OAAjD,EAA0D;AACxD,MAAIuE,aAAa,GAAGjU,KAAK,CAAC2I,cAA1B;AACA,MAAI8L,WAAW,GAAGzU,KAAK,CAACM,IAAN,CAAWmU,WAA7B;AACA,MAAIE,UAAU,GAAGF,WAAW,CAACS,YAAD,CAA5B,CAHwD,CAKxD;;AACA,MAAI,CAAC1Z,OAAO,CAACmZ,UAAD,CAAZ,EAA0B;AACxBA,IAAAA,UAAU,GAAGV,aAAa,CAACkI,kBAAd,CAAiCjH,YAAjC,CAAb;AACD;;AAED,MAAIkH,YAAY,GAAGtf,MAAM,CAACof,kBAAP,CAA0B;AAC3CxM,IAAAA,OAAO,EAAEA,OADkC;AAE3C2M,IAAAA,UAAU,EAAEpI,aAAa,CAACqI,SAAd,CAAwB3H,UAAxB,CAF+B;AAG3C4H,IAAAA,KAAK,EAAExf,WAAW,CAACyf;AAHwB,GAA1B,CAAnB;AAKAJ,EAAAA,YAAY,CAACK,sBAAb,GAAsC,KAAtC;AACAzc,EAAAA,KAAK,CAACkK,kBAAN,CAAyBC,OAAzB,CAAiC+K,YAAjC,IAAiDkH,YAAjD;AACApc,EAAAA,KAAK,CAACkL,mBAAN,IAA6BkR,YAAY,CAACM,WAA1C;AACD,C,CAED;;;AAEA,IAAIC,oBAAoB,GAAG,YAAY;AACrC,OAAKjZ,EAAL,GAAUnC,SAAV;AACA,OAAK6T,aAAL,GAAqB7T,SAArB;AACA,OAAKvB,KAAL,GAAauB,SAAb;AACA,OAAKmO,OAAL,GAAenO,SAAf;AACD,CALD;;AAOAob,oBAAoB,CAAC/b,SAArB,CAA+BC,GAA/B,GAAqC,UACnC6C,EADmC,EAEnC0R,aAFmC,EAGnCpV,KAHmC,EAInC0P,OAJmC,EAKnC;AACA,OAAKhM,EAAL,GAAUA,EAAV;AACA,OAAK0R,aAAL,GAAqBA,aAArB;AACA,OAAKpV,KAAL,GAAaA,KAAb;AACA,OAAK0P,OAAL,GAAeA,OAAf;AACD,CAVD;;AAYAiN,oBAAoB,CAAC/b,SAArB,CAA+Bqb,OAA/B,GAAyC,YAAY;AACnDW,EAAAA,iBAAiB,CAAC,KAAKlZ,EAAN,EAAU,KAAK0R,aAAf,EAA8B,KAAKpV,KAAnC,EAA0C,KAAK0P,OAA/C,CAAjB;AACD,CAFD,C,CAIA;;;AAEA,SAASkN,iBAAT,CAA2B1H,YAA3B,EAAyCE,aAAzC,EAAwDpV,KAAxD,EAA+D0P,OAA/D,EAAwE;AACtE,MAAIuE,aAAa,GAAGjU,KAAK,CAAC2I,cAA1B;AACA,MAAI8L,WAAW,GAAGzU,KAAK,CAACM,IAAN,CAAWmU,WAA7B;AACA,MAAIE,UAAU,GAAGF,WAAW,CAACS,YAAD,CAA5B,CAHsE,CAKtE;;AACA,MAAI,CAAC1Z,OAAO,CAACmZ,UAAD,CAAZ,EAA0B;AACxBA,IAAAA,UAAU,GAAGV,aAAa,CAACkI,kBAAd,CAAiCjH,YAAjC,CAAb;AACD;;AAED,MAAI2H,WAAW,GAAG/f,MAAM,CAAC8f,iBAAP,CAAyB;AACzClN,IAAAA,OAAO,EAAEA,OADgC;AAEzC2M,IAAAA,UAAU,EAAEpI,aAAa,CAACqI,SAAd,CAAwB3H,UAAxB,CAF6B;AAGzC4H,IAAAA,KAAK,EAAExf,WAAW,CAACyf,WAHsB;AAIzCM,IAAAA,aAAa,EAAE1H;AAJ0B,GAAzB,CAAlB;AAMAyH,EAAAA,WAAW,CAACJ,sBAAZ,GAAqC,KAArC;AACAzc,EAAAA,KAAK,CAACkK,kBAAN,CAAyBC,OAAzB,CAAiC+K,YAAjC,IAAiD2H,WAAjD;AACA7c,EAAAA,KAAK,CAACkL,mBAAN,IAA6B2R,WAAW,CAACH,WAAzC;AACD;;AAED,IAAIK,sBAAsB,GAAG,IAAIf,qBAAJ,EAA7B;AACA,IAAIgB,qBAAqB,GAAG,IAAIL,oBAAJ,EAA5B;;AAEA,SAASM,aAAT,CAAuBjd,KAAvB,EAA8Bkd,UAA9B,EAA0C;AACxC,MAAIjJ,aAAa,GAAGjU,KAAK,CAAC2I,cAA1B;;AAEA,MAAIsL,aAAa,CAACM,kBAAd,KAAqC,CAAzC,EAA4C;AAC1C;AACD;;AAED,MAAI7E,OAAO,GAAGwN,UAAU,CAACxN,OAAzB;AACA,MAAIgF,qBAAqB,GAAGT,aAAa,CAACS,qBAA1C;AACA,MAAIK,oBAAoB,GAAGd,aAAa,CAACc,oBAAzC;AACA,MAAI3T,CAAJ;;AAEA,MAAIpB,KAAK,CAACmF,YAAV,EAAwB;AACtB,WAAOuP,qBAAqB,CAACvT,MAAtB,GAA+B,CAAtC,EAAyC;AACvC4b,MAAAA,sBAAsB,CAAClc,GAAvB,CAA2B6T,qBAAqB,CAACyI,IAAtB,EAA3B,EAAyDnd,KAAzD,EAAgE0P,OAAhE;;AACA,UACE,CAACwN,UAAU,CAACE,YAAX,CAAwBnB,OAAxB,CAAgCc,sBAAhC,EAAwDne,OAAO,CAACye,MAAhE,CADH,EAEE;AACA;AACD;;AACD3I,MAAAA,qBAAqB,CAAC4I,OAAtB;AACD;;AAED,WAAOvI,oBAAoB,CAAC5T,MAArB,GAA8B,CAArC,EAAwC;AACtCC,MAAAA,CAAC,GAAG2T,oBAAoB,CAACoI,IAArB,EAAJ;AACAH,MAAAA,qBAAqB,CAACnc,GAAtB,CAA0BO,CAAC,CAACsC,EAA5B,EAAgCtC,CAAC,CAACgU,aAAlC,EAAiDpV,KAAjD,EAAwD0P,OAAxD;;AACA,UACE,CAACwN,UAAU,CAACE,YAAX,CAAwBnB,OAAxB,CAAgCe,qBAAhC,EAAuDpe,OAAO,CAACye,MAA/D,CADH,EAEE;AACA;AACD;;AACDtI,MAAAA,oBAAoB,CAACuI,OAArB;AACD;AACF,GArBD,MAqBO;AACL,WAAO5I,qBAAqB,CAACvT,MAAtB,GAA+B,CAAtC,EAAyC;AACvC+a,MAAAA,kBAAkB,CAACxH,qBAAqB,CAAC4I,OAAtB,EAAD,EAAkCtd,KAAlC,EAAyC0P,OAAzC,CAAlB;AACD;;AAED,WAAOqF,oBAAoB,CAAC5T,MAArB,GAA8B,CAArC,EAAwC;AACtCC,MAAAA,CAAC,GAAG2T,oBAAoB,CAACuI,OAArB,EAAJ;AACAV,MAAAA,iBAAiB,CAACxb,CAAC,CAACsC,EAAH,EAAOtC,CAAC,CAACgU,aAAT,EAAwBpV,KAAxB,EAA+B0P,OAA/B,CAAjB;AACD;AACF;AACF;;AAED,SAASoM,sBAAT,CAAgC9b,KAAhC,EAAuC4b,SAAvC,EAAkD;AAChD,MAAIlB,QAAQ,GAAG1a,KAAK,CAACiJ,QAAN,CAAeW,aAAf,CAA6BgS,SAAS,CAAClB,QAAvC,CAAf;;AACA,MAAI,CAAClf,OAAO,CAACkf,QAAD,CAAZ,EAAwB;AACtB;AACD;;AAED,SAAOA,QAAQ,CAACQ,QAAhB;AACD;;AAED,SAASqC,kCAAT,CAA4CrH,MAA5C,EAAoDsH,WAApD,EAAiExd,KAAjE,EAAwE;AACtE,MAAI4b,SAAJ;AACA,MAAI6B,UAAU,GAAGzd,KAAK,CAACiK,kBAAN,CAAyBuT,WAAzB,CAAjB,CAFsE,CAItE;;AACA,MAAI,CAAChiB,OAAO,CAACiiB,UAAD,CAAZ,EAA0B;AACxB,WAAOvH,MAAP;AACD;;AAED,MAAI2F,WAAJ;;AACA,OAAKA,WAAL,IAAoB4B,UAApB,EAAgC;AAC9B,QAAIA,UAAU,CAAClK,cAAX,CAA0BsI,WAA1B,CAAJ,EAA4C;AAC1CD,MAAAA,SAAS,GAAG6B,UAAU,CAAC5B,WAAD,CAAtB;;AACA,UAAIC,sBAAsB,CAAC9b,KAAD,EAAQ4b,SAAR,CAAtB,KAA6C4B,WAAjD,EAA8D;AAC5D;AACD;AACF;AACF,GAjBqE,CAmBtE;;;AACAxd,EAAAA,KAAK,CAACiK,kBAAN,CAAyBuT,WAAzB,IAAwCjc,SAAxC;AAEA,MAAIgR,MAAJ;;AACA,MAAIvS,KAAK,CAACmO,cAAN,CAAqBuN,0BAAzB,EAAqD;AACnDnJ,IAAAA,MAAM,GAAGnT,YAAY,CAACme,kCAAb,CACPvd,KAAK,CAACM,IADC,EAEPsb,SAFO,EAGP1F,MAHO,CAAT;AAKAlW,IAAAA,KAAK,CAACgK,kBAAN,CAAyBwT,WAAzB,IAAwCjL,MAAM,CAACmL,QAA/C;AACD,GAPD,MAOO;AACL,QAAIC,WAAW,GAAG3d,KAAK,CAAC+K,YAAN,CAAmB8Q,WAAnB,CAAlB;;AACA,QAAIrgB,OAAO,CAACmiB,WAAD,CAAX,EAA0B;AACxBpL,MAAAA,MAAM,GAAGnT,YAAY,CAACwe,uCAAb,CACP5d,KAAK,CAACM,IADC,EAEPsb,SAFO,EAGP1F,MAHO,EAIPyH,WAAW,CAACE,UAJL,CAAT;AAMD,KAPD,MAOO;AACL,aAAO3H,MAAP;AACD;AACF;;AAED,SAAO3D,MAAM,CAAC2D,MAAd;AACD;;AAED,SAAS4H,oBAAT,CAA8B5H,MAA9B,EAAsC;AACpCA,EAAAA,MAAM,GAAG7Y,YAAY,CAAC0gB,WAAb,CAAyB7H,MAAzB,EAAiC,iBAAjC,CAAT;AACAA,EAAAA,MAAM,IACJ,gCACA,mCADA,GAEA,gBAFA,GAGA,MAHA,GAIA,2BAJA,GAKA,mFALA,GAMA,iDANA,GAOA,uEAPA,GAQA,wCARA,GASA,MAVF;AAYA,SAAOA,MAAP;AACD;;AAED,SAAS8H,YAAT,CAAsB9H,MAAtB,EAA8BsH,WAA9B,EAA2CS,QAA3C,EAAqD;AACnD,MAAIziB,OAAO,CAACyiB,QAAD,CAAX,EAAuB;AACrB/H,IAAAA,MAAM,GAAG+H,QAAQ,CAAC/H,MAAD,EAASsH,WAAT,CAAjB;AACD;;AACD,SAAOtH,MAAP;AACD;;AAED,IAAIgI,gBAAgB,GAAG,YAAY;AACjC,OAAKC,eAAL,GAAuB5c,SAAvB;AACA,OAAKvB,KAAL,GAAauB,SAAb;AACA,OAAKmO,OAAL,GAAenO,SAAf;AACD,CAJD;;AAMA2c,gBAAgB,CAACtd,SAAjB,CAA2BC,GAA3B,GAAiC,UAAUsd,eAAV,EAA2Bne,KAA3B,EAAkC0P,OAAlC,EAA2C;AAC1E,OAAKyO,eAAL,GAAuBA,eAAvB;AACA,OAAKne,KAAL,GAAaA,KAAb;AACA,OAAK0P,OAAL,GAAeA,OAAf;AACD,CAJD;;AAMAwO,gBAAgB,CAACtd,SAAjB,CAA2Bqb,OAA3B,GAAqC,YAAY;AAC/CmC,EAAAA,aAAa,CAAC,KAAKD,eAAN,EAAuB,KAAKne,KAA5B,EAAmC,KAAK0P,OAAxC,CAAb;AACD,CAFD,C,CAIA;AAEA;AACA;;;AACA,SAAS0O,aAAT,CAAuBD,eAAvB,EAAwCne,KAAxC,EAA+C0P,OAA/C,EAAwD;AACtD,MAAIkG,SAAS,GAAGuI,eAAe,CAACvI,SAAhC;AACA,MAAID,WAAW,GAAGwI,eAAe,CAACxI,WAAlC;AACA,MAAIE,OAAO,GAAG7V,KAAK,CAACsL,eAAN,CAAsBsK,SAAtB,CAAd;AACA,MAAIG,OAAO,GAAG/V,KAAK,CAACkK,kBAAN,CAAyBI,aAAvC;AAEA,MAAI+T,EAAE,GAAGtI,OAAO,CAACF,OAAO,CAACyI,YAAT,CAAhB;AACA,MAAIC,EAAE,GAAGxI,OAAO,CAACF,OAAO,CAAC2I,cAAT,CAAhB;AAEA,MAAIC,sBAAsB,GAAGze,KAAK,CAACuL,uBAAnC;;AAEA,MACEvL,KAAK,CAACmO,cAAN,CAAqBuN,0BAArB,IACA1b,KAAK,CAAC6K,mBAFR,EAGE;AACA,QAAI6T,WAAW,GAAGD,sBAAsB,CAAC7I,SAAD,CAAxC;;AACA,QAAI,CAACpa,OAAO,CAACkjB,WAAD,CAAZ,EAA2B;AACzBA,MAAAA,WAAW,GAAGnB,kCAAkC,CAACc,EAAD,EAAKzI,SAAL,EAAgB5V,KAAhB,CAAhD;AACAye,MAAAA,sBAAsB,CAAC7I,SAAD,CAAtB,GAAoC8I,WAApC;AACD;;AACDL,IAAAA,EAAE,GAAGK,WAAL;AACD;;AAED,MAAIC,MAAM,GAAGX,YAAY,CAACK,EAAD,EAAKzI,SAAL,EAAgB5V,KAAK,CAAC6G,mBAAtB,CAAzB;AACA,MAAI+X,MAAM,GAAGZ,YAAY,CAACO,EAAD,EAAK3I,SAAL,EAAgB5V,KAAK,CAAC+G,qBAAtB,CAAzB;;AAEA,MAAI,CAACvL,OAAO,CAACwE,KAAK,CAACiH,iBAAP,CAAZ,EAAuC;AACrC2X,IAAAA,MAAM,GAAG,kCAAkCA,MAA3C;AACD;;AAED,MAAIC,MAAM,GACR7e,KAAK,CAACgM,yBAAN,CAAgCkD,CAAhC,GAAoC,GAApC,IACAlP,KAAK,CAACgM,yBAAN,CAAgCoD,CAAhC,GAAoC,GAFtC;;AAGA,MAAIyP,MAAJ,EAAY;AACVD,IAAAA,MAAM,GAAG,kCAAkCA,MAA3C;AACD;;AAED,MAAIpjB,OAAO,CAACwE,KAAK,CAACkM,WAAP,CAAX,EAAgC;AAC9B0S,IAAAA,MAAM,GAAG,wCAAwCA,MAAjD;AACD;;AAED,MAAI5e,KAAK,CAAC8L,cAAN,KAAyB,KAAzB,IAAkC9L,KAAK,CAAC+L,yBAA5C,EAAuE;AACrE6S,IAAAA,MAAM,GAAGvhB,YAAY,CAAC0gB,WAAb,CAAyBa,MAAzB,EAAiC,0BAAjC,CAAT;AACAA,IAAAA,MAAM,GACJA,MAAM,GACN,IADA,GAEA,kBAFA,GAGA,oCAHA,GAIA,uDAJA,GAKA,MANF;AAOD;;AAED,MAAIvf,0BAA0B,CAACyf,WAA3B,CAAuCpP,OAAvC,CAAJ,EAAqD;AACnD,QAAIqP,MAAM,GACRvjB,OAAO,CAACwE,KAAK,CAACsM,8BAAP,CAAP,IACAtM,KAAK,CAAC4M,6BAFR;;AAGA,QAAIoS,MAAM,GACPxjB,OAAO,CAACwE,KAAK,CAAC2M,4BAAP,CAAP,IACC3M,KAAK,CAAC2M,4BAAN,CAAmCpM,KADrC,IAEAP,KAAK,CAAC6M,uBAHR;;AAIA,QAAIoS,SAAS,GAAGF,MAAM,IAAIC,MAAV,IAAoBH,MAApC;;AACA,QAAII,SAAJ,EAAe;AACbL,MAAAA,MAAM,GAAG,kDAAkDA,MAA3D;AACD;;AAED,QAAIpjB,OAAO,CAACwE,KAAK,CAACsM,8BAAP,CAAX,EAAmD;AACjDsS,MAAAA,MAAM,GACJ,2BACA,uCADA,GAEA,wDAFA,GAGAA,MAJF;AAKD,KAND,MAMO,IAAI5e,KAAK,CAAC4M,6BAAV,EAAyC;AAC9CgS,MAAAA,MAAM,GAAG,2BAA2BA,MAApC;AACD;;AAED,QACEpjB,OAAO,CAACwE,KAAK,CAAC2M,4BAAP,CAAP,IACA3M,KAAK,CAAC2M,4BAAN,CAAmCpM,KAFrC,EAGE;AACAqe,MAAAA,MAAM,GACJ,4BACA,gCADA,GAEA,wCAFA,GAGA,uCAHA,GAIA,uCAJA,GAKAA,MANF;AAOD,KAXD,MAWO,IAAI5e,KAAK,CAAC6M,uBAAV,EAAmC;AACxC+R,MAAAA,MAAM,GAAG,4BAA4BA,MAArC;AACD;AACF;;AAED,MAAIpjB,OAAO,CAACwE,KAAK,CAACoM,kBAAP,CAAX,EAAuC;AACrCwS,IAAAA,MAAM,GACJ,iCACA,yCADA,GAEAA,MAHF;AAID;;AAEDM,EAAAA,0BAA0B,CACxBtJ,SADwB,EAExBD,WAFwB,EAGxBiJ,MAHwB,EAIxBD,MAJwB,EAKxB3e,KALwB,EAMxB0P,OANwB,CAA1B;AAQD;;AAED,SAASyP,eAAT,CAAyBhB,eAAzB,EAA0Cne,KAA1C,EAAiD0P,OAAjD,EAA0D;AACxD,MAAIkG,SAAS,GAAGuI,eAAe,CAACvI,SAAhC;AACA,MAAID,WAAW,GAAGwI,eAAe,CAACxI,WAAlC;AACA,MAAIE,OAAO,GAAG7V,KAAK,CAACsL,eAAN,CAAsBsK,SAAtB,CAAd;AACA,MAAIG,OAAO,GAAG/V,KAAK,CAACkK,kBAAN,CAAyBI,aAAvC;AAEA,MAAImU,sBAAsB,GAAGze,KAAK,CAACuL,uBAAnC;AAEA,MAAI6T,uBAAuB,GAAGpf,KAAK,CAAC+F,cAApC;AACA,MAAIsZ,oBAAoB,GAAGxP,iBAAiB,CAAC7P,KAAD,CAA5C;AAEA,MAAIqe,EAAE,GAAGtI,OAAO,CAACF,OAAO,CAACyI,YAAT,CAAhB;AACA,MAAIC,EAAE,GAAGxI,OAAO,CAACF,OAAO,CAAC2I,cAAT,CAAhB;;AAEA,MACExe,KAAK,CAACmO,cAAN,CAAqBuN,0BAArB,IACA1b,KAAK,CAAC6K,mBAFR,EAGE;AACAwT,IAAAA,EAAE,GAAGI,sBAAsB,CAAC7I,SAAD,CAA3B;AACD;;AAED,MAAI0J,OAAO,GAAGf,EAAd;;AACA,MAAI3O,qBAAqB,CAAC5P,KAAD,CAAzB,EAAkC;AAChCsf,IAAAA,OAAO,GAAG5d,KAAK,CAAC6d,qBAAN,CAA4BD,OAA5B,CAAV;AACD;;AACD,MAAID,oBAAJ,EAA0B;AACxBC,IAAAA,OAAO,GAAGE,6BAA6B,CACrCF,OADqC,EAErCF,uBAFqC,EAGrC1P,OAHqC,CAAvC;AAKD;;AAED,MAAIiP,MAAM,GAAGX,YAAY,CAACK,EAAD,EAAKzI,SAAL,EAAgB5V,KAAK,CAAC6G,mBAAtB,CAAzB;AACA,MAAI+X,MAAM,GAAGZ,YAAY,CAACsB,OAAD,EAAU1J,SAAV,EAAqB5V,KAAK,CAAC+G,qBAA3B,CAAzB;;AAEA,MAAI,CAACvL,OAAO,CAACwE,KAAK,CAACiH,iBAAP,CAAZ,EAAuC;AACrC2X,IAAAA,MAAM,GAAG,kCAAkCA,MAA3C;AACD;;AAED,MAAIC,MAAM,GACR7e,KAAK,CAACgM,yBAAN,CAAgCkD,CAAhC,GAAoC,GAApC,IACAlP,KAAK,CAACgM,yBAAN,CAAgCoD,CAAhC,GAAoC,GAFtC;;AAGA,MAAIyP,MAAJ,EAAY;AACVD,IAAAA,MAAM,GAAG,kCAAkCA,MAA3C;AACD;;AAED,MAAIpjB,OAAO,CAACwE,KAAK,CAACkM,WAAP,CAAX,EAAgC;AAC9B0S,IAAAA,MAAM,GAAG,wCAAwCA,MAAjD;AACD;;AAED,MAAI5e,KAAK,CAAC8L,cAAN,KAAyB,KAAzB,IAAkC9L,KAAK,CAAC+L,yBAA5C,EAAuE;AACrE6S,IAAAA,MAAM,GAAGvhB,YAAY,CAAC0gB,WAAb,CAAyBa,MAAzB,EAAiC,0BAAjC,CAAT;AACAA,IAAAA,MAAM,GACJA,MAAM,GACN,IADA,GAEA,kBAFA,GAGA,oCAHA,GAIA,uDAJA,GAKA,MANF;AAOD;;AAED,MAAIvf,0BAA0B,CAACyf,WAA3B,CAAuCpP,OAAvC,CAAJ,EAAqD;AACnD,QAAIqP,MAAM,GACRvjB,OAAO,CAACwE,KAAK,CAACsM,8BAAP,CAAP,IACAtM,KAAK,CAAC4M,6BAFR;;AAGA,QAAIoS,MAAM,GACPxjB,OAAO,CAACwE,KAAK,CAAC2M,4BAAP,CAAP,IACC3M,KAAK,CAAC2M,4BAAN,CAAmCpM,KADrC,IAEAP,KAAK,CAAC6M,uBAHR;;AAIA,QAAIoS,SAAS,GAAGF,MAAM,IAAIC,MAAV,IAAoBH,MAApC;;AACA,QAAII,SAAJ,EAAe;AACbL,MAAAA,MAAM,GAAG,kDAAkDA,MAA3D;AACD;;AAED,QAAIpjB,OAAO,CAACwE,KAAK,CAACsM,8BAAP,CAAX,EAAmD;AACjDsS,MAAAA,MAAM,GACJ,2BACA,uCADA,GAEA,wDAFA,GAGAA,MAJF;AAKD,KAND,MAMO,IAAI5e,KAAK,CAAC4M,6BAAV,EAAyC;AAC9CgS,MAAAA,MAAM,GAAG,2BAA2BA,MAApC;AACD;;AAED,QACEpjB,OAAO,CAACwE,KAAK,CAAC2M,4BAAP,CAAP,IACA3M,KAAK,CAAC2M,4BAAN,CAAmCpM,KAFrC,EAGE;AACAqe,MAAAA,MAAM,GACJ,4BACA,gCADA,GAEA,wCAFA,GAGA,uCAHA,GAIA,uCAJA,GAKAA,MANF;AAOD,KAXD,MAWO,IAAI5e,KAAK,CAAC6M,uBAAV,EAAmC;AACxC+R,MAAAA,MAAM,GAAG,4BAA4BA,MAArC;AACD;AACF;;AAED,MAAIpjB,OAAO,CAACwE,KAAK,CAACoM,kBAAP,CAAX,EAAuC;AACrCwS,IAAAA,MAAM,GACJ,iCACA,yCADA,GAEAA,MAHF;AAID;;AAEDM,EAAAA,0BAA0B,CACxBtJ,SADwB,EAExBD,WAFwB,EAGxBiJ,MAHwB,EAIxBD,MAJwB,EAKxB3e,KALwB,EAMxB0P,OANwB,CAA1B;AAQD;;AAED,SAASwP,0BAAT,CACEtJ,SADF,EAEED,WAFF,EAGEiJ,MAHF,EAIED,MAJF,EAKE3e,KALF,EAME0P,OANF,EAOE;AACA,MAAIgG,SAAS,GAAG1V,KAAK,CAACqL,iBAAN,CAAwBsK,WAAxB,CAAhB;AACA,MAAI8J,kBAAkB,GAAGrgB,YAAY,CAACsgB,wBAAb,CACvBhK,SADuB,EAEvB1V,KAAK,CAAC2G,qBAFiB,CAAzB;AAKA3G,EAAAA,KAAK,CAACkK,kBAAN,CAAyBG,QAAzB,CAAkCuL,SAAlC,IAA+CxY,aAAa,CAACuiB,SAAd,CAAwB;AACrEjQ,IAAAA,OAAO,EAAEA,OAD4D;AAErEkQ,IAAAA,kBAAkB,EAAEjB,MAFiD;AAGrEkB,IAAAA,oBAAoB,EAAEjB,MAH+C;AAIrEa,IAAAA,kBAAkB,EAAEA;AAJiD,GAAxB,CAA/C;AAMD;;AAED,IAAIK,uBAAuB,GAAG,IAAI5B,gBAAJ,EAA9B;;AAEA,SAAS6B,cAAT,CAAwB/f,KAAxB,EAA+Bkd,UAA/B,EAA2C;AACzC,MAAIjJ,aAAa,GAAGjU,KAAK,CAAC2I,cAA1B;AACA,MAAIgO,gBAAgB,GAAG1C,aAAa,CAAC0C,gBAArC;;AAEA,MAAI1C,aAAa,CAAC+B,kBAAd,KAAqC,CAAzC,EAA4C;AAC1C;AACD,GANwC,CAQzC;AACA;;;AACA,MAAI/B,aAAa,CAACM,kBAAd,KAAqC,CAAzC,EAA4C;AAC1C;AACD;;AAED,MAAI7E,OAAO,GAAGwN,UAAU,CAACxN,OAAzB;;AAEA,MAAI1P,KAAK,CAACmF,YAAV,EAAwB;AACtB,WAAOwR,gBAAgB,CAACxV,MAAjB,GAA0B,CAAjC,EAAoC;AAClC2e,MAAAA,uBAAuB,CAACjf,GAAxB,CAA4B8V,gBAAgB,CAACwG,IAAjB,EAA5B,EAAqDnd,KAArD,EAA4D0P,OAA5D;;AACA,UACE,CAACwN,UAAU,CAACE,YAAX,CAAwBnB,OAAxB,CACC6D,uBADD,EAEClhB,OAAO,CAACohB,OAFT,CADH,EAKE;AACA;AACD;;AACDrJ,MAAAA,gBAAgB,CAAC2G,OAAjB;AACD;AACF,GAbD,MAaO;AACL;AACA,WAAO3G,gBAAgB,CAACxV,MAAjB,GAA0B,CAAjC,EAAoC;AAClCid,MAAAA,aAAa,CAACzH,gBAAgB,CAAC2G,OAAjB,EAAD,EAA6Btd,KAA7B,EAAoC0P,OAApC,CAAb;AACD;AACF;AACF;;AAED,SAASuQ,+BAAT,CAAyChM,aAAzC,EAAwDiM,WAAxD,EAAqE;AACnE,SAAO,UAAU5I,KAAV,EAAiB;AACtBrD,IAAAA,aAAa,CAACsD,gBAAd,CAA+BzC,OAA/B,CAAuC;AACrCpR,MAAAA,EAAE,EAAEwc,WAAW,CAACxc,EADqB;AAErC4T,MAAAA,KAAK,EAAEA,KAF8B;AAGrC3C,MAAAA,UAAU,EAAEpT;AAHyB,KAAvC;AAMA,MAAE0S,aAAa,CAACkM,wBAAhB;AACD,GARD;AASD;;AAED,SAASC,2BAAT,CAAqCpgB,KAArC,EAA4C;AAC1C,MAAIiU,aAAa,GAAGjU,KAAK,CAAC2I,cAA1B;;AAEA,MAAIsL,aAAa,CAACM,kBAAd,KAAqC,CAAzC,EAA4C;AAC1C;AACD;;AAED,SAAON,aAAa,CAAC0E,8BAAd,CAA6CxX,MAA7C,GAAsD,CAA7D,EAAgE;AAC9D,QAAI+e,WAAW,GAAGjM,aAAa,CAAC0E,8BAAd,CAA6C2E,OAA7C,EAAlB;AAEA,QAAIhd,IAAI,GAAGN,KAAK,CAACM,IAAjB;AACA,QAAIqU,UAAU,GAAGrU,IAAI,CAACmU,WAAL,CAAiByL,WAAW,CAACvL,UAA7B,CAAjB;AACA,QAAIsD,OAAO,GAAG3X,IAAI,CAACkK,QAAL,CAAc0V,WAAW,CAACxc,EAA1B,EAA8B2Q,MAA5C;AAEA,QAAIgM,OAAO,GAAGjhB,YAAY,CAAC4R,qBAAb,CACZhR,KADY,EAEZ,OAFY,EAGZ,SAASkgB,WAAW,CAACxc,EAArB,GAA0B,gBAA1B,GAA6Cwc,WAAW,CAACvL,UAH7C,CAAd;;AAMA,QAAIuL,WAAW,CAAC9H,QAAZ,KAAyB,WAA7B,EAA0C;AACxChc,MAAAA,OAAO,CAAC6X,aAAa,CAACqI,SAAd,CAAwB3H,UAAxB,CAAD,CAAP,CACGlE,IADH,CACQ2G,SAAS,CAACpX,KAAD,EAAQkgB,WAAW,CAACxc,EAApB,EAAwBuU,OAAxB,CADjB,EAEGlH,SAFH,CAEasP,OAFb;AAGA,QAAErgB,KAAK,CAAC2I,cAAN,CAAqBoF,mBAAvB;AACD,KALD,MAKO,IAAImS,WAAW,CAAC9H,QAAZ,KAAyB,WAA7B,EAA0C;AAC/Clc,MAAAA,OAAO,CAAC+X,aAAa,CAACqI,SAAd,CAAwB3H,UAAxB,CAAD,CAAP,CACGlE,IADH,CACQ2G,SAAS,CAACpX,KAAD,EAAQkgB,WAAW,CAACxc,EAApB,EAAwBuU,OAAxB,CADjB,EAEGlH,SAFH,CAEasP,OAFb;AAGA,QAAErgB,KAAK,CAAC2I,cAAN,CAAqBoF,mBAAvB;AACD,KALM,MAKA;AACL,UAAIuS,MAAM,GAAGL,+BAA+B,CAAChM,aAAD,EAAgBiM,WAAhB,CAA5C;AACA/jB,MAAAA,uBAAuB,CAAC;AACtB6T,QAAAA,UAAU,EAAEiE,aAAa,CAACqI,SAAd,CAAwB3H,UAAxB,CADU;AAEtB4L,QAAAA,MAAM,EAAEL,WAAW,CAAC9H,QAFE;AAGtBoI,QAAAA,KAAK,EAAE;AAHe,OAAD,CAAvB,CAKG/P,IALH,CAKQ6P,MALR,EAMGvP,SANH,CAMasP,OANb;AAOA,QAAEpM,aAAa,CAACkM,wBAAhB;AACD;AACF;AACF;;AAED,SAASM,cAAT,CAAwBzgB,KAAxB,EAA+B;AAC7B,MAAIiU,aAAa,GAAGjU,KAAK,CAAC2I,cAA1B;;AACA,MAAIsL,aAAa,CAACwM,cAAlB,EAAkC;AAChCxM,IAAAA,aAAa,CAACwM,cAAd,GAA+B,KAA/B;AAEA,QAAIC,gBAAgB,GAAG1gB,KAAK,CAACkK,kBAAN,CAAyBO,QAAhD;AACA7M,IAAAA,OAAO,CAAC+iB,OAAR,CAAgB3gB,KAAK,CAACM,IAAtB,EAA4B,UAAUqgB,OAAV,EAAmBC,SAAnB,EAA8B;AACxDF,MAAAA,gBAAgB,CAACE,SAAD,CAAhB,GAA8B,IAAIzjB,OAAJ,CAAY;AACxC0jB,QAAAA,KAAK,EAAEF,OAAO,CAACE,KADyB;AAExCC,QAAAA,KAAK,EAAEH,OAAO,CAACG,KAFyB;AAGxCC,QAAAA,kBAAkB,EAAEJ,OAAO,CAACK,SAHY;AAIxCC,QAAAA,mBAAmB,EAAEN,OAAO,CAACO;AAJW,OAAZ,CAA9B;AAMD,KAPD;AAQD;AACF,C,CAED;;;AAEA,IAAIC,gBAAgB,GAAG,YAAY;AACjC,OAAKjB,WAAL,GAAmB3e,SAAnB;AACA,OAAKvB,KAAL,GAAauB,SAAb;AACA,OAAKmO,OAAL,GAAenO,SAAf;AACD,CAJD;;AAMA4f,gBAAgB,CAACvgB,SAAjB,CAA2BC,GAA3B,GAAiC,UAAUqf,WAAV,EAAuBlgB,KAAvB,EAA8B0P,OAA9B,EAAuC;AACtE,OAAKwQ,WAAL,GAAmBA,WAAnB;AACA,OAAKlgB,KAAL,GAAaA,KAAb;AACA,OAAK0P,OAAL,GAAeA,OAAf;AACD,CAJD;;AAMAyR,gBAAgB,CAACvgB,SAAjB,CAA2Bqb,OAA3B,GAAqC,YAAY;AAC/CmF,EAAAA,aAAa,CAAC,KAAKlB,WAAN,EAAmB,KAAKlgB,KAAxB,EAA+B,KAAK0P,OAApC,CAAb;AACD,CAFD,C,CAIA;;;AAEA,SAAS0R,aAAT,CAAuBlB,WAAvB,EAAoClgB,KAApC,EAA2C0P,OAA3C,EAAoD;AAClD,MAAIlF,QAAQ,GAAGxK,KAAK,CAACM,IAAN,CAAWkK,QAA1B;AACA,MAAIwN,OAAO,GAAGxN,QAAQ,CAAC0V,WAAW,CAACxc,EAAb,CAAtB;AAEA,MAAIgd,gBAAgB,GAAG1gB,KAAK,CAACkK,kBAAN,CAAyBO,QAAhD;AACA,MAAIkW,OAAO,GAAGD,gBAAgB,CAAC1I,OAAO,CAAC2I,OAAT,CAA9B;;AACA,MAAI,CAACnlB,OAAO,CAACmlB,OAAD,CAAZ,EAAuB;AACrBA,IAAAA,OAAO,GAAG,IAAIxjB,OAAJ,CAAY;AACpB0jB,MAAAA,KAAK,EAAErjB,WAAW,CAAC6jB,MADC;AAEpBP,MAAAA,KAAK,EAAEtjB,WAAW,CAAC6jB;AAFC,KAAZ,CAAV;AAID;;AAED,MAAIC,oBAAoB,GAAG,KAA3B;AACA,MAAIC,SAAS,GAAGvhB,KAAK,CAACM,IAAN,CAAWihB,SAA3B;AACA,MAAIC,eAAe,GAAGD,SAAS,CAACpgB,MAAhC;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGogB,eAApB,EAAqC,EAAEpgB,CAAvC,EAA0C;AACxC,QAAIsZ,QAAQ,GAAG6G,SAAS,CAACngB,CAAD,CAAxB;;AACA,QACE5F,OAAO,CAACkf,QAAQ,CAAClF,UAAV,CAAP,IACAha,OAAO,CAACkf,QAAQ,CAAClF,UAAT,CAAoBC,oBAArB,CAFT,EAGE;AACA,UAAIoF,MAAM,GAAGH,QAAQ,CAAClF,UAAT,CAAoBC,oBAApB,CAAyCoF,MAAtD;;AACA,WAAK,IAAI4G,SAAT,IAAsB5G,MAAtB,EAA8B;AAC5B,YACEA,MAAM,CAACtH,cAAP,CAAsBkO,SAAtB,KACAA,SAAS,CAACC,OAAV,CAAkB,SAAlB,MAAiC,CAAC,CAFpC,EAGE;AACA,cAAI5gB,KAAK,GAAG+Z,MAAM,CAAC4G,SAAD,CAAlB;;AACA,cACE3gB,KAAK,CAAC6gB,KAAN,KAAgBzB,WAAW,CAACxc,EAA5B,IACAlI,OAAO,CAACsF,KAAK,CAAC0U,UAAP,CADP,IAEAha,OAAO,CAACsF,KAAK,CAAC0U,UAAN,CAAiBoM,qBAAlB,CAHT,EAIE;AACAN,YAAAA,oBAAoB,GAAG,IAAvB;AACA;AACD;AACF;AACF;AACF;;AACD,QAAIA,oBAAJ,EAA0B;AACxB;AACD;AACF;;AAED,MAAIT,KAAK,GAAGF,OAAO,CAACE,KAApB;AACA,MAAIC,KAAK,GAAGH,OAAO,CAACG,KAApB;AACA,MAAIE,SAAS,GAAGL,OAAO,CAACI,kBAAxB;;AAEA,MACEO,oBAAoB,IACpBN,SAAS,KAAKzjB,yBAAyB,CAACskB,MADxC,IAEAb,SAAS,KAAKzjB,yBAAyB,CAACukB,OAH1C,EAIE;AACA,QACEd,SAAS,KAAKzjB,yBAAyB,CAACwkB,sBAAxC,IACAf,SAAS,KAAKzjB,yBAAyB,CAACykB,qBAF1C,EAGE;AACAhB,MAAAA,SAAS,GAAGzjB,yBAAyB,CAACukB,OAAtC;AACD,KALD,MAKO;AACLd,MAAAA,SAAS,GAAGzjB,yBAAyB,CAACskB,MAAtC;AACD;;AAEDlB,IAAAA,OAAO,GAAG,IAAIxjB,OAAJ,CAAY;AACpB0jB,MAAAA,KAAK,EAAEF,OAAO,CAACE,KADK;AAEpBC,MAAAA,KAAK,EAAEH,OAAO,CAACG,KAFK;AAGpBmB,MAAAA,yBAAyB,EAAEjB,SAHP;AAIpBkB,MAAAA,0BAA0B,EAAEvB,OAAO,CAACM;AAJhB,KAAZ,CAAV;AAMD;;AAED,MAAIvJ,cAAc,GAAGwI,WAAW,CAACxI,cAAjC;AAEA,MAAIyK,MAAM,GACR,EACE3mB,OAAO,CAACkc,cAAD,CAAP,IAA2Blb,WAAW,CAAC4lB,kBAAZ,CAA+B1K,cAA/B,CAD7B,MAGCsJ,SAAS,KAAKzjB,yBAAyB,CAACwkB,sBAAxC,IACCf,SAAS,KAAKzjB,yBAAyB,CAACykB,qBADzC,IAEChB,SAAS,KAAKzjB,yBAAyB,CAAC8kB,qBAFzC,IAGCrB,SAAS,KAAKzjB,yBAAyB,CAAC+kB,oBAN1C,CADF;AAQA,MAAIC,YAAY,GACdJ,MAAM,IACNtB,KAAK,KAAKrjB,WAAW,CAAC6jB,MADtB,IAEAR,KAAK,KAAKrjB,WAAW,CAACglB,eAFtB,IAGA1B,KAAK,KAAKtjB,WAAW,CAAC6jB,MAHtB,IAIAP,KAAK,KAAKtjB,WAAW,CAACglB,eALxB;AAOA,MAAIC,EAAJ;AACA,MAAIpO,MAAM,GAAG6L,WAAW,CAAC5I,KAAzB;;AAEA,MAAI9b,OAAO,CAACkc,cAAD,CAAX,EAA6B;AAC3B+K,IAAAA,EAAE,GAAG,IAAInlB,OAAJ,CAAY;AACfoS,MAAAA,OAAO,EAAEA,OADM;AAEf2E,MAAAA,MAAM,EAAE;AACNqO,QAAAA,eAAe,EAAExC,WAAW,CAACvL;AADvB,OAFO;AAKf6C,MAAAA,KAAK,EAAE0I,WAAW,CAAC1I,KALJ;AAMfC,MAAAA,MAAM,EAAEyI,WAAW,CAACzI,MANL;AAOfkL,MAAAA,WAAW,EAAEjL,cAPE;AAQfiJ,MAAAA,OAAO,EAAEA;AARM,KAAZ,CAAL;AAUD,GAXD,MAWO,IAAInlB,OAAO,CAAC6Y,MAAD,CAAX,EAAqB;AAC1B,QAAIuO,IAAI,GACN,CAACvmB,UAAU,CAACwmB,YAAX,CAAwBxO,MAAM,CAACmD,KAA/B,CAAD,IACA,CAACnb,UAAU,CAACwmB,YAAX,CAAwBxO,MAAM,CAACoD,MAA/B,CAFH;;AAIA,QAAI8K,YAAY,IAAIK,IAApB,EAA0B;AACxB;AACA,UAAIE,MAAM,GAAGC,QAAQ,CAACC,aAAT,CAAuB,QAAvB,CAAb;AACAF,MAAAA,MAAM,CAACtL,KAAP,GAAenb,UAAU,CAAC4mB,cAAX,CAA0B5O,MAAM,CAACmD,KAAjC,CAAf;AACAsL,MAAAA,MAAM,CAACrL,MAAP,GAAgBpb,UAAU,CAAC4mB,cAAX,CAA0B5O,MAAM,CAACoD,MAAjC,CAAhB;AACA,UAAIyL,aAAa,GAAGJ,MAAM,CAACK,UAAP,CAAkB,IAAlB,CAApB;AACAD,MAAAA,aAAa,CAACE,SAAd,CACE/O,MADF,EAEE,CAFF,EAGE,CAHF,EAIEA,MAAM,CAACmD,KAJT,EAKEnD,MAAM,CAACoD,MALT,EAME,CANF,EAOE,CAPF,EAQEqL,MAAM,CAACtL,KART,EASEsL,MAAM,CAACrL,MATT;AAWApD,MAAAA,MAAM,GAAGyO,MAAT;AACD;;AAEDL,IAAAA,EAAE,GAAG,IAAInlB,OAAJ,CAAY;AACfoS,MAAAA,OAAO,EAAEA,OADM;AAEf2E,MAAAA,MAAM,EAAEA,MAFO;AAGfsO,MAAAA,WAAW,EAAE3K,OAAO,CAACN,cAHN;AAIf2L,MAAAA,aAAa,EAAErL,OAAO,CAACtF,IAJR;AAKfiO,MAAAA,OAAO,EAAEA,OALM;AAMfH,MAAAA,KAAK,EAAE;AANQ,KAAZ,CAAL,CAzB0B,CAiC1B;;AACA,QAAI2B,MAAJ,EAAY;AACVM,MAAAA,EAAE,CAACa,cAAH;AACD;AACF;;AACD,MAAI9nB,OAAO,CAACinB,EAAD,CAAX,EAAiB;AACfziB,IAAAA,KAAK,CAACkK,kBAAN,CAAyBM,QAAzB,CAAkC0V,WAAW,CAACxc,EAA9C,IAAoD+e,EAApD;AACAziB,IAAAA,KAAK,CAACmL,mBAAN,IAA6BsX,EAAE,CAAC/F,WAAhC;AACD;AACF;;AAED,IAAI6G,uBAAuB,GAAG,IAAIpC,gBAAJ,EAA9B;;AAEA,SAASqC,cAAT,CAAwBxjB,KAAxB,EAA+Bkd,UAA/B,EAA2C;AACzC,MAAIxN,OAAO,GAAGwN,UAAU,CAACxN,OAAzB;AACA,MAAI6H,gBAAgB,GAAGvX,KAAK,CAAC2I,cAAN,CAAqB4O,gBAA5C;;AAEA,MAAIvX,KAAK,CAACmF,YAAV,EAAwB;AACtB,WAAOoS,gBAAgB,CAACpW,MAAjB,GAA0B,CAAjC,EAAoC;AAClCoiB,MAAAA,uBAAuB,CAAC1iB,GAAxB,CAA4B0W,gBAAgB,CAAC4F,IAAjB,EAA5B,EAAqDnd,KAArD,EAA4D0P,OAA5D;;AACA,UACE,CAACwN,UAAU,CAACE,YAAX,CAAwBnB,OAAxB,CACCsH,uBADD,EAEC3kB,OAAO,CAAC6kB,OAFT,CADH,EAKE;AACA;AACD;;AACDlM,MAAAA,gBAAgB,CAAC+F,OAAjB;AACD;AACF,GAbD,MAaO;AACL;AACA,WAAO/F,gBAAgB,CAACpW,MAAjB,GAA0B,CAAjC,EAAoC;AAClCigB,MAAAA,aAAa,CAAC7J,gBAAgB,CAAC+F,OAAjB,EAAD,EAA6Btd,KAA7B,EAAoC0P,OAApC,CAAb;AACD;AACF;AACF;;AAED,SAASgU,qBAAT,CAA+B1jB,KAA/B,EAAsC4b,SAAtC,EAAiD;AAC/C,MAAItB,UAAU,GAAGta,KAAK,CAACqL,iBAAvB,CAD+C,CAG/C;;AACA,MAAIoU,kBAAkB,GAAG,EAAzB;AAEA,MAAIkE,QAAJ;AACA,MAAIhC,KAAJ;AACA,MAAIjH,QAAQ,GAAG1a,KAAK,CAACiJ,QAAN,CAAeW,aAAf,CAA6BgS,SAAS,CAAClB,QAAvC,CAAf;;AACA,MAAI,CAAClf,OAAO,CAACkf,QAAD,CAAZ,EAAwB;AACtB,WAAO+E,kBAAP;AACD;;AAED,MAAI/J,SAAS,GAAG4E,UAAU,CAACI,QAAQ,CAACO,UAAV,CAA1B;;AACA,MAAI,CAACzf,OAAO,CAACka,SAAD,CAAZ,EAAyB;AACvB,WAAO+J,kBAAP;AACD;;AAED,MAAI5B,UAAU,GAAGnI,SAAS,CAACmI,UAA3B;AACA,MAAIhI,OAAO,GAAG7V,KAAK,CAACkK,kBAAN,CAAyBG,QAAzB,CAAkCqL,SAAS,CAACG,OAA5C,CAAd;AACA,MAAI+N,yBAAyB,GAAG/N,OAAO,CAACgO,mBAAxC;;AAEA,OAAKF,QAAL,IAAiBC,yBAAjB,EAA4C;AAC1C,QAAIA,yBAAyB,CAACrQ,cAA1B,CAAyCoQ,QAAzC,CAAJ,EAAwD;AACtD,UAAIG,SAAS,GAAGjG,UAAU,CAAC8F,QAAD,CAA1B;;AACA,UAAInoB,OAAO,CAACsoB,SAAD,CAAX,EAAwB;AACtBnC,QAAAA,KAAK,GAAGiC,yBAAyB,CAACD,QAAD,CAAjC;AACAlE,QAAAA,kBAAkB,CAACqE,SAAS,CAACC,QAAX,CAAlB,GAAyCpC,KAAzC;AACD;AACF;AACF,GA9B8C,CAgC/C;;;AACA,MAAI/a,oBAAoB,GAAG5G,KAAK,CAAC2G,qBAAjC;;AACA,MAAInL,OAAO,CAACoL,oBAAD,CAAX,EAAmC;AACjC,SAAK+c,QAAL,IAAiB/c,oBAAjB,EAAuC;AACrC,UAAIA,oBAAoB,CAAC2M,cAArB,CAAoCoQ,QAApC,CAAJ,EAAmD;AACjDhC,QAAAA,KAAK,GAAGiC,yBAAyB,CAACD,QAAD,CAAjC;AACAlE,QAAAA,kBAAkB,CAACkE,QAAD,CAAlB,GAA+BhC,KAA/B;AACD;AACF;AACF;;AAED,SAAOlC,kBAAP;AACD;;AAED,SAASuE,YAAT,CAAsBhkB,KAAtB,EAA6BikB,YAA7B,EAA2C;AACzC,MAAI3jB,IAAI,GAAGN,KAAK,CAACM,IAAjB;AACA,MAAI4jB,KAAK,GAAG5jB,IAAI,CAAC4jB,KAAjB;AACA,MAAI3a,KAAK,GAAGjJ,IAAI,CAACiJ,KAAjB;AACA,MAAI0P,YAAY,GAAGjZ,KAAK,CAACiJ,QAAN,CAAeM,KAAlC;AAEA,MAAI4P,eAAe,GAAGnZ,KAAK,CAAC2I,cAAN,CAAqBwQ,eAA3C;AACA,MAAIhY,MAAM,GAAGgY,eAAe,CAAChY,MAA7B;;AACA,OAAK,IAAIgjB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGhjB,MAApB,EAA4B,EAAEgjB,CAA9B,EAAiC;AAC/B,QAAIzgB,EAAE,GAAGyV,eAAe,CAACgL,CAAD,CAAxB;AACA,QAAIC,WAAW,GAAGnL,YAAY,CAACvV,EAAD,CAA9B;AACA,QAAI4N,IAAI,GAAG/H,KAAK,CAAC7F,EAAD,CAAhB;AAEA,QAAI2gB,WAAW,GAAGJ,YAAY,CAAC3S,IAAI,CAAC8I,IAAN,CAA9B;AACAgK,IAAAA,WAAW,CAACzK,mBAAZ,GAAkC0K,WAAW,CAAC1K,mBAA9C;AACAyK,IAAAA,WAAW,CAACxK,eAAZ,GAA8ByK,WAAW,CAACzK,eAA1C;AAEA,QAAI0K,UAAU,GAAGJ,KAAK,CAAC5S,IAAI,CAAC8I,IAAN,CAAL,CAAiBP,MAAlC;AACA,QAAI0K,YAAY,GAAGD,UAAU,CAACnjB,MAA9B;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmjB,YAApB,EAAkC,EAAEnjB,CAApC,EAAuC;AACrC,UAAIojB,MAAM,GAAGF,UAAU,CAACljB,CAAD,CAAvB;AACA,UAAIqjB,SAAS,GAAGxL,YAAY,CAACuL,MAAD,CAA5B;AACAJ,MAAAA,WAAW,CAACvK,MAAZ,CAAmBxJ,IAAnB,CAAwBoU,SAAxB;AACD;AACF;AACF;;AAED,SAASC,WAAT,CAAqB1kB,KAArB,EAA4B;AAC1B,MAAIiU,aAAa,GAAGjU,KAAK,CAAC2I,cAA1B;;AAEA,MAAIsL,aAAa,CAACM,kBAAd,KAAqC,CAAzC,EAA4C;AAC1C;AACD;;AAED,MAAI,CAACN,aAAa,CAACyQ,WAAnB,EAAgC;AAC9B;AACD;;AACDzQ,EAAAA,aAAa,CAACyQ,WAAd,GAA4B,KAA5B;AAEA,MAAIpkB,IAAI,GAAGN,KAAK,CAACM,IAAjB;AACA,MAAIqkB,SAAS,GAAGrkB,IAAI,CAACqkB,SAArB;AACA,MAAIV,YAAY,GAAG,EAAnB;AAEArmB,EAAAA,OAAO,CAACwc,IAAR,CAAa9Z,IAAb,EAAmB,UAAU8Z,IAAV,EAAgB1W,EAAhB,EAAoB;AACrC,QAAIuR,QAAQ,GAAG0P,SAAS,CAACvK,IAAI,CAACT,mBAAN,CAAxB;AAEA,QAAIC,eAAJ;;AACA,QAAI,CAACrd,OAAO,CAAC8S,MAAR,CAAe+K,IAAI,CAACR,eAApB,EAAqCrd,OAAO,CAAC0G,QAA7C,CAAL,EAA6D;AAC3D2W,MAAAA,eAAe,GAAGrd,OAAO,CAACrB,KAAR,CAAckf,IAAI,CAACR,eAAnB,CAAlB;AACD;;AAEDqK,IAAAA,YAAY,CAACvgB,EAAD,CAAZ,GAAmB;AACjBiW,MAAAA,mBAAmB,EAAE9a,mBAAmB,CAAC+lB,0BAApB,CACnB5kB,KADmB,EAEnBiV,QAFmB,CADJ;AAKjB2E,MAAAA,eAAe,EAAEA,eALA,CAKiB;;AALjB,KAAnB;AAOD,GAfD;AAiBAoK,EAAAA,YAAY,CAAChkB,KAAD,EAAQikB,YAAR,CAAZ;AACD;;AAED,SAASY,mBAAT,CAA6B7kB,KAA7B,EAAoCoZ,WAApC,EAAiD0L,UAAjD,EAA6DC,MAA7D,EAAqE;AACnE,SAAO,UAAUC,kBAAV,EAA8B;AACnC,QAAIxpB,OAAO,CAACupB,MAAD,CAAX,EAAqB;AACnBC,MAAAA,kBAAkB,GAAGhlB,KAAK,CAAC8E,eAAN,GACjBigB,MAAM,CAACE,SAAP,CAAiBD,kBAAjB,CADiB,GAEjBD,MAAM,CAACG,QAAP,CAAgBF,kBAAhB,CAFJ;AAGA5L,MAAAA,WAAW,CAAC0L,UAAD,CAAX,GAA0BC,MAAM,CAACI,QAAP,CACxBH,kBADwB,EAExB5L,WAAW,CAAC0L,UAAD,CAFa,CAA1B;AAIA1L,MAAAA,WAAW,CAACK,WAAZ,GAA0BzZ,KAAK,CAACgJ,eAAhC;AACD;AACF,GAXD;AAYD;;AAED,SAASoc,uBAAT,CAAiCplB,KAAjC,EAAwC;AACtC,MAAIiU,aAAa,GAAGjU,KAAK,CAAC2I,cAA1B;;AAEA,MAAI,CAACsL,aAAa,CAACoR,0BAAd,EAAL,EAAiD;AAC/C;AACD;;AAED,MAAI,CAACpR,aAAa,CAACmR,uBAAnB,EAA4C;AAC1C;AACD;;AACDnR,EAAAA,aAAa,CAACmR,uBAAd,GAAwC,KAAxC;AAEAplB,EAAAA,KAAK,CAACiJ,QAAN,CAAeC,UAAf,GAA4B,EAA5B;AAEA,MAAI+P,YAAY,GAAGjZ,KAAK,CAACiJ,QAAN,CAAeM,KAAlC;AACA,MAAIob,SAAS,GAAG3kB,KAAK,CAACM,IAAN,CAAWqkB,SAA3B;AAEA/mB,EAAAA,OAAO,CAAC0nB,SAAR,CAAkBtlB,KAAK,CAACM,IAAxB,EAA8B,UAAUglB,SAAV,EAAqBlkB,CAArB,EAAwB;AACpD,QAAImkB,QAAQ,GAAGD,SAAS,CAACC,QAAzB;AACA,QAAI9a,QAAQ,GAAG6a,SAAS,CAAC7a,QAAzB,CAFoD,CAIpD;;AACA,QAAI+a,SAAS,GAAGC,MAAM,CAACC,SAAvB;AACA,QAAIC,QAAQ,GAAG,CAACF,MAAM,CAACC,SAAvB;AAEA,QAAIE,cAAc,GAAGL,QAAQ,CAACpkB,MAA9B;AACA,QAAI0kB,iBAAiB,GAAG,IAAItW,KAAJ,CAAUqW,cAAV,CAAxB;;AAEA,SAAK,IAAIzB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyB,cAApB,EAAoC,EAAEzB,CAAtC,EAAyC;AACvC,UAAI2B,OAAO,GAAGP,QAAQ,CAACpB,CAAD,CAAtB;AACA,UAAIvP,MAAM,GAAGkR,OAAO,CAAClR,MAArB;AACA,UAAImR,IAAI,GAAGnR,MAAM,CAACmR,IAAlB;AACA,UAAIpF,OAAO,GAAGlW,QAAQ,CAACqb,OAAO,CAACnF,OAAT,CAAtB;AACA,UAAIqF,KAAK,GAAGnnB,mBAAmB,CAAConB,2BAApB,CACVjmB,KADU,EAEV2kB,SAAS,CAAChE,OAAO,CAACqF,KAAT,CAFC,CAAZ;AAIA,UAAIE,MAAM,GAAGrnB,mBAAmB,CAAConB,2BAApB,CACXjmB,KADW,EAEX2kB,SAAS,CAAChE,OAAO,CAACuF,MAAT,CAFE,CAAb;AAKAV,MAAAA,SAAS,GAAGpY,IAAI,CAACC,GAAL,CAASmY,SAAT,EAAoBQ,KAAK,CAAC,CAAD,CAAzB,CAAZ;AACAL,MAAAA,QAAQ,GAAGvY,IAAI,CAAC+Y,GAAL,CAASR,QAAT,EAAmBK,KAAK,CAACA,KAAK,CAAC7kB,MAAN,GAAe,CAAhB,CAAxB,CAAX;AAEA,UAAI4jB,MAAM,GAAGlmB,mBAAmB,CAACunB,kBAApB,CACXpmB,KADW,EAEXoB,CAFW,EAGXkkB,SAHW,EAIXQ,OAAO,CAACnF,OAJG,EAKXA,OALW,EAMXqF,KANW,EAOXD,IAPW,EAQXG,MARW,CAAb;AAWAL,MAAAA,iBAAiB,CAAC1B,CAAD,CAAjB,GAAuBU,mBAAmB,CACxC7kB,KADwC,EAExCiZ,YAAY,CAACrE,MAAM,CAACtD,IAAR,CAF4B,EAGxCsD,MAAM,CAACmR,IAHiC,EAIxChB,MAJwC,CAA1C;AAMD;;AAED/kB,IAAAA,KAAK,CAACiJ,QAAN,CAAeC,UAAf,CAA0B9H,CAA1B,IAA+B;AAC7BgQ,MAAAA,IAAI,EAAEkU,SAAS,CAAClU,IADa;AAE7BoU,MAAAA,SAAS,EAAEA,SAFkB;AAG7BG,MAAAA,QAAQ,EAAEA,QAHmB;AAI7BE,MAAAA,iBAAiB,EAAEA;AAJU,KAA/B;AAMD,GArDD;AAsDD;;AAED,SAASQ,kBAAT,CAA4BrmB,KAA5B,EAAmC0P,OAAnC,EAA4C;AAC1C,MAAIuE,aAAa,GAAGjU,KAAK,CAAC2I,cAA1B;;AACA,MACE,CAACsL,aAAa,CAACqS,uBAAd,EAAD,IACA,CAACrS,aAAa,CAACsS,uBAAd,EADD,IAEA,CAACtS,aAAa,CAACoS,kBAHjB,EAIE;AACA;AACD;;AACDpS,EAAAA,aAAa,CAACoS,kBAAd,GAAmC,KAAnC;AAEA,MAAIG,eAAe,GAAGxmB,KAAK,CAACkK,kBAAN,CAAyBC,OAA/C;AACA,MAAIsc,oBAAoB,GAAGzmB,KAAK,CAACkK,kBAAN,CAAyBE,YAApD;AACA,MAAI9J,IAAI,GAAGN,KAAK,CAACM,IAAjB;AACA,MAAIqkB,SAAS,GAAGrkB,IAAI,CAACqkB,SAArB;AACA/mB,EAAAA,OAAO,CAAC4d,IAAR,CAAalb,IAAb,EAAmB,UAAUkb,IAAV,EAAgBC,MAAhB,EAAwB;AACzC7d,IAAAA,OAAO,CAAC+d,aAAR,CAAsBH,IAAtB,EAA4B,UAAUI,SAAV,EAAqBC,WAArB,EAAkC;AAC5D,UAAIgC,UAAU,GAAG,EAAjB;AACA,UAAI6I,iBAAJ;AACA,UAAIjH,kBAAkB,GAAGiE,qBAAqB,CAAC1jB,KAAD,EAAQ4b,SAAR,CAA9C;AACA,UAAI+B,WAAW,GACb3d,KAAK,CAAC+K,YAAN,CAAmB0Q,MAAM,GAAG,aAAT,GAAyBI,WAA5C,CADF;AAEAje,MAAAA,OAAO,CAAC+oB,sBAAR,CAA+B/K,SAA/B,EAA0C,UACxCgL,UADwC,EAExCC,aAFwC,EAGxC;AACA;AACA;AACAH,QAAAA,iBAAiB,GAAGjH,kBAAkB,CAACoH,aAAD,CAAtC;;AACA,YAAIrrB,OAAO,CAACkrB,iBAAD,CAAX,EAAgC;AAC9B;AACA,cAAIlrB,OAAO,CAACmiB,WAAD,CAAX,EAA0B;AACxB,gBAAImJ,iBAAiB,GAAGnJ,WAAW,CAACE,UAApC;;AACA,gBAAIiJ,iBAAiB,CAACvT,cAAlB,CAAiCsT,aAAjC,CAAJ,EAAqD;AACnD,kBAAIE,gBAAgB,GAAGD,iBAAiB,CAACD,aAAD,CAAxC;AACAhJ,cAAAA,UAAU,CAACxN,IAAX,CAAgB;AACdsR,gBAAAA,KAAK,EAAE+E,iBADO;AAEdtK,gBAAAA,YAAY,EAAEoK,eAAe,CAACO,gBAAgB,CAACpS,UAAlB,CAFf;AAGdqS,gBAAAA,sBAAsB,EAAED,gBAAgB,CAACC,sBAH3B;AAIdC,gBAAAA,iBAAiB,EAAEF,gBAAgB,CAACE,iBAJtB;AAKdC,gBAAAA,SAAS,EAAEH,gBAAgB,CAACI,UALd;AAMdC,gBAAAA,aAAa,EAAEL,gBAAgB,CAAC3Q,UANlB;AAOdiR,gBAAAA,aAAa,EAAEN,gBAAgB,CAACO;AAPlB,eAAhB;AAUA;AACD;AACF;;AAED,cAAIC,CAAC,GAAG5C,SAAS,CAACiC,UAAD,CAAjB;AACA,cAAIM,SAAS,GAAG1rB,OAAO,CAAC+rB,CAAC,CAACJ,UAAH,CAAP,IAAyBI,CAAC,CAACJ,UAA3C;AACAtJ,UAAAA,UAAU,CAACxN,IAAX,CAAgB;AACdsR,YAAAA,KAAK,EAAE+E,iBADO;AAEdtK,YAAAA,YAAY,EAAEoK,eAAe,CAACe,CAAC,CAAC5S,UAAH,CAFf;AAGdqS,YAAAA,sBAAsB,EAAEjpB,yBAAyB,CAACwpB,CAAC,CAAC7U,IAAH,CAHnC;AAIduU,YAAAA,iBAAiB,EAAEM,CAAC,CAACnS,aAJP;AAKd8R,YAAAA,SAAS,EAAEA,SALG;AAMdE,YAAAA,aAAa,EAAEG,CAAC,CAACnR,UANH;AAOdiR,YAAAA,aAAa,EAAExpB,qBAAqB,CAACyC,IAAD,EAAOinB,CAAP;AAPtB,WAAhB;AASD;AACF,OAvCD,EAN4D,CA+C5D;;AACA,UAAIzD,SAAJ;AACA,UAAI+C,aAAJ;AACA,UAAIjgB,oBAAoB,GAAG5G,KAAK,CAAC2G,qBAAjC;;AACA,UAAInL,OAAO,CAACoL,oBAAD,CAAX,EAAmC;AACjC,aAAKigB,aAAL,IAAsBjgB,oBAAtB,EAA4C;AAC1C,cAAIA,oBAAoB,CAAC2M,cAArB,CAAoCsT,aAApC,CAAJ,EAAwD;AACtDH,YAAAA,iBAAiB,GAAGjH,kBAAkB,CAACoH,aAAD,CAAtC;;AACA,gBAAIrrB,OAAO,CAACkrB,iBAAD,CAAX,EAAgC;AAC9B5C,cAAAA,SAAS,GAAGld,oBAAoB,CAACigB,aAAD,CAAhC;AACA/C,cAAAA,SAAS,CAACnC,KAAV,GAAkB+E,iBAAlB;AACA7I,cAAAA,UAAU,CAACxN,IAAX,CAAgByT,SAAhB;AACD;AACF;AACF;AACF;;AAED,UAAIjH,WAAJ;;AACA,UAAIrhB,OAAO,CAACogB,SAAS,CAAC4L,OAAX,CAAX,EAAgC;AAC9B,YAAIvS,QAAQ,GAAG0P,SAAS,CAAC/I,SAAS,CAAC4L,OAAX,CAAxB;AACA,YAAI7S,UAAU,GAAGM,QAAQ,CAACN,UAA1B,CAF8B,CAI9B;;AACA,YAAInZ,OAAO,CAACmiB,WAAD,CAAX,EAA0B;AACxBhJ,UAAAA,UAAU,GAAGgJ,WAAW,CAAChJ,UAAzB;AACD;;AAEDkI,QAAAA,WAAW,GAAG2J,eAAe,CAAC7R,UAAD,CAA7B;AACD;;AACD8R,MAAAA,oBAAoB,CAClBhL,MAAM,GAAG,aAAT,GAAyBI,WADP,CAApB,GAEI,IAAIpe,WAAJ,CAAgB;AAClBiS,QAAAA,OAAO,EAAEA,OADS;AAElBmO,QAAAA,UAAU,EAAEA,UAFM;AAGlBhB,QAAAA,WAAW,EAAEA;AAHK,OAAhB,CAFJ;AAOD,KAnFD;AAoFD,GArFD;AAsFD;;AAED,SAAS4K,kBAAT,CAA4BznB,KAA5B,EAAmC;AACjC,MAAIiU,aAAa,GAAGjU,KAAK,CAAC2I,cAA1B;;AACA,MAAIsL,aAAa,CAACwT,kBAAlB,EAAsC;AACpCxT,IAAAA,aAAa,CAACwT,kBAAd,GAAmC,KAAnC;AAEA7pB,IAAAA,OAAO,CAAC8c,QAAR,CAAiB1a,KAAK,CAACM,IAAvB,EAA6B,UAAUoa,QAAV,EAAoBC,UAApB,EAAgC;AAC3D+M,MAAAA,4BAA4B,CAAC1nB,KAAD,EAAQ0a,QAAR,EAAkBC,UAAlB,CAA5B;AACD,KAFD;AAGD;AACF;;AAED,SAAS+M,4BAAT,CAAsC1nB,KAAtC,EAA6C0a,QAA7C,EAAuDC,UAAvD,EAAmE;AACjE,MAAIgN,oBAAoB,GAAG3nB,KAAK,CAACkK,kBAAN,CAAyBQ,YAApD;AAEA,MAAIkd,qBAAqB,GAAG,CAC1B/qB,cAAc,CAACgrB,QADW,EAE1BhrB,cAAc,CAACgrB,QAFW,CAA5B;AAIA,MAAIC,iBAAiB,GAAG,CACtBjrB,cAAc,CAACkrB,GADO,EAEtBlrB,cAAc,CAACmrB,mBAFO,EAGtBnrB,cAAc,CAACkrB,GAHO,EAItBlrB,cAAc,CAACmrB,mBAJO,CAAxB;;AAOA,MAAIxsB,OAAO,CAACkf,QAAQ,CAAClF,UAAV,CAAP,IAAgCha,OAAO,CAACkf,QAAQ,CAAClF,UAAT,CAAoByS,SAArB,CAA3C,EAA4E;AAC1EL,IAAAA,qBAAqB,GAAGlN,QAAQ,CAAClF,UAAT,CAAoByS,SAApB,CAA8BC,aAAtD;AACAJ,IAAAA,iBAAiB,GAAGpN,QAAQ,CAAClF,UAAT,CAAoByS,SAApB,CAA8BE,YAAlD;AACD;;AAED,MAAIC,aAAa,GAAG,CAAC1N,QAAQ,CAAC2N,WAA9B;AACA,MAAIC,eAAe,GAAG5N,QAAQ,CAAC6N,SAAT,KAAuB,OAA7C;AACAZ,EAAAA,oBAAoB,CAAChN,UAAD,CAApB,GAAmCzd,WAAW,CAACyiB,SAAZ,CAAsB;AACvD3X,IAAAA,IAAI,EAAE;AACJ8H,MAAAA,OAAO,EAAEsY;AADL,KADiD;AAIvDI,IAAAA,SAAS,EAAE;AACT1Y,MAAAA,OAAO,EAAE,IADA;AAET2Y,MAAAA,IAAI,EAAElqB,aAAa,CAACmqB;AAFX,KAJ4C;AAQvDC,IAAAA,SAAS,EAAE,CAACL,eAR2C;AASvDM,IAAAA,QAAQ,EAAE;AACR9Y,MAAAA,OAAO,EAAEwY,eADD;AAERO,MAAAA,WAAW,EAAEjB,qBAAqB,CAAC,CAAD,CAF1B;AAGRkB,MAAAA,aAAa,EAAElB,qBAAqB,CAAC,CAAD,CAH5B;AAIRmB,MAAAA,iBAAiB,EAAEjB,iBAAiB,CAAC,CAAD,CAJ5B;AAKRkB,MAAAA,sBAAsB,EAAElB,iBAAiB,CAAC,CAAD,CALjC;AAMRmB,MAAAA,mBAAmB,EAAEnB,iBAAiB,CAAC,CAAD,CAN9B;AAORoB,MAAAA,wBAAwB,EAAEpB,iBAAiB,CAAC,CAAD;AAPnC;AAT6C,GAAtB,CAAnC;AAmBD,C,CAED;;;AAEA,IAAIqB,oBAAoB,GAAG;AACzBC,EAAAA,KAAK,EAAE,UAAUC,YAAV,EAAwBrpB,KAAxB,EAA+BoZ,WAA/B,EAA4C;AACjD,WAAO,YAAY;AACjB,aAAOA,WAAW,CAACI,cAAnB;AACD,KAFD;AAGD,GALwB;AAMzB8P,EAAAA,IAAI,EAAE,UAAUD,YAAV,EAAwBrpB,KAAxB,EAA+BoZ,WAA/B,EAA4C;AAChD,WAAO,YAAY;AACjB,aAAOiQ,YAAY,CAACE,IAApB;AACD,KAFD;AAGD,GAVwB;AAWzBC,EAAAA,UAAU,EAAE,UAAUH,YAAV,EAAwBrpB,KAAxB,EAA+BoZ,WAA/B,EAA4C;AACtD,WAAO,YAAY;AACjB,aAAOiQ,YAAY,CAACI,UAApB;AACD,KAFD;AAGD,GAfwB;AAgBzBC,EAAAA,SAAS,EAAE,UAAUL,YAAV,EAAwBrpB,KAAxB,EAA+BoZ,WAA/B,EAA4C;AACrD,QAAIuQ,EAAE,GAAG,IAAIptB,OAAJ,EAAT;AACA,WAAO,YAAY;AACjB,aAAOA,OAAO,CAACqtB,sBAAR,CACLP,YAAY,CAACE,IADR,EAELnQ,WAAW,CAACI,cAFP,EAGLmQ,EAHK,CAAP;AAKD,KAND;AAOD,GAzBwB;AA0BzBE,EAAAA,oBAAoB,EAAE,UAAUR,YAAV,EAAwBrpB,KAAxB,EAA+BoZ,WAA/B,EAA4C;AAChE;AACA,QAAI0Q,KAAK,GAAG,IAAIvtB,OAAJ,EAAZ;AACA,WAAO,YAAY;AACjBA,MAAAA,OAAO,CAACqtB,sBAAR,CACEP,YAAY,CAACE,IADf,EAEEnQ,WAAW,CAACI,cAFd,EAGEsQ,KAHF;AAKA,aAAOvtB,OAAO,CAACwtB,cAAR,CAAuBD,KAAvB,EAA8B9pB,KAAK,CAAC2L,aAApC,EAAmDme,KAAnD,CAAP;AACD,KAPD;AAQD,GArCwB;AAsCzBE,EAAAA,mBAAmB,EAAE,UAAUX,YAAV,EAAwBrpB,KAAxB,EAA+BoZ,WAA/B,EAA4C;AAC/D,QAAI6Q,GAAG,GAAG,IAAI1tB,OAAJ,EAAV;AACA,WAAO,YAAY;AACjBA,MAAAA,OAAO,CAACqtB,sBAAR,CACEP,YAAY,CAACE,IADf,EAEEnQ,WAAW,CAACI,cAFd,EAGEyQ,GAHF;AAKA,aAAO1tB,OAAO,CAAC2tB,QAAR,CAAiBb,YAAY,CAACc,WAA9B,EAA2CF,GAA3C,EAAgDA,GAAhD,CAAP;AACD,KAPD;AAQD,GAhDwB;AAiDzBG,EAAAA,YAAY,EAAE,UAAUf,YAAV,EAAwBrpB,KAAxB,EAA+BoZ,WAA/B,EAA4C;AACxD,QAAIiR,QAAQ,GAAG,IAAI9tB,OAAJ,EAAf;AACA,WAAO,YAAY;AACjB,aAAOA,OAAO,CAAC+tB,OAAR,CAAgBlR,WAAW,CAACI,cAA5B,EAA4C6Q,QAA5C,CAAP;AACD,KAFD;AAGD,GAtDwB;AAuDzBE,EAAAA,WAAW,EAAE,UAAUlB,YAAV,EAAwBrpB,KAAxB,EAA+B;AAC1C,WAAO,YAAY;AACjB,aAAOqpB,YAAY,CAACmB,WAApB;AACD,KAFD;AAGD,GA3DwB;AA4DzBC,EAAAA,iBAAiB,EAAE,UAAUpB,YAAV,EAAwBrpB,KAAxB,EAA+BoZ,WAA/B,EAA4C;AAC7D,WAAO,YAAY;AACjB,aAAOiQ,YAAY,CAACqB,iBAApB;AACD,KAFD;AAGD,GAhEwB;AAiEzBC,EAAAA,gBAAgB,EAAE,UAAUtB,YAAV,EAAwBrpB,KAAxB,EAA+BoZ,WAA/B,EAA4C;AAC5D,QAAIuQ,EAAE,GAAG,IAAIptB,OAAJ,EAAT;AACA,QAAIquB,SAAS,GAAG,IAAIruB,OAAJ,EAAhB;AACA,WAAO,YAAY;AACjBA,MAAAA,OAAO,CAACqtB,sBAAR,CACEP,YAAY,CAACE,IADf,EAEEnQ,WAAW,CAACI,cAFd,EAGEmQ,EAHF;AAKA,aAAOptB,OAAO,CAAC+tB,OAAR,CAAgBX,EAAhB,EAAoBiB,SAApB,CAAP;AACD,KAPD;AAQD,GA5EwB;AA6EzBC,EAAAA,0BAA0B,EAAE,UAAUxB,YAAV,EAAwBrpB,KAAxB,EAA+BoZ,WAA/B,EAA4C;AACtE,QAAI6Q,GAAG,GAAG,IAAI1tB,OAAJ,EAAV;AACA,QAAIuuB,UAAU,GAAG,IAAIvuB,OAAJ,EAAjB;AACA,WAAO,YAAY;AACjBA,MAAAA,OAAO,CAACqtB,sBAAR,CACEP,YAAY,CAACE,IADf,EAEEnQ,WAAW,CAACI,cAFd,EAGEyQ,GAHF;AAKA1tB,MAAAA,OAAO,CAAC2tB,QAAR,CAAiBb,YAAY,CAACc,WAA9B,EAA2CF,GAA3C,EAAgDA,GAAhD;AACA,aAAO1tB,OAAO,CAAC+tB,OAAR,CAAgBL,GAAhB,EAAqBa,UAArB,CAAP;AACD,KARD;AASD,GAzFwB;AA0FzBC,EAAAA,qBAAqB,EAAE,UAAU1B,YAAV,EAAwBrpB,KAAxB,EAA+BoZ,WAA/B,EAA4C;AACjE,QAAIiR,QAAQ,GAAG,IAAI9tB,OAAJ,EAAf;AACA,QAAIyuB,iBAAiB,GAAG,IAAI1uB,OAAJ,EAAxB;AACA,WAAO,YAAY;AACjBC,MAAAA,OAAO,CAAC+tB,OAAR,CAAgBlR,WAAW,CAACI,cAA5B,EAA4C6Q,QAA5C;AACA9tB,MAAAA,OAAO,CAAC0uB,UAAR,CAAmBZ,QAAnB,EAA6BW,iBAA7B;AACA,aAAO1uB,OAAO,CAAC4uB,SAAR,CAAkBF,iBAAlB,EAAqCA,iBAArC,CAAP;AACD,KAJD;AAKD,GAlGwB;AAmGzBG,EAAAA,yBAAyB,EAAE,UAAU9B,YAAV,EAAwBrpB,KAAxB,EAA+BoZ,WAA/B,EAA4C;AACrE,QAAIuQ,EAAE,GAAG,IAAIptB,OAAJ,EAAT;AACA,QAAIquB,SAAS,GAAG,IAAIruB,OAAJ,EAAhB;AACA,QAAI6uB,kBAAkB,GAAG,IAAI9uB,OAAJ,EAAzB;AACA,WAAO,YAAY;AACjBC,MAAAA,OAAO,CAACqtB,sBAAR,CACEP,YAAY,CAACE,IADf,EAEEnQ,WAAW,CAACI,cAFd,EAGEmQ,EAHF;AAKAptB,MAAAA,OAAO,CAAC+tB,OAAR,CAAgBX,EAAhB,EAAoBiB,SAApB;AACAruB,MAAAA,OAAO,CAAC0uB,UAAR,CAAmBL,SAAnB,EAA8BQ,kBAA9B;AACA,aAAO9uB,OAAO,CAAC4uB,SAAR,CAAkBE,kBAAlB,EAAsCA,kBAAtC,CAAP;AACD,KATD;AAUD,GAjHwB;AAkHzBC,EAAAA,QAAQ,EAAE,UAAUhC,YAAV,EAAwBrpB,KAAxB,EAA+BoZ,WAA/B,EAA4C;AACpD,WAAO,YAAY;AACjB,aAAOiQ,YAAY,CAACiC,kBAApB;AACD,KAFD;AAGD;AAtHwB,CAA3B;;AAyHA,SAASC,4BAAT,CAAsClX,MAAtC,EAA8CrU,KAA9C,EAAqD+jB,QAArD,EAA+DsF,YAA/D,EAA6E;AAC3E,MAAIjQ,WAAW,GAAGpZ,KAAK,CAACiJ,QAAN,CAAeM,KAAf,CAAqB8K,MAArB,CAAlB;AACA,SAAO8U,oBAAoB,CAACpF,QAAD,CAApB,CAA+BsF,YAA/B,EAA6CrpB,KAA7C,EAAoDoZ,WAApD,CAAP;AACD;;AAED,SAASoS,yBAAT,CACExrB,KADF,EAEE0a,QAFF,EAGEhF,SAHF,EAIE+V,cAJF,EAKE/b,OALF,EAMElF,QANF,EAOEkhB,cAPF,EAQE;AACA,MAAI9Q,UAAU,GAAG,EAAjB;AACA,MAAI+Q,aAAa,GAAG,EAApB;AACA,MAAI7Q,sBAAJ;AACA,MAAIC,uBAAJ;AAEAnd,EAAAA,OAAO,CAACguB,gBAAR,CAAyBlW,SAAzB,EAAoC,UAAUmW,OAAV,EAAmBzQ,WAAnB,EAAgC;AAClE;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA,QAAI0Q,EAAJ;;AACA,QAAItwB,OAAO,CAACiwB,cAAD,CAAP,IAA2BjwB,OAAO,CAACiwB,cAAc,CAACrQ,WAAD,CAAf,CAAtC,EAAqE;AACnE;AACA0Q,MAAAA,EAAE,GAAG1sB,YAAY,CAAC2sB,qBAAb,CACHF,OAAO,CAACnZ,IADL,EAEH+Y,cAAc,CAACrQ,WAAD,CAFX,EAGH5Q,QAHG,EAIHkhB,cAJG,CAAL;AAMA9Q,MAAAA,UAAU,CAACQ,WAAD,CAAV,GAA0B0Q,EAAE,CAACrD,IAA7B;AACAkD,MAAAA,aAAa,CAACvQ,WAAD,CAAb,GAA6B0Q,EAA7B;AACD,KAVD,MAUO,IAAItwB,OAAO,CAACqwB,OAAO,CAACva,IAAT,CAAX,EAA2B;AAChCsJ,MAAAA,UAAU,CAACQ,WAAD,CAAV,GAA0BmQ,4BAA4B,CACpDM,OAAO,CAACva,IAD4C,EAEpDtR,KAFoD,EAGpD6rB,OAAO,CAAC9H,QAH4C,EAIpDrU,OAAO,CAAC2Z,YAJ4C,CAAtD;AAMD,KAPM,MAOA,IAAI7tB,OAAO,CAACqwB,OAAO,CAAC9H,QAAT,CAAX,EAA+B;AACpC,UAAI8H,OAAO,CAAC9H,QAAR,KAAqB,aAAzB,EAAwC;AACtCjJ,QAAAA,sBAAsB,GAAGM,WAAzB;AACD,OAFD,MAEO,IAAIyQ,OAAO,CAAC9H,QAAR,KAAqB,cAAzB,EAAyC;AAC9ChJ,QAAAA,uBAAuB,GAAGK,WAA1B;AACD,OAFM,MAEA,IAAIyQ,OAAO,CAAC9H,QAAR,KAAqB,aAAzB,EAAwC;AAC7C;AACA;AACA,YAAIwE,SAAS,GAAG7N,QAAQ,CAAC6N,SAAzB;;AACA,YAAI/sB,OAAO,CAAC+sB,SAAD,CAAP,IAAsBA,SAAS,KAAK,MAAxC,EAAgD;AAC9C,cAAIyD,gBAAgB,GAAGzwB,YAAY,CAACmf,QAAQ,CAACuR,WAAV,EAAuB,GAAvB,CAAnC;AACAH,UAAAA,EAAE,GAAG1sB,YAAY,CAAC2sB,qBAAb,CACHF,OAAO,CAACnZ,IADL,EAEHsZ,gBAFG,EAGHxhB,QAHG,EAIHkhB,cAJG,CAAL;AAMA9Q,UAAAA,UAAU,CAACQ,WAAD,CAAV,GAA0B0Q,EAAE,CAACrD,IAA7B;AACAkD,UAAAA,aAAa,CAACvQ,WAAD,CAAb,GAA6B0Q,EAA7B;AACD;AACF,OAfM,MAeA;AACL;AACAlR,QAAAA,UAAU,CAACQ,WAAD,CAAV,GAA0Bhc,YAAY,CAAC8sB,uBAAb,GACxBL,OAAO,CAAC9H,QADgB,EAExBrU,OAAO,CAAC2Z,YAFgB,EAEFrpB,KAFE,CAA1B;AAGD;AACF,KA1BM,MA0BA,IAAIxE,OAAO,CAACqwB,OAAO,CAAC/qB,KAAT,CAAX,EAA4B;AACjC;AACA,UAAIqrB,GAAG,GAAG/sB,YAAY,CAAC2sB,qBAAb,CACRF,OAAO,CAACnZ,IADA,EAERmZ,OAAO,CAAC/qB,KAFA,EAGR0J,QAHQ,EAIRkhB,cAJQ,CAAV;AAMA9Q,MAAAA,UAAU,CAACQ,WAAD,CAAV,GAA0B+Q,GAAG,CAAC1D,IAA9B;AACAkD,MAAAA,aAAa,CAACvQ,WAAD,CAAb,GAA6B+Q,GAA7B;AACD;AACF,GAnED;AAqEA,SAAO;AACLC,IAAAA,GAAG,EAAExR,UADA;AAELC,IAAAA,MAAM,EAAE8Q,aAFH;AAGL7Q,IAAAA,sBAAsB,EAAEA,sBAHnB;AAILC,IAAAA,uBAAuB,EAAEA;AAJpB,GAAP;AAMD;;AAED,SAASsR,iBAAT,CAA2BrsB,KAA3B,EAAkC0P,OAAlC,EAA2C;AACzC,MAAIuE,aAAa,GAAGjU,KAAK,CAAC2I,cAA1B;;AAEA,MAAI,CAACsL,aAAa,CAACsS,uBAAd,EAAL,EAA8C;AAC5C;AACD;;AAED,MAAI,CAACtS,aAAa,CAACoY,iBAAnB,EAAsC;AACpC;AACD;;AACDpY,EAAAA,aAAa,CAACoY,iBAAd,GAAkC,KAAlC;AAEA,MAAI/rB,IAAI,GAAGN,KAAK,CAACM,IAAjB;AACA,MAAIga,UAAU,GAAGta,KAAK,CAACqL,iBAAvB;AACA,MAAIoP,WAAW,GAAGza,KAAK,CAAC6J,YAAxB;AAEA,MAAIW,QAAQ,GAAGxK,KAAK,CAACkK,kBAAN,CAAyBM,QAAxC;AACA,MAAIkhB,cAAc,GAAG1rB,KAAK,CAAC+E,eAA3B;AAEAnH,EAAAA,OAAO,CAAC8c,QAAR,CAAiBpa,IAAjB,EAAuB,UAAUoa,QAAV,EAAoBC,UAApB,EAAgC;AACrD,QAAIK,aAAa,GAAGhb,KAAK,CAACiJ,QAAN,CAAeW,aAAf,CAA6B+Q,UAA7B,CAApB;AACA,QAAIjF,SAAS,GAAG4E,UAAU,CAACU,aAAa,CAACC,UAAf,CAA1B;AACA,QAAIwQ,cAAc,GAAGzQ,aAAa,CAACK,OAAnC;AAEA,QAAIqC,QAAQ,GAAG8N,yBAAyB,CACtCxrB,KADsC,EAEtC0a,QAFsC,EAGtChF,SAHsC,EAItC+V,cAJsC,EAKtC/b,OALsC,EAMtClF,QANsC,EAOtCkhB,cAPsC,CAAxC;AAUA,QAAIY,CAAC,GAAG7R,WAAW,CAACE,UAAD,CAAnB;AACA2R,IAAAA,CAAC,CAAC1R,UAAF,GAAe8C,QAAQ,CAAC0O,GAAxB,CAhBqD,CAgBxB;;AAC7BE,IAAAA,CAAC,CAACzR,MAAF,GAAW6C,QAAQ,CAAC7C,MAApB,CAjBqD,CAiBzB;;AAC5ByR,IAAAA,CAAC,CAACxR,sBAAF,GAA2B4C,QAAQ,CAAC5C,sBAApC;AACAwR,IAAAA,CAAC,CAACvR,uBAAF,GAA4B2C,QAAQ,CAAC3C,uBAArC;;AAEA,QAAIvf,OAAO,CAACka,SAAS,CAACmI,UAAV,CAAqB0O,oBAAtB,CAAX,EAAwD;AACtD,UAAIC,cAAc,GAAGrtB,kBAAkB,CAACiiB,aAAnB,CAAiCphB,KAAjC,EAAwC0P,OAAxC,CAArB;;AACA4c,MAAAA,CAAC,CAAC1R,UAAF,CAAa6R,gBAAb,GAAgC,YAAY;AAC1C,eAAOD,cAAP;AACD,OAFD;AAGD;AACF,GA3BD;AA4BD;;AAED,SAASE,yCAAT,CAAmD/O,WAAnD,EAAgE;AAC9D,SAAOve,YAAY,CAACstB,yCAAb,CACL/O,WAAW,CAACE,UADP,CAAP;AAGD;;AAED,SAAS8O,oCAAT,CAA8C3sB,KAA9C,EAAqD4b,SAArD,EAAgE;AAC9D,MAAIhG,SAAS,GAAGkG,sBAAsB,CAAC9b,KAAD,EAAQ4b,SAAR,CAAtC;AACA,MAAIgR,iBAAiB,GAAG5sB,KAAK,CAACgK,kBAAN,CAAyB4L,SAAzB,CAAxB;AACA,SAAOxW,YAAY,CAACutB,oCAAb,CACL3sB,KAAK,CAACM,IADD,EAELsb,SAFK,EAGLgR,iBAHK,CAAP;AAKD;;AAED,SAASC,uBAAT,CAAiCtnB,KAAjC,EAAwC;AACtC,SAAO,YAAY;AACjB,WAAOA,KAAP;AACD,GAFD;AAGD;;AAED,SAASunB,2BAAT,CAAqC1T,WAArC,EAAkD;AAChD,SAAO,YAAY;AACjB,WAAOA,WAAW,CAACU,qBAAnB;AACD,GAFD;AAGD;;AAED,SAASiT,0BAAT,CAAoC3T,WAApC,EAAiD;AAC/C,SAAO,YAAY;AACjB,WAAOA,WAAW,CAACY,OAAnB;AACD,GAFD;AAGD;;AAED,SAASgT,6BAAT,CAAuChtB,KAAvC,EAA8C;AAC5C,SAAO,YAAY;AACjB,WAAOA,KAAK,CAAC0C,eAAb;AACD,GAFD;AAGD;;AAED,SAASuqB,4BAAT,CAAsCjtB,KAAtC,EAA6C;AAC3C,SAAO,YAAY;AACjB,WAAOA,KAAK,CAAC+C,cAAb;AACD,GAFD;AAGD;;AAED,SAASmqB,mBAAT,CAA6BltB,KAA7B,EAAoC;AAClC,SAAO,YAAY;AACjB,WAAOA,KAAK,CAACuF,KAAb;AACD,GAFD;AAGD;;AAED,SAAS4nB,kCAAT,CAA4CntB,KAA5C,EAAmD;AACjD,SAAO,YAAY;AACjB,WAAOA,KAAK,CAACoI,qBAAb;AACD,GAFD;AAGD;;AAED,SAASglB,qCAAT,CAA+CptB,KAA/C,EAAsD;AACpD,SAAO,YAAY;AACjB,WAAOA,KAAK,CAACqI,wBAAb;AACD,GAFD;AAGD;;AAED,SAASglB,4BAAT,CAAsCrtB,KAAtC,EAA6C;AAC3C,SAAO,YAAY;AACjB,QAAI+F,cAAc,GAAG/F,KAAK,CAAC+F,cAA3B;AACA,WAAO,CAACvK,OAAO,CAACuK,cAAD,CAAR,IAA4B,CAACA,cAAc,CAAC+J,OAA5C,GACH9P,KAAK,CAAC+E,eADH,GAEHgB,cAAc,CAACiS,OAFnB;AAGD,GALD;AAMD;;AAED,SAASsV,qCAAT,CAA+CttB,KAA/C,EAAsD;AACpD,SAAO,YAAY;AACjB,QAAI+F,cAAc,GAAG/F,KAAK,CAAC+F,cAA3B;;AACA,QAAI,CAACvK,OAAO,CAACuK,cAAD,CAAZ,EAA8B;AAC5B,aAAO5K,KAAK,CAACqK,KAAN,CAAY+nB,SAAZ,CAAsB,GAAtB,CAAP;AACD;;AAED,QAAIC,KAAK,GAAGryB,KAAK,CAACD,KAAN,CAAY6K,cAAc,CAAC0nB,SAA3B,CAAZ;AACAD,IAAAA,KAAK,CAACE,KAAN,GAAc3nB,cAAc,CAAC4nB,SAA7B;AACA,WAAOH,KAAP;AACD,GATD;AAUD;;AAED,SAASI,wBAAT,CAAkC5tB,KAAlC,EAAyC;AACvC,SAAO,YAAY;AACjB,WAAO1B,cAAc,CAACuvB,aAAf,CACL7tB,KAAK,CAAC0F,cADD,EAEL1F,KAAK,CAAC4F,gBAFD,CAAP;AAID,GALD;AAMD;;AAED,SAASkoB,uBAAT,CAAiC9tB,KAAjC,EAAwC;AACtC,SAAO,YAAY;AACjB,WAAOA,KAAK,CAACgM,yBAAb;AACD,GAFD;AAGD;;AAED,SAAS+hB,wBAAT,CAAkC/tB,KAAlC,EAAyC;AACvC,SAAO,YAAY;AACjB,WAAOA,KAAK,CAACkM,WAAb;AACD,GAFD;AAGD;;AAED,SAAS8hB,+BAAT,CAAyChuB,KAAzC,EAAgD;AAC9C,SAAO,YAAY;AACjB,WAAOA,KAAK,CAACqM,iBAAb;AACD,GAFD;AAGD;;AAED,SAAS4hB,2CAAT,CAAqDjuB,KAArD,EAA4D;AAC1D,SAAO,YAAY;AACjB,WAAOA,KAAK,CAACsM,8BAAb;AACD,GAFD;AAGD;;AAED,SAAS4hB,oCAAT,CAA8CluB,KAA9C,EAAqD;AACnD,SAAO,YAAY;AACjB,WAAOA,KAAK,CAAC2M,4BAAN,CAAmCqL,OAA1C;AACD,GAFD;AAGD;;AAED,SAASmW,wCAAT,CAAkDnuB,KAAlD,EAAyD;AACvD,SAAO,YAAY;AACjB,WAAOA,KAAK,CAAC2M,4BAAN,CAAmCqL,OAAnC,CAA2CoW,UAAlD;AACD,GAFD;AAGD;;AAED,SAASC,+BAAT,CAAyCruB,KAAzC,EAAgD;AAC9C,SAAO,YAAY;AACjB,WAAOA,KAAK,CAAC2M,4BAAN,CAAmC2hB,kBAA1C;AACD,GAFD;AAGD;;AAED,SAASC,iCAAT,CAA2C3S,SAA3C,EAAsD4S,YAAtD,EAAoE;AAClE,UAAQ5S,SAAS,CAAC6S,IAAlB;AACE,SAAKhyB,aAAa,CAACiyB,SAAnB;AACE,aAAOF,YAAY,GAAG,CAAtB;;AACF,SAAK/xB,aAAa,CAACkyB,cAAnB;AACA,SAAKlyB,aAAa,CAACmyB,YAAnB;AACE,aAAOxhB,IAAI,CAAC+Y,GAAL,CAASqI,YAAY,GAAG,CAAxB,EAA2B,CAA3B,CAAP;;AACF;AACE,aAAO,CAAP;AAPJ;AASD;;AAED,SAASK,aAAT,CAAuB7uB,KAAvB,EAA8B8uB,QAA9B,EAAwC1V,WAAxC,EAAqD1J,OAArD,EAA8Dqf,WAA9D,EAA2E;AACzE,MAAIC,YAAY,GAAGhvB,KAAK,CAACwL,aAAzB;AACA,MAAIqD,OAAO,GAAG7O,KAAK,CAACyL,QAApB;AACA,MAAIhH,YAAY,GAAGzE,KAAK,CAACyE,YAAzB;AACA,MAAI8W,mBAAmB,GAAGvb,KAAK,CAACiJ,QAAN,CAAeS,YAAzC;AAEA,MAAIulB,SAAS,GAAGjvB,KAAK,CAACkK,kBAAtB;AACA,MAAIuc,oBAAoB,GAAGwI,SAAS,CAAC7kB,YAArC;AACA,MAAI8kB,gBAAgB,GAAGD,SAAS,CAAC5kB,QAAjC;AACA,MAAIsd,oBAAoB,GAAGsH,SAAS,CAACvkB,YAArC;AACA,MAAI+P,WAAW,GAAGza,KAAK,CAAC6J,YAAxB;AAEA,MAAIvJ,IAAI,GAAGN,KAAK,CAACM,IAAjB;AACA,MAAIqkB,SAAS,GAAGrkB,IAAI,CAACqkB,SAArB;AACA,MAAIwK,UAAU,GAAG7uB,IAAI,CAAC8uB,MAAtB;AAEA,MAAI1rB,EAAE,GAAGorB,QAAQ,CAACtT,IAAlB;AACA,MAAIA,IAAI,GAAG2T,UAAU,CAACzrB,EAAD,CAArB;AAEA,MAAI+Z,UAAU,GAAGjC,IAAI,CAACiC,UAAtB;AACA,MAAItc,MAAM,GAAGsc,UAAU,CAACtc,MAAxB,CApByE,CAsBzE;AACA;AACA;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,MAApB,EAA4B,EAAEC,CAA9B,EAAiC;AAC/B,QAAIwa,SAAS,GAAG6B,UAAU,CAACrc,CAAD,CAA1B;AACA,QAAIiuB,EAAE,GAAG1K,SAAS,CAAC/I,SAAS,CAAC4L,OAAX,CAAlB;AACA,QAAI9M,QAAQ,GAAG1a,KAAK,CAACiJ,QAAN,CAAeW,aAAf,CAA6BgS,SAAS,CAAClB,QAAvC,CAAf;AACA,QAAI9E,SAAS,GAAG8E,QAAQ,CAACQ,QAAzB;AACA,QAAIyC,WAAW,GAAG3d,KAAK,CAAC+K,YAAN,CAAmBrH,EAAE,GAAG,aAAL,GAAqBtC,CAAxC,CAAlB;AAEA,QAAI4L,cAAJ;AACA,QAAIsiB,gBAAgB,GAAG1T,SAAS,CAACiC,UAAV,CAAqB0R,QAA5C;;AACA,QAAI/zB,OAAO,CAAC8zB,gBAAD,CAAX,EAA+B;AAC7B,UAAIE,MAAM,GAAGpwB,YAAY,CAACqwB,iBAAb,CAA+BnvB,IAA/B,EAAqCgvB,gBAArC,CAAb;AACAtiB,MAAAA,cAAc,GAAGpS,cAAc,CAAC80B,gBAAf,CACf50B,UAAU,CAAC60B,SAAX,CAAqBH,MAAM,CAACniB,GAA5B,CADe,EAEfvS,UAAU,CAAC60B,SAAX,CAAqBH,MAAM,CAACrJ,GAA5B,CAFe,CAAjB;AAID;;AAED,QAAIyJ,WAAW,GAAGnJ,oBAAoB,CAAC/iB,EAAE,GAAG,aAAL,GAAqBtC,CAAtB,CAAtC;AACA,QAAIyuB,MAAJ;AACA,QAAIpvB,KAAJ,CAnB+B,CAqB/B;;AACA,QAAIjF,OAAO,CAACmiB,WAAD,CAAX,EAA0B;AACxBld,MAAAA,KAAK,GAAGkd,WAAW,CAACmS,eAApB;AACAD,MAAAA,MAAM,GAAG,CAAT;AACD,KAHD,MAGO,IAAIr0B,OAAO,CAAC6zB,EAAD,CAAX,EAAiB;AACtB5uB,MAAAA,KAAK,GAAG4uB,EAAE,CAAC5uB,KAAX;AACAovB,MAAAA,MAAM,GAAGR,EAAE,CAACjZ,UAAH,GAAgBna,aAAa,CAAC8zB,cAAd,CAA6BV,EAAE,CAACja,aAAhC,CAAzB,CAFsB,CAEmD;AAC1E,KAHM,MAGA;AACL,UAAI4a,SAAS,GAAGrL,SAAS,CAAC/I,SAAS,CAACiC,UAAV,CAAqB0R,QAAtB,CAAzB;AACA9uB,MAAAA,KAAK,GAAGuvB,SAAS,CAACvvB,KAAlB;AACAovB,MAAAA,MAAM,GAAG,CAAT;AACD,KAhC8B,CAkC/B;;;AACA7vB,IAAAA,KAAK,CAACoL,gBAAN,IAA0BmjB,iCAAiC,CACzD3S,SADyD,EAEzDnb,KAFyD,CAA3D;AAKA,QAAIwvB,EAAE,GAAGxV,WAAW,CAACmB,SAAS,CAAClB,QAAX,CAApB;AACA,QAAIE,UAAU,GAAGqV,EAAE,CAACrV,UAApB;;AACA,QAAIpf,OAAO,CAACy0B,EAAE,CAACnV,sBAAJ,CAAX,EAAwC;AACtC,UAAIoV,eAAe,GAAG,EAAtB;AACAA,MAAAA,eAAe,CAACD,EAAE,CAACnV,sBAAJ,CAAf,GAA6CgS,2BAA2B,CACtE1T,WADsE,CAAxE;AAIAwB,MAAAA,UAAU,GAAGxf,OAAO,CAACwf,UAAD,EAAasV,eAAb,CAApB;AACD;;AACD,QAAI10B,OAAO,CAACy0B,EAAE,CAAClV,uBAAJ,CAAX,EAAyC;AACvC,UAAIoV,sBAAsB,GAAG,EAA7B;AACAA,MAAAA,sBAAsB,CACpBF,EAAE,CAAClV,uBADiB,CAAtB,GAEIgS,0BAA0B,CAAC3T,WAAD,CAF9B;AAIAwB,MAAAA,UAAU,GAAGxf,OAAO,CAACwf,UAAD,EAAauV,sBAAb,CAApB;AACD;;AAEDvV,IAAAA,UAAU,GAAGxf,OAAO,CAACwf,UAAD,EAAa;AAC/BwV,MAAAA,UAAU,EAAElD,mBAAmB,CAACltB,KAAD,CADA;AAE/BqwB,MAAAA,eAAe,EAAEzC,wBAAwB,CAAC5tB,KAAD,CAFV;AAG/BswB,MAAAA,mBAAmB,EAAEjD,4BAA4B,CAACrtB,KAAD,CAHlB;AAI/BuwB,MAAAA,4BAA4B,EAAEjD,qCAAqC,CACjEttB,KADiE,CAJpC;AAO/BwwB,MAAAA,yBAAyB,EAAErD,kCAAkC,CAACntB,KAAD,CAP9B;AAQ/BywB,MAAAA,4BAA4B,EAAErD,qCAAqC,CACjEptB,KADiE,CARpC;AAW/B0wB,MAAAA,cAAc,EAAE5C,uBAAuB,CAAC9tB,KAAD,CAXR;AAY/B2wB,MAAAA,eAAe,EAAE5C,wBAAwB,CAAC/tB,KAAD,CAZV;AAa/B4wB,MAAAA,kCAAkC,EAAE3C,2CAA2C,CAC7EjuB,KAD6E,CAbhD;AAgB/B6wB,MAAAA,gBAAgB,EAAE3C,oCAAoC,CAACluB,KAAD,CAhBvB;AAiB/B8wB,MAAAA,oBAAoB,EAAE3C,wCAAwC,CAACnuB,KAAD,CAjB/B;AAkB/B+wB,MAAAA,mBAAmB,EAAE1C,+BAA+B,CAACruB,KAAD,CAlBrB;AAmB/BgxB,MAAAA,sBAAsB,EAAEhD,+BAA+B,CAAChuB,KAAD;AAnBxB,KAAb,CAApB,CA3D+B,CAiF/B;;AACA,QAAIxE,OAAO,CAACwE,KAAK,CAACiH,iBAAP,CAAX,EAAsC;AACpC2T,MAAAA,UAAU,GAAG5a,KAAK,CAACiH,iBAAN,CAAwB2T,UAAxB,EAAoChF,SAApC,EAA+CwD,WAA/C,CAAb;AACD,KApF8B,CAsF/B;;;AACA,QAAI6X,mBAAmB,GAAG,EAA1B;;AACA,QAAIjxB,KAAK,CAACmO,cAAN,CAAqBuN,0BAAzB,EAAqD;AACnDuV,MAAAA,mBAAmB,GAAGtE,oCAAoC,CACxD3sB,KADwD,EAExD4b,SAFwD,CAA1D;AAID,KALD,MAKO,IAAI5b,KAAK,CAAC6K,mBAAN,IAA6BrP,OAAO,CAACmiB,WAAD,CAAxC,EAAuD;AAC5DsT,MAAAA,mBAAmB,GAAGvE,yCAAyC,CAC7D/O,WAD6D,CAA/D;AAGD;;AACD/C,IAAAA,UAAU,GAAGxf,OAAO,CAACwf,UAAD,EAAaqW,mBAAb,CAApB;AAEA,QAAIC,EAAE,GAAGvJ,oBAAoB,CAAC/L,SAAS,CAAClB,QAAX,CAA7B;AACA,QAAIyW,aAAa,GAAGD,EAAE,CAACtI,QAAH,CAAY9Y,OAAhC;AAEA,QAAIshB,KAAK,GAAGpxB,KAAK,CAACsE,WAAlB;;AACA,QAAI,CAAC9I,OAAO,CAAC41B,KAAD,CAAZ,EAAqB;AACnBA,MAAAA,KAAK,GAAG;AACNxV,QAAAA,SAAS,EAAE5b,KADL;AAEN0D,QAAAA,EAAE,EAAE1D,KAAK,CAAC0D,EAFJ;AAGN4N,QAAAA,IAAI,EAAE8H,WAAW,CAAC7H,UAHZ;AAINiK,QAAAA,IAAI,EAAED,mBAAmB,CAACC,IAAI,CAACpK,IAAN;AAJnB,OAAR;AAMD;;AAED,QAAIigB,WAAW,GAAG5xB,UAAU,CAAC4xB,WAAX,CAAuBrxB,KAAK,CAACsF,QAA7B,CAAlB;AACA,QAAIgsB,cAAc,GAAG7xB,UAAU,CAAC6xB,cAAX,CAA0BtxB,KAAK,CAACsF,QAAhC,CAArB;AAEA,QAAIisB,MAAJ;;AACA,QAAI9sB,YAAY,IAAI,CAACjJ,OAAO,CAACwE,KAAK,CAACiH,iBAAP,CAA5B,EAAuD;AACrDsqB,MAAAA,MAAM,GAAG7hB,OAAO,CAAC8hB,YAAR,CAAqBJ,KAArB,CAAT;AACAviB,MAAAA,OAAO,CAACwB,IAAR,CAAakhB,MAAb;AACA,UAAIE,YAAY,GAAG;AACjBC,QAAAA,aAAa,EAAE7E,uBAAuB,CAAC0E,MAAM,CAAChsB,KAAR;AADrB,OAAnB;AAGAqV,MAAAA,UAAU,GAAGxf,OAAO,CAACwf,UAAD,EAAa6W,YAAb,CAApB;AACD;;AAED,QAAIhtB,YAAJ,EAAkB;AAChB,UAAIjJ,OAAO,CAACwE,KAAK,CAACmH,aAAP,CAAP,IAAgC3L,OAAO,CAACwE,KAAK,CAACiH,iBAAP,CAA3C,EAAsE;AACpEsqB,QAAAA,MAAM,GAAGvxB,KAAK,CAACmH,aAAN,EAAT;AACD,OAFD,MAEO;AACLoqB,QAAAA,MAAM,GAAG,eAAT;AACD;AACF;;AAED,QAAII,OAAO,GAAG,IAAI30B,WAAJ,CAAgB;AAC5B40B,MAAAA,cAAc,EAAE,IAAIh3B,cAAJ,EADY;AACU;AACtCoN,MAAAA,IAAI,EAAEhI,KAAK,CAACgI,IAFgB;AAG5BhF,MAAAA,WAAW,EAAE,IAAIzG,OAAJ,EAHe;AAGA;AAC5Bs1B,MAAAA,aAAa,EAAEjW,SAAS,CAAC6S,IAJG;AAK5BmB,MAAAA,WAAW,EAAEA,WALe;AAM5BnvB,MAAAA,KAAK,EAAEA,KANqB;AAO5BovB,MAAAA,MAAM,EAAEA,MAPoB;AAQ5BiC,MAAAA,aAAa,EAAE5C,gBAAgB,CAACtZ,SAAD,CARH;AAS5Byb,MAAAA,WAAW,EAAEA,WATe;AAU5BC,MAAAA,cAAc,EAAEA,cAVY;AAW5B1W,MAAAA,UAAU,EAAEA,UAXgB;AAY5BmX,MAAAA,WAAW,EAAEb,EAZe;AAa5BE,MAAAA,KAAK,EAAEA,KAbqB;AAc5BY,MAAAA,IAAI,EAAEb,aAAa,GAAGl0B,IAAI,CAACg1B,WAAR,GAAsBjyB,KAAK,CAACiI,UAdnB;AAe5BspB,MAAAA,MAAM,EAAEA;AAfoB,KAAhB,CAAd;AAkBA,QAAIW,SAAJ;;AACA,QAAI,CAACnD,WAAL,EAAkB;AAChBmD,MAAAA,SAAS,GAAGl1B,WAAW,CAACm1B,YAAZ,CAAyBR,OAAzB,CAAZ;AACAO,MAAAA,SAAS,CAACN,cAAV,GAA2B,IAAIh3B,cAAJ,EAA3B,CAFgB,CAEiC;;AACjDs3B,MAAAA,SAAS,CAAClvB,WAAV,GAAwB,IAAIzG,OAAJ,EAAxB,CAHgB,CAGuB;AACxC;;AAED,QAAI61B,WAAW,GAAG;AAChB3vB,MAAAA,IAAI,EAAE,IADU;AAEhBuK,MAAAA,cAAc,EAAEA,cAFA;AAGhB2kB,MAAAA,OAAO,EAAEA,OAHO;AAIhBO,MAAAA,SAAS,EAAEA,SAJK;AAKhB;AACAG,MAAAA,sBAAsB,EAAE9wB,SANR;AAOhB+wB,MAAAA,wBAAwB,EAAE/wB,SAPV;AAQhBgxB,MAAAA,sBAAsB,EAAEhxB,SARR;AAShBixB,MAAAA,wBAAwB,EAAEjxB,SATV;AAUhB;AACAkxB,MAAAA,kBAAkB,EAAElxB,SAXJ;AAYhBmxB,MAAAA,oBAAoB,EAAEnxB,SAZN;AAahB;AACAoxB,MAAAA,qBAAqB,EAAEpxB,SAdP;AAehBqxB,MAAAA,uBAAuB,EAAErxB,SAfT;AAgBhB;AACAqU,MAAAA,SAAS,EAAEA;AAjBK,KAAlB;AAmBAwD,IAAAA,WAAW,CAACM,QAAZ,CAAqBrJ,IAArB,CAA0B+hB,WAA1B;AACApD,IAAAA,YAAY,CAAC3e,IAAb,CAAkB+hB,WAAlB;AACD;AACF;;AAED,SAASS,kBAAT,CAA4B7yB,KAA5B,EAAmC0P,OAAnC,EAA4Cqf,WAA5C,EAAyD;AACvD,MAAI9a,aAAa,GAAGjU,KAAK,CAAC2I,cAA1B;;AAEA,MAAI,CAACsL,aAAa,CAAC6e,oCAAd,EAAL,EAA2D;AACzD;AACD;;AAED,MAAI,CAAC7e,aAAa,CAAC4e,kBAAnB,EAAuC;AACrC;AACD;;AACD5e,EAAAA,aAAa,CAAC4e,kBAAd,GAAmC,KAAnC;AAEA,MAAIvpB,SAAS,GAAG,EAAhB;AACA,MAAI2P,YAAY,GAAGjZ,KAAK,CAACiJ,QAAN,CAAeM,KAAlC;AAEA,MAAIjJ,IAAI,GAAGN,KAAK,CAACM,IAAjB;AACA,MAAIiJ,KAAK,GAAGjJ,IAAI,CAACiJ,KAAjB;AAEA,MAAItF,KAAK,GAAG3D,IAAI,CAACyyB,MAAL,CAAYzyB,IAAI,CAAC2D,KAAjB,CAAZ;AACA,MAAI+uB,UAAU,GAAG/uB,KAAK,CAACsF,KAAvB;AACA,MAAIpI,MAAM,GAAG6xB,UAAU,CAAC7xB,MAAxB;AAEA,MAAI8xB,KAAK,GAAG,EAAZ;AACA,MAAIC,IAAI,GAAG,EAAX;;AAEA,OAAK,IAAI9xB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,MAApB,EAA4B,EAAEC,CAA9B,EAAiC;AAC/B6xB,IAAAA,KAAK,CAAC5iB,IAAN,CAAW;AACT8iB,MAAAA,iBAAiB,EAAE5xB,SADV;AAETutB,MAAAA,QAAQ,EAAEvlB,KAAK,CAACypB,UAAU,CAAC5xB,CAAD,CAAX,CAFN;AAGTsC,MAAAA,EAAE,EAAEsvB,UAAU,CAAC5xB,CAAD;AAHL,KAAX;;AAMA,WAAO6xB,KAAK,CAAC9xB,MAAN,GAAe,CAAtB,EAAyB;AACvB,UAAIsS,CAAC,GAAGwf,KAAK,CAACG,GAAN,EAAR;AACAF,MAAAA,IAAI,CAACzf,CAAC,CAAC/P,EAAH,CAAJ,GAAa,IAAb;AACA,UAAIyvB,iBAAiB,GAAG1f,CAAC,CAAC0f,iBAA1B;AACA,UAAIrE,QAAQ,GAAGrb,CAAC,CAACqb,QAAjB,CAJuB,CAMvB;;AACA,UAAI1V,WAAW,GAAGH,YAAY,CAACxF,CAAC,CAAC/P,EAAH,CAA9B;;AACA,UAAI0V,WAAW,CAACc,OAAZ,CAAoB/Y,MAApB,KAA+B,CAAnC,EAAsC;AACpC,YAAI3F,OAAO,CAACszB,QAAQ,CAAC/a,MAAV,CAAX,EAA8B;AAC5BqF,UAAAA,WAAW,CAACrF,MAAZ,GAAqBxX,OAAO,CAAC82B,oBAAR,CAA6BvE,QAAQ,CAAC/a,MAAtC,CAArB;AACD,SAFD,MAEO;AACL;AACA,cAAItB,QAAQ,GAAGqc,QAAQ,CAACrc,QAAxB;AACA2G,UAAAA,WAAW,CAACC,WAAZ,GAA0Bve,UAAU,CAAC60B,SAAX,CAAqBb,QAAQ,CAACzV,WAA9B,CAA1B;AACAD,UAAAA,WAAW,CAAC3G,QAAZ,GAAuB/V,UAAU,CAAC42B,MAAX,CAAkB7gB,QAAlB,CAAvB;AACA2G,UAAAA,WAAW,CAAChW,KAAZ,GAAoBtI,UAAU,CAAC60B,SAAX,CAAqBb,QAAQ,CAAC1rB,KAA9B,CAApB;AACD;AACF;;AAED,UAAI5H,OAAO,CAAC23B,iBAAD,CAAX,EAAgC;AAC9BA,QAAAA,iBAAiB,CAAClZ,QAAlB,CAA2B5J,IAA3B,CAAgC+I,WAAhC;AACAA,QAAAA,WAAW,CAACc,OAAZ,CAAoB7J,IAApB,CAAyB8iB,iBAAzB;AACD,OAHD,MAGO;AACL7pB,QAAAA,SAAS,CAAC+G,IAAV,CAAe+I,WAAf;AACD;;AAED,UAAI5d,OAAO,CAACszB,QAAQ,CAACtT,IAAV,CAAX,EAA4B;AAC1BqT,QAAAA,aAAa,CAAC7uB,KAAD,EAAQ8uB,QAAR,EAAkB1V,WAAlB,EAA+B1J,OAA/B,EAAwCqf,WAAxC,CAAb;AACD;;AAED,UAAI9U,QAAQ,GAAG6U,QAAQ,CAAC7U,QAAxB;;AACA,UAAIze,OAAO,CAACye,QAAD,CAAX,EAAuB;AACrB,YAAIsZ,cAAc,GAAGtZ,QAAQ,CAAC9Y,MAA9B;;AACA,aAAK,IAAIgjB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoP,cAApB,EAAoCpP,CAAC,EAArC,EAAyC;AACvC,cAAIqP,OAAO,GAAGvZ,QAAQ,CAACkK,CAAD,CAAtB;;AACA,cAAI,CAAC+O,IAAI,CAACM,OAAD,CAAT,EAAoB;AAClBP,YAAAA,KAAK,CAAC5iB,IAAN,CAAW;AACT8iB,cAAAA,iBAAiB,EAAE/Z,WADV;AAET0V,cAAAA,QAAQ,EAAEvlB,KAAK,CAACiqB,OAAD,CAFN;AAGT9vB,cAAAA,EAAE,EAAEuW,QAAQ,CAACkK,CAAD;AAHH,aAAX;AAKD;AACF;AACF;AACF;AACF;;AAEDnkB,EAAAA,KAAK,CAACiJ,QAAN,CAAeK,SAAf,GAA2BA,SAA3B;AACAtJ,EAAAA,KAAK,CAACiJ,QAAN,CAAeM,KAAf,GAAuB0P,YAAvB;AACD;;AAED,SAASwa,qBAAT,CAA+BtpB,OAA/B,EAAwC;AACtC,MAAIupB,MAAM,GAAG,CAAb;;AACA,OAAK,IAAIhwB,EAAT,IAAeyG,OAAf,EAAwB;AACtB,QAAIA,OAAO,CAACoJ,cAAR,CAAuB7P,EAAvB,CAAJ,EAAgC;AAC9BgwB,MAAAA,MAAM,IAAIvpB,OAAO,CAACzG,EAAD,CAAP,CAAYgZ,WAAtB;AACD;AACF;;AACD,SAAOgX,MAAP;AACD;;AAED,SAASC,qBAAT,CAA+BnpB,QAA/B,EAAyC;AACvC,MAAIkpB,MAAM,GAAG,CAAb;;AACA,OAAK,IAAIhwB,EAAT,IAAe8G,QAAf,EAAyB;AACvB,QAAIA,QAAQ,CAAC+I,cAAT,CAAwB7P,EAAxB,CAAJ,EAAiC;AAC/BgwB,MAAAA,MAAM,IAAIlpB,QAAQ,CAAC9G,EAAD,CAAR,CAAagZ,WAAvB;AACD;AACF;;AACD,SAAOgX,MAAP;AACD;;AAED,SAASE,eAAT,CAAyB5zB,KAAzB,EAAgCkd,UAAhC,EAA4C;AAC1C,MAAIxN,OAAO,GAAGwN,UAAU,CAACxN,OAAzB;AACA,MAAIqf,WAAW,GAAG7R,UAAU,CAAC6R,WAA7B;AACA,MAAItQ,sBAAsB,GAAGze,KAAK,CAACuL,uBAAnC;AACA,MAAI+O,UAAU,GAAGta,KAAK,CAACqL,iBAAvB;AACA,MAAIhB,QAAQ,GAAGrK,KAAK,CAACsL,eAArB;AAEA,MAAI2jB,SAAS,GAAGjvB,KAAK,CAACkK,kBAAtB;AACA,MAAI6L,OAAO,GAAGkZ,SAAS,CAAC3kB,aAAxB;;AACA,MAAItK,KAAK,CAAC4K,+BAAV,EAA2C;AACzCmL,IAAAA,OAAO,GAAGkZ,SAAS,CAAC3kB,aAAV,GACRtK,KAAK,CAAC2K,wBAAN,CAA+BL,aADjC;AAED;;AAED,OAAK,IAAIqL,WAAT,IAAwB2E,UAAxB,EAAoC;AAClC,QAAIA,UAAU,CAAC/G,cAAX,CAA0BoC,WAA1B,CAAJ,EAA4C;AAC1C,UAAIC,SAAS,GAAG0E,UAAU,CAAC3E,WAAD,CAAV,CAAwBE,OAAxC;AACA,UAAIA,OAAO,GAAGxL,QAAQ,CAACuL,SAAD,CAAtB;AACA,UAAIM,MAAM,GAAGH,OAAO,CAACF,OAAO,CAACyI,YAAT,CAApB;AAEAlf,MAAAA,YAAY,CAACy0B,0BAAb,CAAwChe,OAAO,CAACie,YAAhD,EAA8DpkB,OAA9D;;AAEA,UACE1P,KAAK,CAACmO,cAAN,CAAqBuN,0BAArB,IACA1b,KAAK,CAAC6K,mBAFR,EAGE;AACA,YAAI6T,WAAW,GAAGD,sBAAsB,CAAC7I,SAAD,CAAxC;;AACA,YAAI,CAACpa,OAAO,CAACkjB,WAAD,CAAZ,EAA2B;AACzBA,UAAAA,WAAW,GAAGnB,kCAAkC,CAC9CrH,MAD8C,EAE9CN,SAF8C,EAG9C5V,KAH8C,CAAhD;AAKAye,UAAAA,sBAAsB,CAAC7I,SAAD,CAAtB,GAAoC8I,WAApC;AACD;;AACDxI,QAAAA,MAAM,GAAGwI,WAAT;AACD;;AAEDxI,MAAAA,MAAM,GAAG8H,YAAY,CAAC9H,MAAD,EAASN,SAAT,EAAoB5V,KAAK,CAAC6G,mBAA1B,CAArB;AACD;AACF;;AAED,MAAI7G,KAAK,CAAC4K,+BAAV,EAA2C;AACzC,QAAImpB,eAAe,GAAG/zB,KAAK,CAAC2K,wBAA5B;AAEAskB,IAAAA,SAAS,CAAC9kB,OAAV,GAAoB4pB,eAAe,CAAC5pB,OAApC;AACA8kB,IAAAA,SAAS,CAAC7kB,YAAV,GAAyB2pB,eAAe,CAAC3pB,YAAzC;AACA6kB,IAAAA,SAAS,CAAC5kB,QAAV,GAAqB0pB,eAAe,CAAC1pB,QAArC;AACA4kB,IAAAA,SAAS,CAAC1kB,kBAAV,GAA+BwpB,eAAe,CAACxpB,kBAA/C;AACA0kB,IAAAA,SAAS,CAACzkB,QAAV,GAAqBupB,eAAe,CAACvpB,QAArC;AACAykB,IAAAA,SAAS,CAACxkB,QAAV,GAAqBspB,eAAe,CAACtpB,QAArC;AACAwkB,IAAAA,SAAS,CAACvkB,YAAV,GAAyBqpB,eAAe,CAACrpB,YAAzC,CATyC,CAWzC;;AACA,QAAIlP,OAAO,CAACwE,KAAK,CAAC2G,qBAAP,CAAX,EAA0C;AACxC0f,MAAAA,kBAAkB,CAACrmB,KAAD,EAAQ0P,OAAR,CAAlB;AACD;;AAED1P,IAAAA,KAAK,CAACgL,yBAAN,IAAmCyoB,qBAAqB,CACtDM,eAAe,CAAC5pB,OADsC,CAAxD;AAGAnK,IAAAA,KAAK,CAACiL,yBAAN,IAAmC0oB,qBAAqB,CACtDI,eAAe,CAACvpB,QADsC,CAAxD;AAGD,GAtBD,MAsBO;AACLyS,IAAAA,aAAa,CAACjd,KAAD,EAAQkd,UAAR,CAAb,CADK,CAC6B;;AAClC6C,IAAAA,cAAc,CAAC/f,KAAD,EAAQkd,UAAR,CAAd;AACAuD,IAAAA,cAAc,CAACzgB,KAAD,EAAQ0P,OAAR,CAAd;AACA0Q,IAAAA,2BAA2B,CAACpgB,KAAD,CAA3B;AACAwjB,IAAAA,cAAc,CAACxjB,KAAD,EAAQkd,UAAR,CAAd;AACD;;AAEDwH,EAAAA,WAAW,CAAC1kB,KAAD,CAAX;AACAolB,EAAAA,uBAAuB,CAACplB,KAAD,CAAvB;;AAEA,MAAI,CAACA,KAAK,CAAC4K,+BAAX,EAA4C;AAC1Cyb,IAAAA,kBAAkB,CAACrmB,KAAD,EAAQ0P,OAAR,CAAlB,CAD0C,CACN;;AACpC+X,IAAAA,kBAAkB,CAACznB,KAAD,CAAlB,CAF0C,CAEf;AAC3B;AACA;AACA;AACD;;AAEDqsB,EAAAA,iBAAiB,CAACrsB,KAAD,EAAQ0P,OAAR,CAAjB,CAnF0C,CAmFP;;AACnCmjB,EAAAA,kBAAkB,CAAC7yB,KAAD,EAAQ0P,OAAR,EAAiBqf,WAAjB,CAAlB,CApF0C,CAoFO;AAClD,C,CAED;;;AAEA,SAASiF,aAAT,CAAuB1iB,IAAvB,EAA6BiB,MAA7B,EAAqC;AACnC,MAAIhB,UAAU,GAAGD,IAAI,CAACC,UAAtB;AACA,MAAI0iB,YAAY,GAAG1iB,UAAU,CAACwC,MAA9B;;AAEA,MAAIxC,UAAU,CAAC2iB,SAAX,IAAwB14B,OAAO,CAACy4B,YAAD,CAAnC,EAAmD;AACjD;AACA13B,IAAAA,OAAO,CAACrB,KAAR,CAAc+4B,YAAd,EAA4B1hB,MAA5B;AACD,GAHD,MAGO,IAAI/W,OAAO,CAAC8V,IAAI,CAACyC,MAAN,CAAX,EAA0B;AAC/BxX,IAAAA,OAAO,CAACrB,KAAR,CAAcoW,IAAI,CAACyC,MAAnB,EAA2BxB,MAA3B;AACD,GAFM,MAEA;AACLhW,IAAAA,OAAO,CAAC43B,sCAAR,CACE7iB,IAAI,CAAC+H,WADP,EAEE/H,IAAI,CAACmB,QAFP,EAGEnB,IAAI,CAAClO,KAHP,EAIEmP,MAJF,EADK,CAOL;;AACAhB,IAAAA,UAAU,CAAC6iB,SAAX,CAAqB7hB,MAArB;AACD;AACF;;AAED,IAAI8hB,gBAAgB,GAAG,EAAvB;AACA,IAAIC,0BAA0B,GAAG,IAAIv5B,UAAJ,EAAjC;AACA,IAAIw5B,yBAAyB,GAAG,IAAIh4B,OAAJ,EAAhC;;AAEA,SAASi4B,8BAAT,CACEx0B,KADF,EAEEy0B,qBAFF,EAGEC,UAHF,EAIEjL,UAJF,EAKE;AACA,MAAIkL,cAAc,GAAG30B,KAAK,CAACgJ,eAA3B;AAEA,MAAIM,SAAS,GAAGtJ,KAAK,CAACiJ,QAAN,CAAeK,SAA/B;AACA,MAAInI,MAAM,GAAGmI,SAAS,CAACnI,MAAvB;AAEA,MAAIyzB,SAAS,GAAGP,gBAAhB;AACA,MAAIQ,mBAAmB,GAAG70B,KAAK,CAACmI,oBAAhC;;AAEA,MAAInI,KAAK,CAAC4I,KAAN,KAAgBpJ,SAAS,CAACs1B,OAA1B,IAAqC,CAAC90B,KAAK,CAACqH,eAAhD,EAAiE;AAC/D,QAAIgS,WAAW,GAAG9c,OAAO,CAACw4B,SAAR,CAChBF,mBADgB,EAEhB,CAFgB,EAGhBP,0BAHgB,CAAlB;;AAKA,QAAI,CAACv5B,UAAU,CAACsU,MAAX,CAAkBgK,WAAlB,EAA+Bte,UAAU,CAACi6B,MAA1C,CAAL,EAAwD;AACtDH,MAAAA,mBAAmB,GAAGj4B,UAAU,CAACq4B,SAAX,CACpBxL,UADoB,EAEpBoL,mBAFoB,EAGpBN,yBAHoB,CAAtB;AAKAv0B,MAAAA,KAAK,CAAC0L,UAAN,GAAmB1L,KAAK,CAAC4L,YAAzB;AACD,KAPD,MAOO;AACL,UAAI4B,MAAM,GAAGxN,KAAK,CAACgN,cAAN,CAAqBQ,MAAlC;AACA,UAAI0nB,IAAI,GAAGt4B,UAAU,CAACu4B,oBAAX,CACT1L,UADS,EAETjc,MAFS,EAGT+mB,yBAHS,CAAX;AAKAM,MAAAA,mBAAmB,GAAGt4B,OAAO,CAAC2tB,QAAR,CACpBgL,IADoB,EAEpBL,mBAFoB,EAGpBN,yBAHoB,CAAtB;;AAMA,UAAI/4B,OAAO,CAACwE,KAAK,CAAC0L,UAAP,CAAX,EAA+B;AAC7BnP,QAAAA,OAAO,CAACwtB,cAAR,CACE8K,mBADF,EAEE95B,UAAU,CAACi6B,MAFb,EAGEH,mBAHF;AAKA70B,QAAAA,KAAK,CAAC0L,UAAN,GAAmB1L,KAAK,CAAC6L,YAAzB;AACD;AACF;AACF;;AAED,OAAK,IAAIzK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,MAApB,EAA4B,EAAEC,CAA9B,EAAiC;AAC/B,QAAIqS,CAAC,GAAGnK,SAAS,CAAClI,CAAD,CAAjB;AAEA4yB,IAAAA,aAAa,CAACvgB,CAAD,EAAIA,CAAC,CAAC8F,eAAN,CAAb;AACAqb,IAAAA,SAAS,CAACvkB,IAAV,CAAeoD,CAAf;;AAEA,WAAOmhB,SAAS,CAACzzB,MAAV,GAAmB,CAA1B,EAA6B;AAC3BsS,MAAAA,CAAC,GAAGmhB,SAAS,CAACxB,GAAV,EAAJ;AACA,UAAI7Z,eAAe,GAAG9F,CAAC,CAAC8F,eAAxB;AACA,UAAIG,QAAQ,GAAGjG,CAAC,CAACiG,QAAjB;;AAEA,UACEjG,CAAC,CAACgG,WAAF,KAAkBkb,cAAlB,IACAF,qBADA,IAEAC,UAHF,EAIE;AACA,YAAIU,UAAU,GAAG74B,OAAO,CAACqtB,sBAAR,CACfiL,mBADe,EAEftb,eAFe,EAGf9F,CAAC,CAAC+F,cAHa,CAAjB;AAKA,YAAI6b,cAAc,GAAG3b,QAAQ,CAACvY,MAA9B;;AACA,YAAIk0B,cAAc,GAAG,CAArB,EAAwB;AACtB;AACA,eAAK,IAAIlR,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkR,cAApB,EAAoC,EAAElR,CAAtC,EAAyC;AACvC,gBAAImR,gBAAgB,GAAG5b,QAAQ,CAACyK,CAAD,CAA/B;AACA,gBAAIwN,OAAO,GAAG2D,gBAAgB,CAAC3D,OAA/B;AACAp1B,YAAAA,OAAO,CAACrB,KAAR,CAAck6B,UAAd,EAA0BzD,OAAO,CAAC3uB,WAAlC,EAHuC,CAKvC;;AACApI,YAAAA,cAAc,CAAC8Y,SAAf,CACE4hB,gBAAgB,CAACtoB,cADnB,EAEE2kB,OAAO,CAAC3uB,WAFV,EAGE2uB,OAAO,CAACC,cAHV;;AAMA,gBAAIp2B,OAAO,CAACwE,KAAK,CAAC0L,UAAP,CAAX,EAA+B;AAC7B5Q,cAAAA,UAAU,CAAC8S,GAAX,CACE5N,KAAK,CAAC0L,UADR,EAEEimB,OAAO,CAACC,cAAR,CAAuBpkB,MAFzB,EAGEmkB,OAAO,CAACC,cAAR,CAAuBpkB,MAHzB;AAKD,aAlBsC,CAoBvC;AACA;AACA;AACA;;;AACAmkB,YAAAA,OAAO,GAAG2D,gBAAgB,CAACpD,SAA3B;;AACA,gBAAI12B,OAAO,CAACm2B,OAAD,CAAP,IAAoB3xB,KAAK,CAAC4I,KAAN,KAAgBpJ,SAAS,CAAC+1B,OAAlD,EAA2D;AACzDh5B,cAAAA,OAAO,CAACrB,KAAR,CAAck6B,UAAd,EAA0BzD,OAAO,CAAC3uB,WAAlC;AACA2uB,cAAAA,OAAO,CAAC3uB,WAAR,CAAoB,EAApB,KACE3G,UAAU,CAACm5B,IAAX,CAAgB7D,OAAO,CAAC3uB,WAAR,CAAoB,EAApB,CAAhB,IACA,GADA,GAEA3G,UAAU,CAACo5B,EAFX,GAGAhM,UAAU,CAACiM,SAAX,CAAqBC,aAJvB;AAKA/6B,cAAAA,cAAc,CAAC8Y,SAAf,CACE4hB,gBAAgB,CAACtoB,cADnB,EAEE2kB,OAAO,CAAC3uB,WAFV,EAGE2uB,OAAO,CAACC,cAHV;AAKD;AACF;AACF;AACF;;AAED,UAAI3X,QAAQ,GAAGxG,CAAC,CAACwG,QAAjB;;AACA,UAAIze,OAAO,CAACye,QAAD,CAAX,EAAuB;AACrB,YAAIsZ,cAAc,GAAGtZ,QAAQ,CAAC9Y,MAA9B;;AACA,aAAK,IAAIy0B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGrC,cAApB,EAAoC,EAAEqC,CAAtC,EAAyC;AACvC,cAAIC,KAAK,GAAG5b,QAAQ,CAAC2b,CAAD,CAApB,CADuC,CAGvC;AACA;AACA;AAEA;AACA;AACA;;AACAC,UAAAA,KAAK,CAACpc,WAAN,GAAoBrM,IAAI,CAAC+Y,GAAL,CAAS0P,KAAK,CAACpc,WAAf,EAA4BhG,CAAC,CAACgG,WAA9B,CAApB;;AAEA,cAAIoc,KAAK,CAACpc,WAAN,KAAsBkb,cAAtB,IAAwCD,UAA5C,EAAwD;AACtD;AACA;AACA;AACAV,YAAAA,aAAa,CAAC6B,KAAD,EAAQA,KAAK,CAACtc,eAAd,CAAb;AACAhd,YAAAA,OAAO,CAACqtB,sBAAR,CACErQ,eADF,EAEEsc,KAAK,CAACtc,eAFR,EAGEsc,KAAK,CAACtc,eAHR;AAKD;;AAEDqb,UAAAA,SAAS,CAACvkB,IAAV,CAAewlB,KAAf;AACD;AACF;AACF;AACF;;AAED,IAAE71B,KAAK,CAACgJ,eAAR;AACD;;AAED,IAAI8sB,kBAAkB,GAAG,IAAIv5B,OAAJ,EAAzB;;AAEA,SAASw5B,UAAT,CAAoB/1B,KAApB,EAA2B;AACzB,MAAIyJ,YAAY,GAAGzJ,KAAK,CAACiJ,QAAN,CAAeQ,YAAlC;AACA,MAAItI,MAAM,GAAGsI,YAAY,CAACtI,MAA1B;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,MAApB,EAA4B,EAAEC,CAA9B,EAAiC;AAC/B,QAAIkQ,IAAI,GAAG7H,YAAY,CAACrI,CAAD,CAAvB;AAEA00B,IAAAA,kBAAkB,GAAGv5B,OAAO,CAACy5B,qBAAR,CACnB1kB,IAAI,CAACiI,eADc,EAEnBuc,kBAFmB,CAArB;AAKA,QAAIhc,qBAAqB,GAAGxI,IAAI,CAACwI,qBAAjC;AACA,QAAID,MAAM,GAAGvI,IAAI,CAACuI,MAAlB;AACA,QAAID,eAAe,GAAGtI,IAAI,CAACsI,eAA3B;AACA,QAAID,mBAAmB,GAAGrI,IAAI,CAACqI,mBAA/B;AACA,QAAIsc,yBAAyB,GAAGtc,mBAAmB,CAACxY,MAApD;;AAEA,SAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG40B,yBAApB,EAA+C,EAAE50B,CAAjD,EAAoD;AAClD;AACA,UAAI,CAAC7F,OAAO,CAACse,qBAAqB,CAACzY,CAAD,CAAtB,CAAZ,EAAwC;AACtCyY,QAAAA,qBAAqB,CAACzY,CAAD,CAArB,GAA2B,IAAI9E,OAAJ,EAA3B;AACD;;AACDud,MAAAA,qBAAqB,CAACzY,CAAD,CAArB,GAA2B9E,OAAO,CAACqtB,sBAAR,CACzBkM,kBADyB,EAEzBjc,MAAM,CAACxY,CAAD,CAAN,CAAUkY,eAFe,EAGzBO,qBAAqB,CAACzY,CAAD,CAHI,CAA3B;AAKAyY,MAAAA,qBAAqB,CAACzY,CAAD,CAArB,GAA2B9E,OAAO,CAACqtB,sBAAR,CACzB9P,qBAAqB,CAACzY,CAAD,CADI,EAEzBsY,mBAAmB,CAACtY,CAAD,CAFM,EAGzByY,qBAAqB,CAACzY,CAAD,CAHI,CAA3B;;AAKA,UAAI7F,OAAO,CAACoe,eAAD,CAAX,EAA8B;AAC5B;AACAE,QAAAA,qBAAqB,CAACzY,CAAD,CAArB,GAA2B9E,OAAO,CAACqtB,sBAAR,CACzB9P,qBAAqB,CAACzY,CAAD,CADI,EAEzBuY,eAFyB,EAGzBE,qBAAqB,CAACzY,CAAD,CAHI,CAA3B;AAKD;AACF;AACF;AACF;;AAED,SAAS60B,iBAAT,CAA2Bl2B,KAA3B,EAAkC;AAChC;AACA;AAEA,MAAIsJ,SAAS,GAAGtJ,KAAK,CAACiJ,QAAN,CAAeK,SAA/B;AACA,MAAInI,MAAM,GAAGmI,SAAS,CAACnI,MAAvB;AAEA,MAAIyzB,SAAS,GAAGP,gBAAhB;;AAEA,OAAK,IAAIjzB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,MAApB,EAA4B,EAAEC,CAA9B,EAAiC;AAC/B,QAAIqS,CAAC,GAAGnK,SAAS,CAAClI,CAAD,CAAjB;AACAqS,IAAAA,CAAC,CAAC6F,YAAF,GAAiB7F,CAAC,CAAClC,UAAF,CAAa9O,IAA9B;AACAmyB,IAAAA,SAAS,CAACvkB,IAAV,CAAeoD,CAAf;;AAEA,WAAOmhB,SAAS,CAACzzB,MAAV,GAAmB,CAA1B,EAA6B;AAC3BsS,MAAAA,CAAC,GAAGmhB,SAAS,CAACxB,GAAV,EAAJ;AACA,UAAI3wB,IAAI,GAAGgR,CAAC,CAAC6F,YAAb;AAEA,UAAI0V,YAAY,GAAGvb,CAAC,CAACiG,QAArB;AACA,UAAIyc,kBAAkB,GAAGnH,YAAY,CAAC7tB,MAAtC;;AACA,WAAK,IAAIgjB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGgS,kBAApB,EAAwC,EAAEhS,CAA1C,EAA6C;AAC3C6K,QAAAA,YAAY,CAAC7K,CAAD,CAAZ,CAAgB1hB,IAAhB,GAAuBA,IAAvB;AACD,OAR0B,CAS3B;;;AAEA,UAAIwX,QAAQ,GAAGxG,CAAC,CAACwG,QAAjB;;AACA,UAAIze,OAAO,CAACye,QAAD,CAAX,EAAuB;AACrB,YAAIsZ,cAAc,GAAGtZ,QAAQ,CAAC9Y,MAA9B;;AACA,aAAK,IAAIy0B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGrC,cAApB,EAAoC,EAAEqC,CAAtC,EAAyC;AACvC,cAAIC,KAAK,GAAG5b,QAAQ,CAAC2b,CAAD,CAApB,CADuC,CAEvC;;AACAC,UAAAA,KAAK,CAACvc,YAAN,GAAqB7W,IAAI,IAAIozB,KAAK,CAACtkB,UAAN,CAAiB9O,IAA9C;AACAmyB,UAAAA,SAAS,CAACvkB,IAAV,CAAewlB,KAAf;AACD;AACF;AACF;AACF;AACF;;AAED,SAASO,aAAT,CAAuBp2B,KAAvB,EAA8B0P,OAA9B,EAAuC;AACrC,MAAIhM,EAAE,GAAG1D,KAAK,CAAC0D,EAAf;;AACA,MAAI1D,KAAK,CAAC2D,GAAN,KAAcD,EAAlB,EAAsB;AACpB1D,IAAAA,KAAK,CAAC2D,GAAN,GAAYD,EAAZ;AAEA,QAAImL,OAAO,GAAG7O,KAAK,CAACyL,QAApB;AACA,QAAItK,MAAM,GAAG0N,OAAO,CAAC1N,MAArB;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,MAApB,EAA4B,EAAEC,CAA9B,EAAiC;AAC/ByN,MAAAA,OAAO,CAACzN,CAAD,CAAP,CAAW2N,MAAX,CAAkBrL,EAAlB,GAAuBA,EAAvB;AACD;AACF;AACF;;AAED,SAAS2yB,eAAT,CAAyBr2B,KAAzB,EAAgC;AAC9B,MAAIA,KAAK,CAACsG,eAAN,KAA0BtG,KAAK,CAACqG,cAApC,EAAoD;AAClDrG,IAAAA,KAAK,CAACsG,eAAN,GAAwBtG,KAAK,CAACqG,cAA9B,CADkD,CAGlD;AACA;;AACA,QAAIwrB,aAAa,GAAG7xB,KAAK,CAACqG,cAAN,GAChB5J,aAAa,CAAC65B,KADE,GAEhB75B,aAAa,CAACiyB,SAFlB;AAGA,QAAIM,YAAY,GAAGhvB,KAAK,CAACwL,aAAzB;AACA,QAAIrK,MAAM,GAAG6tB,YAAY,CAAC7tB,MAA1B;;AAEA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,MAApB,EAA4B,EAAEC,CAA9B,EAAiC;AAC/B4tB,MAAAA,YAAY,CAAC5tB,CAAD,CAAZ,CAAgBuwB,OAAhB,CAAwBE,aAAxB,GAAwCA,aAAxC;AACD;AACF;AACF;;AAED,SAAS0E,wBAAT,CAAkCv2B,KAAlC,EAAyC;AACvC,MAAIA,KAAK,CAACmG,uBAAN,KAAkCnG,KAAK,CAACoG,wBAA5C,EAAsE;AACpEpG,IAAAA,KAAK,CAACoG,wBAAN,GAAiCpG,KAAK,CAACmG,uBAAvC;AAEA,QAAIA,uBAAuB,GAAGnG,KAAK,CAACmG,uBAApC;AACA,QAAI6oB,YAAY,GAAGhvB,KAAK,CAACwL,aAAzB;AACA,QAAIrK,MAAM,GAAG6tB,YAAY,CAAC7tB,MAA1B;;AAEA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,MAApB,EAA4B,EAAEC,CAA9B,EAAiC;AAC/B4tB,MAAAA,YAAY,CAAC5tB,CAAD,CAAZ,CAAgBuwB,OAAhB,CAAwBxrB,uBAAxB,GAAkDA,uBAAlD;AACD;AACF;AACF;;AAED,SAASqwB,aAAT,CAAuBx2B,KAAvB,EAA8B;AAC5B,MAAIA,KAAK,CAACoF,OAAN,KAAkBpF,KAAK,CAACsF,QAA5B,EAAsC;AACpCtF,IAAAA,KAAK,CAACsF,QAAN,GAAiBtF,KAAK,CAACoF,OAAvB;AAEA,QAAIisB,WAAW,GAAG5xB,UAAU,CAAC4xB,WAAX,CAAuBrxB,KAAK,CAACoF,OAA7B,CAAlB;AACA,QAAIksB,cAAc,GAAG7xB,UAAU,CAAC6xB,cAAX,CAA0BtxB,KAAK,CAACoF,OAAhC,CAArB;AACA,QAAI4pB,YAAY,GAAGhvB,KAAK,CAACwL,aAAzB;AACA,QAAIrK,MAAM,GAAG6tB,YAAY,CAAC7tB,MAA1B;;AAEA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,MAApB,EAA4BC,CAAC,EAA7B,EAAiC;AAC/B,UAAIgxB,WAAW,GAAGpD,YAAY,CAAC5tB,CAAD,CAA9B;AACAgxB,MAAAA,WAAW,CAACT,OAAZ,CAAoBN,WAApB,GAAkCA,WAAlC;AACAe,MAAAA,WAAW,CAACT,OAAZ,CAAoBL,cAApB,GAAqCA,cAArC;AACD;AACF;AACF;;AAED,SAASmF,yBAAT,CAAmC1E,WAAnC,EAAgD;AAC9C,MAAIb,EAAE,GAAGh2B,KAAK,CAAC62B,WAAD,EAAc,IAAd,CAAd;AACAb,EAAAA,EAAE,CAAClpB,IAAH,CAAQ8H,OAAR,GAAkB,KAAlB;AACAohB,EAAAA,EAAE,CAAC1I,SAAH,CAAa1Y,OAAb,GAAuB,IAAvB;AACAohB,EAAAA,EAAE,CAACvI,SAAH,GAAe,KAAf;AACAuI,EAAAA,EAAE,CAACtI,QAAH,GAAcxqB,aAAa,CAACs4B,WAA5B;AAEA,SAAOx5B,WAAW,CAACyiB,SAAZ,CAAsBuR,EAAtB,CAAP;AACD;;AAED,SAASyF,wBAAT,CAAkChF,OAAlC,EAA2C;AACzC,MAAIc,kBAAkB,GAAGz1B,WAAW,CAACm1B,YAAZ,CAAyBR,OAAzB,CAAzB;AACAc,EAAAA,kBAAkB,CAACT,IAAnB,GAA0B/0B,IAAI,CAACg1B,WAA/B;AACAQ,EAAAA,kBAAkB,CAACV,WAAnB,GAAiC0E,yBAAyB,CACxD9E,OAAO,CAACI,WADgD,CAA1D;AAGA,SAAOU,kBAAP;AACD;;AAED,SAASmE,WAAT,CAAqB52B,KAArB,EAA4Bkd,UAA5B,EAAwC2Z,WAAxC,EAAqD;AACnD;AACA,MAAI9H,WAAW,GAAG7R,UAAU,CAAC6R,WAA7B;AACA,MAAIrB,KAAK,GAAG1tB,KAAK,CAACuF,KAAN,CAAYmoB,KAAxB;;AACA,MAAIA,KAAK,GAAG,GAAR,IAAeA,KAAK,GAAG,GAA3B,EAAgC;AAC9B,QAAIsB,YAAY,GAAGhvB,KAAK,CAACwL,aAAzB;AACA,QAAIrK,MAAM,GAAG6tB,YAAY,CAAC7tB,MAA1B;;AACA,QACEA,MAAM,GAAG,CAAT,KACC,CAAC3F,OAAO,CAACwzB,YAAY,CAAC,CAAD,CAAZ,CAAgByD,kBAAjB,CAAR,IAAgDoE,WADjD,CADF,EAGE;AACA,WAAK,IAAIz1B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,MAApB,EAA4B,EAAEC,CAA9B,EAAiC;AAC/B,YAAIgxB,WAAW,GAAGpD,YAAY,CAAC5tB,CAAD,CAA9B;AACA,YAAIuwB,OAAO,GAAGS,WAAW,CAACT,OAA1B;AACAS,QAAAA,WAAW,CAACK,kBAAZ,GAAiCkE,wBAAwB,CAAChF,OAAD,CAAzD;;AACA,YAAI,CAAC5C,WAAL,EAAkB;AAChB,cAAImD,SAAS,GAAGE,WAAW,CAACF,SAA5B;AACAE,UAAAA,WAAW,CAACM,oBAAZ,GAAmCiE,wBAAwB,CACzDzE,SADyD,CAA3D;AAGD;AACF;AACF;AACF;AACF;;AAED,SAAS4E,4BAAT,CAAsC/E,WAAtC,EAAmD;AACjD,MAAIb,EAAE,GAAGh2B,KAAK,CAAC62B,WAAD,EAAc,IAAd,CAAd;AACAb,EAAAA,EAAE,CAAClpB,IAAH,CAAQ8H,OAAR,GAAkB,KAAlB;AACA,SAAO5S,WAAW,CAACyiB,SAAZ,CAAsBuR,EAAtB,CAAP;AACD;;AAED,SAAS6F,2BAAT,CAAqCpF,OAArC,EAA8C;AAC5C,MAAIgB,qBAAqB,GAAG31B,WAAW,CAACm1B,YAAZ,CAAyBR,OAAzB,CAA5B;AACAgB,EAAAA,qBAAqB,CAACZ,WAAtB,GAAoC+E,4BAA4B,CAC9DnF,OAAO,CAACI,WADsD,CAAhE;AAGA,SAAOY,qBAAP;AACD;;AAED,SAASqE,qBAAT,CAA+Bh3B,KAA/B,EAAsCkd,UAAtC,EAAkD2Z,WAAlD,EAA+D;AAC7D,MAAI9H,WAAW,GAAG7R,UAAU,CAAC6R,WAA7B;AACA,MAAI7oB,eAAe,GAAGlG,KAAK,CAACkG,eAA5B;;AACA,MAAI,CAACA,eAAL,EAAsB;AACpB,QAAI8oB,YAAY,GAAGhvB,KAAK,CAACwL,aAAzB;AACA,QAAIrK,MAAM,GAAG6tB,YAAY,CAAC7tB,MAA1B;;AACA,QACEA,MAAM,GAAG,CAAT,KACC,CAAC3F,OAAO,CAACwzB,YAAY,CAAC,CAAD,CAAZ,CAAgB2D,qBAAjB,CAAR,IAAmDkE,WADpD,CADF,EAGE;AACA,WAAK,IAAIz1B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,MAApB,EAA4B,EAAEC,CAA9B,EAAiC;AAC/B,YAAIgxB,WAAW,GAAGpD,YAAY,CAAC5tB,CAAD,CAA9B;AACA,YAAIuwB,OAAO,GAAGS,WAAW,CAACT,OAA1B;AACAS,QAAAA,WAAW,CAACO,qBAAZ,GAAoCoE,2BAA2B,CAC7DpF,OAD6D,CAA/D;;AAGA,YAAI,CAAC5C,WAAL,EAAkB;AAChB,cAAImD,SAAS,GAAGE,WAAW,CAACF,SAA5B;AACAE,UAAAA,WAAW,CAACQ,uBAAZ,GAAsCmE,2BAA2B,CAC/D7E,SAD+D,CAAjE;AAGD;AACF;AACF;AACF;AACF;;AAED,SAAS+E,YAAT,CAAsBj3B,KAAtB,EAA6B6V,OAA7B,EAAsC;AACpC,MAAIxL,QAAQ,GAAGrK,KAAK,CAACkK,kBAAN,CAAyBG,QAAxC;;AACA,OAAK,IAAI3G,EAAT,IAAe2G,QAAf,EAAyB;AACvB,QAAIA,QAAQ,CAACkJ,cAAT,CAAwB7P,EAAxB,CAAJ,EAAiC;AAC/B,UAAI2G,QAAQ,CAAC3G,EAAD,CAAR,KAAiBmS,OAArB,EAA8B;AAC5B,eAAOnS,EAAP;AACD;AACF;AACF;AACF;;AAED,SAASwzB,uBAAT,CAAiCl3B,KAAjC,EAAwC6V,OAAxC,EAAiDqH,UAAjD,EAA6D;AAC3D,MAAImB,EAAE,GAAGxI,OAAO,CAAC+J,kBAAR,CAA2BuX,OAA3B,CAAmC,CAAnC,CAAT;AACA,MAAI1X,kBAAkB,GAAG5J,OAAO,CAACgO,mBAAjC;AACA,MAAIuT,mBAAmB,GAAGp3B,KAAK,CAAC8C,oBAAhC,CAH2D,CAK3D;;AACAub,EAAAA,EAAE,GAAGhhB,YAAY,CAAC0gB,WAAb,CAAyBM,EAAzB,EAA6B,sBAA7B,CAAL;AACAA,EAAAA,EAAE,IACA,0CACA,gBADA,GAEA,MAFA,GAGA,gCAHA,GAIA,wCAJA,GAKA+Y,mBALA,GAMA,OANA,GAOA,qCAPA,GAQA,qCARA,GASA,iCATA,GAUA,0FAVA,GAWA,4BAXA,GAYA,GAbF;AAeA,MAAI7Y,EAAE,GACJ,0CACA,gBADA,GAEA,MAFA,GAGA,+DAHA,GAIA,GALF;AAOA,SAAOnhB,aAAa,CAACuiB,SAAd,CAAwB;AAC7BjQ,IAAAA,OAAO,EAAEwN,UAAU,CAACxN,OADS;AAE7BkQ,IAAAA,kBAAkB,EAAEvB,EAFS;AAG7BwB,IAAAA,oBAAoB,EAAEtB,EAHO;AAI7BkB,IAAAA,kBAAkB,EAAEA;AAJS,GAAxB,CAAP;AAMD;;AAED,SAAS4X,aAAT,CAAuBr3B,KAAvB,EAA8Bkd,UAA9B,EAA0C;AACxC,SACEzN,mBAAmB,CAACyN,UAAU,CAACxN,OAAZ,CAAnB,IACA1P,KAAK,CAAC+C,cAAN,GAAuB,GADvB,IAEA/C,KAAK,CAAC0C,eAAN,CAAsBgrB,KAAtB,GAA8B,GAF9B,IAGAlyB,OAAO,CAACwE,KAAK,CAAC8C,oBAAP,CAJT;AAMD;;AAED,SAASw0B,sBAAT,CAAgCt3B,KAAhC,EAAuC;AACrC,MAAIgvB,YAAY,GAAGhvB,KAAK,CAACwL,aAAzB;AACA,MAAIrK,MAAM,GAAG6tB,YAAY,CAAC7tB,MAA1B;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,MAApB,EAA4B,EAAEC,CAA9B,EAAiC;AAC/B,QAAIgxB,WAAW,GAAGpD,YAAY,CAAC5tB,CAAD,CAA9B;AACA,QAAIuwB,OAAO,GAAGS,WAAW,CAACT,OAA1B;;AACA,QAAIA,OAAO,CAACK,IAAR,KAAiB/0B,IAAI,CAACg1B,WAA1B,EAAuC;AACrC,aAAO,IAAP;AACD;AACF;;AACD,SAAO,KAAP;AACD;;AAED,SAASd,aAAT,CAAuBnxB,KAAvB,EAA8B;AAC5B,SAAOA,KAAK,CAACuF,KAAN,CAAYmoB,KAAZ,GAAoB,GAApB,IAA2B1tB,KAAK,CAACuF,KAAN,CAAYmoB,KAAZ,GAAoB,GAAtD;AACD;;AAED,SAAS6J,WAAT,CAAqBv3B,KAArB,EAA4B;AAC1B,SAAOA,KAAK,CAACuF,KAAN,CAAYmoB,KAAZ,KAAsB,GAA7B;AACD;;AAED,SAAS8J,UAAT,CAAoBC,SAApB,EAA+BC,SAA/B,EAA0C;AACxC;AACA,SACEtqB,IAAI,CAACuqB,KAAL,CAAWF,SAAX,MAA0BrqB,IAAI,CAACuqB,KAAL,CAAWD,SAAX,CAA1B,IACAtqB,IAAI,CAACwqB,IAAL,CAAUH,SAAV,MAAyBrqB,IAAI,CAACwqB,IAAL,CAAUF,SAAV,CAF3B;AAID;;AAED,IAAIG,iBAAiB,GAAG,CAAxB;;AAEA,SAASC,wBAAT,CAAkC93B,KAAlC,EAAyCkd,UAAzC,EAAqD;AACnD;AACA;AACA,MAAI6a,gBAAgB,GAAG,EAAEF,iBAAF,GAAsB,GAA7C,CAHmD,CAKnD;AACA;;AACA,MAAIG,qBAAqB,GACvBV,sBAAsB,CAACt3B,KAAD,CAAtB,IACAmxB,aAAa,CAACnxB,KAAD,CADb,IAEAA,KAAK,CAAC0C,eAAN,CAAsBgrB,KAAtB,GAA8B,GAHhC;AAIA,MAAInjB,kBAAkB,GAAGvK,KAAK,CAACkK,kBAAN,CAAyBK,kBAAlD;AACA,MAAIwkB,WAAW,GAAG7R,UAAU,CAAC6R,WAA7B;AACA,MAAIC,YAAY,GAAGhvB,KAAK,CAACwL,aAAzB;AACA,MAAIrK,MAAM,GAAG6tB,YAAY,CAAC7tB,MAA1B;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,MAApB,EAA4B,EAAEC,CAA9B,EAAiC;AAC/B,QAAIgxB,WAAW,GAAGpD,YAAY,CAAC5tB,CAAD,CAA9B;AACA,QAAIuwB,OAAO,GAAGS,WAAW,CAACT,OAA1B,CAF+B,CAI/B;;AACA,QAAIsG,YAAY,GAAG9G,aAAa,CAACnxB,KAAD,CAAb,GACfoyB,WAAW,CAACK,kBADG,GAEfd,OAFJ;AAGA,QAAIU,sBAAsB,GAAGr1B,WAAW,CAACm1B,YAAZ,CAAyB8F,YAAzB,CAA7B;AACA,QAAIlG,WAAW,GAAG72B,KAAK,CAAC+8B,YAAY,CAAClG,WAAd,CAAvB,CAT+B,CAW/B;;AACAA,IAAAA,WAAW,CAACmG,WAAZ,GAA0B;AACxBpoB,MAAAA,OAAO,EAAE,IADe;AAExBqoB,MAAAA,aAAa,EAAEt7B,cAAc,CAACu7B,MAFN;AAGxBC,MAAAA,YAAY,EAAEx7B,cAAc,CAACu7B,MAHL;AAIxBE,MAAAA,SAAS,EAAEP,gBAJa;AAKxBQ,MAAAA,IAAI,EAAE,CAAC,CALiB;AAMxBC,MAAAA,cAAc,EAAE;AACdC,QAAAA,IAAI,EAAE57B,cAAc,CAAC67B,IADP;AAEdC,QAAAA,KAAK,EAAE97B,cAAc,CAAC67B,IAFR;AAGdE,QAAAA,KAAK,EAAE/7B,cAAc,CAACg8B;AAHR,OANQ;AAWxBC,MAAAA,aAAa,EAAE;AACbL,QAAAA,IAAI,EAAE57B,cAAc,CAAC67B,IADR;AAEbC,QAAAA,KAAK,EAAE97B,cAAc,CAAC67B,IAFT;AAGbE,QAAAA,KAAK,EAAE/7B,cAAc,CAACg8B;AAHT;AAXS,KAA1B;;AAkBA,QAAItB,WAAW,CAACv3B,KAAD,CAAf,EAAwB;AACtB;AACA+xB,MAAAA,WAAW,CAACgH,SAAZ,GAAwB;AACtBC,QAAAA,GAAG,EAAE,KADiB;AAEtBC,QAAAA,KAAK,EAAE,KAFe;AAGtBC,QAAAA,IAAI,EAAE,KAHgB;AAItBxL,QAAAA,KAAK,EAAE;AAJe,OAAxB;AAMAqE,MAAAA,WAAW,CAACpJ,SAAZ,GAAwB,KAAxB;AACD;;AACDoJ,IAAAA,WAAW,GAAG70B,WAAW,CAACyiB,SAAZ,CAAsBoS,WAAtB,CAAd;AACAM,IAAAA,sBAAsB,CAACN,WAAvB,GAAqCA,WAArC;AACAK,IAAAA,WAAW,CAACC,sBAAZ,GAAqCA,sBAArC,CA1C+B,CA4C/B;;AACA,QAAIE,sBAAsB,GAAGv1B,WAAW,CAACm1B,YAAZ,CAAyBR,OAAzB,CAA7B;AACAI,IAAAA,WAAW,GAAG72B,KAAK,CAACy2B,OAAO,CAACI,WAAT,EAAsB,IAAtB,CAAnB;AACAA,IAAAA,WAAW,CAACvJ,SAAZ,CAAsB1Y,OAAtB,GAAgC,IAAhC;AACAiiB,IAAAA,WAAW,CAAC/pB,IAAZ,CAAiB8H,OAAjB,GAA2B,KAA3B;;AACA,QAAIkoB,qBAAJ,EAA2B;AACzBzF,MAAAA,sBAAsB,CAACP,IAAvB,GAA8B/0B,IAAI,CAACg1B,WAAnC;AACAF,MAAAA,WAAW,CAACpJ,SAAZ,GAAwB,KAAxB;AACAoJ,MAAAA,WAAW,CAACnJ,QAAZ,GAAuBxqB,aAAa,CAACs4B,WAArC;AACD,KArD8B,CAuD/B;;;AACA3E,IAAAA,WAAW,CAACmG,WAAZ,GAA0B;AACxBpoB,MAAAA,OAAO,EAAE,IADe;AAExBqoB,MAAAA,aAAa,EAAEt7B,cAAc,CAACs8B,QAFN;AAGxBd,MAAAA,YAAY,EAAEx7B,cAAc,CAACs8B,QAHL;AAIxBb,MAAAA,SAAS,EAAEP,gBAJa;AAKxBQ,MAAAA,IAAI,EAAE,CAAC,CALiB;AAMxBC,MAAAA,cAAc,EAAE;AACdC,QAAAA,IAAI,EAAE57B,cAAc,CAAC67B,IADP;AAEdC,QAAAA,KAAK,EAAE97B,cAAc,CAAC67B,IAFR;AAGdE,QAAAA,KAAK,EAAE/7B,cAAc,CAAC67B;AAHR,OANQ;AAWxBI,MAAAA,aAAa,EAAE;AACbL,QAAAA,IAAI,EAAE57B,cAAc,CAAC67B,IADR;AAEbC,QAAAA,KAAK,EAAE97B,cAAc,CAAC67B,IAFT;AAGbE,QAAAA,KAAK,EAAE/7B,cAAc,CAAC67B;AAHT;AAXS,KAA1B;AAiBA3G,IAAAA,WAAW,GAAG70B,WAAW,CAACyiB,SAAZ,CAAsBoS,WAAtB,CAAd,CAzE+B,CA2E/B;;AACA,QAAIlc,OAAO,GAAG8b,OAAO,CAACG,aAAtB;AACA,QAAIpuB,EAAE,GAAGuzB,YAAY,CAACj3B,KAAD,EAAQ6V,OAAR,CAArB;AACA,QAAIujB,iBAAiB,GAAG7uB,kBAAkB,CAAC7G,EAAD,CAA1C;;AACA,QAAI,CAAClI,OAAO,CAAC49B,iBAAD,CAAZ,EAAiC;AAC/BA,MAAAA,iBAAiB,GAAGlC,uBAAuB,CAACl3B,KAAD,EAAQ6V,OAAR,EAAiBqH,UAAjB,CAA3C;AACA3S,MAAAA,kBAAkB,CAAC7G,EAAD,CAAlB,GAAyB01B,iBAAzB;AACD;;AAED,QAAIC,oBAAoB,GAAGj+B,OAAO,CAACu2B,OAAO,CAAC/W,UAAT,EAAqB;AACrD0e,MAAAA,oBAAoB,EAAEtM,6BAA6B,CAAChtB,KAAD,CADE;AAErDu5B,MAAAA,mBAAmB,EAAEtM,4BAA4B,CAACjtB,KAAD;AAFI,KAArB,CAAlC;AAKAuyB,IAAAA,sBAAsB,CAACR,WAAvB,GAAqCA,WAArC;AACAQ,IAAAA,sBAAsB,CAACT,aAAvB,GAAuCsH,iBAAvC;AACA7G,IAAAA,sBAAsB,CAAC3X,UAAvB,GAAoCye,oBAApC;AACA9G,IAAAA,sBAAsB,CAAClB,WAAvB,GAAqC,KAArC;AACAkB,IAAAA,sBAAsB,CAACjB,cAAvB,GAAwC,KAAxC;AACAc,IAAAA,WAAW,CAACG,sBAAZ,GAAqCA,sBAArC;;AAEA,QAAI,CAACxD,WAAL,EAAkB;AAChB,UAAImD,SAAS,GAAGE,WAAW,CAACF,SAA5B;AACA,UAAII,wBAAwB,GAAGt1B,WAAW,CAACm1B,YAAZ,CAC7BE,sBAD6B,CAA/B;AAGAC,MAAAA,wBAAwB,CAACV,cAAzB,GAA0CM,SAAS,CAACN,cAApD;AACAU,MAAAA,wBAAwB,CAACtvB,WAAzB,GAAuCkvB,SAAS,CAAClvB,WAAjD;AACAovB,MAAAA,WAAW,CAACE,wBAAZ,GAAuCA,wBAAvC;AAEA,UAAIE,wBAAwB,GAAGx1B,WAAW,CAACm1B,YAAZ,CAC7BI,sBAD6B,CAA/B;AAGAD,MAAAA,wBAAwB,CAACV,cAAzB,GAA0CM,SAAS,CAACN,cAApD;AACAU,MAAAA,wBAAwB,CAACtvB,WAAzB,GAAuCkvB,SAAS,CAAClvB,WAAjD;AACAovB,MAAAA,WAAW,CAACI,wBAAZ,GAAuCA,wBAAvC;AACD;AACF;AACF;;AAED,SAAShT,6BAAT,CACEtJ,MADF,EAEEkJ,uBAFF,EAGE1P,OAHF,EAIE;AACAwG,EAAAA,MAAM,GAAG7Y,YAAY,CAAC0gB,WAAb,CAAyB7H,MAAzB,EAAiC,gBAAjC,CAAT;AACAA,EAAAA,MAAM,IAAIxU,KAAK,CAAC83B,oBAAN,CAA2Bpa,uBAA3B,EAAoD1P,OAApD,IAA+D,IAAzE;AACAwG,EAAAA,MAAM,IACJ,oDACA,4CADA,GAEA,+CAFA,GAGA,gBAHA,GAIA,MAJA,GAKA,0BALA,GAMAzX,mBAAmB,CACjB,qBADiB,EAEjB,2BAFiB,EAGjB,8BAHiB,CANnB,GAWA,MAZF;AAaA,SAAOyX,MAAP;AACD;;AAED,SAASujB,gBAAT,CAA0Bz5B,KAA1B,EAAiCkd,UAAjC,EAA6Cwc,KAA7C,EAAoD;AAClD;AACA;AACA;AACA;AACA,MAAI,CAACrC,aAAa,CAACr3B,KAAD,EAAQkd,UAAR,CAAlB,EAAuC;AACrC;AACD;;AAED,MAAI8R,YAAY,GAAGhvB,KAAK,CAACwL,aAAzB;AACA,MAAIwC,KAAK,GACPghB,YAAY,CAAC7tB,MAAb,GAAsB,CAAtB,KACCq2B,UAAU,CAACx3B,KAAK,CAACuF,KAAN,CAAYmoB,KAAb,EAAoB1tB,KAAK,CAACyF,mBAA1B,CAAV,IACC+xB,UAAU,CACRx3B,KAAK,CAAC0C,eAAN,CAAsBgrB,KADd,EAER1tB,KAAK,CAAC6C,6BAFE,CADX,IAKC,CAACrH,OAAO,CAACwzB,YAAY,CAAC,CAAD,CAAZ,CAAgBqD,sBAAjB,CANV,CADF;AASAryB,EAAAA,KAAK,CAACyF,mBAAN,GAA4BzF,KAAK,CAACuF,KAAN,CAAYmoB,KAAxC;AACA1tB,EAAAA,KAAK,CAAC6C,6BAAN,GAAsC7C,KAAK,CAAC0C,eAAN,CAAsBgrB,KAA5D;;AAEA,MAAI1f,KAAK,IAAI0rB,KAAb,EAAoB;AAClB5B,IAAAA,wBAAwB,CAAC93B,KAAD,EAAQkd,UAAR,CAAxB;AACD;AACF;;AAED,SAASyc,oBAAT,CAA8B35B,KAA9B,EAAqCkd,UAArC,EAAiD;AAC/C,MAAInX,cAAc,GAAG/F,KAAK,CAAC8F,eAA3B;;AACA,MAAItK,OAAO,CAACuK,cAAD,CAAP,IAA2BA,cAAc,CAACqrB,KAAf,KAAyBpxB,KAAxD,EAA+D;AAC7D,QAAI+F,cAAc,CAAC+J,OAAnB,EAA4B;AAC1B/J,MAAAA,cAAc,CAAC6zB,MAAf,CAAsB1c,UAAtB;AACD;AACF;AACF;;AAED,IAAI2c,qBAAqB,GAAG,IAAIj/B,cAAJ,EAA5B;;AAEA,SAASk/B,aAAT,CAAuBC,UAAvB,EAAmCrsB,MAAnC,EAA2CwP,UAA3C,EAAuD;AACrD2c,EAAAA,qBAAqB,CAACrsB,MAAtB,GAA+BusB,UAA/B;AACAF,EAAAA,qBAAqB,CAACnsB,MAAtB,GAA+BA,MAA/B;AACA,SAAOwP,UAAU,CAAC8c,MAAX,CAAkBC,YAAlB,CACLJ,qBADK,EAEL3c,UAAU,CAACxN,OAAX,CAAmBwqB,kBAFd,EAGLhd,UAAU,CAACxN,OAAX,CAAmByqB,mBAHd,CAAP;AAKD;;AAED,IAAIC,eAAe,GAAG,IAAIt/B,UAAJ,EAAtB;AACA,IAAIu/B,mBAAmB,GAAG,IAAIr/B,YAAJ,EAA1B;;AAEA,SAASmS,QAAT,CAAkBnN,KAAlB,EAAyBkd,UAAzB,EAAqC;AACnC,MAAI9Z,KAAK,GAAGpD,KAAK,CAACoD,KAAlB;;AAEA,MAAIpD,KAAK,CAACsD,gBAAN,KAA2B,GAA/B,EAAoC;AAClC;AACA,QAAIoM,OAAO,GAAGwN,UAAU,CAACxN,OAAzB;AACA,QAAI4qB,YAAY,GAAGltB,IAAI,CAAC+Y,GAAL,CACjBzW,OAAO,CAACwqB,kBADS,EAEjBxqB,OAAO,CAACyqB,mBAFS,CAAnB;AAIA,QAAI94B,CAAC,GAAG7F,OAAO,CAACwE,KAAK,CAACmD,mBAAP,CAAP,GACJnD,KAAK,CAACmD,mBADF,GAEJnD,KAAK,CAACgD,WAFV;AAGAo3B,IAAAA,eAAe,CAAClrB,CAAhB,GAAoB7N,CAAC,CAAC,EAAD,CAArB;AACA+4B,IAAAA,eAAe,CAAChrB,CAAhB,GAAoB/N,CAAC,CAAC,EAAD,CAArB;AACA+4B,IAAAA,eAAe,CAACpnB,CAAhB,GAAoB3R,CAAC,CAAC,EAAD,CAArB;;AAEA,QAAI7F,OAAO,CAACwE,KAAK,CAAC0L,UAAP,CAAX,EAA+B;AAC7B5Q,MAAAA,UAAU,CAAC8S,GAAX,CAAe5N,KAAK,CAAC0L,UAArB,EAAiC0uB,eAAjC,EAAkDA,eAAlD;AACD;;AAED,QAAIp6B,KAAK,CAAC4I,KAAN,KAAgBpJ,SAAS,CAACs1B,OAA9B,EAAuC;AACrC,UAAIrL,UAAU,GAAGvM,UAAU,CAACqd,aAA5B;AACA,UAAIC,YAAY,GAAG/Q,UAAU,CAACiM,SAAX,CAAqB+E,uBAArB,CACjBL,eADiB,EAEjBC,mBAFiB,CAAnB;AAIA5Q,MAAAA,UAAU,CAACiR,OAAX,CAAmBF,YAAnB,EAAiCJ,eAAjC;AACAt/B,MAAAA,UAAU,CAAC6/B,YAAX,CACEP,eAAe,CAACpnB,CADlB,EAEEonB,eAAe,CAAClrB,CAFlB,EAGEkrB,eAAe,CAAChrB,CAHlB,EAIEgrB,eAJF;AAMD;;AAED,QAAI1sB,MAAM,GAAG1N,KAAK,CAACgN,cAAN,CAAqBU,MAAlC;AACA,QAAIktB,cAAc,GAAGd,aAAa,CAACM,eAAD,EAAkB1sB,MAAlB,EAA0BwP,UAA1B,CAAlC,CAlCkC,CAoClC;;AACA,QAAI2d,cAAc,GAAG,MAAMD,cAA3B;AACA,QAAIE,gBAAgB,GAAG1tB,IAAI,CAACC,GAAL,CACrBwtB,cAAc,IAAI,MAAMntB,MAAV,CADO,EAErB4sB,YAFqB,CAAvB,CAtCkC,CA2ClC;;AACA,QAAIQ,gBAAgB,GAAG96B,KAAK,CAACsD,gBAA7B,EAA+C;AAC7CF,MAAAA,KAAK,GACFpD,KAAK,CAACsD,gBAAN,GAAyBs3B,cAA1B,IACC,MAAM56B,KAAK,CAACsI,cADb,CADF;AAGD;AACF;;AAED,SAAO9M,OAAO,CAACwE,KAAK,CAACwD,YAAP,CAAP,GACH4J,IAAI,CAACC,GAAL,CAASrN,KAAK,CAACwD,YAAf,EAA6BJ,KAA7B,CADG,GAEHA,KAFJ;AAGD;;AAED,SAAS23B,iBAAT,CAA2B/6B,KAA3B,EAAkC;AAChC,MACExE,OAAO,CAACwE,KAAK,CAAC6B,SAAP,CAAP,IACArG,OAAO,CAACwE,KAAK,CAACE,WAAP,CADP,IAEA,EAAEF,KAAK,CAACE,WAAN,CAAkBO,KAApB,KAA8B,CAHhC,EAIE;AACA,WAAOe,SAAS,CAACxB,KAAK,CAAC6B,SAAP,CAAhB;AACD;;AACD7B,EAAAA,KAAK,CAACE,WAAN,GAAoBqB,SAApB;AACD,C,CAED;;;AAEA,SAASy5B,uBAAT,CAAiCtrB,OAAjC,EAA0C9N,QAA1C,EAAoD;AAClD,OAAKuI,OAAL,GAAe5I,SAAf;AACA,OAAK6I,YAAL,GAAoB7I,SAApB;AACA,OAAK8I,QAAL,GAAgB9I,SAAhB;AACA,OAAK+I,aAAL,GAAqB/I,SAArB;AACA,OAAKgJ,kBAAL,GAA0BhJ,SAA1B;AACA,OAAKiJ,QAAL,GAAgBjJ,SAAhB;AACA,OAAKkJ,QAAL,GAAgBlJ,SAAhB;AACA,OAAKmJ,YAAL,GAAoBnJ,SAApB;AACA,OAAKhB,KAAL,GAAa,KAAb;AAEA,OAAKmP,OAAL,GAAeA,OAAf;AACA,OAAK9N,QAAL,GAAgBA,QAAhB;AACA,OAAKnB,KAAL,GAAa,CAAb;AACD;;AAED,SAASw6B,OAAT,CAAiBC,QAAjB,EAA2B;AACzB,OAAK,IAAI9pB,IAAT,IAAiB8pB,QAAjB,EAA2B;AACzB,QAAIA,QAAQ,CAAC3nB,cAAT,CAAwBnC,IAAxB,CAAJ,EAAmC;AACjC8pB,MAAAA,QAAQ,CAAC9pB,IAAD,CAAR,CAAe6pB,OAAf;AACD;AACF;AACF;;AAED,SAASE,8BAAT,CAAwClM,SAAxC,EAAmD;AACjDgM,EAAAA,OAAO,CAAChM,SAAS,CAAC9kB,OAAX,CAAP;AACA8wB,EAAAA,OAAO,CAAChM,SAAS,CAAC7kB,YAAX,CAAP;AACA6wB,EAAAA,OAAO,CAAChM,SAAS,CAAC5kB,QAAX,CAAP;AACA4wB,EAAAA,OAAO,CAAChM,SAAS,CAAC1kB,kBAAX,CAAP;AACA0wB,EAAAA,OAAO,CAAChM,SAAS,CAACzkB,QAAX,CAAP;AACD;;AAEDwwB,uBAAuB,CAACp6B,SAAxB,CAAkCw6B,OAAlC,GAA4C,YAAY;AACtD,MAAI,EAAE,KAAK36B,KAAP,KAAiB,CAArB,EAAwB;AACtB,QAAIjF,OAAO,CAAC,KAAKoG,QAAN,CAAX,EAA4B;AAC1B;AACA,aAAO,KAAK8N,OAAL,CAAa2rB,KAAb,CAAmBC,0BAAnB,CAA8C,KAAK15B,QAAnD,CAAP;AACD;;AACDu5B,IAAAA,8BAA8B,CAAC,IAAD,CAA9B;AACA,WAAO1/B,aAAa,CAAC,IAAD,CAApB;AACD;;AAED,SAAO8F,SAAP;AACD,CAXD,C,CAaA;;;AAEA,SAASg6B,uBAAT,CAAiCv7B,KAAjC,EAAwC01B,SAAxC,EAAmD8F,aAAnD,EAAkE;AAChE,SAAO,UAAUC,eAAV,EAA2B;AAChC,QAAIz7B,KAAK,CAAC4D,eAAN,KAA0BjF,eAAe,CAAC+8B,kBAA9C,EAAkE;AAChE,UAAIC,WAAW,GAAGjG,SAAS,CAAC+E,uBAAV,CAChBgB,eADgB,EAEhBpB,mBAFgB,CAAlB;AAIAsB,MAAAA,WAAW,CAAClkB,MAAZ,IAAsB+jB,aAAa,CAAC/jB,MAApC;AACAie,MAAAA,SAAS,CAACkG,uBAAV,CAAkCD,WAAlC,EAA+CF,eAA/C;AACD;;AAED,QAAII,kBAAkB,GAAG77B,KAAK,CAACmD,mBAA/B,CAVgC,CAYhC;;AACA5G,IAAAA,OAAO,CAACrB,KAAR,CAAc8E,KAAK,CAACgD,WAApB,EAAiC64B,kBAAjC;AACAA,IAAAA,kBAAkB,CAAC,EAAD,CAAlB,GAAyBJ,eAAe,CAACvsB,CAAzC;AACA2sB,IAAAA,kBAAkB,CAAC,EAAD,CAAlB,GAAyBJ,eAAe,CAACrsB,CAAzC;AACAysB,IAAAA,kBAAkB,CAAC,EAAD,CAAlB,GAAyBJ,eAAe,CAACzoB,CAAzC;AAEAhT,IAAAA,KAAK,CAAC+D,cAAN,GAAuB,IAAvB;AACD,GAnBD;AAoBD;;AAED,SAAS+3B,cAAT,CAAwB97B,KAAxB,EAA+B;AAC7B,MAAIxE,OAAO,CAACwE,KAAK,CAACgE,2BAAP,CAAX,EAAgD;AAC9ChE,IAAAA,KAAK,CAACgE,2BAAN;;AACAhE,IAAAA,KAAK,CAACgE,2BAAN,GAAoCzC,SAApC;AACD;;AAED,MAAI0C,KAAK,GAAGjE,KAAK,CAACkE,MAAlB;;AACA,MACE,CAAC1I,OAAO,CAACyI,KAAD,CAAR,IACA,CAACzI,OAAO,CAACyI,KAAK,CAAC83B,KAAP,CADR,IAEA/7B,KAAK,CAAC4D,eAAN,KAA0BjF,eAAe,CAACkF,IAH5C,EAIE;AACA;AACA,QAAI7D,KAAK,CAAC4D,eAAN,KAA0BjF,eAAe,CAACkF,IAA9C,EAAoD;AAClD,YAAM,IAAInI,cAAJ,CACJ,8DADI,CAAN;AAGD,KAND,CAOA;;;AACAsE,IAAAA,KAAK,CAACmD,mBAAN,GAA4B5B,SAA5B;AACA;AACD;;AAED,MAAIw6B,KAAK,GAAG93B,KAAK,CAAC83B,KAAlB;AACA,MAAIrG,SAAS,GAAGqG,KAAK,CAACrG,SAAtB,CAxB6B,CA0B7B;;AACA,MAAI1yB,WAAW,GAAGhD,KAAK,CAACgD,WAAxB;AACAo3B,EAAAA,eAAe,CAAClrB,CAAhB,GAAoBlM,WAAW,CAAC,EAAD,CAA/B;AACAo3B,EAAAA,eAAe,CAAChrB,CAAhB,GAAoBpM,WAAW,CAAC,EAAD,CAA/B;AACAo3B,EAAAA,eAAe,CAACpnB,CAAhB,GAAoBhQ,WAAW,CAAC,EAAD,CAA/B;AACA,MAAIw4B,aAAa,GAAG9F,SAAS,CAAC+E,uBAAV,CAAkCL,eAAlC,CAApB;;AAEA,MAAI,CAAC5+B,OAAO,CAACwE,KAAK,CAACmD,mBAAP,CAAZ,EAAyC;AACvCnD,IAAAA,KAAK,CAACmD,mBAAN,GAA4B5G,OAAO,CAACrB,KAAR,CAAc8H,WAAd,EAA2B,IAAIzG,OAAJ,EAA3B,CAA5B;AACD,GAnC4B,CAqC7B;;;AACA,MAAIy/B,OAAO,GAAGD,KAAK,CAACE,QAApB;AACAj8B,EAAAA,KAAK,CAACgE,2BAAN,GAAoCg4B,OAAO,CAACE,YAAR,CAClCV,aADkC,EAElCD,uBAAuB,CAACv7B,KAAD,EAAQ01B,SAAR,EAAmB8F,aAAnB,CAFW,CAApC,CAvC6B,CA4C7B;;AACA,MAAI/jB,MAAM,GAAGskB,KAAK,CAACI,SAAN,CAAgBX,aAAhB,CAAb;;AACA,MAAIhgC,OAAO,CAACic,MAAD,CAAX,EAAqB;AACnB;AACA,QAAI2kB,EAAE,GAAGb,uBAAuB,CAACv7B,KAAD,EAAQ01B,SAAR,EAAmB8F,aAAnB,CAAhC,CAFmB,CAInB;;AACAxgC,IAAAA,YAAY,CAACE,KAAb,CAAmBsgC,aAAnB,EAAkCnB,mBAAlC;AACAA,IAAAA,mBAAmB,CAAC5iB,MAApB,GAA6BA,MAA7B;AACAie,IAAAA,SAAS,CAACkG,uBAAV,CAAkCvB,mBAAlC,EAAuDD,eAAvD;AACAgC,IAAAA,EAAE,CAAChC,eAAD,CAAF;AACD;AACF;;AAED,IAAIiC,gCAAgC,GAAG,IAAIvhC,UAAJ,EAAvC;AACA,IAAIwhC,2CAA2C,GAAG,IAAIthC,YAAJ,EAAlD;;AAEA,SAASuhC,+BAAT,CAAyCv8B,KAAzC,EAAgDkd,UAAhD,EAA4D;AAC1D,MAAIsf,SAAJ;AACA,MAAIC,GAAG,GAAGz8B,KAAK,CAACwG,wBAAhB;AACA,MAAIk2B,WAAW,GAAGD,GAAG,CAACvuB,IAAJ,GAAWuuB,GAAG,CAACvuB,IAAjC;AACA,MAAIyuB,UAAU,GAAGF,GAAG,CAACxuB,GAAJ,GAAUwuB,GAAG,CAACxuB,GAA/B;;AAEA,MAAIiP,UAAU,CAACuR,IAAX,KAAoBjvB,SAAS,CAAC+1B,OAAlC,EAA2C;AACzC,QAAIqH,cAAc,GAChB1f,UAAU,CAAC8c,MAAX,CAAkB6C,OAAlB,CAA0BC,KAA1B,GAAkC5f,UAAU,CAAC8c,MAAX,CAAkB6C,OAAlB,CAA0BE,IAD9D;AAEAP,IAAAA,SAAS,GAAGI,cAAc,GAAG,GAA7B;AACAJ,IAAAA,SAAS,GAAGA,SAAS,GAAGA,SAAxB;AACD,GALD,MAKO;AACL;AACA,QAAIQ,QAAQ,GAAGzgC,OAAO,CAAC0gC,cAAR,CACbj9B,KAAK,CAACgD,WADO,EAEbq5B,gCAFa,CAAf;;AAIA,QAAInf,UAAU,CAACuR,IAAX,KAAoBjvB,SAAS,CAAC09B,aAAlC,EAAiD;AAC/C,UAAIzT,UAAU,GAAGvM,UAAU,CAACqd,aAA5B;AACA,UAAI7E,SAAS,GAAGjM,UAAU,CAACiM,SAA3B;AACA,UAAI8E,YAAY,GAAG9E,SAAS,CAAC+E,uBAAV,CACjBuC,QADiB,EAEjBV,2CAFiB,CAAnB;AAIAU,MAAAA,QAAQ,GAAGvT,UAAU,CAACiR,OAAX,CAAmBF,YAAnB,EAAiCwC,QAAjC,CAAX;AACAliC,MAAAA,UAAU,CAAC6/B,YAAX,CAAwBqC,QAAQ,CAAChqB,CAAjC,EAAoCgqB,QAAQ,CAAC9tB,CAA7C,EAAgD8tB,QAAQ,CAAC5tB,CAAzD,EAA4D4tB,QAA5D;AACD;;AACDR,IAAAA,SAAS,GAAG1hC,UAAU,CAACqiC,eAAX,CACVH,QADU,EAEV9f,UAAU,CAAC8c,MAAX,CAAkBD,UAFR,CAAZ;AAID;;AAED,SAAOyC,SAAS,IAAIE,WAAb,IAA4BF,SAAS,IAAIG,UAAhD;AACD;;AAED,IAAIS,2BAA2B,GAAG,IAAI7gC,OAAJ,EAAlC;AACA,IAAI8gC,+BAA+B,GAAG,IAAI9gC,OAAJ,EAAtC;AACA,IAAI+gC,+BAA+B,GAAG,IAAIhhC,OAAJ,EAAtC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAoF,KAAK,CAACd,SAAN,CAAgBg5B,MAAhB,GAAyB,UAAU1c,UAAV,EAAsB;AAC7C,MAAIA,UAAU,CAACuR,IAAX,KAAoBjvB,SAAS,CAAC+9B,QAAlC,EAA4C;AAC1C;AACD;;AAED,MAAI,CAAC3hC,gBAAgB,CAACkc,YAAjB,CAA8B0lB,WAAnC,EAAgD;AAC9C5hC,IAAAA,gBAAgB,CAACkc,YAAjB,CAA8B2lB,UAA9B;AACA;AACD;;AACD,MAAI3lB,YAAY,GAAGlc,gBAAgB,CAACkc,YAAjB,EAAnB;AAEA,MAAIpI,OAAO,GAAGwN,UAAU,CAACxN,OAAzB;AACA,OAAK3K,eAAL,GAAuB2K,OAAO,CAACgc,cAA/B;;AAEA,MAAI,KAAKjjB,MAAL,KAAgB9I,UAAU,CAAC+I,UAA3B,IAAyClN,OAAO,CAAC,KAAK8E,IAAN,CAApD,EAAiE;AAC/D;AACA,QAAIo9B,uBAAJ;AACA,QAAI97B,QAAQ,GAAG,KAAKA,QAApB;;AACA,QAAIpG,OAAO,CAACoG,QAAD,CAAX,EAAuB;AACrB;AACA8N,MAAAA,OAAO,CAAC2rB,KAAR,CAAcC,0BAAd,GAA2C//B,YAAY,CACrDmU,OAAO,CAAC2rB,KAAR,CAAcC,0BADuC,EAErD,EAFqD,CAAvD;AAIA,UAAIqC,WAAW,GAAGjuB,OAAO,CAAC2rB,KAAR,CAAcC,0BAAhC;AAEAoC,MAAAA,uBAAuB,GAAGC,WAAW,CAAC,KAAK/7B,QAAN,CAArC;;AACA,UAAIpG,OAAO,CAACkiC,uBAAD,CAAX,EAAsC;AACpC,YAAI,CAACA,uBAAuB,CAACn9B,KAA7B,EAAoC;AAClC;AACA;AACA;AACD;;AAED,UAAEm9B,uBAAuB,CAACj9B,KAA1B;AACA,aAAKmK,+BAAL,GAAuC,IAAvC;AACD,OATD,MASO;AACL8yB,QAAAA,uBAAuB,GAAG,IAAI1C,uBAAJ,CACxBtrB,OADwB,EAExB9N,QAFwB,CAA1B;AAIA87B,QAAAA,uBAAuB,CAACj9B,KAAxB,GAAgC,CAAhC;AACAk9B,QAAAA,WAAW,CAAC,KAAK/7B,QAAN,CAAX,GAA6B87B,uBAA7B;AACD;;AACD,WAAK/yB,wBAAL,GAAgC+yB,uBAAhC;AACD,KA3BD,MA2BO;AACL;AACAA,MAAAA,uBAAuB,GAAG,IAAI1C,uBAAJ,CAA4BtrB,OAA5B,CAA1B;AACAguB,MAAAA,uBAAuB,CAACj9B,KAAxB,GAAgC,CAAhC;AACA,WAAKkK,wBAAL,GAAgC+yB,uBAAhC;AACD;;AAED,SAAKj1B,MAAL,GAAc9I,UAAU,CAACi+B,OAAzB;;AACA,QAAI,KAAKn1B,MAAL,KAAgB9I,UAAU,CAACk+B,MAA/B,EAAuC;AACrC,UAAIroB,UAAU,GAAG,KAAKlV,IAAL,CAAUkV,UAA3B;;AACA,UAAIha,OAAO,CAACga,UAAD,CAAP,IAAuBha,OAAO,CAACga,UAAU,CAACsoB,UAAZ,CAAlC,EAA2D;AACzD,YAAItwB,MAAM,GAAG1S,UAAU,CAAC60B,SAAX,CAAqBna,UAAU,CAACsoB,UAAX,CAAsBtwB,MAA3C,CAAb;;AACA,YAAI,CAAC1S,UAAU,CAACuU,MAAX,CAAkB7B,MAAlB,EAA0B1S,UAAU,CAACijC,IAArC,CAAL,EAAiD;AAC/C,eAAKnyB,YAAL,GAAoB4B,MAApB;AAEA,cAAIic,UAAU,GAAGvM,UAAU,CAACqd,aAA5B;AACA,cAAI7E,SAAS,GAAGjM,UAAU,CAACiM,SAA3B;AACA,cAAI8E,YAAY,GAAG9E,SAAS,CAAC+E,uBAAV,CACjB,KAAK7uB,YADY,CAAnB;AAGA,cAAIoyB,aAAa,GAAGvU,UAAU,CAACiR,OAAX,CAAmBF,YAAnB,CAApB;AACA1/B,UAAAA,UAAU,CAAC6/B,YAAX,CACEqD,aAAa,CAAChrB,CADhB,EAEEgrB,aAAa,CAAC9uB,CAFhB,EAGE8uB,aAAa,CAAC5uB,CAHhB,EAIE4uB,aAJF;AAMA,eAAKnyB,YAAL,GAAoBmyB,aAApB;AAEA,eAAKryB,aAAL,GAAqB,IAAI7Q,UAAJ,EAArB;AACA,eAAK4Q,UAAL,GAAkB,KAAKE,YAAvB;AACD;AACF;;AAEDjO,MAAAA,iBAAiB,CAAC,KAAK2C,IAAN,CAAjB;AAEA,WAAKqI,cAAL,GAAsB,IAAI5J,kBAAJ,EAAtB;;AACA,UAAI,CAAC,KAAK6L,+BAAV,EAA2C;AACzC;AACAxL,QAAAA,YAAY,CAAC6+B,YAAb,CAA0B,IAA1B,EAAgC3pB,UAAhC;AACD;AACF;AACF;;AAED,MAAIL,aAAa,GAAG,KAAKtL,cAAzB;AACA,MAAI1D,yBAAyB,GAAG,KAAKD,0BAArC;AACA,MAAI0vB,UAAU,GAAG,KAAjB;;AAEA,MAAI,KAAKjsB,MAAL,KAAgB9I,UAAU,CAACi+B,OAA/B,EAAwC;AACtC;AACA;AACA,QAAI3pB,aAAa,CAACM,kBAAd,KAAqC,CAAzC,EAA4C;AAC1C,UAAI,CAACN,aAAa,CAACupB,WAAnB,EAAgC;AAC9BtgB,QAAAA,UAAU,CAACghB,gBAAX,CAA4BtE,MAA5B,CAAmC1c,UAAnC;AAEA9d,QAAAA,YAAY,CAAC++B,wBAAb,CACE,KAAK9vB,kBADP,EAEEyJ,YAFF;AAIA1Y,QAAAA,YAAY,CAACg/B,iBAAb,CAA+B,IAA/B,EAP8B,CAS9B;;AACA,YAAI,CAAC5iC,OAAO,CAAC,KAAK8E,IAAL,CAAU6T,MAAV,CAAiBkqB,aAAlB,CAAZ,EAA8C;AAC5C,cAAI/9B,IAAI,GAAG,KAAKA,IAAhB,CAD4C,CAE5C;;AACAA,UAAAA,IAAI,CAAC6T,MAAL,CAAYkqB,aAAZ,GAA4Bj/B,YAAY,CAACk/B,eAAb,CAA6Bh+B,IAA7B,CAA5B;AACAA,UAAAA,IAAI,CAAC6T,MAAL,CAAYoqB,wBAAZ,GAAuC/iC,OAAO,CAC5C4D,YAAY,CAACgP,iBAAb,CAA+B9N,IAA/B,EAAqCmV,oBADO,CAA9C;AAIA,eAAK3J,cAAL,GAAsBxL,IAAI,CAAC6T,MAAL,CAAYkqB,aAAlC;AACA,eAAKtyB,yBAAL,GAAiCzL,IAAI,CAAC6T,MAAL,CAAYoqB,wBAA7C;AAEAtgC,UAAAA,aAAa,CAACqC,IAAD,CAAb;AACA5C,UAAAA,WAAW,CAAC4C,IAAD,CAAX;AAEA,cAAIF,OAAO,GAAG;AACZsG,YAAAA,4BAA4B,EAAE,KAAKD;AADvB,WAAd;AAIAnH,UAAAA,2BAA2B,CAACgB,IAAD,EAAOF,OAAP,CAA3B;AACAb,UAAAA,mBAAmB,CAACe,IAAD,EAAOF,OAAP,CAAnB;AACD;;AAED,aAAK0L,cAAL,GAAsB,KAAKxL,IAAL,CAAU6T,MAAV,CAAiBkqB,aAAvC;AACA,aAAKtyB,yBAAL,GAAiC,KAAKzL,IAAL,CAAU6T,MAAV,CAAiBoqB,wBAAlD,CAjC8B,CAmC9B;;AACA,aAAK1zB,mBAAL,GACE,KAAKA,mBAAL,IAA4BrM,WAAW,CAACV,YAAZ,CAAyB,IAAzB,CAD9B,CApC8B,CAuC9B;;AACAkW,QAAAA,yBAAyB,CAAC,IAAD,CAAzB;AACA4C,QAAAA,kBAAkB,CAAC,IAAD,CAAlB;AACAvB,QAAAA,eAAe,CAAC,IAAD,CAAf;;AACA,YAAI,CAAC,KAAKzK,+BAAV,EAA2C;AACzC4J,UAAAA,gBAAgB,CAAC,IAAD,CAAhB;AACAyB,UAAAA,YAAY,CAAC,IAAD,CAAZ;AACAS,UAAAA,aAAa,CAAC,IAAD,CAAb;AACAmB,UAAAA,aAAa,CAAC,IAAD,EAAOnI,OAAP,EAAgBoI,YAAhB,CAAb;AACD;;AACDuC,QAAAA,cAAc,CAAC,IAAD,CAAd;AACAiB,QAAAA,WAAW,CAAC,IAAD,CAAX;AACAtC,QAAAA,UAAU,CAAC,IAAD,CAAV,CAnD8B,CAqD9B;;AACAxa,QAAAA,WAAW,CAACggC,KAAZ,CAAkB,IAAlB,EAAwB9uB,OAAxB;AAEAuE,QAAAA,aAAa,CAACupB,WAAd,GAA4B,IAA5B;AACD;;AAED,UAAI,CAACvpB,aAAa,CAACwqB,gBAAd,EAAL,EAAuC;AACrCjgC,QAAAA,WAAW,CAACkgC,WAAZ,CAAwB,IAAxB,EAA8BhvB,OAA9B,EAAuCqB,SAAvC,CACE3R,YAAY,CAAC4R,qBAAb,CAAmC,IAAnC,EAAyC,OAAzC,EAAkD,KAAK7O,QAAvD,CADF;AAGD;;AAED,UAAI8R,aAAa,CAACwqB,gBAAd,MAAoC,CAACxqB,aAAa,CAAC0qB,eAAvD,EAAwE;AACtE,aAAKp2B,eAAL,GAAuBnJ,YAAY,CAACw/B,qBAAb,CAAmC,IAAnC,CAAvB;AACA,aAAKt2B,cAAL,GAAsB,KAAKC,eAAL,CAAqBmF,MAA3C;AAEAlP,QAAAA,WAAW,CAACqgC,iBAAZ,CAA8B,IAA9B;AAEA5qB,QAAAA,aAAa,CAAC0qB,eAAd,GAAgC,IAAhC;AACD;;AAED,UACE1qB,aAAa,CAAC0qB,eAAd,IACA1qB,aAAa,CAAC+B,kBAAd,KAAqC,CAFvC,EAGE;AACA7W,QAAAA,kBAAkB,CAAC2/B,iBAAnB,CAAqC,IAArC;AACAlL,QAAAA,eAAe,CAAC,IAAD,EAAO1W,UAAP,CAAf;AACD;AACF;;AAED,QACEjJ,aAAa,CAAC8qB,QAAd,MACC95B,yBAAyB,IACxBgP,aAAa,CAAC6e,oCAAd,EAHJ,EAIE;AACA,WAAKrqB,MAAL,GAAc9I,UAAU,CAACsN,MAAzB;AACAynB,MAAAA,UAAU,GAAG,IAAb;AACD;AACF,GA5L4C,CA8L7C;;;AACA,MAAIl5B,OAAO,CAACyY,aAAD,CAAP,IAA0B,KAAKxL,MAAL,KAAgB9I,UAAU,CAACsN,MAAzD,EAAiE;AAC/D,QAAIhI,yBAAyB,IAAI,CAACyvB,UAAlC,EAA8C;AAC5Cd,MAAAA,eAAe,CAAC,IAAD,EAAO1W,UAAP,CAAf;AACD;;AAED,QAAIjJ,aAAa,CAAC8qB,QAAd,EAAJ,EAA8B;AAC5B,WAAKp2B,cAAL,GAAsBpH,SAAtB,CAD4B,CACK;;AAEjC,UAAI0tB,SAAS,GAAG,KAAK/kB,kBAArB;AACA,UAAI6pB,eAAe,GAAG,KAAKppB,wBAA3B;AAEAopB,MAAAA,eAAe,CAAC5pB,OAAhB,GAA0B8kB,SAAS,CAAC9kB,OAApC;AACA4pB,MAAAA,eAAe,CAAC3pB,YAAhB,GAA+B6kB,SAAS,CAAC7kB,YAAzC;AACA2pB,MAAAA,eAAe,CAAC1pB,QAAhB,GAA2B4kB,SAAS,CAAC5kB,QAArC;AACA0pB,MAAAA,eAAe,CAACzpB,aAAhB,GAAgC2kB,SAAS,CAAC3kB,aAA1C;AACAypB,MAAAA,eAAe,CAACxpB,kBAAhB,GAAqC0kB,SAAS,CAAC1kB,kBAA/C;AACAwpB,MAAAA,eAAe,CAACvpB,QAAhB,GAA2BykB,SAAS,CAACzkB,QAArC;AACAupB,MAAAA,eAAe,CAACtpB,QAAhB,GAA2BwkB,SAAS,CAACxkB,QAArC;AACAspB,MAAAA,eAAe,CAACrpB,YAAhB,GAA+BukB,SAAS,CAACvkB,YAAzC;AACAqpB,MAAAA,eAAe,CAACxzB,KAAhB,GAAwB,IAAxB,CAd4B,CAgB5B;;AACA,WAAKuC,oBAAL,GAA4B1D,YAAY,CAAC4/B,+BAAb,CAC1B,KAAK1+B,IADqB,EAE1B,QAF0B,CAA5B,CAjB4B,CAsB5B;;AACA,UAAI9E,OAAO,CAAC,KAAKmL,qBAAN,CAAX,EAAyC;AACvCotB,QAAAA,eAAe,CAAC3pB,YAAhB,GAA+B,EAA/B;AACD;;AAED,UAAI,KAAKrI,eAAT,EAA0B;AACxBg5B,QAAAA,iBAAiB,CAAC,IAAD,CAAjB;AACD;AACF;AACF;;AAED,MAAIkE,YAAY,GAAG5/B,0BAA0B,CAACyf,WAA3B,CAAuCpP,OAAvC,CAAnB;;AACA,MAAI,KAAKhD,6BAAL,IAAsCuyB,YAA1C,EAAwD;AACtD,SAAKvyB,6BAAL,GAAqC,KAArC;AACA,SAAKC,4BAAL,GACE,KAAKA,4BAAL,IACA,KAAKA,4BAAL,CAAkCsuB,OAAlC,EAFF;AAGA,SAAKtuB,4BAAL,GAAoCpL,SAApC;;AACA,QAAI/F,OAAO,CAAC,KAAKgR,wBAAN,CAAX,EAA4C;AAC1C,WAAKG,4BAAL,GAAoC,IAAItN,0BAAJ,CAClC,KAAKmN,wBAD6B,CAApC;AAGA,UAAI0yB,IAAI,GAAG,IAAX;;AACA,WAAKvyB,4BAAL,CAAkCkB,YAAlC,CACG4C,IADH,CACQ,YAAY;AAChByuB,QAAAA,IAAI,CAACpyB,wBAAL,GAAgC,IAAhC;AACD,OAHH,EAIGiE,SAJH,CAIa,UAAUouB,KAAV,EAAiB;AAC1BC,QAAAA,OAAO,CAACD,KAAR,CAAc,4CAA4CA,KAA1D;AACD,OANH;AAOD,KAlBqD,CAoBtD;;;AACA,SAAKryB,wBAAL,GAAgC,IAAhC;AACD;;AAED,MAAItR,OAAO,CAAC,KAAKmR,4BAAN,CAAX,EAAgD;AAC9C,SAAKA,4BAAL,CAAkCitB,MAAlC,CAAyC1c,UAAzC;AACD;;AAED,MAAImiB,yBAAyB,GAC3B,CAAC7jC,OAAO,CAAC,KAAKmR,4BAAN,CAAR,IACAnR,OAAO,CAAC0hB,UAAU,CAACzQ,uBAAZ,CADP,IAEA,CAAC,KAAKI,uBAHR;AAIA,MAAIyyB,4BAA4B,GAC9B,CAAC9jC,OAAO,CAAC0hB,UAAU,CAACzQ,uBAAZ,CAAR,IACA,KAAKI,uBAFP;AAIA,MAAI0yB,4BAA4B,GAC9B,CAAC/jC,OAAO,CAAC,KAAK8Q,8BAAN,CAAR,IACA9Q,OAAO,CAAC0hB,UAAU,CAAC3Q,6BAAZ,CADP,IAEA,CAAC,KAAKK,6BAHR;AAIA,MAAI4yB,+BAA+B,GACjC,CAAChkC,OAAO,CAAC0hB,UAAU,CAAC3Q,6BAAZ,CAAR,IACA,KAAKK,6BAFP;AAIA,OAAKE,wBAAL,GACE,KAAKA,wBAAL,IACAuyB,yBADA,IAEAC,4BAFA,IAGAC,4BAHA,IAIAC,+BALF;AAOA,OAAK3yB,uBAAL,GACE,CAACrR,OAAO,CAAC,KAAKmR,4BAAN,CAAR,IACAnR,OAAO,CAAC0hB,UAAU,CAACzQ,uBAAZ,CAFT;AAGA,OAAKG,6BAAL,GACE,CAACpR,OAAO,CAAC,KAAK8Q,8BAAN,CAAR,IACA9Q,OAAO,CAAC0hB,UAAU,CAAC3Q,6BAAZ,CAFT;AAIA,MAAIkzB,UAAU,GAAGpI,aAAa,CAAC,IAAD,EAAOna,UAAP,CAA9B;AACA,MAAIwiB,WAAW,GAAGvO,aAAa,CAAC,IAAD,CAA/B;AACA,MAAIwO,SAAS,GAAGpI,WAAW,CAAC,IAAD,CAA3B;AACA,MAAIrxB,eAAe,GAAG,KAAKA,eAA3B;AACA,MAAI05B,sBAAsB,GAAGpkC,OAAO,CAAC,KAAKgL,wBAAN,CAAP,GACzB+1B,+BAA+B,CAAC,IAAD,EAAOrf,UAAP,CADN,GAEzB,IAFJ;AAGA,MAAIza,IAAI,GACN,KAAKA,IAAL,IACAm9B,sBADA,IAEA,KAAKx8B,KAAL,KAAe,GAFf,KAGC,CAACu8B,SAAD,IAAcF,UAHf,CADF;;AAMA,MAAKh9B,IAAI,IAAI,KAAKgG,MAAL,KAAgB9I,UAAU,CAACsN,MAApC,IAA+CynB,UAAnD,EAA+D;AAC7D,QAAImL,QAAQ,GACV,KAAKh7B,gBAAL,CAAsB+0B,MAAtB,CAA6B1c,UAA7B,KAA4C,KAAKpU,sBADnD;;AAEA,SAAKA,sBAAL,GAA8B,KAA9B;AACA,SAAKC,MAAL,GAAc,KAAd;AACA,QAAI/F,WAAW,GAAG,KAAKA,WAAvB;AAEA,QAAI88B,WAAW,GAAG5iB,UAAU,CAACuR,IAAX,KAAoB,KAAK7lB,KAA3C;AACA,SAAKA,KAAL,GAAasU,UAAU,CAACuR,IAAxB,CAR6D,CAU7D;;AACA,QAAIgG,qBAAqB,GACvB,CAACl4B,OAAO,CAAC8S,MAAR,CAAe,KAAKnM,YAApB,EAAkCF,WAAlC,CAAD,IACA,KAAKK,MAAL,KAAgB,KAAKD,KADrB,IAEA,KAAKG,iBAAL,KAA2B,KAAKD,gBAFhC,IAGA,KAAKA,gBAAL,KAA0B,GAH1B,IAGiC;AACjC,SAAKG,aAAL,KAAuB,KAAKD,YAJ5B,IAKA,KAAKM,gBAAL,KAA0B,KAAKF,eAL/B,IAMA,KAAKG,cANL,IAOA+7B,WARF;;AAUA,QAAIrL,qBAAqB,IAAIC,UAA7B,EAAyC;AACvCn4B,MAAAA,OAAO,CAACrB,KAAR,CAAc8H,WAAd,EAA2B,KAAKE,YAAhC;AAEA44B,MAAAA,cAAc,CAAC,IAAD,CAAd;;AAEA,UAAItgC,OAAO,CAAC,KAAK2H,mBAAN,CAAX,EAAuC;AACrCH,QAAAA,WAAW,GAAG,KAAKG,mBAAnB;AACD;;AAED,WAAKE,MAAL,GAAc,KAAKD,KAAnB;AACA,WAAKG,iBAAL,GAAyB,KAAKD,gBAA9B;AACA,WAAKG,aAAL,GAAqB,KAAKD,YAA1B;AACA,WAAKM,gBAAL,GAAwB,KAAKF,eAA7B;AACA,WAAKG,cAAL,GAAsB,KAAtB;AAEA,UAAIX,KAAK,GAAG+J,QAAQ,CAAC,IAAD,EAAO+P,UAAP,CAApB;AACA,UAAI2X,mBAAmB,GAAG,KAAK1sB,oBAA/B;AACA5L,MAAAA,OAAO,CAAC4W,sBAAR,CAA+BnQ,WAA/B,EAA4CI,KAA5C,EAAmDyxB,mBAAnD;;AACA,UAAI,KAAKptB,OAAL,KAAiBtJ,IAAI,CAACwJ,CAA1B,EAA6B;AAC3BpL,QAAAA,OAAO,CAACqtB,sBAAR,CACEiL,mBADF,EAEE12B,IAAI,CAAC4hC,YAFP,EAGElL,mBAHF;AAKD,OAND,MAMO,IAAI,KAAKptB,OAAL,KAAiBtJ,IAAI,CAAC6hC,CAA1B,EAA6B;AAClCzjC,QAAAA,OAAO,CAACqtB,sBAAR,CACEiL,mBADF,EAEE12B,IAAI,CAAC8hC,YAFP,EAGEpL,mBAHF;AAKD;;AACD,UAAI,KAAK9sB,WAAL,KAAqB5J,IAAI,CAAC0J,CAA9B,EAAiC;AAC/B;AACAtL,QAAAA,OAAO,CAACqtB,sBAAR,CACEiL,mBADF,EAEE12B,IAAI,CAAC+hC,YAFP,EAGErL,mBAHF;AAKD;AACF,KA5D4D,CA8D7D;;;AACA,QAAIgL,QAAQ,IAAIpL,qBAAZ,IAAqCC,UAAzC,EAAqD;AACnDF,MAAAA,8BAA8B,CAC5B,IAD4B,EAE5BC,qBAF4B,EAG5BC,UAH4B,EAI5BxX,UAAU,CAACqd,aAJiB,CAA9B;AAMA,WAAKxxB,MAAL,GAAc,IAAd;;AAEA,UAAI82B,QAAQ,IAAInL,UAAhB,EAA4B;AAC1B;AACAqB,QAAAA,UAAU,CAAC,IAAD,CAAV;AACD;AACF;;AAED,QAAI,KAAKltB,iBAAT,EAA4B;AAC1B,WAAKA,iBAAL,GAAyB,KAAzB;AACAqtB,MAAAA,iBAAiB,CAAC,IAAD,CAAjB;AACD;;AACDE,IAAAA,aAAa,CAAC,IAAD,EAAO1mB,OAAP,CAAb;AACA2mB,IAAAA,eAAe,CAAC,IAAD,CAAf;AACAE,IAAAA,wBAAwB,CAAC,IAAD,CAAxB;AACAC,IAAAA,aAAa,CAAC,IAAD,CAAb;AACAmD,IAAAA,oBAAoB,CAAC,IAAD,EAAOzc,UAAP,CAApB,CAtF6D,CAwF7D;;AACA,QAAInX,cAAc,GAAG,KAAKD,eAA1B;AACA,QAAIq6B,0BAA0B,GAAG,CAAjC;AACA,QAAIC,iBAAiB,GACnB5kC,OAAO,CAACuK,cAAD,CAAP,IACAA,cAAc,CAAC+J,OADf,IAEA/J,cAAc,CAAC5E,MAAf,GAAwB,CAH1B,CA3F6D,CAgG7D;AACA;AACA;AACA;;AACA,QAAI8E,eAAe,GAAG1K,YAAY,CAAC,KAAK0K,eAAN,EAAuBjD,WAAvB,CAAlC;;AAEA,QAAIo9B,iBAAJ,EAAuB;AACrB,UAAIC,oBAAoB,GAAGjD,2BAA3B;AACAiD,MAAAA,oBAAoB,GAAG9jC,OAAO,CAAC2tB,QAAR,CACrBxa,OAAO,CAAC2Z,YAAR,CAAqBiX,MADA,EAErBr6B,eAFqB,EAGrBo6B,oBAHqB,CAAvB;AAKAA,MAAAA,oBAAoB,GAAG9jC,OAAO,CAAC2tB,QAAR,CACrBmW,oBADqB,EAErBt6B,cAAc,CAAC/C,WAFM,EAGrBq9B,oBAHqB,CAAvB;AAKA,WAAKj4B,qBAAL,GAA6B7L,OAAO,CAACgkC,gBAAR,CAC3BF,oBAD2B,EAE3B,KAAKj4B,qBAFsB,CAA7B;AAIA+3B,MAAAA,0BAA0B,GAAGp6B,cAAc,CAACy6B,mBAA5C;AACD;;AAED,QAAIzhB,MAAM,GACRvjB,OAAO,CAAC,KAAK8Q,8BAAN,CAAP,IACA,KAAKM,6BAFP;;AAGA,QAAIoS,MAAM,GACPxjB,OAAO,CAAC,KAAKmR,4BAAN,CAAP,IACC,KAAKA,4BAAL,CAAkCpM,KADpC,IAEA,KAAKsM,uBAHP;;AAKA,QAAIkS,MAAM,IAAIC,MAAd,EAAsB;AACpB,UAAIyhB,wBAAwB,GAAGnD,+BAA/B;AACA,UAAIoD,wBAAwB,GAAGrD,+BAA/B;AAEAqD,MAAAA,wBAAwB,GAAGnkC,OAAO,CAAC2tB,QAAR,CACzBxa,OAAO,CAAC2Z,YAAR,CAAqBiX,MADI,EAEzBr6B,eAFyB,EAGzBy6B,wBAHyB,CAA3B;AAKAD,MAAAA,wBAAwB,GAAGlkC,OAAO,CAAC0uB,UAAR,CACzByV,wBADyB,EAEzBD,wBAFyB,CAA3B;AAIAA,MAAAA,wBAAwB,GAAGnkC,OAAO,CAACqkC,WAAR,CACzBF,wBADyB,EAEzBA,wBAFyB,CAA3B;AAIA,WAAKp4B,wBAAL,GAAgC/L,OAAO,CAAC4uB,SAAR,CAC9BuV,wBAD8B,EAE9B,KAAKp4B,wBAFyB,CAAhC;AAID;;AAED,QAAIu4B,uBAAuB,GAAG,KAAK9zB,wBAAnC;AACA8zB,IAAAA,uBAAuB,GACrBA,uBAAuB,IACvB,KAAK56B,oBAAL,KAA8Bm6B,0BAFhC;AAGA,SAAKn6B,oBAAL,GAA4Bm6B,0BAA5B,CA5J6D,CA8J7D;;AACA,QAAIU,4BAA4B,GAAGjxB,qBAAqB,CAAC,IAAD,CAAxD;;AACA,QAAIixB,4BAA4B,KAAK,KAAKh7B,oBAA1C,EAAgE;AAC9D,WAAKA,oBAAL,GAA4Bg7B,4BAA5B;AACAD,MAAAA,uBAAuB,GAAG,IAA1B;AACD;;AAED,QAAIA,uBAAJ,EAA6B;AAC3BE,MAAAA,iBAAiB,CAAC,IAAD,EAAO5jB,UAAP,CAAjB;AACD,KAFD,MAEO;AACL0Z,MAAAA,WAAW,CAAC,IAAD,EAAO1Z,UAAP,EAAmB,KAAnB,CAAX;AACA8Z,MAAAA,qBAAqB,CAAC,IAAD,EAAO9Z,UAAP,EAAmB,KAAnB,CAArB;AACAuc,MAAAA,gBAAgB,CAAC,IAAD,EAAOvc,UAAP,EAAmB,KAAnB,CAAhB;AACD;AACF;;AAED,MAAIwX,UAAJ,EAAgB;AACd;AACA,QAAI10B,KAAK,GAAG,IAAZ;AACAkd,IAAAA,UAAU,CAAC6jB,WAAX,CAAuB1wB,IAAvB,CAA4B,YAAY;AACtCrQ,MAAAA,KAAK,CAAC0E,MAAN,GAAe,IAAf;;AACA1E,MAAAA,KAAK,CAAC2E,aAAN,CAAoBq8B,OAApB,CAA4BhhC,KAA5B;AACD,KAHD;AAIA;AACD,GAne4C,CAqe7C;AACA;AACA;;;AACA,MAAIyC,IAAI,IAAI,CAAC,KAAK4E,eAAlB,EAAmC;AACjC;AACA,QAAI45B,WAAW,GAAG/jB,UAAU,CAAC+jB,WAA7B;AACA,QAAIC,MAAM,GAAGhkB,UAAU,CAACgkB,MAAxB;AACA,QAAIlS,YAAY,GAAG,KAAKxjB,aAAxB;AACA,QAAIrK,MAAM,GAAG6tB,YAAY,CAAC7tB,MAA1B;AACA,QAAIC,CAAJ;AACA,QAAI+/B,EAAJ;AAEA,QAAIC,KAAK,GACPlkB,UAAU,CAACqd,aAAX,CAAyB7E,SAAzB,CAAmCC,aAAnC,GAAmDt5B,UAAU,CAACo5B,EADhE;AAEA,QAAI7D,cAAJ;;AAEA,QAAIsP,MAAM,CAACG,MAAP,IAAkBH,MAAM,CAACI,IAAP,IAAe,KAAK78B,YAA1C,EAAyD;AACvD,WAAKrD,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGD,MAAhB,EAAwB,EAAEC,CAA1B,EAA6B;AAC3B+/B,QAAAA,EAAE,GAAGnS,YAAY,CAAC5tB,CAAD,CAAjB;;AACA,YAAI+/B,EAAE,CAAC1+B,IAAP,EAAa;AACX,cAAIkvB,OAAO,GAAGwP,EAAE,CAACxP,OAAjB;;AACA,cAAI8N,UAAJ,EAAgB;AACd9N,YAAAA,OAAO,GAAGwP,EAAE,CAAC9O,sBAAb;AACD,WAFD,MAEO,IAAIqN,WAAJ,EAAiB;AACtB/N,YAAAA,OAAO,GAAGwP,EAAE,CAAC1O,kBAAb;AACD,WAFM,MAEA,IAAI,CAACvsB,eAAL,EAAsB;AAC3ByrB,YAAAA,OAAO,GAAGwP,EAAE,CAACxO,qBAAb;AACD;;AACDsO,UAAAA,WAAW,CAAC5wB,IAAZ,CAAiBshB,OAAjB;AACAC,UAAAA,cAAc,GAAGuP,EAAE,CAACxP,OAAH,CAAWC,cAA5B;;AACA,cACE1U,UAAU,CAACuR,IAAX,KAAoBjvB,SAAS,CAAC+1B,OAA9B,KACC3D,cAAc,CAACpkB,MAAf,CAAsB4B,CAAtB,GAA0BwiB,cAAc,CAAClkB,MAAzC,GAAkD0zB,KAAlD,IACCxP,cAAc,CAACpkB,MAAf,CAAsB4B,CAAtB,GAA0BwiB,cAAc,CAAClkB,MAAzC,GAAkD0zB,KAFpD,CADF,EAIE;AACA,gBAAIlP,SAAS,GAAGiP,EAAE,CAACjP,SAAnB;;AACA,gBAAIuN,UAAJ,EAAgB;AACdvN,cAAAA,SAAS,GAAGiP,EAAE,CAAC7O,wBAAf;AACD,aAFD,MAEO,IAAIoN,WAAJ,EAAiB;AACtBxN,cAAAA,SAAS,GAAGiP,EAAE,CAACzO,oBAAf;AACD,aAFM,MAEA,IAAI,CAACxsB,eAAL,EAAsB;AAC3BgsB,cAAAA,SAAS,GAAGiP,EAAE,CAACvO,uBAAf;AACD;;AACDqO,YAAAA,WAAW,CAAC5wB,IAAZ,CAAiB6hB,SAAjB;AACD;AACF;AACF;;AAED,UAAIuN,UAAU,IAAI,CAACyB,MAAM,CAACI,IAA1B,EAAgC;AAC9B;AACA,aAAKlgC,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGD,MAAhB,EAAwB,EAAEC,CAA1B,EAA6B;AAC3B+/B,UAAAA,EAAE,GAAGnS,YAAY,CAAC5tB,CAAD,CAAjB;;AACA,cAAI+/B,EAAE,CAAC1+B,IAAP,EAAa;AACXw+B,YAAAA,WAAW,CAAC5wB,IAAZ,CAAiB8wB,EAAE,CAAC5O,sBAApB;AACAX,YAAAA,cAAc,GAAGuP,EAAE,CAACxP,OAAH,CAAWC,cAA5B;;AACA,gBACE1U,UAAU,CAACuR,IAAX,KAAoBjvB,SAAS,CAAC+1B,OAA9B,KACC3D,cAAc,CAACpkB,MAAf,CAAsB4B,CAAtB,GAA0BwiB,cAAc,CAAClkB,MAAzC,GAAkD0zB,KAAlD,IACCxP,cAAc,CAACpkB,MAAf,CAAsB4B,CAAtB,GAA0BwiB,cAAc,CAAClkB,MAAzC,GAAkD0zB,KAFpD,CADF,EAIE;AACAH,cAAAA,WAAW,CAAC5wB,IAAZ,CAAiB8wB,EAAE,CAAC3O,wBAApB;AACD;AACF;AACF;AACF;AACF;AACF;;AAED,MAAIlwB,MAAM,GAAG,KAAKC,OAAlB;;AACA,MAAI/G,OAAO,CAAC8G,MAAD,CAAX,EAAqB;AACnB4a,IAAAA,UAAU,CAACqkB,aAAX,CAAyBC,SAAzB,CAAmCl/B,MAAnC;AACD;;AAED,MAAIuO,eAAe,GAAG,KAAKrO,gBAA3B;AACA,MAAIi/B,WAAW,GAAG5wB,eAAe,CAAC1P,MAAlC;;AACA,OAAK,IAAIugC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,WAApB,EAAiCC,CAAC,EAAlC,EAAsC;AACpCxkB,IAAAA,UAAU,CAACqkB,aAAX,CAAyBC,SAAzB,CAAmC3wB,eAAe,CAAC6wB,CAAD,CAAlD;AACD;AACF,CAnjBD;;AAqjBA,SAASC,kBAAT,CAA4BC,iBAA5B,EAA+ClE,uBAA/C,EAAwE;AACtE,MAAIkE,iBAAiB,CAACv3B,QAAlB,KAA+BqzB,uBAAuB,CAACrzB,QAA3D,EAAqE;AACnE4wB,IAAAA,OAAO,CAAC2G,iBAAiB,CAACv3B,QAAnB,CAAP;AACD;;AACD,MACEu3B,iBAAiB,CAACr3B,kBAAlB,KACAmzB,uBAAuB,CAACnzB,kBAF1B,EAGE;AACA0wB,IAAAA,OAAO,CAAC2G,iBAAiB,CAACr3B,kBAAnB,CAAP;AACD;AACF,C,CAED;AACA;AACA;AACA;;;AACA,SAASu2B,iBAAT,CAA2B9gC,KAA3B,EAAkCkd,UAAlC,EAA8C;AAC5C;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA,MAAI0kB,iBAAiB,GAAG5hC,KAAK,CAACkK,kBAA9B;AACA,MAAIwzB,uBAAuB,GAAG19B,KAAK,CAAC2K,wBAApC;AACAg3B,EAAAA,kBAAkB,CAACC,iBAAD,EAAoBlE,uBAApB,CAAlB;AAEA,MAAI9nB,SAAJ;;AACA,MACE/F,iBAAiB,CAAC7P,KAAD,CAAjB,IACA4P,qBAAqB,CAAC5P,KAAD,CADrB,IAEAA,KAAK,CAAC8M,wBAHR,EAIE;AACA9M,IAAAA,KAAK,CAAC8M,wBAAN,GAAiC,KAAjC;AAEA80B,IAAAA,iBAAiB,CAACv3B,QAAlB,GAA6B,EAA7B;AACAu3B,IAAAA,iBAAiB,CAACr3B,kBAAlB,GAAuC,EAAvC;AAEA,QAAIs3B,eAAe,GAAG,EAAtB;AACA,QAAIvnB,UAAU,GAAGta,KAAK,CAACqL,iBAAvB;AACA,QAAIqK,SAAJ;;AAEA,SAAK,IAAIC,WAAT,IAAwB2E,UAAxB,EAAoC;AAClC,UAAIA,UAAU,CAAC/G,cAAX,CAA0BoC,WAA1B,CAAJ,EAA4C;AAC1CD,QAAAA,SAAS,GAAG4E,UAAU,CAAC3E,WAAD,CAAtB;AACAC,QAAAA,SAAS,GAAGF,SAAS,CAACG,OAAtB;;AACA,YAAI,CAACgsB,eAAe,CAACjsB,SAAD,CAApB,EAAiC;AAC/BisB,UAAAA,eAAe,CAACjsB,SAAD,CAAf,GAA6B,IAA7B;AACAuJ,UAAAA,eAAe,CACb;AACEvJ,YAAAA,SAAS,EAAEA,SADb;AAEED,YAAAA,WAAW,EAAEA;AAFf,WADa,EAKb3V,KALa,EAMbkd,UAAU,CAACxN,OANE,CAAf;AAQD;AACF;AACF;AACF,GA/BD,MA+BO;AACLkyB,IAAAA,iBAAiB,CAACv3B,QAAlB,GAA6BqzB,uBAAuB,CAACrzB,QAArD;AACAu3B,IAAAA,iBAAiB,CAACr3B,kBAAlB,GACEmzB,uBAAuB,CAACnzB,kBAD1B;AAED,GArD2C,CAuD5C;;;AACA,MAAI2kB,gBAAgB,GAAG0S,iBAAiB,CAACv3B,QAAzC;AAEA,MAAI2kB,YAAY,GAAGhvB,KAAK,CAACwL,aAAzB;AACA,MAAIs2B,YAAY,GAAG9S,YAAY,CAAC7tB,MAAhC;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG0gC,YAApB,EAAkC,EAAE1gC,CAApC,EAAuC;AACrC,QAAIgxB,WAAW,GAAGpD,YAAY,CAAC5tB,CAAD,CAA9B;AACAwU,IAAAA,SAAS,GAAGwc,WAAW,CAACxc,SAAxB;AAEA,QAAImsB,aAAa,GAAG7S,gBAAgB,CAACtZ,SAAD,CAApC;AACAwc,IAAAA,WAAW,CAACT,OAAZ,CAAoBG,aAApB,GAAoCiQ,aAApC;;AACA,QAAIvmC,OAAO,CAAC42B,WAAW,CAACF,SAAb,CAAX,EAAoC;AAClCE,MAAAA,WAAW,CAACF,SAAZ,CAAsBJ,aAAtB,GAAsCiQ,aAAtC;AACD;AACF,GArE2C,CAuE5C;;;AACAnL,EAAAA,WAAW,CAAC52B,KAAD,EAAQkd,UAAR,EAAoB,IAApB,CAAX;AACA8Z,EAAAA,qBAAqB,CAACh3B,KAAD,EAAQkd,UAAR,EAAoB,IAApB,CAArB;AACAuc,EAAAA,gBAAgB,CAACz5B,KAAD,EAAQkd,UAAR,EAAoB,IAApB,CAAhB;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAxb,KAAK,CAACd,SAAN,CAAgBU,WAAhB,GAA8B,YAAY;AACxC,SAAO,KAAP;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAI,KAAK,CAACd,SAAN,CAAgBq6B,OAAhB,GAA0B,YAAY;AACpC;AACA,MAAIz/B,OAAO,CAAC,KAAKmL,qBAAN,CAAX,EAAyC;AACvCs0B,IAAAA,OAAO,CAAC,KAAK/wB,kBAAL,CAAwBE,YAAzB,CAAP;AACD;;AAED,MAAI5O,OAAO,CAAC,KAAKwI,2BAAN,CAAX,EAA+C;AAC7C,SAAKA,2BAAL;;AACA,SAAKA,2BAAL,GAAmCzC,SAAnC;AACD;;AAED,MAAI/F,OAAO,CAAC,KAAK4I,+BAAN,CAAX,EAAmD;AACjD,SAAKA,+BAAL;;AACA,SAAKA,+BAAL,GAAuC7C,SAAvC;AACD,GAdmC,CAgBpC;;;AACA,MAAI/F,OAAO,CAAC,KAAKmP,wBAAN,CAAX,EAA4C;AAC1Cg3B,IAAAA,kBAAkB,CAAC,KAAKz3B,kBAAN,EAA0B,KAAKS,wBAA/B,CAAlB;AACD;;AAED,OAAKT,kBAAL,GAA0B3I,SAA1B;AACA,OAAKoJ,wBAAL,GACE,KAAKA,wBAAL,IAAiC,KAAKA,wBAAL,CAA8BywB,OAA9B,EADnC;AAEA58B,EAAAA,WAAW,CAACwjC,yBAAZ,CAAsC,IAAtC;AAEA,MAAInzB,OAAO,GAAG,KAAKpD,QAAnB;AACA,MAAItK,MAAM,GAAG0N,OAAO,CAAC1N,MAArB;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,MAApB,EAA4B,EAAEC,CAA9B,EAAiC;AAC/ByN,IAAAA,OAAO,CAACzN,CAAD,CAAP,CAAW65B,OAAX;AACD;;AAEDF,EAAAA,iBAAiB,CAAC,IAAD,CAAjB;AACA,OAAKxvB,uBAAL,GAA+BhK,SAA/B,CAjCoC,CAmCpC;AACA;;AACA,MAAI6d,uBAAuB,GAAG,KAAKtZ,eAAnC;;AACA,MACEtK,OAAO,CAAC4jB,uBAAD,CAAP,IACA,CAACA,uBAAuB,CAAC9d,WAAxB,EADD,IAEA8d,uBAAuB,CAACgS,KAAxB,KAAkC,IAHpC,EAIE;AACAhS,IAAAA,uBAAuB,CAAC6b,OAAxB;AACD;;AACD,OAAKn1B,eAAL,GAAuBvE,SAAvB;AAEA,OAAKoL,4BAAL,GACE,KAAKA,4BAAL,IACA,KAAKA,4BAAL,CAAkCsuB,OAAlC,EAFF;AAIA,SAAOx/B,aAAa,CAAC,IAAD,CAApB;AACD,CApDD,C,CAsDA;;;AACAiG,KAAK,CAAC83B,oBAAN,GAA6B96B,mBAA7B;AACAgD,KAAK,CAAC6d,qBAAN,GAA8BzB,oBAA9B;AACA,eAAepc,KAAf","sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport Credit from \"../Core/Credit.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport DistanceDisplayCondition from \"../Core/DistanceDisplayCondition.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport getAbsoluteUri from \"../Core/getAbsoluteUri.js\";\nimport getJsonFromTypedArray from \"../Core/getJsonFromTypedArray.js\";\nimport getMagic from \"../Core/getMagic.js\";\nimport getStringFromTypedArray from \"../Core/getStringFromTypedArray.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport loadCRN from \"../Core/loadCRN.js\";\nimport loadImageFromTypedArray from \"../Core/loadImageFromTypedArray.js\";\nimport loadKTX from \"../Core/loadKTX.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport Resource from \"../Core/Resource.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport Sampler from \"../Renderer/Sampler.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport TextureMinificationFilter from \"../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../Renderer/TextureWrap.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport addDefaults from \"../ThirdParty/GltfPipeline/addDefaults.js\";\nimport addPipelineExtras from \"../ThirdParty/GltfPipeline/addPipelineExtras.js\";\nimport ForEach from \"../ThirdParty/GltfPipeline/ForEach.js\";\nimport getAccessorByteStride from \"../ThirdParty/GltfPipeline/getAccessorByteStride.js\";\nimport hasExtension from \"../ThirdParty/GltfPipeline/hasExtension.js\";\nimport numberOfComponentsForType from \"../ThirdParty/GltfPipeline/numberOfComponentsForType.js\";\nimport parseGlb from \"../ThirdParty/GltfPipeline/parseGlb.js\";\nimport updateVersion from \"../ThirdParty/GltfPipeline/updateVersion.js\";\nimport when from \"../ThirdParty/when.js\";\nimport Axis from \"./Axis.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport ClippingPlaneCollection from \"./ClippingPlaneCollection.js\";\nimport ColorBlendMode from \"./ColorBlendMode.js\";\nimport DepthFunction from \"./DepthFunction.js\";\nimport DracoLoader from \"./DracoLoader.js\";\nimport getClipAndStyleCode from \"./getClipAndStyleCode.js\";\nimport getClippingFunction from \"./getClippingFunction.js\";\nimport HeightReference from \"./HeightReference.js\";\nimport JobType from \"./JobType.js\";\nimport ModelAnimationCache from \"./ModelAnimationCache.js\";\nimport ModelAnimationCollection from \"./ModelAnimationCollection.js\";\nimport ModelLoadResources from \"./ModelLoadResources.js\";\nimport ModelMaterial from \"./ModelMaterial.js\";\nimport ModelMesh from \"./ModelMesh.js\";\nimport ModelNode from \"./ModelNode.js\";\nimport ModelOutlineLoader from \"./ModelOutlineLoader.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport OctahedralProjectedCubeMap from \"./OctahedralProjectedCubeMap.js\";\nimport processModelMaterialsCommon from \"./processModelMaterialsCommon.js\";\nimport processPbrMaterials from \"./processPbrMaterials.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\n\nvar boundingSphereCartesian3Scratch = new Cartesian3();\n\nvar ModelState = ModelUtility.ModelState;\n\n// glTF MIME types discussed in https://github.com/KhronosGroup/glTF/issues/412 and https://github.com/KhronosGroup/glTF/issues/943\nvar defaultModelAccept =\n  \"model/gltf-binary,model/gltf+json;q=0.8,application/json;q=0.2,*/*;q=0.01\";\n\nvar articulationEpsilon = CesiumMath.EPSILON16;\n\n///////////////////////////////////////////////////////////////////////////\n\nfunction setCachedGltf(model, cachedGltf) {\n  model._cachedGltf = cachedGltf;\n}\n\n// glTF JSON can be big given embedded geometry, textures, and animations, so we\n// cache it across all models using the same url/cache-key.  This also reduces the\n// slight overhead in assigning defaults to missing values.\n//\n// Note that this is a global cache, compared to renderer resources, which\n// are cached per context.\nfunction CachedGltf(options) {\n  this._gltf = options.gltf;\n  this.ready = options.ready;\n  this.modelsToLoad = [];\n  this.count = 0;\n}\n\nObject.defineProperties(CachedGltf.prototype, {\n  gltf: {\n    set: function (value) {\n      this._gltf = value;\n    },\n\n    get: function () {\n      return this._gltf;\n    },\n  },\n});\n\nCachedGltf.prototype.makeReady = function (gltfJson) {\n  this.gltf = gltfJson;\n\n  var models = this.modelsToLoad;\n  var length = models.length;\n  for (var i = 0; i < length; ++i) {\n    var m = models[i];\n    if (!m.isDestroyed()) {\n      setCachedGltf(m, this);\n    }\n  }\n  this.modelsToLoad = undefined;\n  this.ready = true;\n};\n\nvar gltfCache = {};\nvar uriToGuid = {};\n///////////////////////////////////////////////////////////////////////////\n\n/**\n * A 3D model based on glTF, the runtime asset format for WebGL, OpenGL ES, and OpenGL.\n * <p>\n * Cesium includes support for geometry and materials, glTF animations, and glTF skinning.\n * In addition, individual glTF nodes are pickable with {@link Scene#pick} and animatable\n * with {@link Model#getNode}.  glTF cameras and lights are not currently supported.\n * </p>\n * <p>\n * An external glTF asset is created with {@link Model.fromGltf}.  glTF JSON can also be\n * created at runtime and passed to this constructor function.  In either case, the\n * {@link Model#readyPromise} is resolved when the model is ready to render, i.e.,\n * when the external binary, image, and shader files are downloaded and the WebGL\n * resources are created.\n * </p>\n * <p>\n * Cesium supports glTF assets with the following extensions:\n * <ul>\n * <li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_binary_glTF/README.md|KHR_binary_glTF (glTF 1.0)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_materials_common/README.md|KHR_materials_common (glTF 1.0)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Vendor/WEB3D_quantized_attributes/README.md|WEB3D_quantized_attributes (glTF 1.0)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/AGI_articulations/README.md|AGI_articulations}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/pull/1302|KHR_blend (draft)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_draco_mesh_compression/README.md|KHR_draco_mesh_compression}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/README.md|KHR_materials_pbrSpecularGlossiness}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit/README.md|KHR_materials_unlit}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_techniques_webgl/README.md|KHR_techniques_webgl}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_texture_transform/README.md|KHR_texture_transform}\n * </li>\n * </ul>\n * </p>\n * <p>\n * For high-precision rendering, Cesium supports the {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Vendor/CESIUM_RTC/README.md|CESIUM_RTC} extension, which introduces the\n * CESIUM_RTC_MODELVIEW parameter semantic that says the node is in WGS84 coordinates translated\n * relative to a local origin.\n * </p>\n *\n * @alias Model\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {Object|ArrayBuffer|Uint8Array} [options.gltf] A glTF JSON object, or a binary glTF buffer.\n * @param {Resource|String} [options.basePath=''] The base path that paths in the glTF JSON are relative to.\n * @param {Boolean} [options.show=true] Determines if the model primitive will be shown.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms the model from model to world coordinates.\n * @param {Number} [options.scale=1.0] A uniform scale applied to this model.\n * @param {Number} [options.minimumPixelSize=0.0] The approximate minimum pixel size of the model regardless of zoom.\n * @param {Number} [options.maximumScale] The maximum scale size of a model. An upper limit for minimumPixelSize.\n * @param {Object} [options.id] A user-defined object to return when the model is picked with {@link Scene#pick}.\n * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each glTF mesh and primitive is pickable with {@link Scene#pick}.\n * @param {Boolean} [options.incrementallyLoadTextures=true] Determine if textures may continue to stream in after the model is loaded.\n * @param {Boolean} [options.asynchronous=true] Determines if model WebGL resource creation will be spread out over several frames or block until completion once all glTF files are loaded.\n * @param {Boolean} [options.clampAnimations=true] Determines if the model's animations should hold a pose over frames where no keyframes are specified.\n * @param {ShadowMode} [options.shadows=ShadowMode.ENABLED] Determines whether the model casts or receives shadows from light sources.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Draws the bounding sphere for each draw command in the model.\n * @param {Boolean} [options.debugWireframe=false] For debugging only. Draws the model in wireframe.\n * @param {HeightReference} [options.heightReference=HeightReference.NONE] Determines how the model is drawn relative to terrain.\n * @param {Scene} [options.scene] Must be passed in for models that use the height reference property.\n * @param {DistanceDisplayCondition} [options.distanceDisplayCondition] The condition specifying at what distance from the camera that this model will be displayed.\n * @param {Color} [options.color=Color.WHITE] A color that blends with the model's rendered color.\n * @param {ColorBlendMode} [options.colorBlendMode=ColorBlendMode.HIGHLIGHT] Defines how the color blends with the model.\n * @param {Number} [options.colorBlendAmount=0.5] Value used to determine the color strength when the <code>colorBlendMode</code> is <code>MIX</code>. A value of 0.0 results in the model's rendered color while a value of 1.0 results in a solid color, with any value in-between resulting in a mix of the two.\n * @param {Color} [options.silhouetteColor=Color.RED] The silhouette color. If more than 256 models have silhouettes enabled, there is a small chance that overlapping models will have minor artifacts.\n * @param {Number} [options.silhouetteSize=0.0] The size of the silhouette in pixels.\n * @param {ClippingPlaneCollection} [options.clippingPlanes] The {@link ClippingPlaneCollection} used to selectively disable rendering the model.\n * @param {Boolean} [options.dequantizeInShader=true] Determines if a {@link https://github.com/google/draco|Draco} encoded model is dequantized on the GPU. This decreases total memory usage for encoded models.\n * @param {Cartesian2} [options.imageBasedLightingFactor=Cartesian2(1.0, 1.0)] Scales diffuse and specular image-based lighting from the earth, sky, atmosphere and star skybox.\n * @param {Cartesian3} [options.lightColor] The light color when shading the model. When <code>undefined</code> the scene's light color is used instead.\n * @param {Number} [options.luminanceAtZenith=0.2] The sun's luminance at the zenith in kilo candela per meter squared to use for this model's procedural environment map.\n * @param {Cartesian3[]} [options.sphericalHarmonicCoefficients] The third order spherical harmonic coefficients used for the diffuse color of image-based lighting.\n * @param {String} [options.specularEnvironmentMaps] A URL to a KTX file that contains a cube map of the specular lighting and the convoluted specular mipmaps.\n * @param {Credit|String} [options.credit] A credit for the data source, which is displayed on the canvas.\n * @param {Boolean} [options.backFaceCulling=true] Whether to cull back-facing geometry. When true, back face culling is determined by the material's doubleSided property; when false, back face culling is disabled. Back faces are not culled if {@link Model#color} is translucent or {@link Model#silhouetteSize} is greater than 0.0.\n *\n * @see Model.fromGltf\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=3D%20Models.html|Cesium Sandcastle Models Demo}\n */\nfunction Model(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  var cacheKey = options.cacheKey;\n  this._cacheKey = cacheKey;\n  this._cachedGltf = undefined;\n  this._releaseGltfJson = defaultValue(options.releaseGltfJson, false);\n\n  var cachedGltf;\n  if (\n    defined(cacheKey) &&\n    defined(gltfCache[cacheKey]) &&\n    gltfCache[cacheKey].ready\n  ) {\n    // glTF JSON is in cache and ready\n    cachedGltf = gltfCache[cacheKey];\n    ++cachedGltf.count;\n  } else {\n    // glTF was explicitly provided, e.g., when a user uses the Model constructor directly\n    var gltf = options.gltf;\n\n    if (defined(gltf)) {\n      if (gltf instanceof ArrayBuffer) {\n        gltf = new Uint8Array(gltf);\n      }\n\n      if (gltf instanceof Uint8Array) {\n        // Binary glTF\n        var parsedGltf = parseGlb(gltf);\n\n        cachedGltf = new CachedGltf({\n          gltf: parsedGltf,\n          ready: true,\n        });\n      } else {\n        // Normal glTF (JSON)\n        cachedGltf = new CachedGltf({\n          gltf: options.gltf,\n          ready: true,\n        });\n      }\n\n      cachedGltf.count = 1;\n\n      if (defined(cacheKey)) {\n        gltfCache[cacheKey] = cachedGltf;\n      }\n    }\n  }\n  setCachedGltf(this, cachedGltf);\n\n  var basePath = defaultValue(options.basePath, \"\");\n  this._resource = Resource.createIfNeeded(basePath);\n\n  // User specified credit\n  var credit = options.credit;\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n  this._credit = credit;\n\n  // Create a list of Credit's so they can be added from the Resource later\n  this._resourceCredits = [];\n\n  /**\n   * Determines if the model primitive will be shown.\n   *\n   * @type {Boolean}\n   *\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n\n  /**\n   * The silhouette color.\n   *\n   * @type {Color}\n   *\n   * @default Color.RED\n   */\n  this.silhouetteColor = defaultValue(options.silhouetteColor, Color.RED);\n  this._silhouetteColor = new Color();\n  this._silhouetteColorPreviousAlpha = 1.0;\n  this._normalAttributeName = undefined;\n\n  /**\n   * The size of the silhouette in pixels.\n   *\n   * @type {Number}\n   *\n   * @default 0.0\n   */\n  this.silhouetteSize = defaultValue(options.silhouetteSize, 0.0);\n\n  /**\n   * The 4x4 transformation matrix that transforms the model from model to world coordinates.\n   * When this is the identity matrix, the model is drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * @type {Matrix4}\n   *\n   * @default {@link Matrix4.IDENTITY}\n   *\n   * @example\n   * var origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);\n   * m.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);\n   */\n  this.modelMatrix = Matrix4.clone(\n    defaultValue(options.modelMatrix, Matrix4.IDENTITY)\n  );\n  this._modelMatrix = Matrix4.clone(this.modelMatrix);\n  this._clampedModelMatrix = undefined;\n\n  /**\n   * A uniform scale applied to this model before the {@link Model#modelMatrix}.\n   * Values greater than <code>1.0</code> increase the size of the model; values\n   * less than <code>1.0</code> decrease.\n   *\n   * @type {Number}\n   *\n   * @default 1.0\n   */\n  this.scale = defaultValue(options.scale, 1.0);\n  this._scale = this.scale;\n\n  /**\n   * The approximate minimum pixel size of the model regardless of zoom.\n   * This can be used to ensure that a model is visible even when the viewer\n   * zooms out.  When <code>0.0</code>, no minimum size is enforced.\n   *\n   * @type {Number}\n   *\n   * @default 0.0\n   */\n  this.minimumPixelSize = defaultValue(options.minimumPixelSize, 0.0);\n  this._minimumPixelSize = this.minimumPixelSize;\n\n  /**\n   * The maximum scale size for a model. This can be used to give\n   * an upper limit to the {@link Model#minimumPixelSize}, ensuring that the model\n   * is never an unreasonable scale.\n   *\n   * @type {Number}\n   */\n  this.maximumScale = options.maximumScale;\n  this._maximumScale = this.maximumScale;\n\n  /**\n   * User-defined object returned when the model is picked.\n   *\n   * @type Object\n   *\n   * @default undefined\n   *\n   * @see Scene#pick\n   */\n  this.id = options.id;\n  this._id = options.id;\n\n  /**\n   * Returns the height reference of the model\n   *\n   * @type {HeightReference}\n   *\n   * @default HeightReference.NONE\n   */\n  this.heightReference = defaultValue(\n    options.heightReference,\n    HeightReference.NONE\n  );\n  this._heightReference = this.heightReference;\n  this._heightChanged = false;\n  this._removeUpdateHeightCallback = undefined;\n  var scene = options.scene;\n  this._scene = scene;\n  if (defined(scene) && defined(scene.terrainProviderChanged)) {\n    this._terrainProviderChangedCallback = scene.terrainProviderChanged.addEventListener(\n      function () {\n        this._heightChanged = true;\n      },\n      this\n    );\n  }\n\n  /**\n   * Used for picking primitives that wrap a model.\n   *\n   * @private\n   */\n  this._pickObject = options.pickObject;\n  this._allowPicking = defaultValue(options.allowPicking, true);\n\n  this._ready = false;\n  this._readyPromise = when.defer();\n\n  /**\n   * The currently playing glTF animations.\n   *\n   * @type {ModelAnimationCollection}\n   */\n  this.activeAnimations = new ModelAnimationCollection(this);\n\n  /**\n   * Determines if the model's animations should hold a pose over frames where no keyframes are specified.\n   *\n   * @type {Boolean}\n   */\n  this.clampAnimations = defaultValue(options.clampAnimations, true);\n\n  this._defaultTexture = undefined;\n  this._incrementallyLoadTextures = defaultValue(\n    options.incrementallyLoadTextures,\n    true\n  );\n  this._asynchronous = defaultValue(options.asynchronous, true);\n\n  /**\n   * Determines whether the model casts or receives shadows from light sources.\n   *\n   * @type {ShadowMode}\n   *\n   * @default ShadowMode.ENABLED\n   */\n  this.shadows = defaultValue(options.shadows, ShadowMode.ENABLED);\n  this._shadows = this.shadows;\n\n  /**\n   * A color that blends with the model's rendered color.\n   *\n   * @type {Color}\n   *\n   * @default Color.WHITE\n   */\n  this.color = Color.clone(defaultValue(options.color, Color.WHITE));\n  this._colorPreviousAlpha = 1.0;\n\n  /**\n   * Defines how the color blends with the model.\n   *\n   * @type {ColorBlendMode}\n   *\n   * @default ColorBlendMode.HIGHLIGHT\n   */\n  this.colorBlendMode = defaultValue(\n    options.colorBlendMode,\n    ColorBlendMode.HIGHLIGHT\n  );\n\n  /**\n   * Value used to determine the color strength when the <code>colorBlendMode</code> is <code>MIX</code>.\n   * A value of 0.0 results in the model's rendered color while a value of 1.0 results in a solid color, with\n   * any value in-between resulting in a mix of the two.\n   *\n   * @type {Number}\n   *\n   * @default 0.5\n   */\n  this.colorBlendAmount = defaultValue(options.colorBlendAmount, 0.5);\n\n  this._colorShadingEnabled = false;\n\n  this._clippingPlanes = undefined;\n  this.clippingPlanes = options.clippingPlanes;\n  // Used for checking if shaders need to be regenerated due to clipping plane changes.\n  this._clippingPlanesState = 0;\n\n  // If defined, use this matrix to transform miscellaneous properties like\n  // clipping planes and IBL instead of the modelMatrix. This is so that when\n  // models are part of a tileset these properties get transformed relative to\n  // a common reference (such as the root).\n  this.referenceMatrix = undefined;\n\n  /**\n   * Whether to cull back-facing geometry. When true, back face culling is\n   * determined by the material's doubleSided property; when false, back face\n   * culling is disabled. Back faces are not culled if {@link Model#color} is\n   * translucent or {@link Model#silhouetteSize} is greater than 0.0.\n   *\n   * @type {Boolean}\n   *\n   * @default true\n   */\n  this.backFaceCulling = defaultValue(options.backFaceCulling, true);\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the model.  A glTF primitive corresponds\n   * to one draw command.  A glTF mesh has an array of primitives, often of length one.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = defaultValue(\n    options.debugShowBoundingVolume,\n    false\n  );\n  this._debugShowBoundingVolume = false;\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the model in wireframe.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n  this.debugWireframe = defaultValue(options.debugWireframe, false);\n  this._debugWireframe = false;\n\n  this._distanceDisplayCondition = options.distanceDisplayCondition;\n\n  // Undocumented options\n  this._addBatchIdToGeneratedShaders = options.addBatchIdToGeneratedShaders;\n  this._precreatedAttributes = options.precreatedAttributes;\n  this._vertexShaderLoaded = options.vertexShaderLoaded;\n  this._fragmentShaderLoaded = options.fragmentShaderLoaded;\n  this._uniformMapLoaded = options.uniformMapLoaded;\n  this._pickIdLoaded = options.pickIdLoaded;\n  this._ignoreCommands = defaultValue(options.ignoreCommands, false);\n  this._requestType = options.requestType;\n  this._upAxis = defaultValue(options.upAxis, Axis.Y);\n  this._gltfForwardAxis = Axis.Z;\n  this._forwardAxis = options.forwardAxis;\n\n  /**\n   * @private\n   * @readonly\n   */\n  this.cull = defaultValue(options.cull, true);\n\n  /**\n   * @private\n   * @readonly\n   */\n  this.opaquePass = defaultValue(options.opaquePass, Pass.OPAQUE);\n\n  this._computedModelMatrix = new Matrix4(); // Derived from modelMatrix and scale\n  this._clippingPlanesMatrix = Matrix4.clone(Matrix4.IDENTITY); // Derived from reference matrix and the current view matrix\n  this._iblReferenceFrameMatrix = Matrix3.clone(Matrix3.IDENTITY); // Derived from reference matrix and the current view matrix\n  this._initialRadius = undefined; // Radius without model's scale property, model-matrix scale, animations, or skins\n  this._boundingSphere = undefined;\n  this._scaledBoundingSphere = new BoundingSphere();\n  this._state = ModelState.NEEDS_LOAD;\n  this._loadResources = undefined;\n\n  this._mode = undefined;\n\n  this._perNodeShowDirty = false; // true when the Cesium API was used to change a node's show property\n  this._cesiumAnimationsDirty = false; // true when the Cesium API, not a glTF animation, changed a node transform\n  this._dirty = false; // true when the model was transformed this frame\n  this._maxDirtyNumber = 0; // Used in place of a dirty boolean flag to avoid an extra graph traversal\n\n  this._runtime = {\n    animations: undefined,\n    articulationsByName: undefined,\n    articulationsByStageKey: undefined,\n    stagesByKey: undefined,\n    rootNodes: undefined,\n    nodes: undefined, // Indexed with the node's index\n    nodesByName: undefined, // Indexed with name property in the node\n    skinnedNodes: undefined,\n    meshesByName: undefined, // Indexed with the name property in the mesh\n    materialsByName: undefined, // Indexed with the name property in the material\n    materialsById: undefined, // Indexed with the material's index\n  };\n\n  this._uniformMaps = {}; // Not cached since it can be targeted by glTF animation\n  this._extensionsUsed = undefined; // Cached used glTF extensions\n  this._extensionsRequired = undefined; // Cached required glTF extensions\n  this._quantizedUniforms = {}; // Quantized uniforms for each program for WEB3D_quantized_attributes\n  this._programPrimitives = {};\n  this._rendererResources = {\n    // Cached between models with the same url/cache-key\n    buffers: {},\n    vertexArrays: {},\n    programs: {},\n    sourceShaders: {},\n    silhouettePrograms: {},\n    textures: {},\n    samplers: {},\n    renderStates: {},\n  };\n  this._cachedRendererResources = undefined;\n  this._loadRendererResourcesFromCache = false;\n\n  this._dequantizeInShader = defaultValue(options.dequantizeInShader, true);\n  this._decodedData = {};\n\n  this._cachedGeometryByteLength = 0;\n  this._cachedTexturesByteLength = 0;\n  this._geometryByteLength = 0;\n  this._texturesByteLength = 0;\n  this._trianglesLength = 0;\n\n  // Hold references for shader reconstruction.\n  // Hold these separately because _cachedGltf may get released (this.releaseGltfJson)\n  this._sourceTechniques = {};\n  this._sourcePrograms = {};\n  this._quantizedVertexShaders = {};\n\n  this._nodeCommands = [];\n  this._pickIds = [];\n\n  // CESIUM_RTC extension\n  this._rtcCenter = undefined; // reference to either 3D or 2D\n  this._rtcCenterEye = undefined; // in eye coordinates\n  this._rtcCenter3D = undefined; // in world coordinates\n  this._rtcCenter2D = undefined; // in projected world coordinates\n\n  this._sourceVersion = undefined;\n  this._sourceKHRTechniquesWebGL = undefined;\n\n  this._imageBasedLightingFactor = new Cartesian2(1.0, 1.0);\n  Cartesian2.clone(\n    options.imageBasedLightingFactor,\n    this._imageBasedLightingFactor\n  );\n  this._lightColor = Cartesian3.clone(options.lightColor);\n\n  this._luminanceAtZenith = undefined;\n  this.luminanceAtZenith = defaultValue(options.luminanceAtZenith, 0.2);\n\n  this._sphericalHarmonicCoefficients = options.sphericalHarmonicCoefficients;\n  this._specularEnvironmentMaps = options.specularEnvironmentMaps;\n  this._shouldUpdateSpecularMapAtlas = true;\n  this._specularEnvironmentMapAtlas = undefined;\n\n  this._useDefaultSphericalHarmonics = false;\n  this._useDefaultSpecularMaps = false;\n\n  this._shouldRegenerateShaders = false;\n}\n\nObject.defineProperties(Model.prototype, {\n  /**\n   * The object for the glTF JSON, including properties with default values omitted\n   * from the JSON provided to this model.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Object}\n   * @readonly\n   *\n   * @default undefined\n   */\n  gltf: {\n    get: function () {\n      return defined(this._cachedGltf) ? this._cachedGltf.gltf : undefined;\n    },\n  },\n\n  /**\n   * When <code>true</code>, the glTF JSON is not stored with the model once the model is\n   * loaded (when {@link Model#ready} is <code>true</code>).  This saves memory when\n   * geometry, textures, and animations are embedded in the .gltf file.\n   * This is especially useful for cases like 3D buildings, where each .gltf model is unique\n   * and caching the glTF JSON is not effective.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   *\n   * @private\n   */\n  releaseGltfJson: {\n    get: function () {\n      return this._releaseGltfJson;\n    },\n  },\n\n  /**\n   * The key identifying this model in the model cache for glTF JSON, renderer resources, and animations.\n   * Caching saves memory and improves loading speed when several models with the same url are created.\n   * <p>\n   * This key is automatically generated when the model is created with {@link Model.fromGltf}.  If the model\n   * is created directly from glTF JSON using the {@link Model} constructor, this key can be manually\n   * provided; otherwise, the model will not be changed.\n   * </p>\n   *\n   * @memberof Model.prototype\n   *\n   * @type {String}\n   * @readonly\n   *\n   * @private\n   */\n  cacheKey: {\n    get: function () {\n      return this._cacheKey;\n    },\n  },\n\n  /**\n   * The base path that paths in the glTF JSON are relative to.  The base\n   * path is the same path as the path containing the .gltf file\n   * minus the .gltf file, when binary, image, and shader files are\n   * in the same directory as the .gltf.  When this is <code>''</code>,\n   * the app's base path is used.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {String}\n   * @readonly\n   *\n   * @default ''\n   */\n  basePath: {\n    get: function () {\n      return this._resource.url;\n    },\n  },\n\n  /**\n   * The model's bounding sphere in its local coordinate system.  This does not take into\n   * account glTF animations and skins nor does it take into account {@link Model#minimumPixelSize}.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {BoundingSphere}\n   * @readonly\n   *\n   * @default undefined\n   *\n   * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\n   *\n   * @example\n   * // Center in WGS84 coordinates\n   * var center = Cesium.Matrix4.multiplyByPoint(model.modelMatrix, model.boundingSphere.center, new Cesium.Cartesian3());\n   */\n  boundingSphere: {\n    get: function () {\n      //>>includeStart('debug', pragmas.debug);\n      if (this._state !== ModelState.LOADED) {\n        throw new DeveloperError(\n          \"The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      var modelMatrix = this.modelMatrix;\n      if (\n        this.heightReference !== HeightReference.NONE &&\n        this._clampedModelMatrix\n      ) {\n        modelMatrix = this._clampedModelMatrix;\n      }\n\n      var nonUniformScale = Matrix4.getScale(\n        modelMatrix,\n        boundingSphereCartesian3Scratch\n      );\n      var scale = defined(this.maximumScale)\n        ? Math.min(this.maximumScale, this.scale)\n        : this.scale;\n      Cartesian3.multiplyByScalar(nonUniformScale, scale, nonUniformScale);\n\n      var scaledBoundingSphere = this._scaledBoundingSphere;\n      scaledBoundingSphere.center = Cartesian3.multiplyComponents(\n        this._boundingSphere.center,\n        nonUniformScale,\n        scaledBoundingSphere.center\n      );\n      scaledBoundingSphere.radius =\n        Cartesian3.maximumComponent(nonUniformScale) * this._initialRadius;\n\n      if (defined(this._rtcCenter)) {\n        Cartesian3.add(\n          this._rtcCenter,\n          scaledBoundingSphere.center,\n          scaledBoundingSphere.center\n        );\n      }\n\n      return scaledBoundingSphere;\n    },\n  },\n\n  /**\n   * When <code>true</code>, this model is ready to render, i.e., the external binary, image,\n   * and shader files were downloaded and the WebGL resources were created.  This is set to\n   * <code>true</code> right before {@link Model#readyPromise} is resolved.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  /**\n   * Gets the promise that will be resolved when this model is ready to render, i.e., when the external binary, image,\n   * and shader files were downloaded and the WebGL resources were created.\n   * <p>\n   * This promise is resolved at the end of the frame before the first frame the model is rendered in.\n   * </p>\n   *\n   * @memberof Model.prototype\n   * @type {Promise.<Model>}\n   * @readonly\n   *\n   * @example\n   * // Play all animations at half-speed when the model is ready to render\n   * Cesium.when(model.readyPromise).then(function(model) {\n   *   model.activeAnimations.addAll({\n   *     multiplier : 0.5\n   *   });\n   * }).otherwise(function(error){\n   *   window.alert(error);\n   * });\n   *\n   * @see Model#ready\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    },\n  },\n\n  /**\n   * Determines if model WebGL resource creation will be spread out over several frames or\n   * block until completion once all glTF files are loaded.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  asynchronous: {\n    get: function () {\n      return this._asynchronous;\n    },\n  },\n\n  /**\n   * When <code>true</code>, each glTF mesh and primitive is pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  allowPicking: {\n    get: function () {\n      return this._allowPicking;\n    },\n  },\n\n  /**\n   * Determine if textures may continue to stream in after the model is loaded.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  incrementallyLoadTextures: {\n    get: function () {\n      return this._incrementallyLoadTextures;\n    },\n  },\n\n  /**\n   * Return the number of pending texture loads.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  pendingTextureLoads: {\n    get: function () {\n      return defined(this._loadResources)\n        ? this._loadResources.pendingTextureLoads\n        : 0;\n    },\n  },\n\n  /**\n   * Returns true if the model was transformed this frame\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @private\n   */\n  dirty: {\n    get: function () {\n      return this._dirty;\n    },\n  },\n\n  /**\n   * Gets or sets the condition specifying at what distance from the camera that this model will be displayed.\n   * @memberof Model.prototype\n   * @type {DistanceDisplayCondition}\n   * @default undefined\n   */\n  distanceDisplayCondition: {\n    get: function () {\n      return this._distanceDisplayCondition;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value.far <= value.near) {\n        throw new DeveloperError(\"far must be greater than near\");\n      }\n      //>>includeEnd('debug');\n      this._distanceDisplayCondition = DistanceDisplayCondition.clone(\n        value,\n        this._distanceDisplayCondition\n      );\n    },\n  },\n\n  extensionsUsed: {\n    get: function () {\n      if (!defined(this._extensionsUsed)) {\n        this._extensionsUsed = ModelUtility.getUsedExtensions(this.gltf);\n      }\n      return this._extensionsUsed;\n    },\n  },\n\n  extensionsRequired: {\n    get: function () {\n      if (!defined(this._extensionsRequired)) {\n        this._extensionsRequired = ModelUtility.getRequiredExtensions(\n          this.gltf\n        );\n      }\n      return this._extensionsRequired;\n    },\n  },\n\n  /**\n   * Gets the model's up-axis.\n   * By default models are y-up according to the glTF spec, however geo-referenced models will typically be z-up.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Number}\n   * @default Axis.Y\n   * @readonly\n   *\n   * @private\n   */\n  upAxis: {\n    get: function () {\n      return this._upAxis;\n    },\n  },\n\n  /**\n   * Gets the model's forward axis.\n   * By default, glTF 2.0 models are z-forward according to the glTF spec, however older\n   * glTF (1.0, 0.8) models used x-forward.  Note that only Axis.X and Axis.Z are supported.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Number}\n   * @default Axis.Z\n   * @readonly\n   *\n   * @private\n   */\n  forwardAxis: {\n    get: function () {\n      if (defined(this._forwardAxis)) {\n        return this._forwardAxis;\n      }\n      return this._gltfForwardAxis;\n    },\n  },\n\n  /**\n   * Gets the model's triangle count.\n   *\n   * @private\n   */\n  trianglesLength: {\n    get: function () {\n      return this._trianglesLength;\n    },\n  },\n\n  /**\n   * Gets the model's geometry memory in bytes. This includes all vertex and index buffers.\n   *\n   * @private\n   */\n  geometryByteLength: {\n    get: function () {\n      return this._geometryByteLength;\n    },\n  },\n\n  /**\n   * Gets the model's texture memory in bytes.\n   *\n   * @private\n   */\n  texturesByteLength: {\n    get: function () {\n      return this._texturesByteLength;\n    },\n  },\n\n  /**\n   * Gets the model's cached geometry memory in bytes. This includes all vertex and index buffers.\n   *\n   * @private\n   */\n  cachedGeometryByteLength: {\n    get: function () {\n      return this._cachedGeometryByteLength;\n    },\n  },\n\n  /**\n   * Gets the model's cached texture memory in bytes.\n   *\n   * @private\n   */\n  cachedTexturesByteLength: {\n    get: function () {\n      return this._cachedTexturesByteLength;\n    },\n  },\n\n  /**\n   * The {@link ClippingPlaneCollection} used to selectively disable rendering the model.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {ClippingPlaneCollection}\n   */\n  clippingPlanes: {\n    get: function () {\n      return this._clippingPlanes;\n    },\n    set: function (value) {\n      if (value === this._clippingPlanes) {\n        return;\n      }\n      // Handle destroying, checking of unknown, checking for existing ownership\n      ClippingPlaneCollection.setOwner(value, this, \"_clippingPlanes\");\n    },\n  },\n\n  /**\n   * @private\n   */\n  pickIds: {\n    get: function () {\n      return this._pickIds;\n    },\n  },\n\n  /**\n   * Cesium adds lighting from the earth, sky, atmosphere, and star skybox. This cartesian is used to scale the final\n   * diffuse and specular lighting contribution from those sources to the final color. A value of 0.0 will disable those light sources.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Cartesian2}\n   * @default Cartesian2(1.0, 1.0)\n   */\n  imageBasedLightingFactor: {\n    get: function () {\n      return this._imageBasedLightingFactor;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.object(\"imageBasedLightingFactor\", value);\n      Check.typeOf.number.greaterThanOrEquals(\n        \"imageBasedLightingFactor.x\",\n        value.x,\n        0.0\n      );\n      Check.typeOf.number.lessThanOrEquals(\n        \"imageBasedLightingFactor.x\",\n        value.x,\n        1.0\n      );\n      Check.typeOf.number.greaterThanOrEquals(\n        \"imageBasedLightingFactor.y\",\n        value.y,\n        0.0\n      );\n      Check.typeOf.number.lessThanOrEquals(\n        \"imageBasedLightingFactor.y\",\n        value.y,\n        1.0\n      );\n      //>>includeEnd('debug');\n      var imageBasedLightingFactor = this._imageBasedLightingFactor;\n      if (\n        value === imageBasedLightingFactor ||\n        Cartesian2.equals(value, imageBasedLightingFactor)\n      ) {\n        return;\n      }\n      this._shouldRegenerateShaders =\n        this._shouldRegenerateShaders ||\n        (this._imageBasedLightingFactor.x > 0.0 && value.x === 0.0) ||\n        (this._imageBasedLightingFactor.x === 0.0 && value.x > 0.0);\n      this._shouldRegenerateShaders =\n        this._shouldRegenerateShaders ||\n        (this._imageBasedLightingFactor.y > 0.0 && value.y === 0.0) ||\n        (this._imageBasedLightingFactor.y === 0.0 && value.y > 0.0);\n      Cartesian2.clone(value, this._imageBasedLightingFactor);\n    },\n  },\n\n  /**\n   * The light color when shading the model. When <code>undefined</code> the scene's light color is used instead.\n   * <p>\n   * For example, disabling additional light sources by setting <code>model.imageBasedLightingFactor = new Cesium.Cartesian2(0.0, 0.0)</code> will make the\n   * model much darker. Here, increasing the intensity of the light source will make the model brighter.\n   * </p>\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Cartesian3}\n   * @default undefined\n   */\n  lightColor: {\n    get: function () {\n      return this._lightColor;\n    },\n    set: function (value) {\n      var lightColor = this._lightColor;\n      if (value === lightColor || Cartesian3.equals(value, lightColor)) {\n        return;\n      }\n      this._shouldRegenerateShaders =\n        this._shouldRegenerateShaders ||\n        (defined(lightColor) && !defined(value)) ||\n        (defined(value) && !defined(lightColor));\n      this._lightColor = Cartesian3.clone(value, lightColor);\n    },\n  },\n\n  /**\n   * The sun's luminance at the zenith in kilo candela per meter squared to use for this model's procedural environment map.\n   * This is used when {@link Model#specularEnvironmentMaps} and {@link Model#sphericalHarmonicCoefficients} are not defined.\n   *\n   * @memberof Model.prototype\n   *\n   * @demo {@link https://sandcastle.cesium.com/index.html?src=Image-Based Lighting.html|Sandcastle Image Based Lighting Demo}\n   * @type {Number}\n   * @default 0.2\n   */\n  luminanceAtZenith: {\n    get: function () {\n      return this._luminanceAtZenith;\n    },\n    set: function (value) {\n      var lum = this._luminanceAtZenith;\n      if (value === lum) {\n        return;\n      }\n      this._shouldRegenerateShaders =\n        this._shouldRegenerateShaders ||\n        (defined(lum) && !defined(value)) ||\n        (defined(value) && !defined(lum));\n      this._luminanceAtZenith = value;\n    },\n  },\n\n  /**\n   * The third order spherical harmonic coefficients used for the diffuse color of image-based lighting. When <code>undefined</code>, a diffuse irradiance\n   * computed from the atmosphere color is used.\n   * <p>\n   * There are nine <code>Cartesian3</code> coefficients.\n   * The order of the coefficients is: L<sub>00</sub>, L<sub>1-1</sub>, L<sub>10</sub>, L<sub>11</sub>, L<sub>2-2</sub>, L<sub>2-1</sub>, L<sub>20</sub>, L<sub>21</sub>, L<sub>22</sub>\n   * </p>\n   *\n   * These values can be obtained by preprocessing the environment map using the <code>cmgen</code> tool of\n   * {@link https://github.com/google/filament/releases|Google's Filament project}. This will also generate a KTX file that can be\n   * supplied to {@link Model#specularEnvironmentMaps}.\n   *\n   * @memberof Model.prototype\n   *\n   * @type {Cartesian3[]}\n   * @demo {@link https://sandcastle.cesium.com/index.html?src=Image-Based Lighting.html|Sandcastle Image Based Lighting Demo}\n   * @see {@link https://graphics.stanford.edu/papers/envmap/envmap.pdf|An Efficient Representation for Irradiance Environment Maps}\n   */\n  sphericalHarmonicCoefficients: {\n    get: function () {\n      return this._sphericalHarmonicCoefficients;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && (!Array.isArray(value) || value.length !== 9)) {\n        throw new DeveloperError(\n          \"sphericalHarmonicCoefficients must be an array of 9 Cartesian3 values.\"\n        );\n      }\n      //>>includeEnd('debug');\n      if (value === this._sphericalHarmonicCoefficients) {\n        return;\n      }\n      this._sphericalHarmonicCoefficients = value;\n      this._shouldRegenerateShaders = true;\n    },\n  },\n\n  /**\n   * A URL to a KTX file that contains a cube map of the specular lighting and the convoluted specular mipmaps.\n   *\n   * @memberof Model.prototype\n   * @demo {@link https://sandcastle.cesium.com/index.html?src=Image-Based Lighting.html|Sandcastle Image Based Lighting Demo}\n   * @type {String}\n   * @see Model#sphericalHarmonicCoefficients\n   */\n  specularEnvironmentMaps: {\n    get: function () {\n      return this._specularEnvironmentMaps;\n    },\n    set: function (value) {\n      this._shouldUpdateSpecularMapAtlas =\n        this._shouldUpdateSpecularMapAtlas ||\n        value !== this._specularEnvironmentMaps;\n      this._specularEnvironmentMaps = value;\n    },\n  },\n  /**\n   * Gets the credit that will be displayed for the model\n   * @memberof Model.prototype\n   * @type {Credit}\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    },\n  },\n});\n\nfunction silhouetteSupported(context) {\n  return context.stencilBuffer;\n}\n\nfunction isColorShadingEnabled(model) {\n  return (\n    !Color.equals(model.color, Color.WHITE) ||\n    model.colorBlendMode !== ColorBlendMode.HIGHLIGHT\n  );\n}\n\nfunction isClippingEnabled(model) {\n  var clippingPlanes = model._clippingPlanes;\n  return (\n    defined(clippingPlanes) &&\n    clippingPlanes.enabled &&\n    clippingPlanes.length !== 0\n  );\n}\n\n/**\n * Determines if silhouettes are supported.\n *\n * @param {Scene} scene The scene.\n * @returns {Boolean} <code>true</code> if silhouettes are supported; otherwise, returns <code>false</code>\n */\nModel.silhouetteSupported = function (scene) {\n  return silhouetteSupported(scene.context);\n};\n\nfunction containsGltfMagic(uint8Array) {\n  var magic = getMagic(uint8Array);\n  return magic === \"glTF\";\n}\n\n/**\n * <p>\n * Creates a model from a glTF asset.  When the model is ready to render, i.e., when the external binary, image,\n * and shader files are downloaded and the WebGL resources are created, the {@link Model#readyPromise} is resolved.\n * </p>\n * <p>\n * The model can be a traditional glTF asset with a .gltf extension or a Binary glTF using the .glb extension.\n * </p>\n * <p>\n * Cesium supports glTF assets with the following extensions:\n * <ul>\n * <li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_binary_glTF/README.md|KHR_binary_glTF (glTF 1.0)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_materials_common/README.md|KHR_materials_common (glTF 1.0)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Vendor/WEB3D_quantized_attributes/README.md|WEB3D_quantized_attributes (glTF 1.0)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/AGI_articulations/README.md|AGI_articulations}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/pull/1302|KHR_blend (draft)}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_draco_mesh_compression/README.md|KHR_draco_mesh_compression}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/README.md|KHR_materials_pbrSpecularGlossiness}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit/README.md|KHR_materials_unlit}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_techniques_webgl/README.md|KHR_techniques_webgl}\n * </li><li>\n * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_texture_transform/README.md|KHR_texture_transform}\n * </li>\n * </ul>\n * </p>\n * <p>\n * For high-precision rendering, Cesium supports the {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Vendor/CESIUM_RTC/README.md|CESIUM_RTC} extension, which introduces the\n * CESIUM_RTC_MODELVIEW parameter semantic that says the node is in WGS84 coordinates translated\n * relative to a local origin.\n * </p>\n *\n * @param {Object} options Object with the following properties:\n * @param {Resource|String} options.url The url to the .gltf file.\n * @param {Resource|String} [options.basePath] The base path that paths in the glTF JSON are relative to.\n * @param {Boolean} [options.show=true] Determines if the model primitive will be shown.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms the model from model to world coordinates.\n * @param {Number} [options.scale=1.0] A uniform scale applied to this model.\n * @param {Number} [options.minimumPixelSize=0.0] The approximate minimum pixel size of the model regardless of zoom.\n * @param {Number} [options.maximumScale] The maximum scale for the model.\n * @param {Object} [options.id] A user-defined object to return when the model is picked with {@link Scene#pick}.\n * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each glTF mesh and primitive is pickable with {@link Scene#pick}.\n * @param {Boolean} [options.incrementallyLoadTextures=true] Determine if textures may continue to stream in after the model is loaded.\n * @param {Boolean} [options.asynchronous=true] Determines if model WebGL resource creation will be spread out over several frames or block until completion once all glTF files are loaded.\n * @param {Boolean} [options.clampAnimations=true] Determines if the model's animations should hold a pose over frames where no keyframes are specified.\n * @param {ShadowMode} [options.shadows=ShadowMode.ENABLED] Determines whether the model casts or receives shadows from light sources.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Draws the bounding sphere for each draw command in the model.\n * @param {Boolean} [options.debugWireframe=false] For debugging only. Draws the model in wireframe.\n * @param {HeightReference} [options.heightReference=HeightReference.NONE] Determines how the model is drawn relative to terrain.\n * @param {Scene} [options.scene] Must be passed in for models that use the height reference property.\n * @param {DistanceDisplayCondition} [options.distanceDisplayCondition] The condition specifying at what distance from the camera that this model will be displayed.\n * @param {Color} [options.color=Color.WHITE] A color that blends with the model's rendered color.\n * @param {ColorBlendMode} [options.colorBlendMode=ColorBlendMode.HIGHLIGHT] Defines how the color blends with the model.\n * @param {Number} [options.colorBlendAmount=0.5] Value used to determine the color strength when the <code>colorBlendMode</code> is <code>MIX</code>. A value of 0.0 results in the model's rendered color while a value of 1.0 results in a solid color, with any value in-between resulting in a mix of the two.\n * @param {Color} [options.silhouetteColor=Color.RED] The silhouette color. If more than 256 models have silhouettes enabled, there is a small chance that overlapping models will have minor artifacts.\n * @param {Number} [options.silhouetteSize=0.0] The size of the silhouette in pixels.\n * @param {ClippingPlaneCollection} [options.clippingPlanes] The {@link ClippingPlaneCollection} used to selectively disable rendering the model.\n * @param {Boolean} [options.dequantizeInShader=true] Determines if a {@link https://github.com/google/draco|Draco} encoded model is dequantized on the GPU. This decreases total memory usage for encoded models.\n * @param {Credit|String} [options.credit] A credit for the model, which is displayed on the canvas.\n * @param {Boolean} [options.backFaceCulling=true] Whether to cull back-facing geometry. When true, back face culling is determined by the material's doubleSided property; when false, back face culling is disabled. Back faces are not culled if {@link Model#color} is translucent or {@link Model#silhouetteSize} is greater than 0.0.\n *\n * @returns {Model} The newly created model.\n *\n * @example\n * // Example 1. Create a model from a glTF asset\n * var model = scene.primitives.add(Cesium.Model.fromGltf({\n *   url : './duck/duck.gltf'\n * }));\n *\n * @example\n * // Example 2. Create model and provide all properties and events\n * var origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);\n * var modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);\n *\n * var model = scene.primitives.add(Cesium.Model.fromGltf({\n *   url : './duck/duck.gltf',\n *   show : true,                     // default\n *   modelMatrix : modelMatrix,\n *   scale : 2.0,                     // double size\n *   minimumPixelSize : 128,          // never smaller than 128 pixels\n *   maximumScale: 20000,             // never larger than 20000 * model size (overrides minimumPixelSize)\n *   allowPicking : false,            // not pickable\n *   debugShowBoundingVolume : false, // default\n *   debugWireframe : false\n * }));\n *\n * model.readyPromise.then(function(model) {\n *   // Play all animations when the model is ready to render\n *   model.activeAnimations.addAll();\n * });\n */\nModel.fromGltf = function (options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options) || !defined(options.url)) {\n    throw new DeveloperError(\"options.url is required\");\n  }\n  //>>includeEnd('debug');\n\n  var url = options.url;\n  options = clone(options);\n\n  // Create resource for the model file\n  var modelResource = Resource.createIfNeeded(url);\n\n  // Setup basePath to get dependent files\n  var basePath = defaultValue(options.basePath, modelResource.clone());\n  var resource = Resource.createIfNeeded(basePath);\n\n  // If no cache key is provided, use a GUID.\n  // Check using a URI to GUID dictionary that we have not already added this model.\n  var cacheKey = defaultValue(\n    options.cacheKey,\n    uriToGuid[getAbsoluteUri(modelResource.url)]\n  );\n  if (!defined(cacheKey)) {\n    cacheKey = createGuid();\n    uriToGuid[getAbsoluteUri(modelResource.url)] = cacheKey;\n  }\n\n  if (defined(options.basePath) && !defined(options.cacheKey)) {\n    cacheKey += resource.url;\n  }\n  options.cacheKey = cacheKey;\n  options.basePath = resource;\n\n  var model = new Model(options);\n\n  var cachedGltf = gltfCache[cacheKey];\n  if (!defined(cachedGltf)) {\n    cachedGltf = new CachedGltf({\n      ready: false,\n    });\n    cachedGltf.count = 1;\n    cachedGltf.modelsToLoad.push(model);\n    setCachedGltf(model, cachedGltf);\n    gltfCache[cacheKey] = cachedGltf;\n\n    // Add Accept header if we need it\n    if (!defined(modelResource.headers.Accept)) {\n      modelResource.headers.Accept = defaultModelAccept;\n    }\n\n    modelResource\n      .fetchArrayBuffer()\n      .then(function (arrayBuffer) {\n        var array = new Uint8Array(arrayBuffer);\n        if (containsGltfMagic(array)) {\n          // Load binary glTF\n          var parsedGltf = parseGlb(array);\n          cachedGltf.makeReady(parsedGltf);\n        } else {\n          // Load text (JSON) glTF\n          var json = getJsonFromTypedArray(array);\n          cachedGltf.makeReady(json);\n        }\n\n        var resourceCredits = model._resourceCredits;\n        var credits = modelResource.credits;\n        if (defined(credits)) {\n          var length = credits.length;\n          for (var i = 0; i < length; i++) {\n            resourceCredits.push(credits[i]);\n          }\n        }\n      })\n      .otherwise(\n        ModelUtility.getFailedLoadFunction(model, \"model\", modelResource.url)\n      );\n  } else if (!cachedGltf.ready) {\n    // Cache hit but the fetchArrayBuffer() or fetchText() request is still pending\n    ++cachedGltf.count;\n    cachedGltf.modelsToLoad.push(model);\n  }\n  // else if the cached glTF is defined and ready, the\n  // model constructor will pick it up using the cache key.\n\n  return model;\n};\n\n/**\n * For the unit tests to verify model caching.\n *\n * @private\n */\nModel._gltfCache = gltfCache;\n\nfunction getRuntime(model, runtimeName, name) {\n  //>>includeStart('debug', pragmas.debug);\n  if (model._state !== ModelState.LOADED) {\n    throw new DeveloperError(\n      \"The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\"\n    );\n  }\n\n  if (!defined(name)) {\n    throw new DeveloperError(\"name is required.\");\n  }\n  //>>includeEnd('debug');\n\n  return model._runtime[runtimeName][name];\n}\n\n/**\n * Returns the glTF node with the given <code>name</code> property.  This is used to\n * modify a node's transform for animation outside of glTF animations.\n *\n * @param {String} name The glTF name of the node.\n * @returns {ModelNode} The node or <code>undefined</code> if no node with <code>name</code> exists.\n *\n * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\n *\n * @example\n * // Apply non-uniform scale to node LOD3sp\n * var node = model.getNode('LOD3sp');\n * node.matrix = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(5.0, 1.0, 1.0), node.matrix);\n */\nModel.prototype.getNode = function (name) {\n  var node = getRuntime(this, \"nodesByName\", name);\n  return defined(node) ? node.publicNode : undefined;\n};\n\n/**\n * Returns the glTF mesh with the given <code>name</code> property.\n *\n * @param {String} name The glTF name of the mesh.\n *\n * @returns {ModelMesh} The mesh or <code>undefined</code> if no mesh with <code>name</code> exists.\n *\n * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\n */\nModel.prototype.getMesh = function (name) {\n  return getRuntime(this, \"meshesByName\", name);\n};\n\n/**\n * Returns the glTF material with the given <code>name</code> property.\n *\n * @param {String} name The glTF name of the material.\n * @returns {ModelMaterial} The material or <code>undefined</code> if no material with <code>name</code> exists.\n *\n * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\n */\nModel.prototype.getMaterial = function (name) {\n  return getRuntime(this, \"materialsByName\", name);\n};\n\n/**\n * Sets the current value of an articulation stage.  After setting one or multiple stage values, call\n * Model.applyArticulations() to cause the node matrices to be recalculated.\n *\n * @param {String} articulationStageKey The name of the articulation, a space, and the name of the stage.\n * @param {Number} value The numeric value of this stage of the articulation.\n *\n * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\n *\n * @see Model#applyArticulations\n */\nModel.prototype.setArticulationStage = function (articulationStageKey, value) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"value\", value);\n  //>>includeEnd('debug');\n\n  var stage = getRuntime(this, \"stagesByKey\", articulationStageKey);\n  var articulation = getRuntime(\n    this,\n    \"articulationsByStageKey\",\n    articulationStageKey\n  );\n  if (defined(stage) && defined(articulation)) {\n    value = CesiumMath.clamp(value, stage.minimumValue, stage.maximumValue);\n    if (\n      !CesiumMath.equalsEpsilon(stage.currentValue, value, articulationEpsilon)\n    ) {\n      stage.currentValue = value;\n      articulation.isDirty = true;\n    }\n  }\n};\n\nvar scratchArticulationCartesian = new Cartesian3();\nvar scratchArticulationRotation = new Matrix3();\n\n/**\n * Modifies a Matrix4 by applying a transformation for a given value of a stage.  Note this is different usage\n * from the typical <code>result</code> parameter, in that the incoming value of <code>result</code> is\n * meaningful.  Various stages of an articulation can be multiplied together, so their\n * transformations are all merged into a composite Matrix4 representing them all.\n *\n * @param {object} stage The stage of an articulation that is being evaluated.\n * @param {Matrix4} result The matrix to be modified.\n * @returns {Matrix4} A matrix transformed as requested by the articulation stage.\n *\n * @private\n */\nfunction applyArticulationStageMatrix(stage, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"stage\", stage);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var value = stage.currentValue;\n  var cartesian = scratchArticulationCartesian;\n  var rotation;\n  switch (stage.type) {\n    case \"xRotate\":\n      rotation = Matrix3.fromRotationX(\n        CesiumMath.toRadians(value),\n        scratchArticulationRotation\n      );\n      Matrix4.multiplyByMatrix3(result, rotation, result);\n      break;\n    case \"yRotate\":\n      rotation = Matrix3.fromRotationY(\n        CesiumMath.toRadians(value),\n        scratchArticulationRotation\n      );\n      Matrix4.multiplyByMatrix3(result, rotation, result);\n      break;\n    case \"zRotate\":\n      rotation = Matrix3.fromRotationZ(\n        CesiumMath.toRadians(value),\n        scratchArticulationRotation\n      );\n      Matrix4.multiplyByMatrix3(result, rotation, result);\n      break;\n    case \"xTranslate\":\n      cartesian.x = value;\n      cartesian.y = 0.0;\n      cartesian.z = 0.0;\n      Matrix4.multiplyByTranslation(result, cartesian, result);\n      break;\n    case \"yTranslate\":\n      cartesian.x = 0.0;\n      cartesian.y = value;\n      cartesian.z = 0.0;\n      Matrix4.multiplyByTranslation(result, cartesian, result);\n      break;\n    case \"zTranslate\":\n      cartesian.x = 0.0;\n      cartesian.y = 0.0;\n      cartesian.z = value;\n      Matrix4.multiplyByTranslation(result, cartesian, result);\n      break;\n    case \"xScale\":\n      cartesian.x = value;\n      cartesian.y = 1.0;\n      cartesian.z = 1.0;\n      Matrix4.multiplyByScale(result, cartesian, result);\n      break;\n    case \"yScale\":\n      cartesian.x = 1.0;\n      cartesian.y = value;\n      cartesian.z = 1.0;\n      Matrix4.multiplyByScale(result, cartesian, result);\n      break;\n    case \"zScale\":\n      cartesian.x = 1.0;\n      cartesian.y = 1.0;\n      cartesian.z = value;\n      Matrix4.multiplyByScale(result, cartesian, result);\n      break;\n    case \"uniformScale\":\n      Matrix4.multiplyByUniformScale(result, value, result);\n      break;\n    default:\n      break;\n  }\n  return result;\n}\n\nvar scratchApplyArticulationTransform = new Matrix4();\n\n/**\n * Applies any modified articulation stages to the matrix of each node that participates\n * in any articulation.  Note that this will overwrite any nodeTransformations on participating nodes.\n *\n * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.\n */\nModel.prototype.applyArticulations = function () {\n  var articulationsByName = this._runtime.articulationsByName;\n  for (var articulationName in articulationsByName) {\n    if (articulationsByName.hasOwnProperty(articulationName)) {\n      var articulation = articulationsByName[articulationName];\n      if (articulation.isDirty) {\n        articulation.isDirty = false;\n        var numNodes = articulation.nodes.length;\n        for (var n = 0; n < numNodes; ++n) {\n          var node = articulation.nodes[n];\n          var transform = Matrix4.clone(\n            node.originalMatrix,\n            scratchApplyArticulationTransform\n          );\n\n          var numStages = articulation.stages.length;\n          for (var s = 0; s < numStages; ++s) {\n            var stage = articulation.stages[s];\n            transform = applyArticulationStageMatrix(stage, transform);\n          }\n          node.matrix = transform;\n        }\n      }\n    }\n  }\n};\n\n///////////////////////////////////////////////////////////////////////////\n\nfunction addBuffersToLoadResources(model) {\n  var gltf = model.gltf;\n  var loadResources = model._loadResources;\n  ForEach.buffer(gltf, function (buffer, id) {\n    loadResources.buffers[id] = buffer.extras._pipeline.source;\n  });\n}\n\nfunction bufferLoad(model, id) {\n  return function (arrayBuffer) {\n    var loadResources = model._loadResources;\n    var buffer = new Uint8Array(arrayBuffer);\n    --loadResources.pendingBufferLoads;\n    model.gltf.buffers[id].extras._pipeline.source = buffer;\n  };\n}\n\nfunction parseBufferViews(model) {\n  var bufferViews = model.gltf.bufferViews;\n  var vertexBuffersToCreate = model._loadResources.vertexBuffersToCreate;\n\n  // Only ARRAY_BUFFER here.  ELEMENT_ARRAY_BUFFER created below.\n  ForEach.bufferView(model.gltf, function (bufferView, id) {\n    if (bufferView.target === WebGLConstants.ARRAY_BUFFER) {\n      vertexBuffersToCreate.enqueue(id);\n    }\n  });\n\n  var indexBuffersToCreate = model._loadResources.indexBuffersToCreate;\n  var indexBufferIds = {};\n\n  // The Cesium Renderer requires knowing the datatype for an index buffer\n  // at creation type, which is not part of the glTF bufferview so loop\n  // through glTF accessors to create the bufferview's index buffer.\n  ForEach.accessor(model.gltf, function (accessor) {\n    var bufferViewId = accessor.bufferView;\n    if (!defined(bufferViewId)) {\n      return;\n    }\n\n    var bufferView = bufferViews[bufferViewId];\n    if (\n      bufferView.target === WebGLConstants.ELEMENT_ARRAY_BUFFER &&\n      !defined(indexBufferIds[bufferViewId])\n    ) {\n      indexBufferIds[bufferViewId] = true;\n      indexBuffersToCreate.enqueue({\n        id: bufferViewId,\n        componentType: accessor.componentType,\n      });\n    }\n  });\n}\n\nfunction parseTechniques(model) {\n  // retain references to gltf techniques\n  var gltf = model.gltf;\n  if (!hasExtension(gltf, \"KHR_techniques_webgl\")) {\n    return;\n  }\n\n  var sourcePrograms = model._sourcePrograms;\n  var sourceTechniques = model._sourceTechniques;\n  var programs = gltf.extensions.KHR_techniques_webgl.programs;\n\n  ForEach.technique(gltf, function (technique, techniqueId) {\n    sourceTechniques[techniqueId] = clone(technique);\n\n    var programId = technique.program;\n    if (!defined(sourcePrograms[programId])) {\n      sourcePrograms[programId] = clone(programs[programId]);\n    }\n  });\n}\n\nfunction shaderLoad(model, type, id) {\n  return function (source) {\n    var loadResources = model._loadResources;\n    loadResources.shaders[id] = {\n      source: source,\n      type: type,\n      bufferView: undefined,\n    };\n    --loadResources.pendingShaderLoads;\n    model._rendererResources.sourceShaders[id] = source;\n  };\n}\n\nfunction parseShaders(model) {\n  var gltf = model.gltf;\n  var buffers = gltf.buffers;\n  var bufferViews = gltf.bufferViews;\n  var sourceShaders = model._rendererResources.sourceShaders;\n  ForEach.shader(gltf, function (shader, id) {\n    // Shader references either uri (external or base64-encoded) or bufferView\n    if (defined(shader.bufferView)) {\n      var bufferViewId = shader.bufferView;\n      var bufferView = bufferViews[bufferViewId];\n      var bufferId = bufferView.buffer;\n      var buffer = buffers[bufferId];\n      var source = getStringFromTypedArray(\n        buffer.extras._pipeline.source,\n        bufferView.byteOffset,\n        bufferView.byteLength\n      );\n      sourceShaders[id] = source;\n    } else if (defined(shader.extras._pipeline.source)) {\n      sourceShaders[id] = shader.extras._pipeline.source;\n    } else {\n      ++model._loadResources.pendingShaderLoads;\n\n      var shaderResource = model._resource.getDerivedResource({\n        url: shader.uri,\n      });\n\n      shaderResource\n        .fetchText()\n        .then(shaderLoad(model, shader.type, id))\n        .otherwise(\n          ModelUtility.getFailedLoadFunction(\n            model,\n            \"shader\",\n            shaderResource.url\n          )\n        );\n    }\n  });\n}\n\nfunction parsePrograms(model) {\n  var sourceTechniques = model._sourceTechniques;\n  for (var techniqueId in sourceTechniques) {\n    if (sourceTechniques.hasOwnProperty(techniqueId)) {\n      var technique = sourceTechniques[techniqueId];\n      model._loadResources.programsToCreate.enqueue({\n        programId: technique.program,\n        techniqueId: techniqueId,\n      });\n    }\n  }\n}\n\nfunction parseArticulations(model) {\n  var articulationsByName = {};\n  var articulationsByStageKey = {};\n  var runtimeStagesByKey = {};\n\n  model._runtime.articulationsByName = articulationsByName;\n  model._runtime.articulationsByStageKey = articulationsByStageKey;\n  model._runtime.stagesByKey = runtimeStagesByKey;\n\n  var gltf = model.gltf;\n  if (\n    !hasExtension(gltf, \"AGI_articulations\") ||\n    !defined(gltf.extensions) ||\n    !defined(gltf.extensions.AGI_articulations)\n  ) {\n    return;\n  }\n\n  var gltfArticulations = gltf.extensions.AGI_articulations.articulations;\n  if (!defined(gltfArticulations)) {\n    return;\n  }\n\n  var numArticulations = gltfArticulations.length;\n  for (var i = 0; i < numArticulations; ++i) {\n    var articulation = clone(gltfArticulations[i]);\n    articulation.nodes = [];\n    articulation.isDirty = true;\n    articulationsByName[articulation.name] = articulation;\n\n    var numStages = articulation.stages.length;\n    for (var s = 0; s < numStages; ++s) {\n      var stage = articulation.stages[s];\n      stage.currentValue = stage.initialValue;\n\n      var stageKey = articulation.name + \" \" + stage.name;\n      articulationsByStageKey[stageKey] = articulation;\n      runtimeStagesByKey[stageKey] = stage;\n    }\n  }\n}\n\nfunction imageLoad(model, textureId) {\n  return function (image) {\n    var loadResources = model._loadResources;\n    --loadResources.pendingTextureLoads;\n    loadResources.texturesToCreate.enqueue({\n      id: textureId,\n      image: image,\n      bufferView: image.bufferView,\n      width: image.width,\n      height: image.height,\n      internalFormat: image.internalFormat,\n    });\n  };\n}\n\nvar ktxRegex = /(^data:image\\/ktx)|(\\.ktx$)/i;\nvar crnRegex = /(^data:image\\/crn)|(\\.crn$)/i;\n\nfunction parseTextures(model, context, supportsWebP) {\n  var gltf = model.gltf;\n  var images = gltf.images;\n  var uri;\n  ForEach.texture(gltf, function (texture, id) {\n    var imageId = texture.source;\n\n    if (\n      defined(texture.extensions) &&\n      defined(texture.extensions.EXT_texture_webp) &&\n      supportsWebP\n    ) {\n      imageId = texture.extensions.EXT_texture_webp.source;\n    }\n\n    var gltfImage = images[imageId];\n    var extras = gltfImage.extras;\n\n    var bufferViewId = gltfImage.bufferView;\n    var mimeType = gltfImage.mimeType;\n    uri = gltfImage.uri;\n\n    // First check for a compressed texture\n    if (defined(extras) && defined(extras.compressedImage3DTiles)) {\n      var crunch = extras.compressedImage3DTiles.crunch;\n      var s3tc = extras.compressedImage3DTiles.s3tc;\n      var pvrtc = extras.compressedImage3DTiles.pvrtc1;\n      var etc1 = extras.compressedImage3DTiles.etc1;\n\n      if (context.s3tc && defined(crunch)) {\n        mimeType = crunch.mimeType;\n        if (defined(crunch.bufferView)) {\n          bufferViewId = crunch.bufferView;\n        } else {\n          uri = crunch.uri;\n        }\n      } else if (context.s3tc && defined(s3tc)) {\n        mimeType = s3tc.mimeType;\n        if (defined(s3tc.bufferView)) {\n          bufferViewId = s3tc.bufferView;\n        } else {\n          uri = s3tc.uri;\n        }\n      } else if (context.pvrtc && defined(pvrtc)) {\n        mimeType = pvrtc.mimeType;\n        if (defined(pvrtc.bufferView)) {\n          bufferViewId = pvrtc.bufferView;\n        } else {\n          uri = pvrtc.uri;\n        }\n      } else if (context.etc1 && defined(etc1)) {\n        mimeType = etc1.mimeType;\n        if (defined(etc1.bufferView)) {\n          bufferViewId = etc1.bufferView;\n        } else {\n          uri = etc1.uri;\n        }\n      }\n    }\n\n    // Image references either uri (external or base64-encoded) or bufferView\n    if (defined(bufferViewId)) {\n      model._loadResources.texturesToCreateFromBufferView.enqueue({\n        id: id,\n        image: undefined,\n        bufferView: bufferViewId,\n        mimeType: mimeType,\n      });\n    } else {\n      ++model._loadResources.pendingTextureLoads;\n\n      var imageResource = model._resource.getDerivedResource({\n        url: uri,\n      });\n\n      var promise;\n      if (ktxRegex.test(uri)) {\n        promise = loadKTX(imageResource);\n      } else if (crnRegex.test(uri)) {\n        promise = loadCRN(imageResource);\n      } else {\n        promise = imageResource.fetchImage();\n      }\n      promise\n        .then(imageLoad(model, id, imageId))\n        .otherwise(\n          ModelUtility.getFailedLoadFunction(model, \"image\", imageResource.url)\n        );\n    }\n  });\n}\n\nvar scratchArticulationStageInitialTransform = new Matrix4();\n\nfunction parseNodes(model) {\n  var runtimeNodes = {};\n  var runtimeNodesByName = {};\n  var skinnedNodes = [];\n\n  var skinnedNodesIds = model._loadResources.skinnedNodesIds;\n  var articulationsByName = model._runtime.articulationsByName;\n\n  ForEach.node(model.gltf, function (node, id) {\n    var runtimeNode = {\n      // Animation targets\n      matrix: undefined,\n      translation: undefined,\n      rotation: undefined,\n      scale: undefined,\n\n      // Per-node show inherited from parent\n      computedShow: true,\n\n      // Computed transforms\n      transformToRoot: new Matrix4(),\n      computedMatrix: new Matrix4(),\n      dirtyNumber: 0, // The frame this node was made dirty by an animation; for graph traversal\n\n      // Rendering\n      commands: [], // empty for transform, light, and camera nodes\n\n      // Skinned node\n      inverseBindMatrices: undefined, // undefined when node is not skinned\n      bindShapeMatrix: undefined, // undefined when node is not skinned or identity\n      joints: [], // empty when node is not skinned\n      computedJointMatrices: [], // empty when node is not skinned\n\n      // Joint node\n      jointName: node.jointName, // undefined when node is not a joint\n\n      weights: [],\n\n      // Graph pointers\n      children: [], // empty for leaf nodes\n      parents: [], // empty for root nodes\n\n      // Publicly-accessible ModelNode instance to modify animation targets\n      publicNode: undefined,\n    };\n    runtimeNode.publicNode = new ModelNode(\n      model,\n      node,\n      runtimeNode,\n      id,\n      ModelUtility.getTransform(node)\n    );\n\n    runtimeNodes[id] = runtimeNode;\n    runtimeNodesByName[node.name] = runtimeNode;\n\n    if (defined(node.skin)) {\n      skinnedNodesIds.push(id);\n      skinnedNodes.push(runtimeNode);\n    }\n\n    if (\n      defined(node.extensions) &&\n      defined(node.extensions.AGI_articulations)\n    ) {\n      var articulationName = node.extensions.AGI_articulations.articulationName;\n      if (defined(articulationName)) {\n        var transform = Matrix4.clone(\n          runtimeNode.publicNode.originalMatrix,\n          scratchArticulationStageInitialTransform\n        );\n        var articulation = articulationsByName[articulationName];\n        articulation.nodes.push(runtimeNode.publicNode);\n\n        var numStages = articulation.stages.length;\n        for (var s = 0; s < numStages; ++s) {\n          var stage = articulation.stages[s];\n          transform = applyArticulationStageMatrix(stage, transform);\n        }\n        runtimeNode.publicNode.matrix = transform;\n      }\n    }\n  });\n\n  model._runtime.nodes = runtimeNodes;\n  model._runtime.nodesByName = runtimeNodesByName;\n  model._runtime.skinnedNodes = skinnedNodes;\n}\n\nfunction parseMaterials(model) {\n  var gltf = model.gltf;\n  var techniques = model._sourceTechniques;\n\n  var runtimeMaterialsByName = {};\n  var runtimeMaterialsById = {};\n  var uniformMaps = model._uniformMaps;\n\n  ForEach.material(gltf, function (material, materialId) {\n    // Allocated now so ModelMaterial can keep a reference to it.\n    uniformMaps[materialId] = {\n      uniformMap: undefined,\n      values: undefined,\n      jointMatrixUniformName: undefined,\n      morphWeightsUniformName: undefined,\n    };\n\n    var modelMaterial = new ModelMaterial(model, material, materialId);\n\n    if (\n      defined(material.extensions) &&\n      defined(material.extensions.KHR_techniques_webgl)\n    ) {\n      var techniqueId = material.extensions.KHR_techniques_webgl.technique;\n      modelMaterial._technique = techniqueId;\n      modelMaterial._program = techniques[techniqueId].program;\n\n      ForEach.materialValue(material, function (value, uniformName) {\n        if (!defined(modelMaterial._values)) {\n          modelMaterial._values = {};\n        }\n\n        modelMaterial._values[uniformName] = clone(value);\n      });\n    }\n\n    runtimeMaterialsByName[material.name] = modelMaterial;\n    runtimeMaterialsById[materialId] = modelMaterial;\n  });\n\n  model._runtime.materialsByName = runtimeMaterialsByName;\n  model._runtime.materialsById = runtimeMaterialsById;\n}\n\nfunction parseMeshes(model) {\n  var runtimeMeshesByName = {};\n  var runtimeMaterialsById = model._runtime.materialsById;\n\n  ForEach.mesh(model.gltf, function (mesh, meshId) {\n    runtimeMeshesByName[mesh.name] = new ModelMesh(\n      mesh,\n      runtimeMaterialsById,\n      meshId\n    );\n    if (\n      defined(model.extensionsUsed.WEB3D_quantized_attributes) ||\n      model._dequantizeInShader\n    ) {\n      // Cache primitives according to their program\n      ForEach.meshPrimitive(mesh, function (primitive, primitiveId) {\n        var programId = getProgramForPrimitive(model, primitive);\n        var programPrimitives = model._programPrimitives[programId];\n        if (!defined(programPrimitives)) {\n          programPrimitives = {};\n          model._programPrimitives[programId] = programPrimitives;\n        }\n        programPrimitives[meshId + \".primitive.\" + primitiveId] = primitive;\n      });\n    }\n  });\n\n  model._runtime.meshesByName = runtimeMeshesByName;\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nvar CreateVertexBufferJob = function () {\n  this.id = undefined;\n  this.model = undefined;\n  this.context = undefined;\n};\n\nCreateVertexBufferJob.prototype.set = function (id, model, context) {\n  this.id = id;\n  this.model = model;\n  this.context = context;\n};\n\nCreateVertexBufferJob.prototype.execute = function () {\n  createVertexBuffer(this.id, this.model, this.context);\n};\n\n///////////////////////////////////////////////////////////////////////////\n\nfunction createVertexBuffer(bufferViewId, model, context) {\n  var loadResources = model._loadResources;\n  var bufferViews = model.gltf.bufferViews;\n  var bufferView = bufferViews[bufferViewId];\n\n  // Use bufferView created at runtime\n  if (!defined(bufferView)) {\n    bufferView = loadResources.createdBufferViews[bufferViewId];\n  }\n\n  var vertexBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: loadResources.getBuffer(bufferView),\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  vertexBuffer.vertexArrayDestroyable = false;\n  model._rendererResources.buffers[bufferViewId] = vertexBuffer;\n  model._geometryByteLength += vertexBuffer.sizeInBytes;\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nvar CreateIndexBufferJob = function () {\n  this.id = undefined;\n  this.componentType = undefined;\n  this.model = undefined;\n  this.context = undefined;\n};\n\nCreateIndexBufferJob.prototype.set = function (\n  id,\n  componentType,\n  model,\n  context\n) {\n  this.id = id;\n  this.componentType = componentType;\n  this.model = model;\n  this.context = context;\n};\n\nCreateIndexBufferJob.prototype.execute = function () {\n  createIndexBuffer(this.id, this.componentType, this.model, this.context);\n};\n\n///////////////////////////////////////////////////////////////////////////\n\nfunction createIndexBuffer(bufferViewId, componentType, model, context) {\n  var loadResources = model._loadResources;\n  var bufferViews = model.gltf.bufferViews;\n  var bufferView = bufferViews[bufferViewId];\n\n  // Use bufferView created at runtime\n  if (!defined(bufferView)) {\n    bufferView = loadResources.createdBufferViews[bufferViewId];\n  }\n\n  var indexBuffer = Buffer.createIndexBuffer({\n    context: context,\n    typedArray: loadResources.getBuffer(bufferView),\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: componentType,\n  });\n  indexBuffer.vertexArrayDestroyable = false;\n  model._rendererResources.buffers[bufferViewId] = indexBuffer;\n  model._geometryByteLength += indexBuffer.sizeInBytes;\n}\n\nvar scratchVertexBufferJob = new CreateVertexBufferJob();\nvar scratchIndexBufferJob = new CreateIndexBufferJob();\n\nfunction createBuffers(model, frameState) {\n  var loadResources = model._loadResources;\n\n  if (loadResources.pendingBufferLoads !== 0) {\n    return;\n  }\n\n  var context = frameState.context;\n  var vertexBuffersToCreate = loadResources.vertexBuffersToCreate;\n  var indexBuffersToCreate = loadResources.indexBuffersToCreate;\n  var i;\n\n  if (model.asynchronous) {\n    while (vertexBuffersToCreate.length > 0) {\n      scratchVertexBufferJob.set(vertexBuffersToCreate.peek(), model, context);\n      if (\n        !frameState.jobScheduler.execute(scratchVertexBufferJob, JobType.BUFFER)\n      ) {\n        break;\n      }\n      vertexBuffersToCreate.dequeue();\n    }\n\n    while (indexBuffersToCreate.length > 0) {\n      i = indexBuffersToCreate.peek();\n      scratchIndexBufferJob.set(i.id, i.componentType, model, context);\n      if (\n        !frameState.jobScheduler.execute(scratchIndexBufferJob, JobType.BUFFER)\n      ) {\n        break;\n      }\n      indexBuffersToCreate.dequeue();\n    }\n  } else {\n    while (vertexBuffersToCreate.length > 0) {\n      createVertexBuffer(vertexBuffersToCreate.dequeue(), model, context);\n    }\n\n    while (indexBuffersToCreate.length > 0) {\n      i = indexBuffersToCreate.dequeue();\n      createIndexBuffer(i.id, i.componentType, model, context);\n    }\n  }\n}\n\nfunction getProgramForPrimitive(model, primitive) {\n  var material = model._runtime.materialsById[primitive.material];\n  if (!defined(material)) {\n    return;\n  }\n\n  return material._program;\n}\n\nfunction modifyShaderForQuantizedAttributes(shader, programName, model) {\n  var primitive;\n  var primitives = model._programPrimitives[programName];\n\n  // If no primitives were cached for this program, there's no need to modify the shader\n  if (!defined(primitives)) {\n    return shader;\n  }\n\n  var primitiveId;\n  for (primitiveId in primitives) {\n    if (primitives.hasOwnProperty(primitiveId)) {\n      primitive = primitives[primitiveId];\n      if (getProgramForPrimitive(model, primitive) === programName) {\n        break;\n      }\n    }\n  }\n\n  // This is not needed after the program is processed, free the memory\n  model._programPrimitives[programName] = undefined;\n\n  var result;\n  if (model.extensionsUsed.WEB3D_quantized_attributes) {\n    result = ModelUtility.modifyShaderForQuantizedAttributes(\n      model.gltf,\n      primitive,\n      shader\n    );\n    model._quantizedUniforms[programName] = result.uniforms;\n  } else {\n    var decodedData = model._decodedData[primitiveId];\n    if (defined(decodedData)) {\n      result = ModelUtility.modifyShaderForDracoQuantizedAttributes(\n        model.gltf,\n        primitive,\n        shader,\n        decodedData.attributes\n      );\n    } else {\n      return shader;\n    }\n  }\n\n  return result.shader;\n}\n\nfunction modifyShaderForColor(shader) {\n  shader = ShaderSource.replaceMain(shader, \"gltf_blend_main\");\n  shader +=\n    \"uniform vec4 gltf_color; \\n\" +\n    \"uniform float gltf_colorBlend; \\n\" +\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    gltf_blend_main(); \\n\" +\n    \"    gl_FragColor.rgb = mix(gl_FragColor.rgb, gltf_color.rgb, gltf_colorBlend); \\n\" +\n    \"    float highlight = ceil(gltf_colorBlend); \\n\" +\n    \"    gl_FragColor.rgb *= mix(gltf_color.rgb, vec3(1.0), highlight); \\n\" +\n    \"    gl_FragColor.a *= gltf_color.a; \\n\" +\n    \"} \\n\";\n\n  return shader;\n}\n\nfunction modifyShader(shader, programName, callback) {\n  if (defined(callback)) {\n    shader = callback(shader, programName);\n  }\n  return shader;\n}\n\nvar CreateProgramJob = function () {\n  this.programToCreate = undefined;\n  this.model = undefined;\n  this.context = undefined;\n};\n\nCreateProgramJob.prototype.set = function (programToCreate, model, context) {\n  this.programToCreate = programToCreate;\n  this.model = model;\n  this.context = context;\n};\n\nCreateProgramJob.prototype.execute = function () {\n  createProgram(this.programToCreate, this.model, this.context);\n};\n\n///////////////////////////////////////////////////////////////////////////\n\n// When building programs for the first time, do not include modifiers for clipping planes and color\n// since this is the version of the program that will be cached for use with other Models.\nfunction createProgram(programToCreate, model, context) {\n  var programId = programToCreate.programId;\n  var techniqueId = programToCreate.techniqueId;\n  var program = model._sourcePrograms[programId];\n  var shaders = model._rendererResources.sourceShaders;\n\n  var vs = shaders[program.vertexShader];\n  var fs = shaders[program.fragmentShader];\n\n  var quantizedVertexShaders = model._quantizedVertexShaders;\n\n  if (\n    model.extensionsUsed.WEB3D_quantized_attributes ||\n    model._dequantizeInShader\n  ) {\n    var quantizedVS = quantizedVertexShaders[programId];\n    if (!defined(quantizedVS)) {\n      quantizedVS = modifyShaderForQuantizedAttributes(vs, programId, model);\n      quantizedVertexShaders[programId] = quantizedVS;\n    }\n    vs = quantizedVS;\n  }\n\n  var drawVS = modifyShader(vs, programId, model._vertexShaderLoaded);\n  var drawFS = modifyShader(fs, programId, model._fragmentShaderLoaded);\n\n  if (!defined(model._uniformMapLoaded)) {\n    drawFS = \"uniform vec4 czm_pickColor;\\n\" + drawFS;\n  }\n\n  var useIBL =\n    model._imageBasedLightingFactor.x > 0.0 ||\n    model._imageBasedLightingFactor.y > 0.0;\n  if (useIBL) {\n    drawFS = \"#define USE_IBL_LIGHTING \\n\\n\" + drawFS;\n  }\n\n  if (defined(model._lightColor)) {\n    drawFS = \"#define USE_CUSTOM_LIGHT_COLOR \\n\\n\" + drawFS;\n  }\n\n  if (model._sourceVersion !== \"2.0\" || model._sourceKHRTechniquesWebGL) {\n    drawFS = ShaderSource.replaceMain(drawFS, \"non_gamma_corrected_main\");\n    drawFS =\n      drawFS +\n      \"\\n\" +\n      \"void main() { \\n\" +\n      \"    non_gamma_corrected_main(); \\n\" +\n      \"    gl_FragColor = czm_gammaCorrect(gl_FragColor); \\n\" +\n      \"} \\n\";\n  }\n\n  if (OctahedralProjectedCubeMap.isSupported(context)) {\n    var usesSH =\n      defined(model._sphericalHarmonicCoefficients) ||\n      model._useDefaultSphericalHarmonics;\n    var usesSM =\n      (defined(model._specularEnvironmentMapAtlas) &&\n        model._specularEnvironmentMapAtlas.ready) ||\n      model._useDefaultSpecularMaps;\n    var addMatrix = usesSH || usesSM || useIBL;\n    if (addMatrix) {\n      drawFS = \"uniform mat3 gltf_iblReferenceFrameMatrix; \\n\" + drawFS;\n    }\n\n    if (defined(model._sphericalHarmonicCoefficients)) {\n      drawFS =\n        \"#define DIFFUSE_IBL \\n\" +\n        \"#define CUSTOM_SPHERICAL_HARMONICS \\n\" +\n        \"uniform vec3 gltf_sphericalHarmonicCoefficients[9]; \\n\" +\n        drawFS;\n    } else if (model._useDefaultSphericalHarmonics) {\n      drawFS = \"#define DIFFUSE_IBL \\n\" + drawFS;\n    }\n\n    if (\n      defined(model._specularEnvironmentMapAtlas) &&\n      model._specularEnvironmentMapAtlas.ready\n    ) {\n      drawFS =\n        \"#define SPECULAR_IBL \\n\" +\n        \"#define CUSTOM_SPECULAR_IBL \\n\" +\n        \"uniform sampler2D gltf_specularMap; \\n\" +\n        \"uniform vec2 gltf_specularMapSize; \\n\" +\n        \"uniform float gltf_maxSpecularLOD; \\n\" +\n        drawFS;\n    } else if (model._useDefaultSpecularMaps) {\n      drawFS = \"#define SPECULAR_IBL \\n\" + drawFS;\n    }\n  }\n\n  if (defined(model._luminanceAtZenith)) {\n    drawFS =\n      \"#define USE_SUN_LUMINANCE \\n\" +\n      \"uniform float gltf_luminanceAtZenith;\\n\" +\n      drawFS;\n  }\n\n  createAttributesAndProgram(\n    programId,\n    techniqueId,\n    drawFS,\n    drawVS,\n    model,\n    context\n  );\n}\n\nfunction recreateProgram(programToCreate, model, context) {\n  var programId = programToCreate.programId;\n  var techniqueId = programToCreate.techniqueId;\n  var program = model._sourcePrograms[programId];\n  var shaders = model._rendererResources.sourceShaders;\n\n  var quantizedVertexShaders = model._quantizedVertexShaders;\n\n  var clippingPlaneCollection = model.clippingPlanes;\n  var addClippingPlaneCode = isClippingEnabled(model);\n\n  var vs = shaders[program.vertexShader];\n  var fs = shaders[program.fragmentShader];\n\n  if (\n    model.extensionsUsed.WEB3D_quantized_attributes ||\n    model._dequantizeInShader\n  ) {\n    vs = quantizedVertexShaders[programId];\n  }\n\n  var finalFS = fs;\n  if (isColorShadingEnabled(model)) {\n    finalFS = Model._modifyShaderForColor(finalFS);\n  }\n  if (addClippingPlaneCode) {\n    finalFS = modifyShaderForClippingPlanes(\n      finalFS,\n      clippingPlaneCollection,\n      context\n    );\n  }\n\n  var drawVS = modifyShader(vs, programId, model._vertexShaderLoaded);\n  var drawFS = modifyShader(finalFS, programId, model._fragmentShaderLoaded);\n\n  if (!defined(model._uniformMapLoaded)) {\n    drawFS = \"uniform vec4 czm_pickColor;\\n\" + drawFS;\n  }\n\n  var useIBL =\n    model._imageBasedLightingFactor.x > 0.0 ||\n    model._imageBasedLightingFactor.y > 0.0;\n  if (useIBL) {\n    drawFS = \"#define USE_IBL_LIGHTING \\n\\n\" + drawFS;\n  }\n\n  if (defined(model._lightColor)) {\n    drawFS = \"#define USE_CUSTOM_LIGHT_COLOR \\n\\n\" + drawFS;\n  }\n\n  if (model._sourceVersion !== \"2.0\" || model._sourceKHRTechniquesWebGL) {\n    drawFS = ShaderSource.replaceMain(drawFS, \"non_gamma_corrected_main\");\n    drawFS =\n      drawFS +\n      \"\\n\" +\n      \"void main() { \\n\" +\n      \"    non_gamma_corrected_main(); \\n\" +\n      \"    gl_FragColor = czm_gammaCorrect(gl_FragColor); \\n\" +\n      \"} \\n\";\n  }\n\n  if (OctahedralProjectedCubeMap.isSupported(context)) {\n    var usesSH =\n      defined(model._sphericalHarmonicCoefficients) ||\n      model._useDefaultSphericalHarmonics;\n    var usesSM =\n      (defined(model._specularEnvironmentMapAtlas) &&\n        model._specularEnvironmentMapAtlas.ready) ||\n      model._useDefaultSpecularMaps;\n    var addMatrix = usesSH || usesSM || useIBL;\n    if (addMatrix) {\n      drawFS = \"uniform mat3 gltf_iblReferenceFrameMatrix; \\n\" + drawFS;\n    }\n\n    if (defined(model._sphericalHarmonicCoefficients)) {\n      drawFS =\n        \"#define DIFFUSE_IBL \\n\" +\n        \"#define CUSTOM_SPHERICAL_HARMONICS \\n\" +\n        \"uniform vec3 gltf_sphericalHarmonicCoefficients[9]; \\n\" +\n        drawFS;\n    } else if (model._useDefaultSphericalHarmonics) {\n      drawFS = \"#define DIFFUSE_IBL \\n\" + drawFS;\n    }\n\n    if (\n      defined(model._specularEnvironmentMapAtlas) &&\n      model._specularEnvironmentMapAtlas.ready\n    ) {\n      drawFS =\n        \"#define SPECULAR_IBL \\n\" +\n        \"#define CUSTOM_SPECULAR_IBL \\n\" +\n        \"uniform sampler2D gltf_specularMap; \\n\" +\n        \"uniform vec2 gltf_specularMapSize; \\n\" +\n        \"uniform float gltf_maxSpecularLOD; \\n\" +\n        drawFS;\n    } else if (model._useDefaultSpecularMaps) {\n      drawFS = \"#define SPECULAR_IBL \\n\" + drawFS;\n    }\n  }\n\n  if (defined(model._luminanceAtZenith)) {\n    drawFS =\n      \"#define USE_SUN_LUMINANCE \\n\" +\n      \"uniform float gltf_luminanceAtZenith;\\n\" +\n      drawFS;\n  }\n\n  createAttributesAndProgram(\n    programId,\n    techniqueId,\n    drawFS,\n    drawVS,\n    model,\n    context\n  );\n}\n\nfunction createAttributesAndProgram(\n  programId,\n  techniqueId,\n  drawFS,\n  drawVS,\n  model,\n  context\n) {\n  var technique = model._sourceTechniques[techniqueId];\n  var attributeLocations = ModelUtility.createAttributeLocations(\n    technique,\n    model._precreatedAttributes\n  );\n\n  model._rendererResources.programs[programId] = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: drawVS,\n    fragmentShaderSource: drawFS,\n    attributeLocations: attributeLocations,\n  });\n}\n\nvar scratchCreateProgramJob = new CreateProgramJob();\n\nfunction createPrograms(model, frameState) {\n  var loadResources = model._loadResources;\n  var programsToCreate = loadResources.programsToCreate;\n\n  if (loadResources.pendingShaderLoads !== 0) {\n    return;\n  }\n\n  // PERFORMANCE_IDEA: this could be more fine-grained by looking\n  // at the shader's bufferView's to determine the buffer dependencies.\n  if (loadResources.pendingBufferLoads !== 0) {\n    return;\n  }\n\n  var context = frameState.context;\n\n  if (model.asynchronous) {\n    while (programsToCreate.length > 0) {\n      scratchCreateProgramJob.set(programsToCreate.peek(), model, context);\n      if (\n        !frameState.jobScheduler.execute(\n          scratchCreateProgramJob,\n          JobType.PROGRAM\n        )\n      ) {\n        break;\n      }\n      programsToCreate.dequeue();\n    }\n  } else {\n    // Create all loaded programs this frame\n    while (programsToCreate.length > 0) {\n      createProgram(programsToCreate.dequeue(), model, context);\n    }\n  }\n}\n\nfunction getOnImageCreatedFromTypedArray(loadResources, gltfTexture) {\n  return function (image) {\n    loadResources.texturesToCreate.enqueue({\n      id: gltfTexture.id,\n      image: image,\n      bufferView: undefined,\n    });\n\n    --loadResources.pendingBufferViewToImage;\n  };\n}\n\nfunction loadTexturesFromBufferViews(model) {\n  var loadResources = model._loadResources;\n\n  if (loadResources.pendingBufferLoads !== 0) {\n    return;\n  }\n\n  while (loadResources.texturesToCreateFromBufferView.length > 0) {\n    var gltfTexture = loadResources.texturesToCreateFromBufferView.dequeue();\n\n    var gltf = model.gltf;\n    var bufferView = gltf.bufferViews[gltfTexture.bufferView];\n    var imageId = gltf.textures[gltfTexture.id].source;\n\n    var onerror = ModelUtility.getFailedLoadFunction(\n      model,\n      \"image\",\n      \"id: \" + gltfTexture.id + \", bufferView: \" + gltfTexture.bufferView\n    );\n\n    if (gltfTexture.mimeType === \"image/ktx\") {\n      loadKTX(loadResources.getBuffer(bufferView))\n        .then(imageLoad(model, gltfTexture.id, imageId))\n        .otherwise(onerror);\n      ++model._loadResources.pendingTextureLoads;\n    } else if (gltfTexture.mimeType === \"image/crn\") {\n      loadCRN(loadResources.getBuffer(bufferView))\n        .then(imageLoad(model, gltfTexture.id, imageId))\n        .otherwise(onerror);\n      ++model._loadResources.pendingTextureLoads;\n    } else {\n      var onload = getOnImageCreatedFromTypedArray(loadResources, gltfTexture);\n      loadImageFromTypedArray({\n        uint8Array: loadResources.getBuffer(bufferView),\n        format: gltfTexture.mimeType,\n        flipY: false,\n      })\n        .then(onload)\n        .otherwise(onerror);\n      ++loadResources.pendingBufferViewToImage;\n    }\n  }\n}\n\nfunction createSamplers(model) {\n  var loadResources = model._loadResources;\n  if (loadResources.createSamplers) {\n    loadResources.createSamplers = false;\n\n    var rendererSamplers = model._rendererResources.samplers;\n    ForEach.sampler(model.gltf, function (sampler, samplerId) {\n      rendererSamplers[samplerId] = new Sampler({\n        wrapS: sampler.wrapS,\n        wrapT: sampler.wrapT,\n        minificationFilter: sampler.minFilter,\n        magnificationFilter: sampler.magFilter,\n      });\n    });\n  }\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nvar CreateTextureJob = function () {\n  this.gltfTexture = undefined;\n  this.model = undefined;\n  this.context = undefined;\n};\n\nCreateTextureJob.prototype.set = function (gltfTexture, model, context) {\n  this.gltfTexture = gltfTexture;\n  this.model = model;\n  this.context = context;\n};\n\nCreateTextureJob.prototype.execute = function () {\n  createTexture(this.gltfTexture, this.model, this.context);\n};\n\n///////////////////////////////////////////////////////////////////////////\n\nfunction createTexture(gltfTexture, model, context) {\n  var textures = model.gltf.textures;\n  var texture = textures[gltfTexture.id];\n\n  var rendererSamplers = model._rendererResources.samplers;\n  var sampler = rendererSamplers[texture.sampler];\n  if (!defined(sampler)) {\n    sampler = new Sampler({\n      wrapS: TextureWrap.REPEAT,\n      wrapT: TextureWrap.REPEAT,\n    });\n  }\n\n  var usesTextureTransform = false;\n  var materials = model.gltf.materials;\n  var materialsLength = materials.length;\n  for (var i = 0; i < materialsLength; ++i) {\n    var material = materials[i];\n    if (\n      defined(material.extensions) &&\n      defined(material.extensions.KHR_techniques_webgl)\n    ) {\n      var values = material.extensions.KHR_techniques_webgl.values;\n      for (var valueName in values) {\n        if (\n          values.hasOwnProperty(valueName) &&\n          valueName.indexOf(\"Texture\") !== -1\n        ) {\n          var value = values[valueName];\n          if (\n            value.index === gltfTexture.id &&\n            defined(value.extensions) &&\n            defined(value.extensions.KHR_texture_transform)\n          ) {\n            usesTextureTransform = true;\n            break;\n          }\n        }\n      }\n    }\n    if (usesTextureTransform) {\n      break;\n    }\n  }\n\n  var wrapS = sampler.wrapS;\n  var wrapT = sampler.wrapT;\n  var minFilter = sampler.minificationFilter;\n\n  if (\n    usesTextureTransform &&\n    minFilter !== TextureMinificationFilter.LINEAR &&\n    minFilter !== TextureMinificationFilter.NEAREST\n  ) {\n    if (\n      minFilter === TextureMinificationFilter.NEAREST_MIPMAP_NEAREST ||\n      minFilter === TextureMinificationFilter.NEAREST_MIPMAP_LINEAR\n    ) {\n      minFilter = TextureMinificationFilter.NEAREST;\n    } else {\n      minFilter = TextureMinificationFilter.LINEAR;\n    }\n\n    sampler = new Sampler({\n      wrapS: sampler.wrapS,\n      wrapT: sampler.wrapT,\n      textureMinificationFilter: minFilter,\n      textureMagnificationFilter: sampler.magnificationFilter,\n    });\n  }\n\n  var internalFormat = gltfTexture.internalFormat;\n\n  var mipmap =\n    !(\n      defined(internalFormat) && PixelFormat.isCompressedFormat(internalFormat)\n    ) &&\n    (minFilter === TextureMinificationFilter.NEAREST_MIPMAP_NEAREST ||\n      minFilter === TextureMinificationFilter.NEAREST_MIPMAP_LINEAR ||\n      minFilter === TextureMinificationFilter.LINEAR_MIPMAP_NEAREST ||\n      minFilter === TextureMinificationFilter.LINEAR_MIPMAP_LINEAR);\n  var requiresNpot =\n    mipmap ||\n    wrapS === TextureWrap.REPEAT ||\n    wrapS === TextureWrap.MIRRORED_REPEAT ||\n    wrapT === TextureWrap.REPEAT ||\n    wrapT === TextureWrap.MIRRORED_REPEAT;\n\n  var tx;\n  var source = gltfTexture.image;\n\n  if (defined(internalFormat)) {\n    tx = new Texture({\n      context: context,\n      source: {\n        arrayBufferView: gltfTexture.bufferView,\n      },\n      width: gltfTexture.width,\n      height: gltfTexture.height,\n      pixelFormat: internalFormat,\n      sampler: sampler,\n    });\n  } else if (defined(source)) {\n    var npot =\n      !CesiumMath.isPowerOfTwo(source.width) ||\n      !CesiumMath.isPowerOfTwo(source.height);\n\n    if (requiresNpot && npot) {\n      // WebGL requires power-of-two texture dimensions for mipmapping and REPEAT/MIRRORED_REPEAT wrap modes.\n      var canvas = document.createElement(\"canvas\");\n      canvas.width = CesiumMath.nextPowerOfTwo(source.width);\n      canvas.height = CesiumMath.nextPowerOfTwo(source.height);\n      var canvasContext = canvas.getContext(\"2d\");\n      canvasContext.drawImage(\n        source,\n        0,\n        0,\n        source.width,\n        source.height,\n        0,\n        0,\n        canvas.width,\n        canvas.height\n      );\n      source = canvas;\n    }\n\n    tx = new Texture({\n      context: context,\n      source: source,\n      pixelFormat: texture.internalFormat,\n      pixelDatatype: texture.type,\n      sampler: sampler,\n      flipY: false,\n    });\n    // GLTF_SPEC: Support TEXTURE_CUBE_MAP.  https://github.com/KhronosGroup/glTF/issues/40\n    if (mipmap) {\n      tx.generateMipmap();\n    }\n  }\n  if (defined(tx)) {\n    model._rendererResources.textures[gltfTexture.id] = tx;\n    model._texturesByteLength += tx.sizeInBytes;\n  }\n}\n\nvar scratchCreateTextureJob = new CreateTextureJob();\n\nfunction createTextures(model, frameState) {\n  var context = frameState.context;\n  var texturesToCreate = model._loadResources.texturesToCreate;\n\n  if (model.asynchronous) {\n    while (texturesToCreate.length > 0) {\n      scratchCreateTextureJob.set(texturesToCreate.peek(), model, context);\n      if (\n        !frameState.jobScheduler.execute(\n          scratchCreateTextureJob,\n          JobType.TEXTURE\n        )\n      ) {\n        break;\n      }\n      texturesToCreate.dequeue();\n    }\n  } else {\n    // Create all loaded textures this frame\n    while (texturesToCreate.length > 0) {\n      createTexture(texturesToCreate.dequeue(), model, context);\n    }\n  }\n}\n\nfunction getAttributeLocations(model, primitive) {\n  var techniques = model._sourceTechniques;\n\n  // Retrieve the compiled shader program to assign index values to attributes\n  var attributeLocations = {};\n\n  var location;\n  var index;\n  var material = model._runtime.materialsById[primitive.material];\n  if (!defined(material)) {\n    return attributeLocations;\n  }\n\n  var technique = techniques[material._technique];\n  if (!defined(technique)) {\n    return attributeLocations;\n  }\n\n  var attributes = technique.attributes;\n  var program = model._rendererResources.programs[technique.program];\n  var programAttributeLocations = program._attributeLocations;\n\n  for (location in programAttributeLocations) {\n    if (programAttributeLocations.hasOwnProperty(location)) {\n      var attribute = attributes[location];\n      if (defined(attribute)) {\n        index = programAttributeLocations[location];\n        attributeLocations[attribute.semantic] = index;\n      }\n    }\n  }\n\n  // Add pre-created attributes.\n  var precreatedAttributes = model._precreatedAttributes;\n  if (defined(precreatedAttributes)) {\n    for (location in precreatedAttributes) {\n      if (precreatedAttributes.hasOwnProperty(location)) {\n        index = programAttributeLocations[location];\n        attributeLocations[location] = index;\n      }\n    }\n  }\n\n  return attributeLocations;\n}\n\nfunction createJoints(model, runtimeSkins) {\n  var gltf = model.gltf;\n  var skins = gltf.skins;\n  var nodes = gltf.nodes;\n  var runtimeNodes = model._runtime.nodes;\n\n  var skinnedNodesIds = model._loadResources.skinnedNodesIds;\n  var length = skinnedNodesIds.length;\n  for (var j = 0; j < length; ++j) {\n    var id = skinnedNodesIds[j];\n    var skinnedNode = runtimeNodes[id];\n    var node = nodes[id];\n\n    var runtimeSkin = runtimeSkins[node.skin];\n    skinnedNode.inverseBindMatrices = runtimeSkin.inverseBindMatrices;\n    skinnedNode.bindShapeMatrix = runtimeSkin.bindShapeMatrix;\n\n    var gltfJoints = skins[node.skin].joints;\n    var jointsLength = gltfJoints.length;\n    for (var i = 0; i < jointsLength; ++i) {\n      var nodeId = gltfJoints[i];\n      var jointNode = runtimeNodes[nodeId];\n      skinnedNode.joints.push(jointNode);\n    }\n  }\n}\n\nfunction createSkins(model) {\n  var loadResources = model._loadResources;\n\n  if (loadResources.pendingBufferLoads !== 0) {\n    return;\n  }\n\n  if (!loadResources.createSkins) {\n    return;\n  }\n  loadResources.createSkins = false;\n\n  var gltf = model.gltf;\n  var accessors = gltf.accessors;\n  var runtimeSkins = {};\n\n  ForEach.skin(gltf, function (skin, id) {\n    var accessor = accessors[skin.inverseBindMatrices];\n\n    var bindShapeMatrix;\n    if (!Matrix4.equals(skin.bindShapeMatrix, Matrix4.IDENTITY)) {\n      bindShapeMatrix = Matrix4.clone(skin.bindShapeMatrix);\n    }\n\n    runtimeSkins[id] = {\n      inverseBindMatrices: ModelAnimationCache.getSkinInverseBindMatrices(\n        model,\n        accessor\n      ),\n      bindShapeMatrix: bindShapeMatrix, // not used when undefined\n    };\n  });\n\n  createJoints(model, runtimeSkins);\n}\n\nfunction getChannelEvaluator(model, runtimeNode, targetPath, spline) {\n  return function (localAnimationTime) {\n    if (defined(spline)) {\n      localAnimationTime = model.clampAnimations\n        ? spline.clampTime(localAnimationTime)\n        : spline.wrapTime(localAnimationTime);\n      runtimeNode[targetPath] = spline.evaluate(\n        localAnimationTime,\n        runtimeNode[targetPath]\n      );\n      runtimeNode.dirtyNumber = model._maxDirtyNumber;\n    }\n  };\n}\n\nfunction createRuntimeAnimations(model) {\n  var loadResources = model._loadResources;\n\n  if (!loadResources.finishedPendingBufferLoads()) {\n    return;\n  }\n\n  if (!loadResources.createRuntimeAnimations) {\n    return;\n  }\n  loadResources.createRuntimeAnimations = false;\n\n  model._runtime.animations = [];\n\n  var runtimeNodes = model._runtime.nodes;\n  var accessors = model.gltf.accessors;\n\n  ForEach.animation(model.gltf, function (animation, i) {\n    var channels = animation.channels;\n    var samplers = animation.samplers;\n\n    // Find start and stop time for the entire animation\n    var startTime = Number.MAX_VALUE;\n    var stopTime = -Number.MAX_VALUE;\n\n    var channelsLength = channels.length;\n    var channelEvaluators = new Array(channelsLength);\n\n    for (var j = 0; j < channelsLength; ++j) {\n      var channel = channels[j];\n      var target = channel.target;\n      var path = target.path;\n      var sampler = samplers[channel.sampler];\n      var input = ModelAnimationCache.getAnimationParameterValues(\n        model,\n        accessors[sampler.input]\n      );\n      var output = ModelAnimationCache.getAnimationParameterValues(\n        model,\n        accessors[sampler.output]\n      );\n\n      startTime = Math.min(startTime, input[0]);\n      stopTime = Math.max(stopTime, input[input.length - 1]);\n\n      var spline = ModelAnimationCache.getAnimationSpline(\n        model,\n        i,\n        animation,\n        channel.sampler,\n        sampler,\n        input,\n        path,\n        output\n      );\n\n      channelEvaluators[j] = getChannelEvaluator(\n        model,\n        runtimeNodes[target.node],\n        target.path,\n        spline\n      );\n    }\n\n    model._runtime.animations[i] = {\n      name: animation.name,\n      startTime: startTime,\n      stopTime: stopTime,\n      channelEvaluators: channelEvaluators,\n    };\n  });\n}\n\nfunction createVertexArrays(model, context) {\n  var loadResources = model._loadResources;\n  if (\n    !loadResources.finishedBuffersCreation() ||\n    !loadResources.finishedProgramCreation() ||\n    !loadResources.createVertexArrays\n  ) {\n    return;\n  }\n  loadResources.createVertexArrays = false;\n\n  var rendererBuffers = model._rendererResources.buffers;\n  var rendererVertexArrays = model._rendererResources.vertexArrays;\n  var gltf = model.gltf;\n  var accessors = gltf.accessors;\n  ForEach.mesh(gltf, function (mesh, meshId) {\n    ForEach.meshPrimitive(mesh, function (primitive, primitiveId) {\n      var attributes = [];\n      var attributeLocation;\n      var attributeLocations = getAttributeLocations(model, primitive);\n      var decodedData =\n        model._decodedData[meshId + \".primitive.\" + primitiveId];\n      ForEach.meshPrimitiveAttribute(primitive, function (\n        accessorId,\n        attributeName\n      ) {\n        // Skip if the attribute is not used by the material, e.g., because the asset\n        // was exported with an attribute that wasn't used and the asset wasn't optimized.\n        attributeLocation = attributeLocations[attributeName];\n        if (defined(attributeLocation)) {\n          // Use attributes of previously decoded draco geometry\n          if (defined(decodedData)) {\n            var decodedAttributes = decodedData.attributes;\n            if (decodedAttributes.hasOwnProperty(attributeName)) {\n              var decodedAttribute = decodedAttributes[attributeName];\n              attributes.push({\n                index: attributeLocation,\n                vertexBuffer: rendererBuffers[decodedAttribute.bufferView],\n                componentsPerAttribute: decodedAttribute.componentsPerAttribute,\n                componentDatatype: decodedAttribute.componentDatatype,\n                normalize: decodedAttribute.normalized,\n                offsetInBytes: decodedAttribute.byteOffset,\n                strideInBytes: decodedAttribute.byteStride,\n              });\n\n              return;\n            }\n          }\n\n          var a = accessors[accessorId];\n          var normalize = defined(a.normalized) && a.normalized;\n          attributes.push({\n            index: attributeLocation,\n            vertexBuffer: rendererBuffers[a.bufferView],\n            componentsPerAttribute: numberOfComponentsForType(a.type),\n            componentDatatype: a.componentType,\n            normalize: normalize,\n            offsetInBytes: a.byteOffset,\n            strideInBytes: getAccessorByteStride(gltf, a),\n          });\n        }\n      });\n\n      // Add pre-created attributes\n      var attribute;\n      var attributeName;\n      var precreatedAttributes = model._precreatedAttributes;\n      if (defined(precreatedAttributes)) {\n        for (attributeName in precreatedAttributes) {\n          if (precreatedAttributes.hasOwnProperty(attributeName)) {\n            attributeLocation = attributeLocations[attributeName];\n            if (defined(attributeLocation)) {\n              attribute = precreatedAttributes[attributeName];\n              attribute.index = attributeLocation;\n              attributes.push(attribute);\n            }\n          }\n        }\n      }\n\n      var indexBuffer;\n      if (defined(primitive.indices)) {\n        var accessor = accessors[primitive.indices];\n        var bufferView = accessor.bufferView;\n\n        // Use buffer of previously decoded draco geometry\n        if (defined(decodedData)) {\n          bufferView = decodedData.bufferView;\n        }\n\n        indexBuffer = rendererBuffers[bufferView];\n      }\n      rendererVertexArrays[\n        meshId + \".primitive.\" + primitiveId\n      ] = new VertexArray({\n        context: context,\n        attributes: attributes,\n        indexBuffer: indexBuffer,\n      });\n    });\n  });\n}\n\nfunction createRenderStates(model) {\n  var loadResources = model._loadResources;\n  if (loadResources.createRenderStates) {\n    loadResources.createRenderStates = false;\n\n    ForEach.material(model.gltf, function (material, materialId) {\n      createRenderStateForMaterial(model, material, materialId);\n    });\n  }\n}\n\nfunction createRenderStateForMaterial(model, material, materialId) {\n  var rendererRenderStates = model._rendererResources.renderStates;\n\n  var blendEquationSeparate = [\n    WebGLConstants.FUNC_ADD,\n    WebGLConstants.FUNC_ADD,\n  ];\n  var blendFuncSeparate = [\n    WebGLConstants.ONE,\n    WebGLConstants.ONE_MINUS_SRC_ALPHA,\n    WebGLConstants.ONE,\n    WebGLConstants.ONE_MINUS_SRC_ALPHA,\n  ];\n\n  if (defined(material.extensions) && defined(material.extensions.KHR_blend)) {\n    blendEquationSeparate = material.extensions.KHR_blend.blendEquation;\n    blendFuncSeparate = material.extensions.KHR_blend.blendFactors;\n  }\n\n  var enableCulling = !material.doubleSided;\n  var blendingEnabled = material.alphaMode === \"BLEND\";\n  rendererRenderStates[materialId] = RenderState.fromCache({\n    cull: {\n      enabled: enableCulling,\n    },\n    depthTest: {\n      enabled: true,\n      func: DepthFunction.LESS_OR_EQUAL,\n    },\n    depthMask: !blendingEnabled,\n    blending: {\n      enabled: blendingEnabled,\n      equationRgb: blendEquationSeparate[0],\n      equationAlpha: blendEquationSeparate[1],\n      functionSourceRgb: blendFuncSeparate[0],\n      functionDestinationRgb: blendFuncSeparate[1],\n      functionSourceAlpha: blendFuncSeparate[2],\n      functionDestinationAlpha: blendFuncSeparate[3],\n    },\n  });\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nvar gltfUniformsFromNode = {\n  MODEL: function (uniformState, model, runtimeNode) {\n    return function () {\n      return runtimeNode.computedMatrix;\n    };\n  },\n  VIEW: function (uniformState, model, runtimeNode) {\n    return function () {\n      return uniformState.view;\n    };\n  },\n  PROJECTION: function (uniformState, model, runtimeNode) {\n    return function () {\n      return uniformState.projection;\n    };\n  },\n  MODELVIEW: function (uniformState, model, runtimeNode) {\n    var mv = new Matrix4();\n    return function () {\n      return Matrix4.multiplyTransformation(\n        uniformState.view,\n        runtimeNode.computedMatrix,\n        mv\n      );\n    };\n  },\n  CESIUM_RTC_MODELVIEW: function (uniformState, model, runtimeNode) {\n    // CESIUM_RTC extension\n    var mvRtc = new Matrix4();\n    return function () {\n      Matrix4.multiplyTransformation(\n        uniformState.view,\n        runtimeNode.computedMatrix,\n        mvRtc\n      );\n      return Matrix4.setTranslation(mvRtc, model._rtcCenterEye, mvRtc);\n    };\n  },\n  MODELVIEWPROJECTION: function (uniformState, model, runtimeNode) {\n    var mvp = new Matrix4();\n    return function () {\n      Matrix4.multiplyTransformation(\n        uniformState.view,\n        runtimeNode.computedMatrix,\n        mvp\n      );\n      return Matrix4.multiply(uniformState._projection, mvp, mvp);\n    };\n  },\n  MODELINVERSE: function (uniformState, model, runtimeNode) {\n    var mInverse = new Matrix4();\n    return function () {\n      return Matrix4.inverse(runtimeNode.computedMatrix, mInverse);\n    };\n  },\n  VIEWINVERSE: function (uniformState, model) {\n    return function () {\n      return uniformState.inverseView;\n    };\n  },\n  PROJECTIONINVERSE: function (uniformState, model, runtimeNode) {\n    return function () {\n      return uniformState.inverseProjection;\n    };\n  },\n  MODELVIEWINVERSE: function (uniformState, model, runtimeNode) {\n    var mv = new Matrix4();\n    var mvInverse = new Matrix4();\n    return function () {\n      Matrix4.multiplyTransformation(\n        uniformState.view,\n        runtimeNode.computedMatrix,\n        mv\n      );\n      return Matrix4.inverse(mv, mvInverse);\n    };\n  },\n  MODELVIEWPROJECTIONINVERSE: function (uniformState, model, runtimeNode) {\n    var mvp = new Matrix4();\n    var mvpInverse = new Matrix4();\n    return function () {\n      Matrix4.multiplyTransformation(\n        uniformState.view,\n        runtimeNode.computedMatrix,\n        mvp\n      );\n      Matrix4.multiply(uniformState._projection, mvp, mvp);\n      return Matrix4.inverse(mvp, mvpInverse);\n    };\n  },\n  MODELINVERSETRANSPOSE: function (uniformState, model, runtimeNode) {\n    var mInverse = new Matrix4();\n    var mInverseTranspose = new Matrix3();\n    return function () {\n      Matrix4.inverse(runtimeNode.computedMatrix, mInverse);\n      Matrix4.getMatrix3(mInverse, mInverseTranspose);\n      return Matrix3.transpose(mInverseTranspose, mInverseTranspose);\n    };\n  },\n  MODELVIEWINVERSETRANSPOSE: function (uniformState, model, runtimeNode) {\n    var mv = new Matrix4();\n    var mvInverse = new Matrix4();\n    var mvInverseTranspose = new Matrix3();\n    return function () {\n      Matrix4.multiplyTransformation(\n        uniformState.view,\n        runtimeNode.computedMatrix,\n        mv\n      );\n      Matrix4.inverse(mv, mvInverse);\n      Matrix4.getMatrix3(mvInverse, mvInverseTranspose);\n      return Matrix3.transpose(mvInverseTranspose, mvInverseTranspose);\n    };\n  },\n  VIEWPORT: function (uniformState, model, runtimeNode) {\n    return function () {\n      return uniformState.viewportCartesian4;\n    };\n  },\n};\n\nfunction getUniformFunctionFromSource(source, model, semantic, uniformState) {\n  var runtimeNode = model._runtime.nodes[source];\n  return gltfUniformsFromNode[semantic](uniformState, model, runtimeNode);\n}\n\nfunction createUniformsForMaterial(\n  model,\n  material,\n  technique,\n  instanceValues,\n  context,\n  textures,\n  defaultTexture\n) {\n  var uniformMap = {};\n  var uniformValues = {};\n  var jointMatrixUniformName;\n  var morphWeightsUniformName;\n\n  ForEach.techniqueUniform(technique, function (uniform, uniformName) {\n    // GLTF_SPEC: This does not take into account uniform arrays,\n    // indicated by uniforms with a count property.\n    //\n    // https://github.com/KhronosGroup/glTF/issues/258\n\n    // GLTF_SPEC: In this implementation, material parameters with a\n    // semantic or targeted via a source (for animation) are not\n    // targetable for material animations.  Is this too strict?\n    //\n    // https://github.com/KhronosGroup/glTF/issues/142\n\n    var uv;\n    if (defined(instanceValues) && defined(instanceValues[uniformName])) {\n      // Parameter overrides by the instance technique\n      uv = ModelUtility.createUniformFunction(\n        uniform.type,\n        instanceValues[uniformName],\n        textures,\n        defaultTexture\n      );\n      uniformMap[uniformName] = uv.func;\n      uniformValues[uniformName] = uv;\n    } else if (defined(uniform.node)) {\n      uniformMap[uniformName] = getUniformFunctionFromSource(\n        uniform.node,\n        model,\n        uniform.semantic,\n        context.uniformState\n      );\n    } else if (defined(uniform.semantic)) {\n      if (uniform.semantic === \"JOINTMATRIX\") {\n        jointMatrixUniformName = uniformName;\n      } else if (uniform.semantic === \"MORPHWEIGHTS\") {\n        morphWeightsUniformName = uniformName;\n      } else if (uniform.semantic === \"ALPHACUTOFF\") {\n        // The material's alphaCutoff value uses a uniform with semantic ALPHACUTOFF.\n        // A uniform with this semantic will ignore the instance or default values.\n        var alphaMode = material.alphaMode;\n        if (defined(alphaMode) && alphaMode === \"MASK\") {\n          var alphaCutoffValue = defaultValue(material.alphaCutoff, 0.5);\n          uv = ModelUtility.createUniformFunction(\n            uniform.type,\n            alphaCutoffValue,\n            textures,\n            defaultTexture\n          );\n          uniformMap[uniformName] = uv.func;\n          uniformValues[uniformName] = uv;\n        }\n      } else {\n        // Map glTF semantic to Cesium automatic uniform\n        uniformMap[uniformName] = ModelUtility.getGltfSemanticUniforms()[\n          uniform.semantic\n        ](context.uniformState, model);\n      }\n    } else if (defined(uniform.value)) {\n      // Technique value that isn't overridden by a material\n      var uv2 = ModelUtility.createUniformFunction(\n        uniform.type,\n        uniform.value,\n        textures,\n        defaultTexture\n      );\n      uniformMap[uniformName] = uv2.func;\n      uniformValues[uniformName] = uv2;\n    }\n  });\n\n  return {\n    map: uniformMap,\n    values: uniformValues,\n    jointMatrixUniformName: jointMatrixUniformName,\n    morphWeightsUniformName: morphWeightsUniformName,\n  };\n}\n\nfunction createUniformMaps(model, context) {\n  var loadResources = model._loadResources;\n\n  if (!loadResources.finishedProgramCreation()) {\n    return;\n  }\n\n  if (!loadResources.createUniformMaps) {\n    return;\n  }\n  loadResources.createUniformMaps = false;\n\n  var gltf = model.gltf;\n  var techniques = model._sourceTechniques;\n  var uniformMaps = model._uniformMaps;\n\n  var textures = model._rendererResources.textures;\n  var defaultTexture = model._defaultTexture;\n\n  ForEach.material(gltf, function (material, materialId) {\n    var modelMaterial = model._runtime.materialsById[materialId];\n    var technique = techniques[modelMaterial._technique];\n    var instanceValues = modelMaterial._values;\n\n    var uniforms = createUniformsForMaterial(\n      model,\n      material,\n      technique,\n      instanceValues,\n      context,\n      textures,\n      defaultTexture\n    );\n\n    var u = uniformMaps[materialId];\n    u.uniformMap = uniforms.map; // uniform name -> function for the renderer\n    u.values = uniforms.values; // material parameter name -> ModelMaterial for modifying the parameter at runtime\n    u.jointMatrixUniformName = uniforms.jointMatrixUniformName;\n    u.morphWeightsUniformName = uniforms.morphWeightsUniformName;\n\n    if (defined(technique.attributes.a_outlineCoordinates)) {\n      var outlineTexture = ModelOutlineLoader.createTexture(model, context);\n      u.uniformMap.u_outlineTexture = function () {\n        return outlineTexture;\n      };\n    }\n  });\n}\n\nfunction createUniformsForDracoQuantizedAttributes(decodedData) {\n  return ModelUtility.createUniformsForDracoQuantizedAttributes(\n    decodedData.attributes\n  );\n}\n\nfunction createUniformsForQuantizedAttributes(model, primitive) {\n  var programId = getProgramForPrimitive(model, primitive);\n  var quantizedUniforms = model._quantizedUniforms[programId];\n  return ModelUtility.createUniformsForQuantizedAttributes(\n    model.gltf,\n    primitive,\n    quantizedUniforms\n  );\n}\n\nfunction createPickColorFunction(color) {\n  return function () {\n    return color;\n  };\n}\n\nfunction createJointMatricesFunction(runtimeNode) {\n  return function () {\n    return runtimeNode.computedJointMatrices;\n  };\n}\n\nfunction createMorphWeightsFunction(runtimeNode) {\n  return function () {\n    return runtimeNode.weights;\n  };\n}\n\nfunction createSilhouetteColorFunction(model) {\n  return function () {\n    return model.silhouetteColor;\n  };\n}\n\nfunction createSilhouetteSizeFunction(model) {\n  return function () {\n    return model.silhouetteSize;\n  };\n}\n\nfunction createColorFunction(model) {\n  return function () {\n    return model.color;\n  };\n}\n\nfunction createClippingPlanesMatrixFunction(model) {\n  return function () {\n    return model._clippingPlanesMatrix;\n  };\n}\n\nfunction createIBLReferenceFrameMatrixFunction(model) {\n  return function () {\n    return model._iblReferenceFrameMatrix;\n  };\n}\n\nfunction createClippingPlanesFunction(model) {\n  return function () {\n    var clippingPlanes = model.clippingPlanes;\n    return !defined(clippingPlanes) || !clippingPlanes.enabled\n      ? model._defaultTexture\n      : clippingPlanes.texture;\n  };\n}\n\nfunction createClippingPlanesEdgeStyleFunction(model) {\n  return function () {\n    var clippingPlanes = model.clippingPlanes;\n    if (!defined(clippingPlanes)) {\n      return Color.WHITE.withAlpha(0.0);\n    }\n\n    var style = Color.clone(clippingPlanes.edgeColor);\n    style.alpha = clippingPlanes.edgeWidth;\n    return style;\n  };\n}\n\nfunction createColorBlendFunction(model) {\n  return function () {\n    return ColorBlendMode.getColorBlend(\n      model.colorBlendMode,\n      model.colorBlendAmount\n    );\n  };\n}\n\nfunction createIBLFactorFunction(model) {\n  return function () {\n    return model._imageBasedLightingFactor;\n  };\n}\n\nfunction createLightColorFunction(model) {\n  return function () {\n    return model._lightColor;\n  };\n}\n\nfunction createLuminanceAtZenithFunction(model) {\n  return function () {\n    return model.luminanceAtZenith;\n  };\n}\n\nfunction createSphericalHarmonicCoefficientsFunction(model) {\n  return function () {\n    return model._sphericalHarmonicCoefficients;\n  };\n}\n\nfunction createSpecularEnvironmentMapFunction(model) {\n  return function () {\n    return model._specularEnvironmentMapAtlas.texture;\n  };\n}\n\nfunction createSpecularEnvironmentMapSizeFunction(model) {\n  return function () {\n    return model._specularEnvironmentMapAtlas.texture.dimensions;\n  };\n}\n\nfunction createSpecularEnvironmentMapLOD(model) {\n  return function () {\n    return model._specularEnvironmentMapAtlas.maximumMipmapLevel;\n  };\n}\n\nfunction triangleCountFromPrimitiveIndices(primitive, indicesCount) {\n  switch (primitive.mode) {\n    case PrimitiveType.TRIANGLES:\n      return indicesCount / 3;\n    case PrimitiveType.TRIANGLE_STRIP:\n    case PrimitiveType.TRIANGLE_FAN:\n      return Math.max(indicesCount - 2, 0);\n    default:\n      return 0;\n  }\n}\n\nfunction createCommand(model, gltfNode, runtimeNode, context, scene3DOnly) {\n  var nodeCommands = model._nodeCommands;\n  var pickIds = model._pickIds;\n  var allowPicking = model.allowPicking;\n  var runtimeMeshesByName = model._runtime.meshesByName;\n\n  var resources = model._rendererResources;\n  var rendererVertexArrays = resources.vertexArrays;\n  var rendererPrograms = resources.programs;\n  var rendererRenderStates = resources.renderStates;\n  var uniformMaps = model._uniformMaps;\n\n  var gltf = model.gltf;\n  var accessors = gltf.accessors;\n  var gltfMeshes = gltf.meshes;\n\n  var id = gltfNode.mesh;\n  var mesh = gltfMeshes[id];\n\n  var primitives = mesh.primitives;\n  var length = primitives.length;\n\n  // The glTF node hierarchy is a DAG so a node can have more than one\n  // parent, so a node may already have commands.  If so, append more\n  // since they will have a different model matrix.\n\n  for (var i = 0; i < length; ++i) {\n    var primitive = primitives[i];\n    var ix = accessors[primitive.indices];\n    var material = model._runtime.materialsById[primitive.material];\n    var programId = material._program;\n    var decodedData = model._decodedData[id + \".primitive.\" + i];\n\n    var boundingSphere;\n    var positionAccessor = primitive.attributes.POSITION;\n    if (defined(positionAccessor)) {\n      var minMax = ModelUtility.getAccessorMinMax(gltf, positionAccessor);\n      boundingSphere = BoundingSphere.fromCornerPoints(\n        Cartesian3.fromArray(minMax.min),\n        Cartesian3.fromArray(minMax.max)\n      );\n    }\n\n    var vertexArray = rendererVertexArrays[id + \".primitive.\" + i];\n    var offset;\n    var count;\n\n    // Use indices of the previously decoded Draco geometry.\n    if (defined(decodedData)) {\n      count = decodedData.numberOfIndices;\n      offset = 0;\n    } else if (defined(ix)) {\n      count = ix.count;\n      offset = ix.byteOffset / IndexDatatype.getSizeInBytes(ix.componentType); // glTF has offset in bytes.  Cesium has offsets in indices\n    } else {\n      var positions = accessors[primitive.attributes.POSITION];\n      count = positions.count;\n      offset = 0;\n    }\n\n    // Update model triangle count using number of indices\n    model._trianglesLength += triangleCountFromPrimitiveIndices(\n      primitive,\n      count\n    );\n\n    var um = uniformMaps[primitive.material];\n    var uniformMap = um.uniformMap;\n    if (defined(um.jointMatrixUniformName)) {\n      var jointUniformMap = {};\n      jointUniformMap[um.jointMatrixUniformName] = createJointMatricesFunction(\n        runtimeNode\n      );\n\n      uniformMap = combine(uniformMap, jointUniformMap);\n    }\n    if (defined(um.morphWeightsUniformName)) {\n      var morphWeightsUniformMap = {};\n      morphWeightsUniformMap[\n        um.morphWeightsUniformName\n      ] = createMorphWeightsFunction(runtimeNode);\n\n      uniformMap = combine(uniformMap, morphWeightsUniformMap);\n    }\n\n    uniformMap = combine(uniformMap, {\n      gltf_color: createColorFunction(model),\n      gltf_colorBlend: createColorBlendFunction(model),\n      gltf_clippingPlanes: createClippingPlanesFunction(model),\n      gltf_clippingPlanesEdgeStyle: createClippingPlanesEdgeStyleFunction(\n        model\n      ),\n      gltf_clippingPlanesMatrix: createClippingPlanesMatrixFunction(model),\n      gltf_iblReferenceFrameMatrix: createIBLReferenceFrameMatrixFunction(\n        model\n      ),\n      gltf_iblFactor: createIBLFactorFunction(model),\n      gltf_lightColor: createLightColorFunction(model),\n      gltf_sphericalHarmonicCoefficients: createSphericalHarmonicCoefficientsFunction(\n        model\n      ),\n      gltf_specularMap: createSpecularEnvironmentMapFunction(model),\n      gltf_specularMapSize: createSpecularEnvironmentMapSizeFunction(model),\n      gltf_maxSpecularLOD: createSpecularEnvironmentMapLOD(model),\n      gltf_luminanceAtZenith: createLuminanceAtZenithFunction(model),\n    });\n\n    // Allow callback to modify the uniformMap\n    if (defined(model._uniformMapLoaded)) {\n      uniformMap = model._uniformMapLoaded(uniformMap, programId, runtimeNode);\n    }\n\n    // Add uniforms for decoding quantized attributes if used\n    var quantizedUniformMap = {};\n    if (model.extensionsUsed.WEB3D_quantized_attributes) {\n      quantizedUniformMap = createUniformsForQuantizedAttributes(\n        model,\n        primitive\n      );\n    } else if (model._dequantizeInShader && defined(decodedData)) {\n      quantizedUniformMap = createUniformsForDracoQuantizedAttributes(\n        decodedData\n      );\n    }\n    uniformMap = combine(uniformMap, quantizedUniformMap);\n\n    var rs = rendererRenderStates[primitive.material];\n    var isTranslucent = rs.blending.enabled;\n\n    var owner = model._pickObject;\n    if (!defined(owner)) {\n      owner = {\n        primitive: model,\n        id: model.id,\n        node: runtimeNode.publicNode,\n        mesh: runtimeMeshesByName[mesh.name],\n      };\n    }\n\n    var castShadows = ShadowMode.castShadows(model._shadows);\n    var receiveShadows = ShadowMode.receiveShadows(model._shadows);\n\n    var pickId;\n    if (allowPicking && !defined(model._uniformMapLoaded)) {\n      pickId = context.createPickId(owner);\n      pickIds.push(pickId);\n      var pickUniforms = {\n        czm_pickColor: createPickColorFunction(pickId.color),\n      };\n      uniformMap = combine(uniformMap, pickUniforms);\n    }\n\n    if (allowPicking) {\n      if (defined(model._pickIdLoaded) && defined(model._uniformMapLoaded)) {\n        pickId = model._pickIdLoaded();\n      } else {\n        pickId = \"czm_pickColor\";\n      }\n    }\n\n    var command = new DrawCommand({\n      boundingVolume: new BoundingSphere(), // updated in update()\n      cull: model.cull,\n      modelMatrix: new Matrix4(), // computed in update()\n      primitiveType: primitive.mode,\n      vertexArray: vertexArray,\n      count: count,\n      offset: offset,\n      shaderProgram: rendererPrograms[programId],\n      castShadows: castShadows,\n      receiveShadows: receiveShadows,\n      uniformMap: uniformMap,\n      renderState: rs,\n      owner: owner,\n      pass: isTranslucent ? Pass.TRANSLUCENT : model.opaquePass,\n      pickId: pickId,\n    });\n\n    var command2D;\n    if (!scene3DOnly) {\n      command2D = DrawCommand.shallowClone(command);\n      command2D.boundingVolume = new BoundingSphere(); // updated in update()\n      command2D.modelMatrix = new Matrix4(); // updated in update()\n    }\n\n    var nodeCommand = {\n      show: true,\n      boundingSphere: boundingSphere,\n      command: command,\n      command2D: command2D,\n      // Generated on demand when silhouette size is greater than 0.0 and silhouette alpha is greater than 0.0\n      silhouetteModelCommand: undefined,\n      silhouetteModelCommand2D: undefined,\n      silhouetteColorCommand: undefined,\n      silhouetteColorCommand2D: undefined,\n      // Generated on demand when color alpha is less than 1.0\n      translucentCommand: undefined,\n      translucentCommand2D: undefined,\n      // Generated on demand when back face culling is false\n      disableCullingCommand: undefined,\n      disableCullingCommand2D: undefined,\n      // For updating node commands on shader reconstruction\n      programId: programId,\n    };\n    runtimeNode.commands.push(nodeCommand);\n    nodeCommands.push(nodeCommand);\n  }\n}\n\nfunction createRuntimeNodes(model, context, scene3DOnly) {\n  var loadResources = model._loadResources;\n\n  if (!loadResources.finishedEverythingButTextureCreation()) {\n    return;\n  }\n\n  if (!loadResources.createRuntimeNodes) {\n    return;\n  }\n  loadResources.createRuntimeNodes = false;\n\n  var rootNodes = [];\n  var runtimeNodes = model._runtime.nodes;\n\n  var gltf = model.gltf;\n  var nodes = gltf.nodes;\n\n  var scene = gltf.scenes[gltf.scene];\n  var sceneNodes = scene.nodes;\n  var length = sceneNodes.length;\n\n  var stack = [];\n  var seen = {};\n\n  for (var i = 0; i < length; ++i) {\n    stack.push({\n      parentRuntimeNode: undefined,\n      gltfNode: nodes[sceneNodes[i]],\n      id: sceneNodes[i],\n    });\n\n    while (stack.length > 0) {\n      var n = stack.pop();\n      seen[n.id] = true;\n      var parentRuntimeNode = n.parentRuntimeNode;\n      var gltfNode = n.gltfNode;\n\n      // Node hierarchy is a DAG so a node can have more than one parent so it may already exist\n      var runtimeNode = runtimeNodes[n.id];\n      if (runtimeNode.parents.length === 0) {\n        if (defined(gltfNode.matrix)) {\n          runtimeNode.matrix = Matrix4.fromColumnMajorArray(gltfNode.matrix);\n        } else {\n          // TRS converted to Cesium types\n          var rotation = gltfNode.rotation;\n          runtimeNode.translation = Cartesian3.fromArray(gltfNode.translation);\n          runtimeNode.rotation = Quaternion.unpack(rotation);\n          runtimeNode.scale = Cartesian3.fromArray(gltfNode.scale);\n        }\n      }\n\n      if (defined(parentRuntimeNode)) {\n        parentRuntimeNode.children.push(runtimeNode);\n        runtimeNode.parents.push(parentRuntimeNode);\n      } else {\n        rootNodes.push(runtimeNode);\n      }\n\n      if (defined(gltfNode.mesh)) {\n        createCommand(model, gltfNode, runtimeNode, context, scene3DOnly);\n      }\n\n      var children = gltfNode.children;\n      if (defined(children)) {\n        var childrenLength = children.length;\n        for (var j = 0; j < childrenLength; j++) {\n          var childId = children[j];\n          if (!seen[childId]) {\n            stack.push({\n              parentRuntimeNode: runtimeNode,\n              gltfNode: nodes[childId],\n              id: children[j],\n            });\n          }\n        }\n      }\n    }\n  }\n\n  model._runtime.rootNodes = rootNodes;\n  model._runtime.nodes = runtimeNodes;\n}\n\nfunction getGeometryByteLength(buffers) {\n  var memory = 0;\n  for (var id in buffers) {\n    if (buffers.hasOwnProperty(id)) {\n      memory += buffers[id].sizeInBytes;\n    }\n  }\n  return memory;\n}\n\nfunction getTexturesByteLength(textures) {\n  var memory = 0;\n  for (var id in textures) {\n    if (textures.hasOwnProperty(id)) {\n      memory += textures[id].sizeInBytes;\n    }\n  }\n  return memory;\n}\n\nfunction createResources(model, frameState) {\n  var context = frameState.context;\n  var scene3DOnly = frameState.scene3DOnly;\n  var quantizedVertexShaders = model._quantizedVertexShaders;\n  var techniques = model._sourceTechniques;\n  var programs = model._sourcePrograms;\n\n  var resources = model._rendererResources;\n  var shaders = resources.sourceShaders;\n  if (model._loadRendererResourcesFromCache) {\n    shaders = resources.sourceShaders =\n      model._cachedRendererResources.sourceShaders;\n  }\n\n  for (var techniqueId in techniques) {\n    if (techniques.hasOwnProperty(techniqueId)) {\n      var programId = techniques[techniqueId].program;\n      var program = programs[programId];\n      var shader = shaders[program.vertexShader];\n\n      ModelUtility.checkSupportedGlExtensions(program.glExtensions, context);\n\n      if (\n        model.extensionsUsed.WEB3D_quantized_attributes ||\n        model._dequantizeInShader\n      ) {\n        var quantizedVS = quantizedVertexShaders[programId];\n        if (!defined(quantizedVS)) {\n          quantizedVS = modifyShaderForQuantizedAttributes(\n            shader,\n            programId,\n            model\n          );\n          quantizedVertexShaders[programId] = quantizedVS;\n        }\n        shader = quantizedVS;\n      }\n\n      shader = modifyShader(shader, programId, model._vertexShaderLoaded);\n    }\n  }\n\n  if (model._loadRendererResourcesFromCache) {\n    var cachedResources = model._cachedRendererResources;\n\n    resources.buffers = cachedResources.buffers;\n    resources.vertexArrays = cachedResources.vertexArrays;\n    resources.programs = cachedResources.programs;\n    resources.silhouettePrograms = cachedResources.silhouettePrograms;\n    resources.textures = cachedResources.textures;\n    resources.samplers = cachedResources.samplers;\n    resources.renderStates = cachedResources.renderStates;\n\n    // Vertex arrays are unique to this model, create instead of using the cache.\n    if (defined(model._precreatedAttributes)) {\n      createVertexArrays(model, context);\n    }\n\n    model._cachedGeometryByteLength += getGeometryByteLength(\n      cachedResources.buffers\n    );\n    model._cachedTexturesByteLength += getTexturesByteLength(\n      cachedResources.textures\n    );\n  } else {\n    createBuffers(model, frameState); // using glTF bufferViews\n    createPrograms(model, frameState);\n    createSamplers(model, context);\n    loadTexturesFromBufferViews(model);\n    createTextures(model, frameState);\n  }\n\n  createSkins(model);\n  createRuntimeAnimations(model);\n\n  if (!model._loadRendererResourcesFromCache) {\n    createVertexArrays(model, context); // using glTF meshes\n    createRenderStates(model); // using glTF materials/techniques/states\n    // Long-term, we might not cache render states if they could change\n    // due to an animation, e.g., a uniform going from opaque to transparent.\n    // Could use copy-on-write if it is worth it.  Probably overkill.\n  }\n\n  createUniformMaps(model, context); // using glTF materials/techniques\n  createRuntimeNodes(model, context, scene3DOnly); // using glTF scene\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nfunction getNodeMatrix(node, result) {\n  var publicNode = node.publicNode;\n  var publicMatrix = publicNode.matrix;\n\n  if (publicNode.useMatrix && defined(publicMatrix)) {\n    // Public matrix overrides original glTF matrix and glTF animations\n    Matrix4.clone(publicMatrix, result);\n  } else if (defined(node.matrix)) {\n    Matrix4.clone(node.matrix, result);\n  } else {\n    Matrix4.fromTranslationQuaternionRotationScale(\n      node.translation,\n      node.rotation,\n      node.scale,\n      result\n    );\n    // Keep matrix returned by the node in-sync if the node is targeted by an animation.  Only TRS nodes can be targeted.\n    publicNode.setMatrix(result);\n  }\n}\n\nvar scratchNodeStack = [];\nvar scratchComputedTranslation = new Cartesian4();\nvar scratchComputedMatrixIn2D = new Matrix4();\n\nfunction updateNodeHierarchyModelMatrix(\n  model,\n  modelTransformChanged,\n  justLoaded,\n  projection\n) {\n  var maxDirtyNumber = model._maxDirtyNumber;\n\n  var rootNodes = model._runtime.rootNodes;\n  var length = rootNodes.length;\n\n  var nodeStack = scratchNodeStack;\n  var computedModelMatrix = model._computedModelMatrix;\n\n  if (model._mode !== SceneMode.SCENE3D && !model._ignoreCommands) {\n    var translation = Matrix4.getColumn(\n      computedModelMatrix,\n      3,\n      scratchComputedTranslation\n    );\n    if (!Cartesian4.equals(translation, Cartesian4.UNIT_W)) {\n      computedModelMatrix = Transforms.basisTo2D(\n        projection,\n        computedModelMatrix,\n        scratchComputedMatrixIn2D\n      );\n      model._rtcCenter = model._rtcCenter3D;\n    } else {\n      var center = model.boundingSphere.center;\n      var to2D = Transforms.wgs84To2DModelMatrix(\n        projection,\n        center,\n        scratchComputedMatrixIn2D\n      );\n      computedModelMatrix = Matrix4.multiply(\n        to2D,\n        computedModelMatrix,\n        scratchComputedMatrixIn2D\n      );\n\n      if (defined(model._rtcCenter)) {\n        Matrix4.setTranslation(\n          computedModelMatrix,\n          Cartesian4.UNIT_W,\n          computedModelMatrix\n        );\n        model._rtcCenter = model._rtcCenter2D;\n      }\n    }\n  }\n\n  for (var i = 0; i < length; ++i) {\n    var n = rootNodes[i];\n\n    getNodeMatrix(n, n.transformToRoot);\n    nodeStack.push(n);\n\n    while (nodeStack.length > 0) {\n      n = nodeStack.pop();\n      var transformToRoot = n.transformToRoot;\n      var commands = n.commands;\n\n      if (\n        n.dirtyNumber === maxDirtyNumber ||\n        modelTransformChanged ||\n        justLoaded\n      ) {\n        var nodeMatrix = Matrix4.multiplyTransformation(\n          computedModelMatrix,\n          transformToRoot,\n          n.computedMatrix\n        );\n        var commandsLength = commands.length;\n        if (commandsLength > 0) {\n          // Node has meshes, which has primitives.  Update their commands.\n          for (var j = 0; j < commandsLength; ++j) {\n            var primitiveCommand = commands[j];\n            var command = primitiveCommand.command;\n            Matrix4.clone(nodeMatrix, command.modelMatrix);\n\n            // PERFORMANCE_IDEA: Can use transformWithoutScale if no node up to the root has scale (including animation)\n            BoundingSphere.transform(\n              primitiveCommand.boundingSphere,\n              command.modelMatrix,\n              command.boundingVolume\n            );\n\n            if (defined(model._rtcCenter)) {\n              Cartesian3.add(\n                model._rtcCenter,\n                command.boundingVolume.center,\n                command.boundingVolume.center\n              );\n            }\n\n            // If the model crosses the IDL in 2D, it will be drawn in one viewport, but part of it\n            // will be clipped by the viewport. We create a second command that translates the model\n            // model matrix to the opposite side of the map so the part that was clipped in one viewport\n            // is drawn in the other.\n            command = primitiveCommand.command2D;\n            if (defined(command) && model._mode === SceneMode.SCENE2D) {\n              Matrix4.clone(nodeMatrix, command.modelMatrix);\n              command.modelMatrix[13] -=\n                CesiumMath.sign(command.modelMatrix[13]) *\n                2.0 *\n                CesiumMath.PI *\n                projection.ellipsoid.maximumRadius;\n              BoundingSphere.transform(\n                primitiveCommand.boundingSphere,\n                command.modelMatrix,\n                command.boundingVolume\n              );\n            }\n          }\n        }\n      }\n\n      var children = n.children;\n      if (defined(children)) {\n        var childrenLength = children.length;\n        for (var k = 0; k < childrenLength; ++k) {\n          var child = children[k];\n\n          // A node's transform needs to be updated if\n          // - It was targeted for animation this frame, or\n          // - Any of its ancestors were targeted for animation this frame\n\n          // PERFORMANCE_IDEA: if a child has multiple parents and only one of the parents\n          // is dirty, all the subtrees for each child instance will be dirty; we probably\n          // won't see this in the wild often.\n          child.dirtyNumber = Math.max(child.dirtyNumber, n.dirtyNumber);\n\n          if (child.dirtyNumber === maxDirtyNumber || justLoaded) {\n            // Don't check for modelTransformChanged since if only the model's model matrix changed,\n            // we do not need to rebuild the local transform-to-root, only the final\n            // [model's-model-matrix][transform-to-root] above.\n            getNodeMatrix(child, child.transformToRoot);\n            Matrix4.multiplyTransformation(\n              transformToRoot,\n              child.transformToRoot,\n              child.transformToRoot\n            );\n          }\n\n          nodeStack.push(child);\n        }\n      }\n    }\n  }\n\n  ++model._maxDirtyNumber;\n}\n\nvar scratchObjectSpace = new Matrix4();\n\nfunction applySkins(model) {\n  var skinnedNodes = model._runtime.skinnedNodes;\n  var length = skinnedNodes.length;\n\n  for (var i = 0; i < length; ++i) {\n    var node = skinnedNodes[i];\n\n    scratchObjectSpace = Matrix4.inverseTransformation(\n      node.transformToRoot,\n      scratchObjectSpace\n    );\n\n    var computedJointMatrices = node.computedJointMatrices;\n    var joints = node.joints;\n    var bindShapeMatrix = node.bindShapeMatrix;\n    var inverseBindMatrices = node.inverseBindMatrices;\n    var inverseBindMatricesLength = inverseBindMatrices.length;\n\n    for (var m = 0; m < inverseBindMatricesLength; ++m) {\n      // [joint-matrix] = [node-to-root^-1][joint-to-root][inverse-bind][bind-shape]\n      if (!defined(computedJointMatrices[m])) {\n        computedJointMatrices[m] = new Matrix4();\n      }\n      computedJointMatrices[m] = Matrix4.multiplyTransformation(\n        scratchObjectSpace,\n        joints[m].transformToRoot,\n        computedJointMatrices[m]\n      );\n      computedJointMatrices[m] = Matrix4.multiplyTransformation(\n        computedJointMatrices[m],\n        inverseBindMatrices[m],\n        computedJointMatrices[m]\n      );\n      if (defined(bindShapeMatrix)) {\n        // NOTE: bindShapeMatrix is glTF 1.0 only, removed in glTF 2.0.\n        computedJointMatrices[m] = Matrix4.multiplyTransformation(\n          computedJointMatrices[m],\n          bindShapeMatrix,\n          computedJointMatrices[m]\n        );\n      }\n    }\n  }\n}\n\nfunction updatePerNodeShow(model) {\n  // Totally not worth it, but we could optimize this:\n  // http://help.agi.com/AGIComponents/html/BlogDeletionInBoundingVolumeHierarchies.htm\n\n  var rootNodes = model._runtime.rootNodes;\n  var length = rootNodes.length;\n\n  var nodeStack = scratchNodeStack;\n\n  for (var i = 0; i < length; ++i) {\n    var n = rootNodes[i];\n    n.computedShow = n.publicNode.show;\n    nodeStack.push(n);\n\n    while (nodeStack.length > 0) {\n      n = nodeStack.pop();\n      var show = n.computedShow;\n\n      var nodeCommands = n.commands;\n      var nodeCommandsLength = nodeCommands.length;\n      for (var j = 0; j < nodeCommandsLength; ++j) {\n        nodeCommands[j].show = show;\n      }\n      // if commandsLength is zero, the node has a light or camera\n\n      var children = n.children;\n      if (defined(children)) {\n        var childrenLength = children.length;\n        for (var k = 0; k < childrenLength; ++k) {\n          var child = children[k];\n          // Parent needs to be shown for child to be shown.\n          child.computedShow = show && child.publicNode.show;\n          nodeStack.push(child);\n        }\n      }\n    }\n  }\n}\n\nfunction updatePickIds(model, context) {\n  var id = model.id;\n  if (model._id !== id) {\n    model._id = id;\n\n    var pickIds = model._pickIds;\n    var length = pickIds.length;\n    for (var i = 0; i < length; ++i) {\n      pickIds[i].object.id = id;\n    }\n  }\n}\n\nfunction updateWireframe(model) {\n  if (model._debugWireframe !== model.debugWireframe) {\n    model._debugWireframe = model.debugWireframe;\n\n    // This assumes the original primitive was TRIANGLES and that the triangles\n    // are connected for the wireframe to look perfect.\n    var primitiveType = model.debugWireframe\n      ? PrimitiveType.LINES\n      : PrimitiveType.TRIANGLES;\n    var nodeCommands = model._nodeCommands;\n    var length = nodeCommands.length;\n\n    for (var i = 0; i < length; ++i) {\n      nodeCommands[i].command.primitiveType = primitiveType;\n    }\n  }\n}\n\nfunction updateShowBoundingVolume(model) {\n  if (model.debugShowBoundingVolume !== model._debugShowBoundingVolume) {\n    model._debugShowBoundingVolume = model.debugShowBoundingVolume;\n\n    var debugShowBoundingVolume = model.debugShowBoundingVolume;\n    var nodeCommands = model._nodeCommands;\n    var length = nodeCommands.length;\n\n    for (var i = 0; i < length; ++i) {\n      nodeCommands[i].command.debugShowBoundingVolume = debugShowBoundingVolume;\n    }\n  }\n}\n\nfunction updateShadows(model) {\n  if (model.shadows !== model._shadows) {\n    model._shadows = model.shadows;\n\n    var castShadows = ShadowMode.castShadows(model.shadows);\n    var receiveShadows = ShadowMode.receiveShadows(model.shadows);\n    var nodeCommands = model._nodeCommands;\n    var length = nodeCommands.length;\n\n    for (var i = 0; i < length; i++) {\n      var nodeCommand = nodeCommands[i];\n      nodeCommand.command.castShadows = castShadows;\n      nodeCommand.command.receiveShadows = receiveShadows;\n    }\n  }\n}\n\nfunction getTranslucentRenderState(renderState) {\n  var rs = clone(renderState, true);\n  rs.cull.enabled = false;\n  rs.depthTest.enabled = true;\n  rs.depthMask = false;\n  rs.blending = BlendingState.ALPHA_BLEND;\n\n  return RenderState.fromCache(rs);\n}\n\nfunction deriveTranslucentCommand(command) {\n  var translucentCommand = DrawCommand.shallowClone(command);\n  translucentCommand.pass = Pass.TRANSLUCENT;\n  translucentCommand.renderState = getTranslucentRenderState(\n    command.renderState\n  );\n  return translucentCommand;\n}\n\nfunction updateColor(model, frameState, forceDerive) {\n  // Generate translucent commands when the blend color has an alpha in the range (0.0, 1.0) exclusive\n  var scene3DOnly = frameState.scene3DOnly;\n  var alpha = model.color.alpha;\n  if (alpha > 0.0 && alpha < 1.0) {\n    var nodeCommands = model._nodeCommands;\n    var length = nodeCommands.length;\n    if (\n      length > 0 &&\n      (!defined(nodeCommands[0].translucentCommand) || forceDerive)\n    ) {\n      for (var i = 0; i < length; ++i) {\n        var nodeCommand = nodeCommands[i];\n        var command = nodeCommand.command;\n        nodeCommand.translucentCommand = deriveTranslucentCommand(command);\n        if (!scene3DOnly) {\n          var command2D = nodeCommand.command2D;\n          nodeCommand.translucentCommand2D = deriveTranslucentCommand(\n            command2D\n          );\n        }\n      }\n    }\n  }\n}\n\nfunction getDisableCullingRenderState(renderState) {\n  var rs = clone(renderState, true);\n  rs.cull.enabled = false;\n  return RenderState.fromCache(rs);\n}\n\nfunction deriveDisableCullingCommand(command) {\n  var disableCullingCommand = DrawCommand.shallowClone(command);\n  disableCullingCommand.renderState = getDisableCullingRenderState(\n    command.renderState\n  );\n  return disableCullingCommand;\n}\n\nfunction updateBackFaceCulling(model, frameState, forceDerive) {\n  var scene3DOnly = frameState.scene3DOnly;\n  var backFaceCulling = model.backFaceCulling;\n  if (!backFaceCulling) {\n    var nodeCommands = model._nodeCommands;\n    var length = nodeCommands.length;\n    if (\n      length > 0 &&\n      (!defined(nodeCommands[0].disableCullingCommand) || forceDerive)\n    ) {\n      for (var i = 0; i < length; ++i) {\n        var nodeCommand = nodeCommands[i];\n        var command = nodeCommand.command;\n        nodeCommand.disableCullingCommand = deriveDisableCullingCommand(\n          command\n        );\n        if (!scene3DOnly) {\n          var command2D = nodeCommand.command2D;\n          nodeCommand.disableCullingCommand2D = deriveDisableCullingCommand(\n            command2D\n          );\n        }\n      }\n    }\n  }\n}\n\nfunction getProgramId(model, program) {\n  var programs = model._rendererResources.programs;\n  for (var id in programs) {\n    if (programs.hasOwnProperty(id)) {\n      if (programs[id] === program) {\n        return id;\n      }\n    }\n  }\n}\n\nfunction createSilhouetteProgram(model, program, frameState) {\n  var vs = program.vertexShaderSource.sources[0];\n  var attributeLocations = program._attributeLocations;\n  var normalAttributeName = model._normalAttributeName;\n\n  // Modified from http://forum.unity3d.com/threads/toon-outline-but-with-diffuse-surface.24668/\n  vs = ShaderSource.replaceMain(vs, \"gltf_silhouette_main\");\n  vs +=\n    \"uniform float gltf_silhouetteSize; \\n\" +\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    gltf_silhouette_main(); \\n\" +\n    \"    vec3 n = normalize(czm_normal3D * \" +\n    normalAttributeName +\n    \"); \\n\" +\n    \"    n.x *= czm_projection[0][0]; \\n\" +\n    \"    n.y *= czm_projection[1][1]; \\n\" +\n    \"    vec4 clip = gl_Position; \\n\" +\n    \"    clip.xy += n.xy * clip.w * gltf_silhouetteSize * czm_pixelRatio / czm_viewport.z; \\n\" +\n    \"    gl_Position = clip; \\n\" +\n    \"}\";\n\n  var fs =\n    \"uniform vec4 gltf_silhouetteColor; \\n\" +\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    gl_FragColor = czm_gammaCorrect(gltf_silhouetteColor); \\n\" +\n    \"}\";\n\n  return ShaderProgram.fromCache({\n    context: frameState.context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations,\n  });\n}\n\nfunction hasSilhouette(model, frameState) {\n  return (\n    silhouetteSupported(frameState.context) &&\n    model.silhouetteSize > 0.0 &&\n    model.silhouetteColor.alpha > 0.0 &&\n    defined(model._normalAttributeName)\n  );\n}\n\nfunction hasTranslucentCommands(model) {\n  var nodeCommands = model._nodeCommands;\n  var length = nodeCommands.length;\n  for (var i = 0; i < length; ++i) {\n    var nodeCommand = nodeCommands[i];\n    var command = nodeCommand.command;\n    if (command.pass === Pass.TRANSLUCENT) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction isTranslucent(model) {\n  return model.color.alpha > 0.0 && model.color.alpha < 1.0;\n}\n\nfunction isInvisible(model) {\n  return model.color.alpha === 0.0;\n}\n\nfunction alphaDirty(currAlpha, prevAlpha) {\n  // Returns whether the alpha state has changed between invisible, translucent, or opaque\n  return (\n    Math.floor(currAlpha) !== Math.floor(prevAlpha) ||\n    Math.ceil(currAlpha) !== Math.ceil(prevAlpha)\n  );\n}\n\nvar silhouettesLength = 0;\n\nfunction createSilhouetteCommands(model, frameState) {\n  // Wrap around after exceeding the 8-bit stencil limit.\n  // The reference is unique to each model until this point.\n  var stencilReference = ++silhouettesLength % 255;\n\n  // If the model is translucent the silhouette needs to be in the translucent pass.\n  // Otherwise the silhouette would be rendered before the model.\n  var silhouetteTranslucent =\n    hasTranslucentCommands(model) ||\n    isTranslucent(model) ||\n    model.silhouetteColor.alpha < 1.0;\n  var silhouettePrograms = model._rendererResources.silhouettePrograms;\n  var scene3DOnly = frameState.scene3DOnly;\n  var nodeCommands = model._nodeCommands;\n  var length = nodeCommands.length;\n  for (var i = 0; i < length; ++i) {\n    var nodeCommand = nodeCommands[i];\n    var command = nodeCommand.command;\n\n    // Create model command\n    var modelCommand = isTranslucent(model)\n      ? nodeCommand.translucentCommand\n      : command;\n    var silhouetteModelCommand = DrawCommand.shallowClone(modelCommand);\n    var renderState = clone(modelCommand.renderState);\n\n    // Write the reference value into the stencil buffer.\n    renderState.stencilTest = {\n      enabled: true,\n      frontFunction: WebGLConstants.ALWAYS,\n      backFunction: WebGLConstants.ALWAYS,\n      reference: stencilReference,\n      mask: ~0,\n      frontOperation: {\n        fail: WebGLConstants.KEEP,\n        zFail: WebGLConstants.KEEP,\n        zPass: WebGLConstants.REPLACE,\n      },\n      backOperation: {\n        fail: WebGLConstants.KEEP,\n        zFail: WebGLConstants.KEEP,\n        zPass: WebGLConstants.REPLACE,\n      },\n    };\n\n    if (isInvisible(model)) {\n      // When the model is invisible disable color and depth writes but still write into the stencil buffer\n      renderState.colorMask = {\n        red: false,\n        green: false,\n        blue: false,\n        alpha: false,\n      };\n      renderState.depthMask = false;\n    }\n    renderState = RenderState.fromCache(renderState);\n    silhouetteModelCommand.renderState = renderState;\n    nodeCommand.silhouetteModelCommand = silhouetteModelCommand;\n\n    // Create color command\n    var silhouetteColorCommand = DrawCommand.shallowClone(command);\n    renderState = clone(command.renderState, true);\n    renderState.depthTest.enabled = true;\n    renderState.cull.enabled = false;\n    if (silhouetteTranslucent) {\n      silhouetteColorCommand.pass = Pass.TRANSLUCENT;\n      renderState.depthMask = false;\n      renderState.blending = BlendingState.ALPHA_BLEND;\n    }\n\n    // Only render silhouette if the value in the stencil buffer equals the reference\n    renderState.stencilTest = {\n      enabled: true,\n      frontFunction: WebGLConstants.NOTEQUAL,\n      backFunction: WebGLConstants.NOTEQUAL,\n      reference: stencilReference,\n      mask: ~0,\n      frontOperation: {\n        fail: WebGLConstants.KEEP,\n        zFail: WebGLConstants.KEEP,\n        zPass: WebGLConstants.KEEP,\n      },\n      backOperation: {\n        fail: WebGLConstants.KEEP,\n        zFail: WebGLConstants.KEEP,\n        zPass: WebGLConstants.KEEP,\n      },\n    };\n    renderState = RenderState.fromCache(renderState);\n\n    // If the silhouette program has already been cached use it\n    var program = command.shaderProgram;\n    var id = getProgramId(model, program);\n    var silhouetteProgram = silhouettePrograms[id];\n    if (!defined(silhouetteProgram)) {\n      silhouetteProgram = createSilhouetteProgram(model, program, frameState);\n      silhouettePrograms[id] = silhouetteProgram;\n    }\n\n    var silhouetteUniformMap = combine(command.uniformMap, {\n      gltf_silhouetteColor: createSilhouetteColorFunction(model),\n      gltf_silhouetteSize: createSilhouetteSizeFunction(model),\n    });\n\n    silhouetteColorCommand.renderState = renderState;\n    silhouetteColorCommand.shaderProgram = silhouetteProgram;\n    silhouetteColorCommand.uniformMap = silhouetteUniformMap;\n    silhouetteColorCommand.castShadows = false;\n    silhouetteColorCommand.receiveShadows = false;\n    nodeCommand.silhouetteColorCommand = silhouetteColorCommand;\n\n    if (!scene3DOnly) {\n      var command2D = nodeCommand.command2D;\n      var silhouetteModelCommand2D = DrawCommand.shallowClone(\n        silhouetteModelCommand\n      );\n      silhouetteModelCommand2D.boundingVolume = command2D.boundingVolume;\n      silhouetteModelCommand2D.modelMatrix = command2D.modelMatrix;\n      nodeCommand.silhouetteModelCommand2D = silhouetteModelCommand2D;\n\n      var silhouetteColorCommand2D = DrawCommand.shallowClone(\n        silhouetteColorCommand\n      );\n      silhouetteModelCommand2D.boundingVolume = command2D.boundingVolume;\n      silhouetteModelCommand2D.modelMatrix = command2D.modelMatrix;\n      nodeCommand.silhouetteColorCommand2D = silhouetteColorCommand2D;\n    }\n  }\n}\n\nfunction modifyShaderForClippingPlanes(\n  shader,\n  clippingPlaneCollection,\n  context\n) {\n  shader = ShaderSource.replaceMain(shader, \"gltf_clip_main\");\n  shader += Model._getClippingFunction(clippingPlaneCollection, context) + \"\\n\";\n  shader +=\n    \"uniform highp sampler2D gltf_clippingPlanes; \\n\" +\n    \"uniform mat4 gltf_clippingPlanesMatrix; \\n\" +\n    \"uniform vec4 gltf_clippingPlanesEdgeStyle; \\n\" +\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    gltf_clip_main(); \\n\" +\n    getClipAndStyleCode(\n      \"gltf_clippingPlanes\",\n      \"gltf_clippingPlanesMatrix\",\n      \"gltf_clippingPlanesEdgeStyle\"\n    ) +\n    \"} \\n\";\n  return shader;\n}\n\nfunction updateSilhouette(model, frameState, force) {\n  // Generate silhouette commands when the silhouette size is greater than 0.0 and the alpha is greater than 0.0\n  // There are two silhouette commands:\n  //     1. silhouetteModelCommand : render model normally while enabling stencil mask\n  //     2. silhouetteColorCommand : render enlarged model with a solid color while enabling stencil tests\n  if (!hasSilhouette(model, frameState)) {\n    return;\n  }\n\n  var nodeCommands = model._nodeCommands;\n  var dirty =\n    nodeCommands.length > 0 &&\n    (alphaDirty(model.color.alpha, model._colorPreviousAlpha) ||\n      alphaDirty(\n        model.silhouetteColor.alpha,\n        model._silhouetteColorPreviousAlpha\n      ) ||\n      !defined(nodeCommands[0].silhouetteModelCommand));\n\n  model._colorPreviousAlpha = model.color.alpha;\n  model._silhouetteColorPreviousAlpha = model.silhouetteColor.alpha;\n\n  if (dirty || force) {\n    createSilhouetteCommands(model, frameState);\n  }\n}\n\nfunction updateClippingPlanes(model, frameState) {\n  var clippingPlanes = model._clippingPlanes;\n  if (defined(clippingPlanes) && clippingPlanes.owner === model) {\n    if (clippingPlanes.enabled) {\n      clippingPlanes.update(frameState);\n    }\n  }\n}\n\nvar scratchBoundingSphere = new BoundingSphere();\n\nfunction scaleInPixels(positionWC, radius, frameState) {\n  scratchBoundingSphere.center = positionWC;\n  scratchBoundingSphere.radius = radius;\n  return frameState.camera.getPixelSize(\n    scratchBoundingSphere,\n    frameState.context.drawingBufferWidth,\n    frameState.context.drawingBufferHeight\n  );\n}\n\nvar scratchPosition = new Cartesian3();\nvar scratchCartographic = new Cartographic();\n\nfunction getScale(model, frameState) {\n  var scale = model.scale;\n\n  if (model.minimumPixelSize !== 0.0) {\n    // Compute size of bounding sphere in pixels\n    var context = frameState.context;\n    var maxPixelSize = Math.max(\n      context.drawingBufferWidth,\n      context.drawingBufferHeight\n    );\n    var m = defined(model._clampedModelMatrix)\n      ? model._clampedModelMatrix\n      : model.modelMatrix;\n    scratchPosition.x = m[12];\n    scratchPosition.y = m[13];\n    scratchPosition.z = m[14];\n\n    if (defined(model._rtcCenter)) {\n      Cartesian3.add(model._rtcCenter, scratchPosition, scratchPosition);\n    }\n\n    if (model._mode !== SceneMode.SCENE3D) {\n      var projection = frameState.mapProjection;\n      var cartographic = projection.ellipsoid.cartesianToCartographic(\n        scratchPosition,\n        scratchCartographic\n      );\n      projection.project(cartographic, scratchPosition);\n      Cartesian3.fromElements(\n        scratchPosition.z,\n        scratchPosition.x,\n        scratchPosition.y,\n        scratchPosition\n      );\n    }\n\n    var radius = model.boundingSphere.radius;\n    var metersPerPixel = scaleInPixels(scratchPosition, radius, frameState);\n\n    // metersPerPixel is always > 0.0\n    var pixelsPerMeter = 1.0 / metersPerPixel;\n    var diameterInPixels = Math.min(\n      pixelsPerMeter * (2.0 * radius),\n      maxPixelSize\n    );\n\n    // Maintain model's minimum pixel size\n    if (diameterInPixels < model.minimumPixelSize) {\n      scale =\n        (model.minimumPixelSize * metersPerPixel) /\n        (2.0 * model._initialRadius);\n    }\n  }\n\n  return defined(model.maximumScale)\n    ? Math.min(model.maximumScale, scale)\n    : scale;\n}\n\nfunction releaseCachedGltf(model) {\n  if (\n    defined(model._cacheKey) &&\n    defined(model._cachedGltf) &&\n    --model._cachedGltf.count === 0\n  ) {\n    delete gltfCache[model._cacheKey];\n  }\n  model._cachedGltf = undefined;\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nfunction CachedRendererResources(context, cacheKey) {\n  this.buffers = undefined;\n  this.vertexArrays = undefined;\n  this.programs = undefined;\n  this.sourceShaders = undefined;\n  this.silhouettePrograms = undefined;\n  this.textures = undefined;\n  this.samplers = undefined;\n  this.renderStates = undefined;\n  this.ready = false;\n\n  this.context = context;\n  this.cacheKey = cacheKey;\n  this.count = 0;\n}\n\nfunction destroy(property) {\n  for (var name in property) {\n    if (property.hasOwnProperty(name)) {\n      property[name].destroy();\n    }\n  }\n}\n\nfunction destroyCachedRendererResources(resources) {\n  destroy(resources.buffers);\n  destroy(resources.vertexArrays);\n  destroy(resources.programs);\n  destroy(resources.silhouettePrograms);\n  destroy(resources.textures);\n}\n\nCachedRendererResources.prototype.release = function () {\n  if (--this.count === 0) {\n    if (defined(this.cacheKey)) {\n      // Remove if this was cached\n      delete this.context.cache.modelRendererResourceCache[this.cacheKey];\n    }\n    destroyCachedRendererResources(this);\n    return destroyObject(this);\n  }\n\n  return undefined;\n};\n\n///////////////////////////////////////////////////////////////////////////\n\nfunction getUpdateHeightCallback(model, ellipsoid, cartoPosition) {\n  return function (clampedPosition) {\n    if (model.heightReference === HeightReference.RELATIVE_TO_GROUND) {\n      var clampedCart = ellipsoid.cartesianToCartographic(\n        clampedPosition,\n        scratchCartographic\n      );\n      clampedCart.height += cartoPosition.height;\n      ellipsoid.cartographicToCartesian(clampedCart, clampedPosition);\n    }\n\n    var clampedModelMatrix = model._clampedModelMatrix;\n\n    // Modify clamped model matrix to use new height\n    Matrix4.clone(model.modelMatrix, clampedModelMatrix);\n    clampedModelMatrix[12] = clampedPosition.x;\n    clampedModelMatrix[13] = clampedPosition.y;\n    clampedModelMatrix[14] = clampedPosition.z;\n\n    model._heightChanged = true;\n  };\n}\n\nfunction updateClamping(model) {\n  if (defined(model._removeUpdateHeightCallback)) {\n    model._removeUpdateHeightCallback();\n    model._removeUpdateHeightCallback = undefined;\n  }\n\n  var scene = model._scene;\n  if (\n    !defined(scene) ||\n    !defined(scene.globe) ||\n    model.heightReference === HeightReference.NONE\n  ) {\n    //>>includeStart('debug', pragmas.debug);\n    if (model.heightReference !== HeightReference.NONE) {\n      throw new DeveloperError(\n        \"Height reference is not supported without a scene and globe.\"\n      );\n    }\n    //>>includeEnd('debug');\n    model._clampedModelMatrix = undefined;\n    return;\n  }\n\n  var globe = scene.globe;\n  var ellipsoid = globe.ellipsoid;\n\n  // Compute cartographic position so we don't recompute every update\n  var modelMatrix = model.modelMatrix;\n  scratchPosition.x = modelMatrix[12];\n  scratchPosition.y = modelMatrix[13];\n  scratchPosition.z = modelMatrix[14];\n  var cartoPosition = ellipsoid.cartesianToCartographic(scratchPosition);\n\n  if (!defined(model._clampedModelMatrix)) {\n    model._clampedModelMatrix = Matrix4.clone(modelMatrix, new Matrix4());\n  }\n\n  // Install callback to handle updating of terrain tiles\n  var surface = globe._surface;\n  model._removeUpdateHeightCallback = surface.updateHeight(\n    cartoPosition,\n    getUpdateHeightCallback(model, ellipsoid, cartoPosition)\n  );\n\n  // Set the correct height now\n  var height = globe.getHeight(cartoPosition);\n  if (defined(height)) {\n    // Get callback with cartoPosition being the non-clamped position\n    var cb = getUpdateHeightCallback(model, ellipsoid, cartoPosition);\n\n    // Compute the clamped cartesian and call updateHeight callback\n    Cartographic.clone(cartoPosition, scratchCartographic);\n    scratchCartographic.height = height;\n    ellipsoid.cartographicToCartesian(scratchCartographic, scratchPosition);\n    cb(scratchPosition);\n  }\n}\n\nvar scratchDisplayConditionCartesian = new Cartesian3();\nvar scratchDistanceDisplayConditionCartographic = new Cartographic();\n\nfunction distanceDisplayConditionVisible(model, frameState) {\n  var distance2;\n  var ddc = model.distanceDisplayCondition;\n  var nearSquared = ddc.near * ddc.near;\n  var farSquared = ddc.far * ddc.far;\n\n  if (frameState.mode === SceneMode.SCENE2D) {\n    var frustum2DWidth =\n      frameState.camera.frustum.right - frameState.camera.frustum.left;\n    distance2 = frustum2DWidth * 0.5;\n    distance2 = distance2 * distance2;\n  } else {\n    // Distance to center of primitive's reference frame\n    var position = Matrix4.getTranslation(\n      model.modelMatrix,\n      scratchDisplayConditionCartesian\n    );\n    if (frameState.mode === SceneMode.COLUMBUS_VIEW) {\n      var projection = frameState.mapProjection;\n      var ellipsoid = projection.ellipsoid;\n      var cartographic = ellipsoid.cartesianToCartographic(\n        position,\n        scratchDistanceDisplayConditionCartographic\n      );\n      position = projection.project(cartographic, position);\n      Cartesian3.fromElements(position.z, position.x, position.y, position);\n    }\n    distance2 = Cartesian3.distanceSquared(\n      position,\n      frameState.camera.positionWC\n    );\n  }\n\n  return distance2 >= nearSquared && distance2 <= farSquared;\n}\n\nvar scratchClippingPlanesMatrix = new Matrix4();\nvar scratchIBLReferenceFrameMatrix4 = new Matrix4();\nvar scratchIBLReferenceFrameMatrix3 = new Matrix3();\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {RuntimeError} Failed to load external reference.\n */\nModel.prototype.update = function (frameState) {\n  if (frameState.mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  if (!FeatureDetection.supportsWebP.initialized) {\n    FeatureDetection.supportsWebP.initialize();\n    return;\n  }\n  var supportsWebP = FeatureDetection.supportsWebP();\n\n  var context = frameState.context;\n  this._defaultTexture = context.defaultTexture;\n\n  if (this._state === ModelState.NEEDS_LOAD && defined(this.gltf)) {\n    // Use renderer resources from cache instead of loading/creating them?\n    var cachedRendererResources;\n    var cacheKey = this.cacheKey;\n    if (defined(cacheKey)) {\n      // cache key given? this model will pull from or contribute to context level cache\n      context.cache.modelRendererResourceCache = defaultValue(\n        context.cache.modelRendererResourceCache,\n        {}\n      );\n      var modelCaches = context.cache.modelRendererResourceCache;\n\n      cachedRendererResources = modelCaches[this.cacheKey];\n      if (defined(cachedRendererResources)) {\n        if (!cachedRendererResources.ready) {\n          // Cached resources for the model are not loaded yet.  We'll\n          // try again every frame until they are.\n          return;\n        }\n\n        ++cachedRendererResources.count;\n        this._loadRendererResourcesFromCache = true;\n      } else {\n        cachedRendererResources = new CachedRendererResources(\n          context,\n          cacheKey\n        );\n        cachedRendererResources.count = 1;\n        modelCaches[this.cacheKey] = cachedRendererResources;\n      }\n      this._cachedRendererResources = cachedRendererResources;\n    } else {\n      // cache key not given? this model doesn't care about context level cache at all. Cache is here to simplify freeing on destroy.\n      cachedRendererResources = new CachedRendererResources(context);\n      cachedRendererResources.count = 1;\n      this._cachedRendererResources = cachedRendererResources;\n    }\n\n    this._state = ModelState.LOADING;\n    if (this._state !== ModelState.FAILED) {\n      var extensions = this.gltf.extensions;\n      if (defined(extensions) && defined(extensions.CESIUM_RTC)) {\n        var center = Cartesian3.fromArray(extensions.CESIUM_RTC.center);\n        if (!Cartesian3.equals(center, Cartesian3.ZERO)) {\n          this._rtcCenter3D = center;\n\n          var projection = frameState.mapProjection;\n          var ellipsoid = projection.ellipsoid;\n          var cartographic = ellipsoid.cartesianToCartographic(\n            this._rtcCenter3D\n          );\n          var projectedCart = projection.project(cartographic);\n          Cartesian3.fromElements(\n            projectedCart.z,\n            projectedCart.x,\n            projectedCart.y,\n            projectedCart\n          );\n          this._rtcCenter2D = projectedCart;\n\n          this._rtcCenterEye = new Cartesian3();\n          this._rtcCenter = this._rtcCenter3D;\n        }\n      }\n\n      addPipelineExtras(this.gltf);\n\n      this._loadResources = new ModelLoadResources();\n      if (!this._loadRendererResourcesFromCache) {\n        // Buffers are required to updateVersion\n        ModelUtility.parseBuffers(this, bufferLoad);\n      }\n    }\n  }\n\n  var loadResources = this._loadResources;\n  var incrementallyLoadTextures = this._incrementallyLoadTextures;\n  var justLoaded = false;\n\n  if (this._state === ModelState.LOADING) {\n    // Transition from LOADING -> LOADED once resources are downloaded and created.\n    // Textures may continue to stream in while in the LOADED state.\n    if (loadResources.pendingBufferLoads === 0) {\n      if (!loadResources.initialized) {\n        frameState.brdfLutGenerator.update(frameState);\n\n        ModelUtility.checkSupportedExtensions(\n          this.extensionsRequired,\n          supportsWebP\n        );\n        ModelUtility.updateForwardAxis(this);\n\n        // glTF pipeline updates, not needed if loading from cache\n        if (!defined(this.gltf.extras.sourceVersion)) {\n          var gltf = this.gltf;\n          // Add the original version so it remains cached\n          gltf.extras.sourceVersion = ModelUtility.getAssetVersion(gltf);\n          gltf.extras.sourceKHRTechniquesWebGL = defined(\n            ModelUtility.getUsedExtensions(gltf).KHR_techniques_webgl\n          );\n\n          this._sourceVersion = gltf.extras.sourceVersion;\n          this._sourceKHRTechniquesWebGL = gltf.extras.sourceKHRTechniquesWebGL;\n\n          updateVersion(gltf);\n          addDefaults(gltf);\n\n          var options = {\n            addBatchIdToGeneratedShaders: this._addBatchIdToGeneratedShaders,\n          };\n\n          processModelMaterialsCommon(gltf, options);\n          processPbrMaterials(gltf, options);\n        }\n\n        this._sourceVersion = this.gltf.extras.sourceVersion;\n        this._sourceKHRTechniquesWebGL = this.gltf.extras.sourceKHRTechniquesWebGL;\n\n        // Skip dequantizing in the shader if not encoded\n        this._dequantizeInShader =\n          this._dequantizeInShader && DracoLoader.hasExtension(this);\n\n        // We do this after to make sure that the ids don't change\n        addBuffersToLoadResources(this);\n        parseArticulations(this);\n        parseTechniques(this);\n        if (!this._loadRendererResourcesFromCache) {\n          parseBufferViews(this);\n          parseShaders(this);\n          parsePrograms(this);\n          parseTextures(this, context, supportsWebP);\n        }\n        parseMaterials(this);\n        parseMeshes(this);\n        parseNodes(this);\n\n        // Start draco decoding\n        DracoLoader.parse(this, context);\n\n        loadResources.initialized = true;\n      }\n\n      if (!loadResources.finishedDecoding()) {\n        DracoLoader.decodeModel(this, context).otherwise(\n          ModelUtility.getFailedLoadFunction(this, \"model\", this.basePath)\n        );\n      }\n\n      if (loadResources.finishedDecoding() && !loadResources.resourcesParsed) {\n        this._boundingSphere = ModelUtility.computeBoundingSphere(this);\n        this._initialRadius = this._boundingSphere.radius;\n\n        DracoLoader.cacheDataForModel(this);\n\n        loadResources.resourcesParsed = true;\n      }\n\n      if (\n        loadResources.resourcesParsed &&\n        loadResources.pendingShaderLoads === 0\n      ) {\n        ModelOutlineLoader.outlinePrimitives(this);\n        createResources(this, frameState);\n      }\n    }\n\n    if (\n      loadResources.finished() ||\n      (incrementallyLoadTextures &&\n        loadResources.finishedEverythingButTextureCreation())\n    ) {\n      this._state = ModelState.LOADED;\n      justLoaded = true;\n    }\n  }\n\n  // Incrementally stream textures.\n  if (defined(loadResources) && this._state === ModelState.LOADED) {\n    if (incrementallyLoadTextures && !justLoaded) {\n      createResources(this, frameState);\n    }\n\n    if (loadResources.finished()) {\n      this._loadResources = undefined; // Clear CPU memory since WebGL resources were created.\n\n      var resources = this._rendererResources;\n      var cachedResources = this._cachedRendererResources;\n\n      cachedResources.buffers = resources.buffers;\n      cachedResources.vertexArrays = resources.vertexArrays;\n      cachedResources.programs = resources.programs;\n      cachedResources.sourceShaders = resources.sourceShaders;\n      cachedResources.silhouettePrograms = resources.silhouettePrograms;\n      cachedResources.textures = resources.textures;\n      cachedResources.samplers = resources.samplers;\n      cachedResources.renderStates = resources.renderStates;\n      cachedResources.ready = true;\n\n      // The normal attribute name is required for silhouettes, so get it before the gltf JSON is released\n      this._normalAttributeName = ModelUtility.getAttributeOrUniformBySemantic(\n        this.gltf,\n        \"NORMAL\"\n      );\n\n      // Vertex arrays are unique to this model, do not store in cache.\n      if (defined(this._precreatedAttributes)) {\n        cachedResources.vertexArrays = {};\n      }\n\n      if (this.releaseGltfJson) {\n        releaseCachedGltf(this);\n      }\n    }\n  }\n\n  var iblSupported = OctahedralProjectedCubeMap.isSupported(context);\n  if (this._shouldUpdateSpecularMapAtlas && iblSupported) {\n    this._shouldUpdateSpecularMapAtlas = false;\n    this._specularEnvironmentMapAtlas =\n      this._specularEnvironmentMapAtlas &&\n      this._specularEnvironmentMapAtlas.destroy();\n    this._specularEnvironmentMapAtlas = undefined;\n    if (defined(this._specularEnvironmentMaps)) {\n      this._specularEnvironmentMapAtlas = new OctahedralProjectedCubeMap(\n        this._specularEnvironmentMaps\n      );\n      var that = this;\n      this._specularEnvironmentMapAtlas.readyPromise\n        .then(function () {\n          that._shouldRegenerateShaders = true;\n        })\n        .otherwise(function (error) {\n          console.error(\"Error loading specularEnvironmentMaps: \" + error);\n        });\n    }\n\n    // Regenerate shaders to not use an environment map. Will be set to true again if there was a new environment map and it is ready.\n    this._shouldRegenerateShaders = true;\n  }\n\n  if (defined(this._specularEnvironmentMapAtlas)) {\n    this._specularEnvironmentMapAtlas.update(frameState);\n  }\n\n  var recompileWithDefaultAtlas =\n    !defined(this._specularEnvironmentMapAtlas) &&\n    defined(frameState.specularEnvironmentMaps) &&\n    !this._useDefaultSpecularMaps;\n  var recompileWithoutDefaultAtlas =\n    !defined(frameState.specularEnvironmentMaps) &&\n    this._useDefaultSpecularMaps;\n\n  var recompileWithDefaultSHCoeffs =\n    !defined(this._sphericalHarmonicCoefficients) &&\n    defined(frameState.sphericalHarmonicCoefficients) &&\n    !this._useDefaultSphericalHarmonics;\n  var recompileWithoutDefaultSHCoeffs =\n    !defined(frameState.sphericalHarmonicCoefficients) &&\n    this._useDefaultSphericalHarmonics;\n\n  this._shouldRegenerateShaders =\n    this._shouldRegenerateShaders ||\n    recompileWithDefaultAtlas ||\n    recompileWithoutDefaultAtlas ||\n    recompileWithDefaultSHCoeffs ||\n    recompileWithoutDefaultSHCoeffs;\n\n  this._useDefaultSpecularMaps =\n    !defined(this._specularEnvironmentMapAtlas) &&\n    defined(frameState.specularEnvironmentMaps);\n  this._useDefaultSphericalHarmonics =\n    !defined(this._sphericalHarmonicCoefficients) &&\n    defined(frameState.sphericalHarmonicCoefficients);\n\n  var silhouette = hasSilhouette(this, frameState);\n  var translucent = isTranslucent(this);\n  var invisible = isInvisible(this);\n  var backFaceCulling = this.backFaceCulling;\n  var displayConditionPassed = defined(this.distanceDisplayCondition)\n    ? distanceDisplayConditionVisible(this, frameState)\n    : true;\n  var show =\n    this.show &&\n    displayConditionPassed &&\n    this.scale !== 0.0 &&\n    (!invisible || silhouette);\n\n  if ((show && this._state === ModelState.LOADED) || justLoaded) {\n    var animated =\n      this.activeAnimations.update(frameState) || this._cesiumAnimationsDirty;\n    this._cesiumAnimationsDirty = false;\n    this._dirty = false;\n    var modelMatrix = this.modelMatrix;\n\n    var modeChanged = frameState.mode !== this._mode;\n    this._mode = frameState.mode;\n\n    // Model's model matrix needs to be updated\n    var modelTransformChanged =\n      !Matrix4.equals(this._modelMatrix, modelMatrix) ||\n      this._scale !== this.scale ||\n      this._minimumPixelSize !== this.minimumPixelSize ||\n      this.minimumPixelSize !== 0.0 || // Minimum pixel size changed or is enabled\n      this._maximumScale !== this.maximumScale ||\n      this._heightReference !== this.heightReference ||\n      this._heightChanged ||\n      modeChanged;\n\n    if (modelTransformChanged || justLoaded) {\n      Matrix4.clone(modelMatrix, this._modelMatrix);\n\n      updateClamping(this);\n\n      if (defined(this._clampedModelMatrix)) {\n        modelMatrix = this._clampedModelMatrix;\n      }\n\n      this._scale = this.scale;\n      this._minimumPixelSize = this.minimumPixelSize;\n      this._maximumScale = this.maximumScale;\n      this._heightReference = this.heightReference;\n      this._heightChanged = false;\n\n      var scale = getScale(this, frameState);\n      var computedModelMatrix = this._computedModelMatrix;\n      Matrix4.multiplyByUniformScale(modelMatrix, scale, computedModelMatrix);\n      if (this._upAxis === Axis.Y) {\n        Matrix4.multiplyTransformation(\n          computedModelMatrix,\n          Axis.Y_UP_TO_Z_UP,\n          computedModelMatrix\n        );\n      } else if (this._upAxis === Axis.X) {\n        Matrix4.multiplyTransformation(\n          computedModelMatrix,\n          Axis.X_UP_TO_Z_UP,\n          computedModelMatrix\n        );\n      }\n      if (this.forwardAxis === Axis.Z) {\n        // glTF 2.0 has a Z-forward convention that must be adapted here to X-forward.\n        Matrix4.multiplyTransformation(\n          computedModelMatrix,\n          Axis.Z_UP_TO_X_UP,\n          computedModelMatrix\n        );\n      }\n    }\n\n    // Update modelMatrix throughout the graph as needed\n    if (animated || modelTransformChanged || justLoaded) {\n      updateNodeHierarchyModelMatrix(\n        this,\n        modelTransformChanged,\n        justLoaded,\n        frameState.mapProjection\n      );\n      this._dirty = true;\n\n      if (animated || justLoaded) {\n        // Apply skins if animation changed any node transforms\n        applySkins(this);\n      }\n    }\n\n    if (this._perNodeShowDirty) {\n      this._perNodeShowDirty = false;\n      updatePerNodeShow(this);\n    }\n    updatePickIds(this, context);\n    updateWireframe(this);\n    updateShowBoundingVolume(this);\n    updateShadows(this);\n    updateClippingPlanes(this, frameState);\n\n    // Regenerate shaders if ClippingPlaneCollection state changed or it was removed\n    var clippingPlanes = this._clippingPlanes;\n    var currentClippingPlanesState = 0;\n    var useClippingPlanes =\n      defined(clippingPlanes) &&\n      clippingPlanes.enabled &&\n      clippingPlanes.length > 0;\n\n    // If defined, use the reference matrix to transform miscellaneous properties like\n    // clipping planes and IBL instead of the modelMatrix. This is so that when\n    // models are part of a tileset these properties get transformed relative to\n    // a common reference (such as the root).\n    var referenceMatrix = defaultValue(this.referenceMatrix, modelMatrix);\n\n    if (useClippingPlanes) {\n      var clippingPlanesMatrix = scratchClippingPlanesMatrix;\n      clippingPlanesMatrix = Matrix4.multiply(\n        context.uniformState.view3D,\n        referenceMatrix,\n        clippingPlanesMatrix\n      );\n      clippingPlanesMatrix = Matrix4.multiply(\n        clippingPlanesMatrix,\n        clippingPlanes.modelMatrix,\n        clippingPlanesMatrix\n      );\n      this._clippingPlanesMatrix = Matrix4.inverseTranspose(\n        clippingPlanesMatrix,\n        this._clippingPlanesMatrix\n      );\n      currentClippingPlanesState = clippingPlanes.clippingPlanesState;\n    }\n\n    var usesSH =\n      defined(this._sphericalHarmonicCoefficients) ||\n      this._useDefaultSphericalHarmonics;\n    var usesSM =\n      (defined(this._specularEnvironmentMapAtlas) &&\n        this._specularEnvironmentMapAtlas.ready) ||\n      this._useDefaultSpecularMaps;\n\n    if (usesSH || usesSM) {\n      var iblReferenceFrameMatrix3 = scratchIBLReferenceFrameMatrix3;\n      var iblReferenceFrameMatrix4 = scratchIBLReferenceFrameMatrix4;\n\n      iblReferenceFrameMatrix4 = Matrix4.multiply(\n        context.uniformState.view3D,\n        referenceMatrix,\n        iblReferenceFrameMatrix4\n      );\n      iblReferenceFrameMatrix3 = Matrix4.getMatrix3(\n        iblReferenceFrameMatrix4,\n        iblReferenceFrameMatrix3\n      );\n      iblReferenceFrameMatrix3 = Matrix3.getRotation(\n        iblReferenceFrameMatrix3,\n        iblReferenceFrameMatrix3\n      );\n      this._iblReferenceFrameMatrix = Matrix3.transpose(\n        iblReferenceFrameMatrix3,\n        this._iblReferenceFrameMatrix\n      );\n    }\n\n    var shouldRegenerateShaders = this._shouldRegenerateShaders;\n    shouldRegenerateShaders =\n      shouldRegenerateShaders ||\n      this._clippingPlanesState !== currentClippingPlanesState;\n    this._clippingPlanesState = currentClippingPlanesState;\n\n    // Regenerate shaders if color shading changed from last update\n    var currentlyColorShadingEnabled = isColorShadingEnabled(this);\n    if (currentlyColorShadingEnabled !== this._colorShadingEnabled) {\n      this._colorShadingEnabled = currentlyColorShadingEnabled;\n      shouldRegenerateShaders = true;\n    }\n\n    if (shouldRegenerateShaders) {\n      regenerateShaders(this, frameState);\n    } else {\n      updateColor(this, frameState, false);\n      updateBackFaceCulling(this, frameState, false);\n      updateSilhouette(this, frameState, false);\n    }\n  }\n\n  if (justLoaded) {\n    // Called after modelMatrix update.\n    var model = this;\n    frameState.afterRender.push(function () {\n      model._ready = true;\n      model._readyPromise.resolve(model);\n    });\n    return;\n  }\n\n  // We don't check show at the top of the function since we\n  // want to be able to progressively load models when they are not shown,\n  // and then have them visible immediately when show is set to true.\n  if (show && !this._ignoreCommands) {\n    // PERFORMANCE_IDEA: This is terrible\n    var commandList = frameState.commandList;\n    var passes = frameState.passes;\n    var nodeCommands = this._nodeCommands;\n    var length = nodeCommands.length;\n    var i;\n    var nc;\n\n    var idl2D =\n      frameState.mapProjection.ellipsoid.maximumRadius * CesiumMath.PI;\n    var boundingVolume;\n\n    if (passes.render || (passes.pick && this.allowPicking)) {\n      for (i = 0; i < length; ++i) {\n        nc = nodeCommands[i];\n        if (nc.show) {\n          var command = nc.command;\n          if (silhouette) {\n            command = nc.silhouetteModelCommand;\n          } else if (translucent) {\n            command = nc.translucentCommand;\n          } else if (!backFaceCulling) {\n            command = nc.disableCullingCommand;\n          }\n          commandList.push(command);\n          boundingVolume = nc.command.boundingVolume;\n          if (\n            frameState.mode === SceneMode.SCENE2D &&\n            (boundingVolume.center.y + boundingVolume.radius > idl2D ||\n              boundingVolume.center.y - boundingVolume.radius < idl2D)\n          ) {\n            var command2D = nc.command2D;\n            if (silhouette) {\n              command2D = nc.silhouetteModelCommand2D;\n            } else if (translucent) {\n              command2D = nc.translucentCommand2D;\n            } else if (!backFaceCulling) {\n              command2D = nc.disableCullingCommand2D;\n            }\n            commandList.push(command2D);\n          }\n        }\n      }\n\n      if (silhouette && !passes.pick) {\n        // Render second silhouette pass\n        for (i = 0; i < length; ++i) {\n          nc = nodeCommands[i];\n          if (nc.show) {\n            commandList.push(nc.silhouetteColorCommand);\n            boundingVolume = nc.command.boundingVolume;\n            if (\n              frameState.mode === SceneMode.SCENE2D &&\n              (boundingVolume.center.y + boundingVolume.radius > idl2D ||\n                boundingVolume.center.y - boundingVolume.radius < idl2D)\n            ) {\n              commandList.push(nc.silhouetteColorCommand2D);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  var credit = this._credit;\n  if (defined(credit)) {\n    frameState.creditDisplay.addCredit(credit);\n  }\n\n  var resourceCredits = this._resourceCredits;\n  var creditCount = resourceCredits.length;\n  for (var c = 0; c < creditCount; c++) {\n    frameState.creditDisplay.addCredit(resourceCredits[c]);\n  }\n};\n\nfunction destroyIfNotCached(rendererResources, cachedRendererResources) {\n  if (rendererResources.programs !== cachedRendererResources.programs) {\n    destroy(rendererResources.programs);\n  }\n  if (\n    rendererResources.silhouettePrograms !==\n    cachedRendererResources.silhouettePrograms\n  ) {\n    destroy(rendererResources.silhouettePrograms);\n  }\n}\n\n// Run from update iff:\n// - everything is loaded\n// - clipping planes state change OR color state set\n// Run this from destructor after removing color state and clipping plane state\nfunction regenerateShaders(model, frameState) {\n  // In regards to _cachedRendererResources:\n  // Fair to assume that this is data that should just never get modified due to clipping planes or model color.\n  // So if clipping planes or model color active:\n  // - delink _rendererResources.*programs and create new dictionaries.\n  // - do NOT destroy any programs - might be used by copies of the model or by might be needed in the future if clipping planes/model color is deactivated\n\n  // If clipping planes and model color inactive:\n  // - destroy _rendererResources.*programs\n  // - relink _rendererResources.*programs to _cachedRendererResources\n\n  // In both cases, need to mark commands as dirty, re-run derived commands (elsewhere)\n\n  var rendererResources = model._rendererResources;\n  var cachedRendererResources = model._cachedRendererResources;\n  destroyIfNotCached(rendererResources, cachedRendererResources);\n\n  var programId;\n  if (\n    isClippingEnabled(model) ||\n    isColorShadingEnabled(model) ||\n    model._shouldRegenerateShaders\n  ) {\n    model._shouldRegenerateShaders = false;\n\n    rendererResources.programs = {};\n    rendererResources.silhouettePrograms = {};\n\n    var visitedPrograms = {};\n    var techniques = model._sourceTechniques;\n    var technique;\n\n    for (var techniqueId in techniques) {\n      if (techniques.hasOwnProperty(techniqueId)) {\n        technique = techniques[techniqueId];\n        programId = technique.program;\n        if (!visitedPrograms[programId]) {\n          visitedPrograms[programId] = true;\n          recreateProgram(\n            {\n              programId: programId,\n              techniqueId: techniqueId,\n            },\n            model,\n            frameState.context\n          );\n        }\n      }\n    }\n  } else {\n    rendererResources.programs = cachedRendererResources.programs;\n    rendererResources.silhouettePrograms =\n      cachedRendererResources.silhouettePrograms;\n  }\n\n  // Fix all the commands, marking them as dirty so everything that derives will re-derive\n  var rendererPrograms = rendererResources.programs;\n\n  var nodeCommands = model._nodeCommands;\n  var commandCount = nodeCommands.length;\n  for (var i = 0; i < commandCount; ++i) {\n    var nodeCommand = nodeCommands[i];\n    programId = nodeCommand.programId;\n\n    var renderProgram = rendererPrograms[programId];\n    nodeCommand.command.shaderProgram = renderProgram;\n    if (defined(nodeCommand.command2D)) {\n      nodeCommand.command2D.shaderProgram = renderProgram;\n    }\n  }\n\n  // Force update silhouette commands/shaders\n  updateColor(model, frameState, true);\n  updateBackFaceCulling(model, frameState, true);\n  updateSilhouette(model, frameState, true);\n}\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see Model#destroy\n */\nModel.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * model = model && model.destroy();\n *\n * @see Model#isDestroyed\n */\nModel.prototype.destroy = function () {\n  // Vertex arrays are unique to this model, destroy here.\n  if (defined(this._precreatedAttributes)) {\n    destroy(this._rendererResources.vertexArrays);\n  }\n\n  if (defined(this._removeUpdateHeightCallback)) {\n    this._removeUpdateHeightCallback();\n    this._removeUpdateHeightCallback = undefined;\n  }\n\n  if (defined(this._terrainProviderChangedCallback)) {\n    this._terrainProviderChangedCallback();\n    this._terrainProviderChangedCallback = undefined;\n  }\n\n  // Shaders modified for clipping and for color don't get cached, so destroy these manually\n  if (defined(this._cachedRendererResources)) {\n    destroyIfNotCached(this._rendererResources, this._cachedRendererResources);\n  }\n\n  this._rendererResources = undefined;\n  this._cachedRendererResources =\n    this._cachedRendererResources && this._cachedRendererResources.release();\n  DracoLoader.destroyCachedDataForModel(this);\n\n  var pickIds = this._pickIds;\n  var length = pickIds.length;\n  for (var i = 0; i < length; ++i) {\n    pickIds[i].destroy();\n  }\n\n  releaseCachedGltf(this);\n  this._quantizedVertexShaders = undefined;\n\n  // Only destroy the ClippingPlaneCollection if this is the owner - if this model is part of a Cesium3DTileset,\n  // _clippingPlanes references a ClippingPlaneCollection that this model does not own.\n  var clippingPlaneCollection = this._clippingPlanes;\n  if (\n    defined(clippingPlaneCollection) &&\n    !clippingPlaneCollection.isDestroyed() &&\n    clippingPlaneCollection.owner === this\n  ) {\n    clippingPlaneCollection.destroy();\n  }\n  this._clippingPlanes = undefined;\n\n  this._specularEnvironmentMapAtlas =\n    this._specularEnvironmentMapAtlas &&\n    this._specularEnvironmentMapAtlas.destroy();\n\n  return destroyObject(this);\n};\n\n// exposed for testing\nModel._getClippingFunction = getClippingFunction;\nModel._modifyShaderForColor = modifyShaderForColor;\nexport default Model;\n"]},"metadata":{},"sourceType":"module"}