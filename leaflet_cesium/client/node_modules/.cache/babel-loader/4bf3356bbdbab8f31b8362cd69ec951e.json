{"ast":null,"code":"import when from \"../ThirdParty/when.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport Intersections2D from \"./Intersections2D.js\";\nimport CesiumMath from \"./Math.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\nimport TaskProcessor from \"./TaskProcessor.js\";\nimport TerrainData from \"./TerrainData.js\";\nimport TerrainEncoding from \"./TerrainEncoding.js\";\nimport TerrainMesh from \"./TerrainMesh.js\";\n/**\n * Terrain data for a single tile where the terrain data is represented as a quantized mesh.  A quantized\n * mesh consists of three vertex attributes, longitude, latitude, and height.  All attributes are expressed\n * as 16-bit values in the range 0 to 32767.  Longitude and latitude are zero at the southwest corner\n * of the tile and 32767 at the northeast corner.  Height is zero at the minimum height in the tile\n * and 32767 at the maximum height in the tile.\n *\n * @alias QuantizedMeshTerrainData\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Uint16Array} options.quantizedVertices The buffer containing the quantized mesh.\n * @param {Uint16Array|Uint32Array} options.indices The indices specifying how the quantized vertices are linked\n *                      together into triangles.  Each three indices specifies one triangle.\n * @param {Number} options.minimumHeight The minimum terrain height within the tile, in meters above the ellipsoid.\n * @param {Number} options.maximumHeight The maximum terrain height within the tile, in meters above the ellipsoid.\n * @param {BoundingSphere} options.boundingSphere A sphere bounding all of the vertices in the mesh.\n * @param {OrientedBoundingBox} [options.orientedBoundingBox] An OrientedBoundingBox bounding all of the vertices in the mesh.\n * @param {Cartesian3} options.horizonOcclusionPoint The horizon occlusion point of the mesh.  If this point\n *                      is below the horizon, the entire tile is assumed to be below the horizon as well.\n *                      The point is expressed in ellipsoid-scaled coordinates.\n * @param {Number[]} options.westIndices The indices of the vertices on the western edge of the tile.\n * @param {Number[]} options.southIndices The indices of the vertices on the southern edge of the tile.\n * @param {Number[]} options.eastIndices The indices of the vertices on the eastern edge of the tile.\n * @param {Number[]} options.northIndices The indices of the vertices on the northern edge of the tile.\n * @param {Number} options.westSkirtHeight The height of the skirt to add on the western edge of the tile.\n * @param {Number} options.southSkirtHeight The height of the skirt to add on the southern edge of the tile.\n * @param {Number} options.eastSkirtHeight The height of the skirt to add on the eastern edge of the tile.\n * @param {Number} options.northSkirtHeight The height of the skirt to add on the northern edge of the tile.\n * @param {Number} [options.childTileMask=15] A bit mask indicating which of this tile's four children exist.\n *                 If a child's bit is set, geometry will be requested for that tile as well when it\n *                 is needed.  If the bit is cleared, the child tile is not requested and geometry is\n *                 instead upsampled from the parent.  The bit values are as follows:\n *                 <table>\n *                  <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>\n *                  <tr><td>0</td><td>1</td><td>Southwest</td></tr>\n *                  <tr><td>1</td><td>2</td><td>Southeast</td></tr>\n *                  <tr><td>2</td><td>4</td><td>Northwest</td></tr>\n *                  <tr><td>3</td><td>8</td><td>Northeast</td></tr>\n *                 </table>\n * @param {Boolean} [options.createdByUpsampling=false] True if this instance was created by upsampling another instance;\n *                  otherwise, false.\n * @param {Uint8Array} [options.encodedNormals] The buffer containing per vertex normals, encoded using 'oct' encoding\n * @param {Uint8Array} [options.waterMask] The buffer containing the watermask.\n * @param {Credit[]} [options.credits] Array of credits for this tile.\n *\n *\n * @example\n * var data = new Cesium.QuantizedMeshTerrainData({\n *     minimumHeight : -100,\n *     maximumHeight : 2101,\n *     quantizedVertices : new Uint16Array([// order is SW NW SE NE\n *                                          // longitude\n *                                          0, 0, 32767, 32767,\n *                                          // latitude\n *                                          0, 32767, 0, 32767,\n *                                          // heights\n *                                          16384, 0, 32767, 16384]),\n *     indices : new Uint16Array([0, 3, 1,\n *                                0, 2, 3]),\n *     boundingSphere : new Cesium.BoundingSphere(new Cesium.Cartesian3(1.0, 2.0, 3.0), 10000),\n *     orientedBoundingBox : new Cesium.OrientedBoundingBox(new Cesium.Cartesian3(1.0, 2.0, 3.0), Cesium.Matrix3.fromRotationX(Cesium.Math.PI, new Cesium.Matrix3())),\n *     horizonOcclusionPoint : new Cesium.Cartesian3(3.0, 2.0, 1.0),\n *     westIndices : [0, 1],\n *     southIndices : [0, 1],\n *     eastIndices : [2, 3],\n *     northIndices : [1, 3],\n *     westSkirtHeight : 1.0,\n *     southSkirtHeight : 1.0,\n *     eastSkirtHeight : 1.0,\n *     northSkirtHeight : 1.0\n * });\n *\n * @see TerrainData\n * @see HeightmapTerrainData\n * @see GoogleEarthEnterpriseTerrainData\n */\n\nfunction QuantizedMeshTerrainData(options) {\n  //>>includeStart('debug', pragmas.debug)\n  if (!defined(options) || !defined(options.quantizedVertices)) {\n    throw new DeveloperError(\"options.quantizedVertices is required.\");\n  }\n\n  if (!defined(options.indices)) {\n    throw new DeveloperError(\"options.indices is required.\");\n  }\n\n  if (!defined(options.minimumHeight)) {\n    throw new DeveloperError(\"options.minimumHeight is required.\");\n  }\n\n  if (!defined(options.maximumHeight)) {\n    throw new DeveloperError(\"options.maximumHeight is required.\");\n  }\n\n  if (!defined(options.maximumHeight)) {\n    throw new DeveloperError(\"options.maximumHeight is required.\");\n  }\n\n  if (!defined(options.boundingSphere)) {\n    throw new DeveloperError(\"options.boundingSphere is required.\");\n  }\n\n  if (!defined(options.horizonOcclusionPoint)) {\n    throw new DeveloperError(\"options.horizonOcclusionPoint is required.\");\n  }\n\n  if (!defined(options.westIndices)) {\n    throw new DeveloperError(\"options.westIndices is required.\");\n  }\n\n  if (!defined(options.southIndices)) {\n    throw new DeveloperError(\"options.southIndices is required.\");\n  }\n\n  if (!defined(options.eastIndices)) {\n    throw new DeveloperError(\"options.eastIndices is required.\");\n  }\n\n  if (!defined(options.northIndices)) {\n    throw new DeveloperError(\"options.northIndices is required.\");\n  }\n\n  if (!defined(options.westSkirtHeight)) {\n    throw new DeveloperError(\"options.westSkirtHeight is required.\");\n  }\n\n  if (!defined(options.southSkirtHeight)) {\n    throw new DeveloperError(\"options.southSkirtHeight is required.\");\n  }\n\n  if (!defined(options.eastSkirtHeight)) {\n    throw new DeveloperError(\"options.eastSkirtHeight is required.\");\n  }\n\n  if (!defined(options.northSkirtHeight)) {\n    throw new DeveloperError(\"options.northSkirtHeight is required.\");\n  } //>>includeEnd('debug');\n\n\n  this._quantizedVertices = options.quantizedVertices;\n  this._encodedNormals = options.encodedNormals;\n  this._indices = options.indices;\n  this._minimumHeight = options.minimumHeight;\n  this._maximumHeight = options.maximumHeight;\n  this._boundingSphere = options.boundingSphere;\n  this._orientedBoundingBox = options.orientedBoundingBox;\n  this._horizonOcclusionPoint = options.horizonOcclusionPoint;\n  this._credits = options.credits;\n  var vertexCount = this._quantizedVertices.length / 3;\n\n  var uValues = this._uValues = this._quantizedVertices.subarray(0, vertexCount);\n\n  var vValues = this._vValues = this._quantizedVertices.subarray(vertexCount, 2 * vertexCount);\n\n  this._heightValues = this._quantizedVertices.subarray(2 * vertexCount, 3 * vertexCount); // We don't assume that we can count on the edge vertices being sorted by u or v.\n\n  function sortByV(a, b) {\n    return vValues[a] - vValues[b];\n  }\n\n  function sortByU(a, b) {\n    return uValues[a] - uValues[b];\n  }\n\n  this._westIndices = sortIndicesIfNecessary(options.westIndices, sortByV, vertexCount);\n  this._southIndices = sortIndicesIfNecessary(options.southIndices, sortByU, vertexCount);\n  this._eastIndices = sortIndicesIfNecessary(options.eastIndices, sortByV, vertexCount);\n  this._northIndices = sortIndicesIfNecessary(options.northIndices, sortByU, vertexCount);\n  this._westSkirtHeight = options.westSkirtHeight;\n  this._southSkirtHeight = options.southSkirtHeight;\n  this._eastSkirtHeight = options.eastSkirtHeight;\n  this._northSkirtHeight = options.northSkirtHeight;\n  this._childTileMask = defaultValue(options.childTileMask, 15);\n  this._createdByUpsampling = defaultValue(options.createdByUpsampling, false);\n  this._waterMask = options.waterMask;\n  this._mesh = undefined;\n}\n\nObject.defineProperties(QuantizedMeshTerrainData.prototype, {\n  /**\n   * An array of credits for this tile.\n   * @memberof QuantizedMeshTerrainData.prototype\n   * @type {Credit[]}\n   */\n  credits: {\n    get: function () {\n      return this._credits;\n    }\n  },\n\n  /**\n   * The water mask included in this terrain data, if any.  A water mask is a rectangular\n   * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.\n   * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.\n   * @memberof QuantizedMeshTerrainData.prototype\n   * @type {Uint8Array|HTMLImageElement|HTMLCanvasElement}\n   */\n  waterMask: {\n    get: function () {\n      return this._waterMask;\n    }\n  },\n  childTileMask: {\n    get: function () {\n      return this._childTileMask;\n    }\n  },\n  canUpsample: {\n    get: function () {\n      return defined(this._mesh);\n    }\n  }\n});\nvar arrayScratch = [];\n\nfunction sortIndicesIfNecessary(indices, sortFunction, vertexCount) {\n  arrayScratch.length = indices.length;\n  var needsSort = false;\n\n  for (var i = 0, len = indices.length; i < len; ++i) {\n    arrayScratch[i] = indices[i];\n    needsSort = needsSort || i > 0 && sortFunction(indices[i - 1], indices[i]) > 0;\n  }\n\n  if (needsSort) {\n    arrayScratch.sort(sortFunction);\n    return IndexDatatype.createTypedArray(vertexCount, arrayScratch);\n  }\n\n  return indices;\n}\n\nvar createMeshTaskName = \"createVerticesFromQuantizedTerrainMesh\";\nvar createMeshTaskProcessorNoThrottle = new TaskProcessor(createMeshTaskName);\nvar createMeshTaskProcessorThrottle = new TaskProcessor(createMeshTaskName, TerrainData.maximumAsynchronousTasks);\n/**\n * Creates a {@link TerrainMesh} from this terrain data.\n *\n * @private\n *\n * @param {Object} options Object with the following properties:\n * @param {TilingScheme} options.tilingScheme The tiling scheme to which this tile belongs.\n * @param {Number} options.x The X coordinate of the tile for which to create the terrain data.\n * @param {Number} options.y The Y coordinate of the tile for which to create the terrain data.\n * @param {Number} options.level The level of the tile for which to create the terrain data.\n * @param {Number} [options.exaggeration=1.0] The scale used to exaggerate the terrain.\n * @param {Boolean} [options.throttle=true] If true, indicates that this operation will need to be retried if too many asynchronous mesh creations are already in progress.\n * @returns {Promise.<TerrainMesh>|undefined} A promise for the terrain mesh, or undefined if too many\n *          asynchronous mesh creations are already in progress and the operation should\n *          be retried later.\n */\n\nQuantizedMeshTerrainData.prototype.createMesh = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT); //>>includeStart('debug', pragmas.debug);\n\n  Check.typeOf.object(\"options.tilingScheme\", options.tilingScheme);\n  Check.typeOf.number(\"options.x\", options.x);\n  Check.typeOf.number(\"options.y\", options.y);\n  Check.typeOf.number(\"options.level\", options.level); //>>includeEnd('debug');\n\n  var tilingScheme = options.tilingScheme;\n  var x = options.x;\n  var y = options.y;\n  var level = options.level;\n  var exaggeration = defaultValue(options.exaggeration, 1.0);\n  var throttle = defaultValue(options.throttle, true);\n  var ellipsoid = tilingScheme.ellipsoid;\n  var rectangle = tilingScheme.tileXYToRectangle(x, y, level);\n  var createMeshTaskProcessor = throttle ? createMeshTaskProcessorThrottle : createMeshTaskProcessorNoThrottle;\n  var verticesPromise = createMeshTaskProcessor.scheduleTask({\n    minimumHeight: this._minimumHeight,\n    maximumHeight: this._maximumHeight,\n    quantizedVertices: this._quantizedVertices,\n    octEncodedNormals: this._encodedNormals,\n    includeWebMercatorT: true,\n    indices: this._indices,\n    westIndices: this._westIndices,\n    southIndices: this._southIndices,\n    eastIndices: this._eastIndices,\n    northIndices: this._northIndices,\n    westSkirtHeight: this._westSkirtHeight,\n    southSkirtHeight: this._southSkirtHeight,\n    eastSkirtHeight: this._eastSkirtHeight,\n    northSkirtHeight: this._northSkirtHeight,\n    rectangle: rectangle,\n    relativeToCenter: this._boundingSphere.center,\n    ellipsoid: ellipsoid,\n    exaggeration: exaggeration\n  });\n\n  if (!defined(verticesPromise)) {\n    // Postponed\n    return undefined;\n  }\n\n  var that = this;\n  return when(verticesPromise, function (result) {\n    var vertexCountWithoutSkirts = that._quantizedVertices.length / 3;\n    var vertexCount = vertexCountWithoutSkirts + that._westIndices.length + that._southIndices.length + that._eastIndices.length + that._northIndices.length;\n    var indicesTypedArray = IndexDatatype.createTypedArray(vertexCount, result.indices);\n    var vertices = new Float32Array(result.vertices);\n    var rtc = result.center;\n    var minimumHeight = result.minimumHeight;\n    var maximumHeight = result.maximumHeight;\n    var boundingSphere = defaultValue(BoundingSphere.clone(result.boundingSphere), that._boundingSphere);\n    var obb = defaultValue(OrientedBoundingBox.clone(result.orientedBoundingBox), that._orientedBoundingBox);\n    var occludeePointInScaledSpace = defaultValue(Cartesian3.clone(result.occludeePointInScaledSpace), that._horizonOcclusionPoint);\n    var stride = result.vertexStride;\n    var terrainEncoding = TerrainEncoding.clone(result.encoding); // Clone complex result objects because the transfer from the web worker\n    // has stripped them down to JSON-style objects.\n\n    that._mesh = new TerrainMesh(rtc, vertices, indicesTypedArray, result.indexCountWithoutSkirts, vertexCountWithoutSkirts, minimumHeight, maximumHeight, boundingSphere, occludeePointInScaledSpace, stride, obb, terrainEncoding, exaggeration, result.westIndicesSouthToNorth, result.southIndicesEastToWest, result.eastIndicesNorthToSouth, result.northIndicesWestToEast); // Free memory received from server after mesh is created.\n\n    that._quantizedVertices = undefined;\n    that._encodedNormals = undefined;\n    that._indices = undefined;\n    that._uValues = undefined;\n    that._vValues = undefined;\n    that._heightValues = undefined;\n    that._westIndices = undefined;\n    that._southIndices = undefined;\n    that._eastIndices = undefined;\n    that._northIndices = undefined;\n    return that._mesh;\n  });\n};\n\nvar upsampleTaskProcessor = new TaskProcessor(\"upsampleQuantizedTerrainMesh\", TerrainData.maximumAsynchronousTasks);\n/**\n * Upsamples this terrain data for use by a descendant tile.  The resulting instance will contain a subset of the\n * vertices in this instance, interpolated if necessary.\n *\n * @param {TilingScheme} tilingScheme The tiling scheme of this terrain data.\n * @param {Number} thisX The X coordinate of this tile in the tiling scheme.\n * @param {Number} thisY The Y coordinate of this tile in the tiling scheme.\n * @param {Number} thisLevel The level of this tile in the tiling scheme.\n * @param {Number} descendantX The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {Number} descendantY The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {Number} descendantLevel The level within the tiling scheme of the descendant tile for which we are upsampling.\n * @returns {Promise.<QuantizedMeshTerrainData>|undefined} A promise for upsampled heightmap terrain data for the descendant tile,\n *          or undefined if too many asynchronous upsample operations are in progress and the request has been\n *          deferred.\n */\n\nQuantizedMeshTerrainData.prototype.upsample = function (tilingScheme, thisX, thisY, thisLevel, descendantX, descendantY, descendantLevel) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(tilingScheme)) {\n    throw new DeveloperError(\"tilingScheme is required.\");\n  }\n\n  if (!defined(thisX)) {\n    throw new DeveloperError(\"thisX is required.\");\n  }\n\n  if (!defined(thisY)) {\n    throw new DeveloperError(\"thisY is required.\");\n  }\n\n  if (!defined(thisLevel)) {\n    throw new DeveloperError(\"thisLevel is required.\");\n  }\n\n  if (!defined(descendantX)) {\n    throw new DeveloperError(\"descendantX is required.\");\n  }\n\n  if (!defined(descendantY)) {\n    throw new DeveloperError(\"descendantY is required.\");\n  }\n\n  if (!defined(descendantLevel)) {\n    throw new DeveloperError(\"descendantLevel is required.\");\n  }\n\n  var levelDifference = descendantLevel - thisLevel;\n\n  if (levelDifference > 1) {\n    throw new DeveloperError(\"Upsampling through more than one level at a time is not currently supported.\");\n  } //>>includeEnd('debug');\n\n\n  var mesh = this._mesh;\n\n  if (!defined(this._mesh)) {\n    return undefined;\n  }\n\n  var isEastChild = thisX * 2 !== descendantX;\n  var isNorthChild = thisY * 2 === descendantY;\n  var ellipsoid = tilingScheme.ellipsoid;\n  var childRectangle = tilingScheme.tileXYToRectangle(descendantX, descendantY, descendantLevel);\n  var upsamplePromise = upsampleTaskProcessor.scheduleTask({\n    vertices: mesh.vertices,\n    vertexCountWithoutSkirts: mesh.vertexCountWithoutSkirts,\n    indices: mesh.indices,\n    indexCountWithoutSkirts: mesh.indexCountWithoutSkirts,\n    encoding: mesh.encoding,\n    minimumHeight: this._minimumHeight,\n    maximumHeight: this._maximumHeight,\n    isEastChild: isEastChild,\n    isNorthChild: isNorthChild,\n    childRectangle: childRectangle,\n    ellipsoid: ellipsoid,\n    exaggeration: mesh.exaggeration\n  });\n\n  if (!defined(upsamplePromise)) {\n    // Postponed\n    return undefined;\n  }\n\n  var shortestSkirt = Math.min(this._westSkirtHeight, this._eastSkirtHeight);\n  shortestSkirt = Math.min(shortestSkirt, this._southSkirtHeight);\n  shortestSkirt = Math.min(shortestSkirt, this._northSkirtHeight);\n  var westSkirtHeight = isEastChild ? shortestSkirt * 0.5 : this._westSkirtHeight;\n  var southSkirtHeight = isNorthChild ? shortestSkirt * 0.5 : this._southSkirtHeight;\n  var eastSkirtHeight = isEastChild ? this._eastSkirtHeight : shortestSkirt * 0.5;\n  var northSkirtHeight = isNorthChild ? this._northSkirtHeight : shortestSkirt * 0.5;\n  var credits = this._credits;\n  return when(upsamplePromise).then(function (result) {\n    var quantizedVertices = new Uint16Array(result.vertices);\n    var indicesTypedArray = IndexDatatype.createTypedArray(quantizedVertices.length / 3, result.indices);\n    var encodedNormals;\n\n    if (defined(result.encodedNormals)) {\n      encodedNormals = new Uint8Array(result.encodedNormals);\n    }\n\n    return new QuantizedMeshTerrainData({\n      quantizedVertices: quantizedVertices,\n      indices: indicesTypedArray,\n      encodedNormals: encodedNormals,\n      minimumHeight: result.minimumHeight,\n      maximumHeight: result.maximumHeight,\n      boundingSphere: BoundingSphere.clone(result.boundingSphere),\n      orientedBoundingBox: OrientedBoundingBox.clone(result.orientedBoundingBox),\n      horizonOcclusionPoint: Cartesian3.clone(result.horizonOcclusionPoint),\n      westIndices: result.westIndices,\n      southIndices: result.southIndices,\n      eastIndices: result.eastIndices,\n      northIndices: result.northIndices,\n      westSkirtHeight: westSkirtHeight,\n      southSkirtHeight: southSkirtHeight,\n      eastSkirtHeight: eastSkirtHeight,\n      northSkirtHeight: northSkirtHeight,\n      childTileMask: 0,\n      credits: credits,\n      createdByUpsampling: true\n    });\n  });\n};\n\nvar maxShort = 32767;\nvar barycentricCoordinateScratch = new Cartesian3();\n/**\n * Computes the terrain height at a specified longitude and latitude.\n *\n * @param {Rectangle} rectangle The rectangle covered by this terrain data.\n * @param {Number} longitude The longitude in radians.\n * @param {Number} latitude The latitude in radians.\n * @returns {Number} The terrain height at the specified position.  The position is clamped to\n *          the rectangle, so expect incorrect results for positions far outside the rectangle.\n */\n\nQuantizedMeshTerrainData.prototype.interpolateHeight = function (rectangle, longitude, latitude) {\n  var u = CesiumMath.clamp((longitude - rectangle.west) / rectangle.width, 0.0, 1.0);\n  u *= maxShort;\n  var v = CesiumMath.clamp((latitude - rectangle.south) / rectangle.height, 0.0, 1.0);\n  v *= maxShort;\n\n  if (!defined(this._mesh)) {\n    return interpolateHeight(this, u, v);\n  }\n\n  return interpolateMeshHeight(this, u, v);\n};\n\nfunction pointInBoundingBox(u, v, u0, v0, u1, v1, u2, v2) {\n  var minU = Math.min(u0, u1, u2);\n  var maxU = Math.max(u0, u1, u2);\n  var minV = Math.min(v0, v1, v2);\n  var maxV = Math.max(v0, v1, v2);\n  return u >= minU && u <= maxU && v >= minV && v <= maxV;\n}\n\nvar texCoordScratch0 = new Cartesian2();\nvar texCoordScratch1 = new Cartesian2();\nvar texCoordScratch2 = new Cartesian2();\n\nfunction interpolateMeshHeight(terrainData, u, v) {\n  var mesh = terrainData._mesh;\n  var vertices = mesh.vertices;\n  var encoding = mesh.encoding;\n  var indices = mesh.indices;\n\n  for (var i = 0, len = indices.length; i < len; i += 3) {\n    var i0 = indices[i];\n    var i1 = indices[i + 1];\n    var i2 = indices[i + 2];\n    var uv0 = encoding.decodeTextureCoordinates(vertices, i0, texCoordScratch0);\n    var uv1 = encoding.decodeTextureCoordinates(vertices, i1, texCoordScratch1);\n    var uv2 = encoding.decodeTextureCoordinates(vertices, i2, texCoordScratch2);\n\n    if (pointInBoundingBox(u, v, uv0.x, uv0.y, uv1.x, uv1.y, uv2.x, uv2.y)) {\n      var barycentric = Intersections2D.computeBarycentricCoordinates(u, v, uv0.x, uv0.y, uv1.x, uv1.y, uv2.x, uv2.y, barycentricCoordinateScratch);\n\n      if (barycentric.x >= -1e-15 && barycentric.y >= -1e-15 && barycentric.z >= -1e-15) {\n        var h0 = encoding.decodeHeight(vertices, i0);\n        var h1 = encoding.decodeHeight(vertices, i1);\n        var h2 = encoding.decodeHeight(vertices, i2);\n        return barycentric.x * h0 + barycentric.y * h1 + barycentric.z * h2;\n      }\n    }\n  } // Position does not lie in any triangle in this mesh.\n\n\n  return undefined;\n}\n\nfunction interpolateHeight(terrainData, u, v) {\n  var uBuffer = terrainData._uValues;\n  var vBuffer = terrainData._vValues;\n  var heightBuffer = terrainData._heightValues;\n  var indices = terrainData._indices;\n\n  for (var i = 0, len = indices.length; i < len; i += 3) {\n    var i0 = indices[i];\n    var i1 = indices[i + 1];\n    var i2 = indices[i + 2];\n    var u0 = uBuffer[i0];\n    var u1 = uBuffer[i1];\n    var u2 = uBuffer[i2];\n    var v0 = vBuffer[i0];\n    var v1 = vBuffer[i1];\n    var v2 = vBuffer[i2];\n\n    if (pointInBoundingBox(u, v, u0, v0, u1, v1, u2, v2)) {\n      var barycentric = Intersections2D.computeBarycentricCoordinates(u, v, u0, v0, u1, v1, u2, v2, barycentricCoordinateScratch);\n\n      if (barycentric.x >= -1e-15 && barycentric.y >= -1e-15 && barycentric.z >= -1e-15) {\n        var quantizedHeight = barycentric.x * heightBuffer[i0] + barycentric.y * heightBuffer[i1] + barycentric.z * heightBuffer[i2];\n        return CesiumMath.lerp(terrainData._minimumHeight, terrainData._maximumHeight, quantizedHeight / maxShort);\n      }\n    }\n  } // Position does not lie in any triangle in this mesh.\n\n\n  return undefined;\n}\n/**\n * Determines if a given child tile is available, based on the\n * {@link HeightmapTerrainData.childTileMask}.  The given child tile coordinates are assumed\n * to be one of the four children of this tile.  If non-child tile coordinates are\n * given, the availability of the southeast child tile is returned.\n *\n * @param {Number} thisX The tile X coordinate of this (the parent) tile.\n * @param {Number} thisY The tile Y coordinate of this (the parent) tile.\n * @param {Number} childX The tile X coordinate of the child tile to check for availability.\n * @param {Number} childY The tile Y coordinate of the child tile to check for availability.\n * @returns {Boolean} True if the child tile is available; otherwise, false.\n */\n\n\nQuantizedMeshTerrainData.prototype.isChildAvailable = function (thisX, thisY, childX, childY) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(thisX)) {\n    throw new DeveloperError(\"thisX is required.\");\n  }\n\n  if (!defined(thisY)) {\n    throw new DeveloperError(\"thisY is required.\");\n  }\n\n  if (!defined(childX)) {\n    throw new DeveloperError(\"childX is required.\");\n  }\n\n  if (!defined(childY)) {\n    throw new DeveloperError(\"childY is required.\");\n  } //>>includeEnd('debug');\n\n\n  var bitNumber = 2; // northwest child\n\n  if (childX !== thisX * 2) {\n    ++bitNumber; // east child\n  }\n\n  if (childY !== thisY * 2) {\n    bitNumber -= 2; // south child\n  }\n\n  return (this._childTileMask & 1 << bitNumber) !== 0;\n};\n/**\n * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution\n * terrain data.  If this value is false, the data was obtained from some other source, such\n * as by downloading it from a remote server.  This method should return true for instances\n * returned from a call to {@link HeightmapTerrainData#upsample}.\n *\n * @returns {Boolean} True if this instance was created by upsampling; otherwise, false.\n */\n\n\nQuantizedMeshTerrainData.prototype.wasCreatedByUpsampling = function () {\n  return this._createdByUpsampling;\n};\n\nexport default QuantizedMeshTerrainData;","map":{"version":3,"sources":["/home/usuario/davi/thalamus/wms/3dmaptestes/leaflet_cesium/client/node_modules/cesium/Source/Core/QuantizedMeshTerrainData.js"],"names":["when","BoundingSphere","Cartesian2","Cartesian3","Check","defaultValue","defined","DeveloperError","IndexDatatype","Intersections2D","CesiumMath","OrientedBoundingBox","TaskProcessor","TerrainData","TerrainEncoding","TerrainMesh","QuantizedMeshTerrainData","options","quantizedVertices","indices","minimumHeight","maximumHeight","boundingSphere","horizonOcclusionPoint","westIndices","southIndices","eastIndices","northIndices","westSkirtHeight","southSkirtHeight","eastSkirtHeight","northSkirtHeight","_quantizedVertices","_encodedNormals","encodedNormals","_indices","_minimumHeight","_maximumHeight","_boundingSphere","_orientedBoundingBox","orientedBoundingBox","_horizonOcclusionPoint","_credits","credits","vertexCount","length","uValues","_uValues","subarray","vValues","_vValues","_heightValues","sortByV","a","b","sortByU","_westIndices","sortIndicesIfNecessary","_southIndices","_eastIndices","_northIndices","_westSkirtHeight","_southSkirtHeight","_eastSkirtHeight","_northSkirtHeight","_childTileMask","childTileMask","_createdByUpsampling","createdByUpsampling","_waterMask","waterMask","_mesh","undefined","Object","defineProperties","prototype","get","canUpsample","arrayScratch","sortFunction","needsSort","i","len","sort","createTypedArray","createMeshTaskName","createMeshTaskProcessorNoThrottle","createMeshTaskProcessorThrottle","maximumAsynchronousTasks","createMesh","EMPTY_OBJECT","typeOf","object","tilingScheme","number","x","y","level","exaggeration","throttle","ellipsoid","rectangle","tileXYToRectangle","createMeshTaskProcessor","verticesPromise","scheduleTask","octEncodedNormals","includeWebMercatorT","relativeToCenter","center","that","result","vertexCountWithoutSkirts","indicesTypedArray","vertices","Float32Array","rtc","clone","obb","occludeePointInScaledSpace","stride","vertexStride","terrainEncoding","encoding","indexCountWithoutSkirts","westIndicesSouthToNorth","southIndicesEastToWest","eastIndicesNorthToSouth","northIndicesWestToEast","upsampleTaskProcessor","upsample","thisX","thisY","thisLevel","descendantX","descendantY","descendantLevel","levelDifference","mesh","isEastChild","isNorthChild","childRectangle","upsamplePromise","shortestSkirt","Math","min","then","Uint16Array","Uint8Array","maxShort","barycentricCoordinateScratch","interpolateHeight","longitude","latitude","u","clamp","west","width","v","south","height","interpolateMeshHeight","pointInBoundingBox","u0","v0","u1","v1","u2","v2","minU","maxU","max","minV","maxV","texCoordScratch0","texCoordScratch1","texCoordScratch2","terrainData","i0","i1","i2","uv0","decodeTextureCoordinates","uv1","uv2","barycentric","computeBarycentricCoordinates","z","h0","decodeHeight","h1","h2","uBuffer","vBuffer","heightBuffer","quantizedHeight","lerp","isChildAvailable","childX","childY","bitNumber","wasCreatedByUpsampling"],"mappings":"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","sourcesContent":["import when from \"../ThirdParty/when.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport Intersections2D from \"./Intersections2D.js\";\nimport CesiumMath from \"./Math.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\nimport TaskProcessor from \"./TaskProcessor.js\";\nimport TerrainData from \"./TerrainData.js\";\nimport TerrainEncoding from \"./TerrainEncoding.js\";\nimport TerrainMesh from \"./TerrainMesh.js\";\n\n/**\n * Terrain data for a single tile where the terrain data is represented as a quantized mesh.  A quantized\n * mesh consists of three vertex attributes, longitude, latitude, and height.  All attributes are expressed\n * as 16-bit values in the range 0 to 32767.  Longitude and latitude are zero at the southwest corner\n * of the tile and 32767 at the northeast corner.  Height is zero at the minimum height in the tile\n * and 32767 at the maximum height in the tile.\n *\n * @alias QuantizedMeshTerrainData\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Uint16Array} options.quantizedVertices The buffer containing the quantized mesh.\n * @param {Uint16Array|Uint32Array} options.indices The indices specifying how the quantized vertices are linked\n *                      together into triangles.  Each three indices specifies one triangle.\n * @param {Number} options.minimumHeight The minimum terrain height within the tile, in meters above the ellipsoid.\n * @param {Number} options.maximumHeight The maximum terrain height within the tile, in meters above the ellipsoid.\n * @param {BoundingSphere} options.boundingSphere A sphere bounding all of the vertices in the mesh.\n * @param {OrientedBoundingBox} [options.orientedBoundingBox] An OrientedBoundingBox bounding all of the vertices in the mesh.\n * @param {Cartesian3} options.horizonOcclusionPoint The horizon occlusion point of the mesh.  If this point\n *                      is below the horizon, the entire tile is assumed to be below the horizon as well.\n *                      The point is expressed in ellipsoid-scaled coordinates.\n * @param {Number[]} options.westIndices The indices of the vertices on the western edge of the tile.\n * @param {Number[]} options.southIndices The indices of the vertices on the southern edge of the tile.\n * @param {Number[]} options.eastIndices The indices of the vertices on the eastern edge of the tile.\n * @param {Number[]} options.northIndices The indices of the vertices on the northern edge of the tile.\n * @param {Number} options.westSkirtHeight The height of the skirt to add on the western edge of the tile.\n * @param {Number} options.southSkirtHeight The height of the skirt to add on the southern edge of the tile.\n * @param {Number} options.eastSkirtHeight The height of the skirt to add on the eastern edge of the tile.\n * @param {Number} options.northSkirtHeight The height of the skirt to add on the northern edge of the tile.\n * @param {Number} [options.childTileMask=15] A bit mask indicating which of this tile's four children exist.\n *                 If a child's bit is set, geometry will be requested for that tile as well when it\n *                 is needed.  If the bit is cleared, the child tile is not requested and geometry is\n *                 instead upsampled from the parent.  The bit values are as follows:\n *                 <table>\n *                  <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>\n *                  <tr><td>0</td><td>1</td><td>Southwest</td></tr>\n *                  <tr><td>1</td><td>2</td><td>Southeast</td></tr>\n *                  <tr><td>2</td><td>4</td><td>Northwest</td></tr>\n *                  <tr><td>3</td><td>8</td><td>Northeast</td></tr>\n *                 </table>\n * @param {Boolean} [options.createdByUpsampling=false] True if this instance was created by upsampling another instance;\n *                  otherwise, false.\n * @param {Uint8Array} [options.encodedNormals] The buffer containing per vertex normals, encoded using 'oct' encoding\n * @param {Uint8Array} [options.waterMask] The buffer containing the watermask.\n * @param {Credit[]} [options.credits] Array of credits for this tile.\n *\n *\n * @example\n * var data = new Cesium.QuantizedMeshTerrainData({\n *     minimumHeight : -100,\n *     maximumHeight : 2101,\n *     quantizedVertices : new Uint16Array([// order is SW NW SE NE\n *                                          // longitude\n *                                          0, 0, 32767, 32767,\n *                                          // latitude\n *                                          0, 32767, 0, 32767,\n *                                          // heights\n *                                          16384, 0, 32767, 16384]),\n *     indices : new Uint16Array([0, 3, 1,\n *                                0, 2, 3]),\n *     boundingSphere : new Cesium.BoundingSphere(new Cesium.Cartesian3(1.0, 2.0, 3.0), 10000),\n *     orientedBoundingBox : new Cesium.OrientedBoundingBox(new Cesium.Cartesian3(1.0, 2.0, 3.0), Cesium.Matrix3.fromRotationX(Cesium.Math.PI, new Cesium.Matrix3())),\n *     horizonOcclusionPoint : new Cesium.Cartesian3(3.0, 2.0, 1.0),\n *     westIndices : [0, 1],\n *     southIndices : [0, 1],\n *     eastIndices : [2, 3],\n *     northIndices : [1, 3],\n *     westSkirtHeight : 1.0,\n *     southSkirtHeight : 1.0,\n *     eastSkirtHeight : 1.0,\n *     northSkirtHeight : 1.0\n * });\n *\n * @see TerrainData\n * @see HeightmapTerrainData\n * @see GoogleEarthEnterpriseTerrainData\n */\nfunction QuantizedMeshTerrainData(options) {\n  //>>includeStart('debug', pragmas.debug)\n  if (!defined(options) || !defined(options.quantizedVertices)) {\n    throw new DeveloperError(\"options.quantizedVertices is required.\");\n  }\n  if (!defined(options.indices)) {\n    throw new DeveloperError(\"options.indices is required.\");\n  }\n  if (!defined(options.minimumHeight)) {\n    throw new DeveloperError(\"options.minimumHeight is required.\");\n  }\n  if (!defined(options.maximumHeight)) {\n    throw new DeveloperError(\"options.maximumHeight is required.\");\n  }\n  if (!defined(options.maximumHeight)) {\n    throw new DeveloperError(\"options.maximumHeight is required.\");\n  }\n  if (!defined(options.boundingSphere)) {\n    throw new DeveloperError(\"options.boundingSphere is required.\");\n  }\n  if (!defined(options.horizonOcclusionPoint)) {\n    throw new DeveloperError(\"options.horizonOcclusionPoint is required.\");\n  }\n  if (!defined(options.westIndices)) {\n    throw new DeveloperError(\"options.westIndices is required.\");\n  }\n  if (!defined(options.southIndices)) {\n    throw new DeveloperError(\"options.southIndices is required.\");\n  }\n  if (!defined(options.eastIndices)) {\n    throw new DeveloperError(\"options.eastIndices is required.\");\n  }\n  if (!defined(options.northIndices)) {\n    throw new DeveloperError(\"options.northIndices is required.\");\n  }\n  if (!defined(options.westSkirtHeight)) {\n    throw new DeveloperError(\"options.westSkirtHeight is required.\");\n  }\n  if (!defined(options.southSkirtHeight)) {\n    throw new DeveloperError(\"options.southSkirtHeight is required.\");\n  }\n  if (!defined(options.eastSkirtHeight)) {\n    throw new DeveloperError(\"options.eastSkirtHeight is required.\");\n  }\n  if (!defined(options.northSkirtHeight)) {\n    throw new DeveloperError(\"options.northSkirtHeight is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this._quantizedVertices = options.quantizedVertices;\n  this._encodedNormals = options.encodedNormals;\n  this._indices = options.indices;\n  this._minimumHeight = options.minimumHeight;\n  this._maximumHeight = options.maximumHeight;\n  this._boundingSphere = options.boundingSphere;\n  this._orientedBoundingBox = options.orientedBoundingBox;\n  this._horizonOcclusionPoint = options.horizonOcclusionPoint;\n  this._credits = options.credits;\n\n  var vertexCount = this._quantizedVertices.length / 3;\n  var uValues = (this._uValues = this._quantizedVertices.subarray(\n    0,\n    vertexCount\n  ));\n  var vValues = (this._vValues = this._quantizedVertices.subarray(\n    vertexCount,\n    2 * vertexCount\n  ));\n  this._heightValues = this._quantizedVertices.subarray(\n    2 * vertexCount,\n    3 * vertexCount\n  );\n\n  // We don't assume that we can count on the edge vertices being sorted by u or v.\n  function sortByV(a, b) {\n    return vValues[a] - vValues[b];\n  }\n\n  function sortByU(a, b) {\n    return uValues[a] - uValues[b];\n  }\n\n  this._westIndices = sortIndicesIfNecessary(\n    options.westIndices,\n    sortByV,\n    vertexCount\n  );\n  this._southIndices = sortIndicesIfNecessary(\n    options.southIndices,\n    sortByU,\n    vertexCount\n  );\n  this._eastIndices = sortIndicesIfNecessary(\n    options.eastIndices,\n    sortByV,\n    vertexCount\n  );\n  this._northIndices = sortIndicesIfNecessary(\n    options.northIndices,\n    sortByU,\n    vertexCount\n  );\n\n  this._westSkirtHeight = options.westSkirtHeight;\n  this._southSkirtHeight = options.southSkirtHeight;\n  this._eastSkirtHeight = options.eastSkirtHeight;\n  this._northSkirtHeight = options.northSkirtHeight;\n\n  this._childTileMask = defaultValue(options.childTileMask, 15);\n\n  this._createdByUpsampling = defaultValue(options.createdByUpsampling, false);\n  this._waterMask = options.waterMask;\n\n  this._mesh = undefined;\n}\n\nObject.defineProperties(QuantizedMeshTerrainData.prototype, {\n  /**\n   * An array of credits for this tile.\n   * @memberof QuantizedMeshTerrainData.prototype\n   * @type {Credit[]}\n   */\n  credits: {\n    get: function () {\n      return this._credits;\n    },\n  },\n  /**\n   * The water mask included in this terrain data, if any.  A water mask is a rectangular\n   * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.\n   * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.\n   * @memberof QuantizedMeshTerrainData.prototype\n   * @type {Uint8Array|HTMLImageElement|HTMLCanvasElement}\n   */\n  waterMask: {\n    get: function () {\n      return this._waterMask;\n    },\n  },\n\n  childTileMask: {\n    get: function () {\n      return this._childTileMask;\n    },\n  },\n\n  canUpsample: {\n    get: function () {\n      return defined(this._mesh);\n    },\n  },\n});\n\nvar arrayScratch = [];\n\nfunction sortIndicesIfNecessary(indices, sortFunction, vertexCount) {\n  arrayScratch.length = indices.length;\n\n  var needsSort = false;\n  for (var i = 0, len = indices.length; i < len; ++i) {\n    arrayScratch[i] = indices[i];\n    needsSort =\n      needsSort || (i > 0 && sortFunction(indices[i - 1], indices[i]) > 0);\n  }\n\n  if (needsSort) {\n    arrayScratch.sort(sortFunction);\n    return IndexDatatype.createTypedArray(vertexCount, arrayScratch);\n  }\n  return indices;\n}\n\nvar createMeshTaskName = \"createVerticesFromQuantizedTerrainMesh\";\nvar createMeshTaskProcessorNoThrottle = new TaskProcessor(createMeshTaskName);\nvar createMeshTaskProcessorThrottle = new TaskProcessor(\n  createMeshTaskName,\n  TerrainData.maximumAsynchronousTasks\n);\n\n/**\n * Creates a {@link TerrainMesh} from this terrain data.\n *\n * @private\n *\n * @param {Object} options Object with the following properties:\n * @param {TilingScheme} options.tilingScheme The tiling scheme to which this tile belongs.\n * @param {Number} options.x The X coordinate of the tile for which to create the terrain data.\n * @param {Number} options.y The Y coordinate of the tile for which to create the terrain data.\n * @param {Number} options.level The level of the tile for which to create the terrain data.\n * @param {Number} [options.exaggeration=1.0] The scale used to exaggerate the terrain.\n * @param {Boolean} [options.throttle=true] If true, indicates that this operation will need to be retried if too many asynchronous mesh creations are already in progress.\n * @returns {Promise.<TerrainMesh>|undefined} A promise for the terrain mesh, or undefined if too many\n *          asynchronous mesh creations are already in progress and the operation should\n *          be retried later.\n */\nQuantizedMeshTerrainData.prototype.createMesh = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.tilingScheme\", options.tilingScheme);\n  Check.typeOf.number(\"options.x\", options.x);\n  Check.typeOf.number(\"options.y\", options.y);\n  Check.typeOf.number(\"options.level\", options.level);\n  //>>includeEnd('debug');\n\n  var tilingScheme = options.tilingScheme;\n  var x = options.x;\n  var y = options.y;\n  var level = options.level;\n  var exaggeration = defaultValue(options.exaggeration, 1.0);\n  var throttle = defaultValue(options.throttle, true);\n\n  var ellipsoid = tilingScheme.ellipsoid;\n  var rectangle = tilingScheme.tileXYToRectangle(x, y, level);\n\n  var createMeshTaskProcessor = throttle\n    ? createMeshTaskProcessorThrottle\n    : createMeshTaskProcessorNoThrottle;\n\n  var verticesPromise = createMeshTaskProcessor.scheduleTask({\n    minimumHeight: this._minimumHeight,\n    maximumHeight: this._maximumHeight,\n    quantizedVertices: this._quantizedVertices,\n    octEncodedNormals: this._encodedNormals,\n    includeWebMercatorT: true,\n    indices: this._indices,\n    westIndices: this._westIndices,\n    southIndices: this._southIndices,\n    eastIndices: this._eastIndices,\n    northIndices: this._northIndices,\n    westSkirtHeight: this._westSkirtHeight,\n    southSkirtHeight: this._southSkirtHeight,\n    eastSkirtHeight: this._eastSkirtHeight,\n    northSkirtHeight: this._northSkirtHeight,\n    rectangle: rectangle,\n    relativeToCenter: this._boundingSphere.center,\n    ellipsoid: ellipsoid,\n    exaggeration: exaggeration,\n  });\n\n  if (!defined(verticesPromise)) {\n    // Postponed\n    return undefined;\n  }\n\n  var that = this;\n  return when(verticesPromise, function (result) {\n    var vertexCountWithoutSkirts = that._quantizedVertices.length / 3;\n    var vertexCount =\n      vertexCountWithoutSkirts +\n      that._westIndices.length +\n      that._southIndices.length +\n      that._eastIndices.length +\n      that._northIndices.length;\n    var indicesTypedArray = IndexDatatype.createTypedArray(\n      vertexCount,\n      result.indices\n    );\n\n    var vertices = new Float32Array(result.vertices);\n    var rtc = result.center;\n    var minimumHeight = result.minimumHeight;\n    var maximumHeight = result.maximumHeight;\n    var boundingSphere = defaultValue(\n      BoundingSphere.clone(result.boundingSphere),\n      that._boundingSphere\n    );\n    var obb = defaultValue(\n      OrientedBoundingBox.clone(result.orientedBoundingBox),\n      that._orientedBoundingBox\n    );\n    var occludeePointInScaledSpace = defaultValue(\n      Cartesian3.clone(result.occludeePointInScaledSpace),\n      that._horizonOcclusionPoint\n    );\n    var stride = result.vertexStride;\n    var terrainEncoding = TerrainEncoding.clone(result.encoding);\n\n    // Clone complex result objects because the transfer from the web worker\n    // has stripped them down to JSON-style objects.\n    that._mesh = new TerrainMesh(\n      rtc,\n      vertices,\n      indicesTypedArray,\n      result.indexCountWithoutSkirts,\n      vertexCountWithoutSkirts,\n      minimumHeight,\n      maximumHeight,\n      boundingSphere,\n      occludeePointInScaledSpace,\n      stride,\n      obb,\n      terrainEncoding,\n      exaggeration,\n      result.westIndicesSouthToNorth,\n      result.southIndicesEastToWest,\n      result.eastIndicesNorthToSouth,\n      result.northIndicesWestToEast\n    );\n\n    // Free memory received from server after mesh is created.\n    that._quantizedVertices = undefined;\n    that._encodedNormals = undefined;\n    that._indices = undefined;\n\n    that._uValues = undefined;\n    that._vValues = undefined;\n    that._heightValues = undefined;\n\n    that._westIndices = undefined;\n    that._southIndices = undefined;\n    that._eastIndices = undefined;\n    that._northIndices = undefined;\n\n    return that._mesh;\n  });\n};\n\nvar upsampleTaskProcessor = new TaskProcessor(\n  \"upsampleQuantizedTerrainMesh\",\n  TerrainData.maximumAsynchronousTasks\n);\n\n/**\n * Upsamples this terrain data for use by a descendant tile.  The resulting instance will contain a subset of the\n * vertices in this instance, interpolated if necessary.\n *\n * @param {TilingScheme} tilingScheme The tiling scheme of this terrain data.\n * @param {Number} thisX The X coordinate of this tile in the tiling scheme.\n * @param {Number} thisY The Y coordinate of this tile in the tiling scheme.\n * @param {Number} thisLevel The level of this tile in the tiling scheme.\n * @param {Number} descendantX The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {Number} descendantY The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {Number} descendantLevel The level within the tiling scheme of the descendant tile for which we are upsampling.\n * @returns {Promise.<QuantizedMeshTerrainData>|undefined} A promise for upsampled heightmap terrain data for the descendant tile,\n *          or undefined if too many asynchronous upsample operations are in progress and the request has been\n *          deferred.\n */\nQuantizedMeshTerrainData.prototype.upsample = function (\n  tilingScheme,\n  thisX,\n  thisY,\n  thisLevel,\n  descendantX,\n  descendantY,\n  descendantLevel\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(tilingScheme)) {\n    throw new DeveloperError(\"tilingScheme is required.\");\n  }\n  if (!defined(thisX)) {\n    throw new DeveloperError(\"thisX is required.\");\n  }\n  if (!defined(thisY)) {\n    throw new DeveloperError(\"thisY is required.\");\n  }\n  if (!defined(thisLevel)) {\n    throw new DeveloperError(\"thisLevel is required.\");\n  }\n  if (!defined(descendantX)) {\n    throw new DeveloperError(\"descendantX is required.\");\n  }\n  if (!defined(descendantY)) {\n    throw new DeveloperError(\"descendantY is required.\");\n  }\n  if (!defined(descendantLevel)) {\n    throw new DeveloperError(\"descendantLevel is required.\");\n  }\n  var levelDifference = descendantLevel - thisLevel;\n  if (levelDifference > 1) {\n    throw new DeveloperError(\n      \"Upsampling through more than one level at a time is not currently supported.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var mesh = this._mesh;\n  if (!defined(this._mesh)) {\n    return undefined;\n  }\n\n  var isEastChild = thisX * 2 !== descendantX;\n  var isNorthChild = thisY * 2 === descendantY;\n\n  var ellipsoid = tilingScheme.ellipsoid;\n  var childRectangle = tilingScheme.tileXYToRectangle(\n    descendantX,\n    descendantY,\n    descendantLevel\n  );\n\n  var upsamplePromise = upsampleTaskProcessor.scheduleTask({\n    vertices: mesh.vertices,\n    vertexCountWithoutSkirts: mesh.vertexCountWithoutSkirts,\n    indices: mesh.indices,\n    indexCountWithoutSkirts: mesh.indexCountWithoutSkirts,\n    encoding: mesh.encoding,\n    minimumHeight: this._minimumHeight,\n    maximumHeight: this._maximumHeight,\n    isEastChild: isEastChild,\n    isNorthChild: isNorthChild,\n    childRectangle: childRectangle,\n    ellipsoid: ellipsoid,\n    exaggeration: mesh.exaggeration,\n  });\n\n  if (!defined(upsamplePromise)) {\n    // Postponed\n    return undefined;\n  }\n\n  var shortestSkirt = Math.min(this._westSkirtHeight, this._eastSkirtHeight);\n  shortestSkirt = Math.min(shortestSkirt, this._southSkirtHeight);\n  shortestSkirt = Math.min(shortestSkirt, this._northSkirtHeight);\n\n  var westSkirtHeight = isEastChild\n    ? shortestSkirt * 0.5\n    : this._westSkirtHeight;\n  var southSkirtHeight = isNorthChild\n    ? shortestSkirt * 0.5\n    : this._southSkirtHeight;\n  var eastSkirtHeight = isEastChild\n    ? this._eastSkirtHeight\n    : shortestSkirt * 0.5;\n  var northSkirtHeight = isNorthChild\n    ? this._northSkirtHeight\n    : shortestSkirt * 0.5;\n  var credits = this._credits;\n\n  return when(upsamplePromise).then(function (result) {\n    var quantizedVertices = new Uint16Array(result.vertices);\n    var indicesTypedArray = IndexDatatype.createTypedArray(\n      quantizedVertices.length / 3,\n      result.indices\n    );\n    var encodedNormals;\n    if (defined(result.encodedNormals)) {\n      encodedNormals = new Uint8Array(result.encodedNormals);\n    }\n\n    return new QuantizedMeshTerrainData({\n      quantizedVertices: quantizedVertices,\n      indices: indicesTypedArray,\n      encodedNormals: encodedNormals,\n      minimumHeight: result.minimumHeight,\n      maximumHeight: result.maximumHeight,\n      boundingSphere: BoundingSphere.clone(result.boundingSphere),\n      orientedBoundingBox: OrientedBoundingBox.clone(\n        result.orientedBoundingBox\n      ),\n      horizonOcclusionPoint: Cartesian3.clone(result.horizonOcclusionPoint),\n      westIndices: result.westIndices,\n      southIndices: result.southIndices,\n      eastIndices: result.eastIndices,\n      northIndices: result.northIndices,\n      westSkirtHeight: westSkirtHeight,\n      southSkirtHeight: southSkirtHeight,\n      eastSkirtHeight: eastSkirtHeight,\n      northSkirtHeight: northSkirtHeight,\n      childTileMask: 0,\n      credits: credits,\n      createdByUpsampling: true,\n    });\n  });\n};\n\nvar maxShort = 32767;\nvar barycentricCoordinateScratch = new Cartesian3();\n\n/**\n * Computes the terrain height at a specified longitude and latitude.\n *\n * @param {Rectangle} rectangle The rectangle covered by this terrain data.\n * @param {Number} longitude The longitude in radians.\n * @param {Number} latitude The latitude in radians.\n * @returns {Number} The terrain height at the specified position.  The position is clamped to\n *          the rectangle, so expect incorrect results for positions far outside the rectangle.\n */\nQuantizedMeshTerrainData.prototype.interpolateHeight = function (\n  rectangle,\n  longitude,\n  latitude\n) {\n  var u = CesiumMath.clamp(\n    (longitude - rectangle.west) / rectangle.width,\n    0.0,\n    1.0\n  );\n  u *= maxShort;\n  var v = CesiumMath.clamp(\n    (latitude - rectangle.south) / rectangle.height,\n    0.0,\n    1.0\n  );\n  v *= maxShort;\n\n  if (!defined(this._mesh)) {\n    return interpolateHeight(this, u, v);\n  }\n\n  return interpolateMeshHeight(this, u, v);\n};\n\nfunction pointInBoundingBox(u, v, u0, v0, u1, v1, u2, v2) {\n  var minU = Math.min(u0, u1, u2);\n  var maxU = Math.max(u0, u1, u2);\n  var minV = Math.min(v0, v1, v2);\n  var maxV = Math.max(v0, v1, v2);\n  return u >= minU && u <= maxU && v >= minV && v <= maxV;\n}\n\nvar texCoordScratch0 = new Cartesian2();\nvar texCoordScratch1 = new Cartesian2();\nvar texCoordScratch2 = new Cartesian2();\n\nfunction interpolateMeshHeight(terrainData, u, v) {\n  var mesh = terrainData._mesh;\n  var vertices = mesh.vertices;\n  var encoding = mesh.encoding;\n  var indices = mesh.indices;\n\n  for (var i = 0, len = indices.length; i < len; i += 3) {\n    var i0 = indices[i];\n    var i1 = indices[i + 1];\n    var i2 = indices[i + 2];\n\n    var uv0 = encoding.decodeTextureCoordinates(vertices, i0, texCoordScratch0);\n    var uv1 = encoding.decodeTextureCoordinates(vertices, i1, texCoordScratch1);\n    var uv2 = encoding.decodeTextureCoordinates(vertices, i2, texCoordScratch2);\n\n    if (pointInBoundingBox(u, v, uv0.x, uv0.y, uv1.x, uv1.y, uv2.x, uv2.y)) {\n      var barycentric = Intersections2D.computeBarycentricCoordinates(\n        u,\n        v,\n        uv0.x,\n        uv0.y,\n        uv1.x,\n        uv1.y,\n        uv2.x,\n        uv2.y,\n        barycentricCoordinateScratch\n      );\n      if (\n        barycentric.x >= -1e-15 &&\n        barycentric.y >= -1e-15 &&\n        barycentric.z >= -1e-15\n      ) {\n        var h0 = encoding.decodeHeight(vertices, i0);\n        var h1 = encoding.decodeHeight(vertices, i1);\n        var h2 = encoding.decodeHeight(vertices, i2);\n        return barycentric.x * h0 + barycentric.y * h1 + barycentric.z * h2;\n      }\n    }\n  }\n\n  // Position does not lie in any triangle in this mesh.\n  return undefined;\n}\n\nfunction interpolateHeight(terrainData, u, v) {\n  var uBuffer = terrainData._uValues;\n  var vBuffer = terrainData._vValues;\n  var heightBuffer = terrainData._heightValues;\n\n  var indices = terrainData._indices;\n  for (var i = 0, len = indices.length; i < len; i += 3) {\n    var i0 = indices[i];\n    var i1 = indices[i + 1];\n    var i2 = indices[i + 2];\n\n    var u0 = uBuffer[i0];\n    var u1 = uBuffer[i1];\n    var u2 = uBuffer[i2];\n\n    var v0 = vBuffer[i0];\n    var v1 = vBuffer[i1];\n    var v2 = vBuffer[i2];\n\n    if (pointInBoundingBox(u, v, u0, v0, u1, v1, u2, v2)) {\n      var barycentric = Intersections2D.computeBarycentricCoordinates(\n        u,\n        v,\n        u0,\n        v0,\n        u1,\n        v1,\n        u2,\n        v2,\n        barycentricCoordinateScratch\n      );\n      if (\n        barycentric.x >= -1e-15 &&\n        barycentric.y >= -1e-15 &&\n        barycentric.z >= -1e-15\n      ) {\n        var quantizedHeight =\n          barycentric.x * heightBuffer[i0] +\n          barycentric.y * heightBuffer[i1] +\n          barycentric.z * heightBuffer[i2];\n        return CesiumMath.lerp(\n          terrainData._minimumHeight,\n          terrainData._maximumHeight,\n          quantizedHeight / maxShort\n        );\n      }\n    }\n  }\n\n  // Position does not lie in any triangle in this mesh.\n  return undefined;\n}\n\n/**\n * Determines if a given child tile is available, based on the\n * {@link HeightmapTerrainData.childTileMask}.  The given child tile coordinates are assumed\n * to be one of the four children of this tile.  If non-child tile coordinates are\n * given, the availability of the southeast child tile is returned.\n *\n * @param {Number} thisX The tile X coordinate of this (the parent) tile.\n * @param {Number} thisY The tile Y coordinate of this (the parent) tile.\n * @param {Number} childX The tile X coordinate of the child tile to check for availability.\n * @param {Number} childY The tile Y coordinate of the child tile to check for availability.\n * @returns {Boolean} True if the child tile is available; otherwise, false.\n */\nQuantizedMeshTerrainData.prototype.isChildAvailable = function (\n  thisX,\n  thisY,\n  childX,\n  childY\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(thisX)) {\n    throw new DeveloperError(\"thisX is required.\");\n  }\n  if (!defined(thisY)) {\n    throw new DeveloperError(\"thisY is required.\");\n  }\n  if (!defined(childX)) {\n    throw new DeveloperError(\"childX is required.\");\n  }\n  if (!defined(childY)) {\n    throw new DeveloperError(\"childY is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var bitNumber = 2; // northwest child\n  if (childX !== thisX * 2) {\n    ++bitNumber; // east child\n  }\n  if (childY !== thisY * 2) {\n    bitNumber -= 2; // south child\n  }\n\n  return (this._childTileMask & (1 << bitNumber)) !== 0;\n};\n\n/**\n * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution\n * terrain data.  If this value is false, the data was obtained from some other source, such\n * as by downloading it from a remote server.  This method should return true for instances\n * returned from a call to {@link HeightmapTerrainData#upsample}.\n *\n * @returns {Boolean} True if this instance was created by upsampling; otherwise, false.\n */\nQuantizedMeshTerrainData.prototype.wasCreatedByUpsampling = function () {\n  return this._createdByUpsampling;\n};\nexport default QuantizedMeshTerrainData;\n"]},"metadata":{},"sourceType":"module"}