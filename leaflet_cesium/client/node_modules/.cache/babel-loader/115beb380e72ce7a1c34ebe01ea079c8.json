{"ast":null,"code":"import arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport defined from \"./defined.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolylinePipeline from \"./PolylinePipeline.js\";\n/**\n * @private\n */\n\nvar WallGeometryLibrary = {};\n\nfunction latLonEquals(c0, c1) {\n  return CesiumMath.equalsEpsilon(c0.latitude, c1.latitude, CesiumMath.EPSILON10) && CesiumMath.equalsEpsilon(c0.longitude, c1.longitude, CesiumMath.EPSILON10);\n}\n\nvar scratchCartographic1 = new Cartographic();\nvar scratchCartographic2 = new Cartographic();\n\nfunction removeDuplicates(ellipsoid, positions, topHeights, bottomHeights) {\n  positions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);\n  var length = positions.length;\n\n  if (length < 2) {\n    return;\n  }\n\n  var hasBottomHeights = defined(bottomHeights);\n  var hasTopHeights = defined(topHeights);\n  var cleanedPositions = new Array(length);\n  var cleanedTopHeights = new Array(length);\n  var cleanedBottomHeights = new Array(length);\n  var v0 = positions[0];\n  cleanedPositions[0] = v0;\n  var c0 = ellipsoid.cartesianToCartographic(v0, scratchCartographic1);\n\n  if (hasTopHeights) {\n    c0.height = topHeights[0];\n  }\n\n  cleanedTopHeights[0] = c0.height;\n\n  if (hasBottomHeights) {\n    cleanedBottomHeights[0] = bottomHeights[0];\n  } else {\n    cleanedBottomHeights[0] = 0.0;\n  }\n\n  var startTopHeight = cleanedTopHeights[0];\n  var startBottomHeight = cleanedBottomHeights[0];\n  var hasAllSameHeights = startTopHeight === startBottomHeight;\n  var index = 1;\n\n  for (var i = 1; i < length; ++i) {\n    var v1 = positions[i];\n    var c1 = ellipsoid.cartesianToCartographic(v1, scratchCartographic2);\n\n    if (hasTopHeights) {\n      c1.height = topHeights[i];\n    }\n\n    hasAllSameHeights = hasAllSameHeights && c1.height === 0;\n\n    if (!latLonEquals(c0, c1)) {\n      cleanedPositions[index] = v1; // Shallow copy!\n\n      cleanedTopHeights[index] = c1.height;\n\n      if (hasBottomHeights) {\n        cleanedBottomHeights[index] = bottomHeights[i];\n      } else {\n        cleanedBottomHeights[index] = 0.0;\n      }\n\n      hasAllSameHeights = hasAllSameHeights && cleanedTopHeights[index] === cleanedBottomHeights[index];\n      Cartographic.clone(c1, c0);\n      ++index;\n    } else if (c0.height < c1.height) {\n      // two adjacent positions are the same, so use whichever has the greater height\n      cleanedTopHeights[index - 1] = c1.height;\n    }\n  }\n\n  if (hasAllSameHeights || index < 2) {\n    return;\n  }\n\n  cleanedPositions.length = index;\n  cleanedTopHeights.length = index;\n  cleanedBottomHeights.length = index;\n  return {\n    positions: cleanedPositions,\n    topHeights: cleanedTopHeights,\n    bottomHeights: cleanedBottomHeights\n  };\n}\n\nvar positionsArrayScratch = new Array(2);\nvar heightsArrayScratch = new Array(2);\nvar generateArcOptionsScratch = {\n  positions: undefined,\n  height: undefined,\n  granularity: undefined,\n  ellipsoid: undefined\n};\n/**\n * @private\n */\n\nWallGeometryLibrary.computePositions = function (ellipsoid, wallPositions, maximumHeights, minimumHeights, granularity, duplicateCorners) {\n  var o = removeDuplicates(ellipsoid, wallPositions, maximumHeights, minimumHeights);\n\n  if (!defined(o)) {\n    return;\n  }\n\n  wallPositions = o.positions;\n  maximumHeights = o.topHeights;\n  minimumHeights = o.bottomHeights;\n  var length = wallPositions.length;\n  var numCorners = length - 2;\n  var topPositions;\n  var bottomPositions;\n  var minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n  var generateArcOptions = generateArcOptionsScratch;\n  generateArcOptions.minDistance = minDistance;\n  generateArcOptions.ellipsoid = ellipsoid;\n\n  if (duplicateCorners) {\n    var count = 0;\n    var i;\n\n    for (i = 0; i < length - 1; i++) {\n      count += PolylinePipeline.numberOfPoints(wallPositions[i], wallPositions[i + 1], minDistance) + 1;\n    }\n\n    topPositions = new Float64Array(count * 3);\n    bottomPositions = new Float64Array(count * 3);\n    var generateArcPositions = positionsArrayScratch;\n    var generateArcHeights = heightsArrayScratch;\n    generateArcOptions.positions = generateArcPositions;\n    generateArcOptions.height = generateArcHeights;\n    var offset = 0;\n\n    for (i = 0; i < length - 1; i++) {\n      generateArcPositions[0] = wallPositions[i];\n      generateArcPositions[1] = wallPositions[i + 1];\n      generateArcHeights[0] = maximumHeights[i];\n      generateArcHeights[1] = maximumHeights[i + 1];\n      var pos = PolylinePipeline.generateArc(generateArcOptions);\n      topPositions.set(pos, offset);\n      generateArcHeights[0] = minimumHeights[i];\n      generateArcHeights[1] = minimumHeights[i + 1];\n      bottomPositions.set(PolylinePipeline.generateArc(generateArcOptions), offset);\n      offset += pos.length;\n    }\n  } else {\n    generateArcOptions.positions = wallPositions;\n    generateArcOptions.height = maximumHeights;\n    topPositions = new Float64Array(PolylinePipeline.generateArc(generateArcOptions));\n    generateArcOptions.height = minimumHeights;\n    bottomPositions = new Float64Array(PolylinePipeline.generateArc(generateArcOptions));\n  }\n\n  return {\n    bottomPositions: bottomPositions,\n    topPositions: topPositions,\n    numCorners: numCorners\n  };\n};\n\nexport default WallGeometryLibrary;","map":{"version":3,"sources":["/home/usuario/davi/thalamus/wms/3dmaptestes/leaflet_cesium/client/node_modules/cesium/Source/Core/WallGeometryLibrary.js"],"names":["arrayRemoveDuplicates","Cartesian3","Cartographic","defined","CesiumMath","PolylinePipeline","WallGeometryLibrary","latLonEquals","c0","c1","equalsEpsilon","latitude","EPSILON10","longitude","scratchCartographic1","scratchCartographic2","removeDuplicates","ellipsoid","positions","topHeights","bottomHeights","length","hasBottomHeights","hasTopHeights","cleanedPositions","Array","cleanedTopHeights","cleanedBottomHeights","v0","cartesianToCartographic","height","startTopHeight","startBottomHeight","hasAllSameHeights","index","i","v1","clone","positionsArrayScratch","heightsArrayScratch","generateArcOptionsScratch","undefined","granularity","computePositions","wallPositions","maximumHeights","minimumHeights","duplicateCorners","o","numCorners","topPositions","bottomPositions","minDistance","chordLength","maximumRadius","generateArcOptions","count","numberOfPoints","Float64Array","generateArcPositions","generateArcHeights","offset","pos","generateArc","set"],"mappings":"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","sourcesContent":["import arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport defined from \"./defined.js\";\nimport CesiumMath from \"./Math.js\";\nimport PolylinePipeline from \"./PolylinePipeline.js\";\n\n/**\n * @private\n */\nvar WallGeometryLibrary = {};\n\nfunction latLonEquals(c0, c1) {\n  return (\n    CesiumMath.equalsEpsilon(c0.latitude, c1.latitude, CesiumMath.EPSILON10) &&\n    CesiumMath.equalsEpsilon(c0.longitude, c1.longitude, CesiumMath.EPSILON10)\n  );\n}\n\nvar scratchCartographic1 = new Cartographic();\nvar scratchCartographic2 = new Cartographic();\nfunction removeDuplicates(ellipsoid, positions, topHeights, bottomHeights) {\n  positions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);\n\n  var length = positions.length;\n  if (length < 2) {\n    return;\n  }\n\n  var hasBottomHeights = defined(bottomHeights);\n  var hasTopHeights = defined(topHeights);\n\n  var cleanedPositions = new Array(length);\n  var cleanedTopHeights = new Array(length);\n  var cleanedBottomHeights = new Array(length);\n\n  var v0 = positions[0];\n  cleanedPositions[0] = v0;\n\n  var c0 = ellipsoid.cartesianToCartographic(v0, scratchCartographic1);\n  if (hasTopHeights) {\n    c0.height = topHeights[0];\n  }\n\n  cleanedTopHeights[0] = c0.height;\n\n  if (hasBottomHeights) {\n    cleanedBottomHeights[0] = bottomHeights[0];\n  } else {\n    cleanedBottomHeights[0] = 0.0;\n  }\n\n  var startTopHeight = cleanedTopHeights[0];\n  var startBottomHeight = cleanedBottomHeights[0];\n  var hasAllSameHeights = startTopHeight === startBottomHeight;\n\n  var index = 1;\n  for (var i = 1; i < length; ++i) {\n    var v1 = positions[i];\n    var c1 = ellipsoid.cartesianToCartographic(v1, scratchCartographic2);\n    if (hasTopHeights) {\n      c1.height = topHeights[i];\n    }\n    hasAllSameHeights = hasAllSameHeights && c1.height === 0;\n\n    if (!latLonEquals(c0, c1)) {\n      cleanedPositions[index] = v1; // Shallow copy!\n      cleanedTopHeights[index] = c1.height;\n\n      if (hasBottomHeights) {\n        cleanedBottomHeights[index] = bottomHeights[i];\n      } else {\n        cleanedBottomHeights[index] = 0.0;\n      }\n      hasAllSameHeights =\n        hasAllSameHeights &&\n        cleanedTopHeights[index] === cleanedBottomHeights[index];\n\n      Cartographic.clone(c1, c0);\n      ++index;\n    } else if (c0.height < c1.height) {\n      // two adjacent positions are the same, so use whichever has the greater height\n      cleanedTopHeights[index - 1] = c1.height;\n    }\n  }\n\n  if (hasAllSameHeights || index < 2) {\n    return;\n  }\n\n  cleanedPositions.length = index;\n  cleanedTopHeights.length = index;\n  cleanedBottomHeights.length = index;\n\n  return {\n    positions: cleanedPositions,\n    topHeights: cleanedTopHeights,\n    bottomHeights: cleanedBottomHeights,\n  };\n}\n\nvar positionsArrayScratch = new Array(2);\nvar heightsArrayScratch = new Array(2);\nvar generateArcOptionsScratch = {\n  positions: undefined,\n  height: undefined,\n  granularity: undefined,\n  ellipsoid: undefined,\n};\n\n/**\n * @private\n */\nWallGeometryLibrary.computePositions = function (\n  ellipsoid,\n  wallPositions,\n  maximumHeights,\n  minimumHeights,\n  granularity,\n  duplicateCorners\n) {\n  var o = removeDuplicates(\n    ellipsoid,\n    wallPositions,\n    maximumHeights,\n    minimumHeights\n  );\n\n  if (!defined(o)) {\n    return;\n  }\n\n  wallPositions = o.positions;\n  maximumHeights = o.topHeights;\n  minimumHeights = o.bottomHeights;\n\n  var length = wallPositions.length;\n  var numCorners = length - 2;\n  var topPositions;\n  var bottomPositions;\n\n  var minDistance = CesiumMath.chordLength(\n    granularity,\n    ellipsoid.maximumRadius\n  );\n\n  var generateArcOptions = generateArcOptionsScratch;\n  generateArcOptions.minDistance = minDistance;\n  generateArcOptions.ellipsoid = ellipsoid;\n\n  if (duplicateCorners) {\n    var count = 0;\n    var i;\n\n    for (i = 0; i < length - 1; i++) {\n      count +=\n        PolylinePipeline.numberOfPoints(\n          wallPositions[i],\n          wallPositions[i + 1],\n          minDistance\n        ) + 1;\n    }\n\n    topPositions = new Float64Array(count * 3);\n    bottomPositions = new Float64Array(count * 3);\n\n    var generateArcPositions = positionsArrayScratch;\n    var generateArcHeights = heightsArrayScratch;\n    generateArcOptions.positions = generateArcPositions;\n    generateArcOptions.height = generateArcHeights;\n\n    var offset = 0;\n    for (i = 0; i < length - 1; i++) {\n      generateArcPositions[0] = wallPositions[i];\n      generateArcPositions[1] = wallPositions[i + 1];\n\n      generateArcHeights[0] = maximumHeights[i];\n      generateArcHeights[1] = maximumHeights[i + 1];\n\n      var pos = PolylinePipeline.generateArc(generateArcOptions);\n      topPositions.set(pos, offset);\n\n      generateArcHeights[0] = minimumHeights[i];\n      generateArcHeights[1] = minimumHeights[i + 1];\n\n      bottomPositions.set(\n        PolylinePipeline.generateArc(generateArcOptions),\n        offset\n      );\n\n      offset += pos.length;\n    }\n  } else {\n    generateArcOptions.positions = wallPositions;\n    generateArcOptions.height = maximumHeights;\n    topPositions = new Float64Array(\n      PolylinePipeline.generateArc(generateArcOptions)\n    );\n\n    generateArcOptions.height = minimumHeights;\n    bottomPositions = new Float64Array(\n      PolylinePipeline.generateArc(generateArcOptions)\n    );\n  }\n\n  return {\n    bottomPositions: bottomPositions,\n    topPositions: topPositions,\n    numCorners: numCorners,\n  };\n};\nexport default WallGeometryLibrary;\n"]},"metadata":{},"sourceType":"module"}