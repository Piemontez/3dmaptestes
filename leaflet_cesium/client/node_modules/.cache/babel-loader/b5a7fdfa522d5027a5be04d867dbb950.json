{"ast":null,"code":"import Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n/**\n * A 2D Cartesian point.\n * @alias Cartesian2\n * @constructor\n *\n * @param {Number} [x=0.0] The X component.\n * @param {Number} [y=0.0] The Y component.\n *\n * @see Cartesian3\n * @see Cartesian4\n * @see Packable\n */\n\nfunction Cartesian2(x, y) {\n  /**\n   * The X component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.x = defaultValue(x, 0.0);\n  /**\n   * The Y component.\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.y = defaultValue(y, 0.0);\n}\n/**\n * Creates a Cartesian2 instance from x and y coordinates.\n *\n * @param {Number} x The x coordinate.\n * @param {Number} y The y coordinate.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\n\n\nCartesian2.fromElements = function (x, y, result) {\n  if (!defined(result)) {\n    return new Cartesian2(x, y);\n  }\n\n  result.x = x;\n  result.y = y;\n  return result;\n};\n/**\n * Duplicates a Cartesian2 instance.\n *\n * @param {Cartesian2} cartesian The Cartesian to duplicate.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided. (Returns undefined if cartesian is undefined)\n */\n\n\nCartesian2.clone = function (cartesian, result) {\n  if (!defined(cartesian)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new Cartesian2(cartesian.x, cartesian.y);\n  }\n\n  result.x = cartesian.x;\n  result.y = cartesian.y;\n  return result;\n};\n/**\n * Creates a Cartesian2 instance from an existing Cartesian3.  This simply takes the\n * x and y properties of the Cartesian3 and drops z.\n * @function\n *\n * @param {Cartesian3} cartesian The Cartesian3 instance to create a Cartesian2 instance from.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\n\n\nCartesian2.fromCartesian3 = Cartesian2.clone;\n/**\n * Creates a Cartesian2 instance from an existing Cartesian4.  This simply takes the\n * x and y properties of the Cartesian4 and drops z and w.\n * @function\n *\n * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian2 instance from.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\n\nCartesian2.fromCartesian4 = Cartesian2.clone;\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\n\nCartesian2.packedLength = 2;\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Cartesian2} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\n\nCartesian2.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  array[startingIndex++] = value.x;\n  array[startingIndex] = value.y;\n  return array;\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Cartesian2} [result] The object into which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\n\n\nCartesian2.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n\n  result.x = array[startingIndex++];\n  result.y = array[startingIndex];\n  return result;\n};\n/**\n     * Flattens an array of Cartesian2s into and array of components.\n     *\n     * @param {Cartesian2[]} array The array of cartesians to pack.\n     * @param {Number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 2 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 2) elements.\n\n     * @returns {Number[]} The packed array.\n     */\n\n\nCartesian2.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  var length = array.length;\n  var resultLength = length * 2;\n\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    throw new DeveloperError(\"If result is a typed array, it must have exactly array.length * 2 elements\");\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n\n  for (var i = 0; i < length; ++i) {\n    Cartesian2.pack(array[i], result, i * 2);\n  }\n\n  return result;\n};\n/**\n * Unpacks an array of cartesian components into and array of Cartesian2s.\n *\n * @param {Number[]} array The array of components to unpack.\n * @param {Cartesian2[]} [result] The array onto which to store the result.\n * @returns {Cartesian2[]} The unpacked array.\n */\n\n\nCartesian2.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 2);\n\n  if (array.length % 2 !== 0) {\n    throw new DeveloperError(\"array length must be a multiple of 2.\");\n  } //>>includeEnd('debug');\n\n\n  var length = array.length;\n\n  if (!defined(result)) {\n    result = new Array(length / 2);\n  } else {\n    result.length = length / 2;\n  }\n\n  for (var i = 0; i < length; i += 2) {\n    var index = i / 2;\n    result[index] = Cartesian2.unpack(array, i, result[index]);\n  }\n\n  return result;\n};\n/**\n * Creates a Cartesian2 from two consecutive elements in an array.\n * @function\n *\n * @param {Number[]} array The array whose two consecutive elements correspond to the x and y components, respectively.\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n *\n * @example\n * // Create a Cartesian2 with (1.0, 2.0)\n * var v = [1.0, 2.0];\n * var p = Cesium.Cartesian2.fromArray(v);\n *\n * // Create a Cartesian2 with (1.0, 2.0) using an offset into an array\n * var v2 = [0.0, 0.0, 1.0, 2.0];\n * var p2 = Cesium.Cartesian2.fromArray(v2, 2);\n */\n\n\nCartesian2.fromArray = Cartesian2.unpack;\n/**\n * Computes the value of the maximum component for the supplied Cartesian.\n *\n * @param {Cartesian2} cartesian The cartesian to use.\n * @returns {Number} The value of the maximum component.\n */\n\nCartesian2.maximumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian); //>>includeEnd('debug');\n\n  return Math.max(cartesian.x, cartesian.y);\n};\n/**\n * Computes the value of the minimum component for the supplied Cartesian.\n *\n * @param {Cartesian2} cartesian The cartesian to use.\n * @returns {Number} The value of the minimum component.\n */\n\n\nCartesian2.minimumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian); //>>includeEnd('debug');\n\n  return Math.min(cartesian.x, cartesian.y);\n};\n/**\n * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\n *\n * @param {Cartesian2} first A cartesian to compare.\n * @param {Cartesian2} second A cartesian to compare.\n * @param {Cartesian2} result The object into which to store the result.\n * @returns {Cartesian2} A cartesian with the minimum components.\n */\n\n\nCartesian2.minimumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = Math.min(first.x, second.x);\n  result.y = Math.min(first.y, second.y);\n  return result;\n};\n/**\n * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\n *\n * @param {Cartesian2} first A cartesian to compare.\n * @param {Cartesian2} second A cartesian to compare.\n * @param {Cartesian2} result The object into which to store the result.\n * @returns {Cartesian2} A cartesian with the maximum components.\n */\n\n\nCartesian2.maximumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = Math.max(first.x, second.x);\n  result.y = Math.max(first.y, second.y);\n  return result;\n};\n/**\n * Computes the provided Cartesian's squared magnitude.\n *\n * @param {Cartesian2} cartesian The Cartesian instance whose squared magnitude is to be computed.\n * @returns {Number} The squared magnitude.\n */\n\n\nCartesian2.magnitudeSquared = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian); //>>includeEnd('debug');\n\n  return cartesian.x * cartesian.x + cartesian.y * cartesian.y;\n};\n/**\n * Computes the Cartesian's magnitude (length).\n *\n * @param {Cartesian2} cartesian The Cartesian instance whose magnitude is to be computed.\n * @returns {Number} The magnitude.\n */\n\n\nCartesian2.magnitude = function (cartesian) {\n  return Math.sqrt(Cartesian2.magnitudeSquared(cartesian));\n};\n\nvar distanceScratch = new Cartesian2();\n/**\n * Computes the distance between two points.\n *\n * @param {Cartesian2} left The first point to compute the distance from.\n * @param {Cartesian2} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 1.0\n * var d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(2.0, 0.0));\n */\n\nCartesian2.distance = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right); //>>includeEnd('debug');\n\n  Cartesian2.subtract(left, right, distanceScratch);\n  return Cartesian2.magnitude(distanceScratch);\n};\n/**\n * Computes the squared distance between two points.  Comparing squared distances\n * using this function is more efficient than comparing distances using {@link Cartesian2#distance}.\n *\n * @param {Cartesian2} left The first point to compute the distance from.\n * @param {Cartesian2} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 4.0, not 2.0\n * var d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(3.0, 0.0));\n */\n\n\nCartesian2.distanceSquared = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right); //>>includeEnd('debug');\n\n  Cartesian2.subtract(left, right, distanceScratch);\n  return Cartesian2.magnitudeSquared(distanceScratch);\n};\n/**\n * Computes the normalized form of the supplied Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian to be normalized.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\n\n\nCartesian2.normalize = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  var magnitude = Cartesian2.magnitude(cartesian);\n  result.x = cartesian.x / magnitude;\n  result.y = cartesian.y / magnitude; //>>includeStart('debug', pragmas.debug);\n\n  if (isNaN(result.x) || isNaN(result.y)) {\n    throw new DeveloperError(\"normalized result is not a number\");\n  } //>>includeEnd('debug');\n\n\n  return result;\n};\n/**\n * Computes the dot (scalar) product of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @returns {Number} The dot product.\n */\n\n\nCartesian2.dot = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right); //>>includeEnd('debug');\n\n  return left.x * right.x + left.y * right.y;\n};\n/**\n * Computes the magnitude of the cross product that would result from implicitly setting the Z coordinate of the input vectors to 0\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @returns {Number} The cross product.\n */\n\n\nCartesian2.cross = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right); //>>includeEnd('debug');\n\n  return left.x * right.y - left.y * right.x;\n};\n/**\n * Computes the componentwise product of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\n\n\nCartesian2.multiplyComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = left.x * right.x;\n  result.y = left.y * right.y;\n  return result;\n};\n/**\n * Computes the componentwise quotient of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\n\n\nCartesian2.divideComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = left.x / right.x;\n  result.y = left.y / right.y;\n  return result;\n};\n/**\n * Computes the componentwise sum of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\n\n\nCartesian2.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  return result;\n};\n/**\n * Computes the componentwise difference of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\n\n\nCartesian2.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  return result;\n};\n/**\n * Multiplies the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian2} cartesian The Cartesian to be scaled.\n * @param {Number} scalar The scalar to multiply with.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\n\n\nCartesian2.multiplyByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = cartesian.x * scalar;\n  result.y = cartesian.y * scalar;\n  return result;\n};\n/**\n * Divides the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian2} cartesian The Cartesian to be divided.\n * @param {Number} scalar The scalar to divide by.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\n\n\nCartesian2.divideByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = cartesian.x / scalar;\n  result.y = cartesian.y / scalar;\n  return result;\n};\n/**\n * Negates the provided Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian to be negated.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\n\n\nCartesian2.negate = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = -cartesian.x;\n  result.y = -cartesian.y;\n  return result;\n};\n/**\n * Computes the absolute value of the provided Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian whose absolute value is to be computed.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\n\n\nCartesian2.abs = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = Math.abs(cartesian.x);\n  result.y = Math.abs(cartesian.y);\n  return result;\n};\n\nvar lerpScratch = new Cartesian2();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided cartesians.\n *\n * @param {Cartesian2} start The value corresponding to t at 0.0.\n * @param {Cartesian2} end The value corresponding to t at 1.0.\n * @param {Number} t The point along t at which to interpolate.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\n\nCartesian2.lerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  Cartesian2.multiplyByScalar(end, t, lerpScratch);\n  result = Cartesian2.multiplyByScalar(start, 1.0 - t, result);\n  return Cartesian2.add(lerpScratch, result, result);\n};\n\nvar angleBetweenScratch = new Cartesian2();\nvar angleBetweenScratch2 = new Cartesian2();\n/**\n * Returns the angle, in radians, between the provided Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @returns {Number} The angle between the Cartesians.\n */\n\nCartesian2.angleBetween = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right); //>>includeEnd('debug');\n\n  Cartesian2.normalize(left, angleBetweenScratch);\n  Cartesian2.normalize(right, angleBetweenScratch2);\n  return CesiumMath.acosClamped(Cartesian2.dot(angleBetweenScratch, angleBetweenScratch2));\n};\n\nvar mostOrthogonalAxisScratch = new Cartesian2();\n/**\n * Returns the axis that is most orthogonal to the provided Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian on which to find the most orthogonal axis.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The most orthogonal axis.\n */\n\nCartesian2.mostOrthogonalAxis = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  var f = Cartesian2.normalize(cartesian, mostOrthogonalAxisScratch);\n  Cartesian2.abs(f, f);\n\n  if (f.x <= f.y) {\n    result = Cartesian2.clone(Cartesian2.UNIT_X, result);\n  } else {\n    result = Cartesian2.clone(Cartesian2.UNIT_Y, result);\n  }\n\n  return result;\n};\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian2} [left] The first Cartesian.\n * @param {Cartesian2} [right] The second Cartesian.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\n\n\nCartesian2.equals = function (left, right) {\n  return left === right || defined(left) && defined(right) && left.x === right.x && left.y === right.y;\n};\n/**\n * @private\n */\n\n\nCartesian2.equalsArray = function (cartesian, array, offset) {\n  return cartesian.x === array[offset] && cartesian.y === array[offset + 1];\n};\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian2} [left] The first Cartesian.\n * @param {Cartesian2} [right] The second Cartesian.\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\n\n\nCartesian2.equalsEpsilon = function (left, right, relativeEpsilon, absoluteEpsilon) {\n  return left === right || defined(left) && defined(right) && CesiumMath.equalsEpsilon(left.x, right.x, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.y, right.y, relativeEpsilon, absoluteEpsilon);\n};\n/**\n * An immutable Cartesian2 instance initialized to (0.0, 0.0).\n *\n * @type {Cartesian2}\n * @constant\n */\n\n\nCartesian2.ZERO = Object.freeze(new Cartesian2(0.0, 0.0));\n/**\n * An immutable Cartesian2 instance initialized to (1.0, 0.0).\n *\n * @type {Cartesian2}\n * @constant\n */\n\nCartesian2.UNIT_X = Object.freeze(new Cartesian2(1.0, 0.0));\n/**\n * An immutable Cartesian2 instance initialized to (0.0, 1.0).\n *\n * @type {Cartesian2}\n * @constant\n */\n\nCartesian2.UNIT_Y = Object.freeze(new Cartesian2(0.0, 1.0));\n/**\n * Duplicates this Cartesian2 instance.\n *\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\n\nCartesian2.prototype.clone = function (result) {\n  return Cartesian2.clone(this, result);\n};\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian2} [right] The right hand side Cartesian.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\n\n\nCartesian2.prototype.equals = function (right) {\n  return Cartesian2.equals(this, right);\n};\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian2} [right] The right hand side Cartesian.\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\n\n\nCartesian2.prototype.equalsEpsilon = function (right, relativeEpsilon, absoluteEpsilon) {\n  return Cartesian2.equalsEpsilon(this, right, relativeEpsilon, absoluteEpsilon);\n};\n/**\n * Creates a string representing this Cartesian in the format '(x, y)'.\n *\n * @returns {String} A string representing the provided Cartesian in the format '(x, y)'.\n */\n\n\nCartesian2.prototype.toString = function () {\n  return \"(\" + this.x + \", \" + this.y + \")\";\n};\n\nexport default Cartesian2;","map":{"version":3,"sources":["/home/usuario/davi/thalamus/wms/3dmaptestes/leaflet_cesium/client/node_modules/cesium/Source/Core/Cartesian2.js"],"names":["Check","defaultValue","defined","DeveloperError","CesiumMath","Cartesian2","x","y","fromElements","result","clone","cartesian","undefined","fromCartesian3","fromCartesian4","packedLength","pack","value","array","startingIndex","typeOf","object","unpack","packArray","length","resultLength","Array","isArray","i","unpackArray","number","greaterThanOrEquals","index","fromArray","maximumComponent","Math","max","minimumComponent","min","minimumByComponent","first","second","maximumByComponent","magnitudeSquared","magnitude","sqrt","distanceScratch","distance","left","right","subtract","distanceSquared","normalize","isNaN","dot","cross","multiplyComponents","divideComponents","add","multiplyByScalar","scalar","divideByScalar","negate","abs","lerpScratch","lerp","start","end","t","angleBetweenScratch","angleBetweenScratch2","angleBetween","acosClamped","mostOrthogonalAxisScratch","mostOrthogonalAxis","f","UNIT_X","UNIT_Y","equals","equalsArray","offset","equalsEpsilon","relativeEpsilon","absoluteEpsilon","ZERO","Object","freeze","prototype","toString"],"mappings":"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","sourcesContent":["import Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * A 2D Cartesian point.\n * @alias Cartesian2\n * @constructor\n *\n * @param {Number} [x=0.0] The X component.\n * @param {Number} [y=0.0] The Y component.\n *\n * @see Cartesian3\n * @see Cartesian4\n * @see Packable\n */\nfunction Cartesian2(x, y) {\n  /**\n   * The X component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.x = defaultValue(x, 0.0);\n\n  /**\n   * The Y component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.y = defaultValue(y, 0.0);\n}\n\n/**\n * Creates a Cartesian2 instance from x and y coordinates.\n *\n * @param {Number} x The x coordinate.\n * @param {Number} y The y coordinate.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.fromElements = function (x, y, result) {\n  if (!defined(result)) {\n    return new Cartesian2(x, y);\n  }\n\n  result.x = x;\n  result.y = y;\n  return result;\n};\n\n/**\n * Duplicates a Cartesian2 instance.\n *\n * @param {Cartesian2} cartesian The Cartesian to duplicate.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided. (Returns undefined if cartesian is undefined)\n */\nCartesian2.clone = function (cartesian, result) {\n  if (!defined(cartesian)) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    return new Cartesian2(cartesian.x, cartesian.y);\n  }\n\n  result.x = cartesian.x;\n  result.y = cartesian.y;\n  return result;\n};\n\n/**\n * Creates a Cartesian2 instance from an existing Cartesian3.  This simply takes the\n * x and y properties of the Cartesian3 and drops z.\n * @function\n *\n * @param {Cartesian3} cartesian The Cartesian3 instance to create a Cartesian2 instance from.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.fromCartesian3 = Cartesian2.clone;\n\n/**\n * Creates a Cartesian2 instance from an existing Cartesian4.  This simply takes the\n * x and y properties of the Cartesian4 and drops z and w.\n * @function\n *\n * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian2 instance from.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.fromCartesian4 = Cartesian2.clone;\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nCartesian2.packedLength = 2;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Cartesian2} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nCartesian2.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value.x;\n  array[startingIndex] = value.y;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Cartesian2} [result] The object into which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Cartesian2();\n  }\n  result.x = array[startingIndex++];\n  result.y = array[startingIndex];\n  return result;\n};\n\n/**\n     * Flattens an array of Cartesian2s into and array of components.\n     *\n     * @param {Cartesian2[]} array The array of cartesians to pack.\n     * @param {Number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 2 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 2) elements.\n\n     * @returns {Number[]} The packed array.\n     */\nCartesian2.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  var length = array.length;\n  var resultLength = length * 2;\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    throw new DeveloperError(\n      \"If result is a typed array, it must have exactly array.length * 2 elements\"\n    );\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n\n  for (var i = 0; i < length; ++i) {\n    Cartesian2.pack(array[i], result, i * 2);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of cartesian components into and array of Cartesian2s.\n *\n * @param {Number[]} array The array of components to unpack.\n * @param {Cartesian2[]} [result] The array onto which to store the result.\n * @returns {Cartesian2[]} The unpacked array.\n */\nCartesian2.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 2);\n  if (array.length % 2 !== 0) {\n    throw new DeveloperError(\"array length must be a multiple of 2.\");\n  }\n  //>>includeEnd('debug');\n\n  var length = array.length;\n  if (!defined(result)) {\n    result = new Array(length / 2);\n  } else {\n    result.length = length / 2;\n  }\n\n  for (var i = 0; i < length; i += 2) {\n    var index = i / 2;\n    result[index] = Cartesian2.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Creates a Cartesian2 from two consecutive elements in an array.\n * @function\n *\n * @param {Number[]} array The array whose two consecutive elements correspond to the x and y components, respectively.\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n *\n * @example\n * // Create a Cartesian2 with (1.0, 2.0)\n * var v = [1.0, 2.0];\n * var p = Cesium.Cartesian2.fromArray(v);\n *\n * // Create a Cartesian2 with (1.0, 2.0) using an offset into an array\n * var v2 = [0.0, 0.0, 1.0, 2.0];\n * var p2 = Cesium.Cartesian2.fromArray(v2, 2);\n */\nCartesian2.fromArray = Cartesian2.unpack;\n\n/**\n * Computes the value of the maximum component for the supplied Cartesian.\n *\n * @param {Cartesian2} cartesian The cartesian to use.\n * @returns {Number} The value of the maximum component.\n */\nCartesian2.maximumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.max(cartesian.x, cartesian.y);\n};\n\n/**\n * Computes the value of the minimum component for the supplied Cartesian.\n *\n * @param {Cartesian2} cartesian The cartesian to use.\n * @returns {Number} The value of the minimum component.\n */\nCartesian2.minimumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.min(cartesian.x, cartesian.y);\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\n *\n * @param {Cartesian2} first A cartesian to compare.\n * @param {Cartesian2} second A cartesian to compare.\n * @param {Cartesian2} result The object into which to store the result.\n * @returns {Cartesian2} A cartesian with the minimum components.\n */\nCartesian2.minimumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.min(first.x, second.x);\n  result.y = Math.min(first.y, second.y);\n\n  return result;\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\n *\n * @param {Cartesian2} first A cartesian to compare.\n * @param {Cartesian2} second A cartesian to compare.\n * @param {Cartesian2} result The object into which to store the result.\n * @returns {Cartesian2} A cartesian with the maximum components.\n */\nCartesian2.maximumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.max(first.x, second.x);\n  result.y = Math.max(first.y, second.y);\n  return result;\n};\n\n/**\n * Computes the provided Cartesian's squared magnitude.\n *\n * @param {Cartesian2} cartesian The Cartesian instance whose squared magnitude is to be computed.\n * @returns {Number} The squared magnitude.\n */\nCartesian2.magnitudeSquared = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return cartesian.x * cartesian.x + cartesian.y * cartesian.y;\n};\n\n/**\n * Computes the Cartesian's magnitude (length).\n *\n * @param {Cartesian2} cartesian The Cartesian instance whose magnitude is to be computed.\n * @returns {Number} The magnitude.\n */\nCartesian2.magnitude = function (cartesian) {\n  return Math.sqrt(Cartesian2.magnitudeSquared(cartesian));\n};\n\nvar distanceScratch = new Cartesian2();\n\n/**\n * Computes the distance between two points.\n *\n * @param {Cartesian2} left The first point to compute the distance from.\n * @param {Cartesian2} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 1.0\n * var d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(2.0, 0.0));\n */\nCartesian2.distance = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian2.subtract(left, right, distanceScratch);\n  return Cartesian2.magnitude(distanceScratch);\n};\n\n/**\n * Computes the squared distance between two points.  Comparing squared distances\n * using this function is more efficient than comparing distances using {@link Cartesian2#distance}.\n *\n * @param {Cartesian2} left The first point to compute the distance from.\n * @param {Cartesian2} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 4.0, not 2.0\n * var d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(3.0, 0.0));\n */\nCartesian2.distanceSquared = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian2.subtract(left, right, distanceScratch);\n  return Cartesian2.magnitudeSquared(distanceScratch);\n};\n\n/**\n * Computes the normalized form of the supplied Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian to be normalized.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.normalize = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var magnitude = Cartesian2.magnitude(cartesian);\n\n  result.x = cartesian.x / magnitude;\n  result.y = cartesian.y / magnitude;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (isNaN(result.x) || isNaN(result.y)) {\n    throw new DeveloperError(\"normalized result is not a number\");\n  }\n  //>>includeEnd('debug');\n\n  return result;\n};\n\n/**\n * Computes the dot (scalar) product of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @returns {Number} The dot product.\n */\nCartesian2.dot = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return left.x * right.x + left.y * right.y;\n};\n\n/**\n * Computes the magnitude of the cross product that would result from implicitly setting the Z coordinate of the input vectors to 0\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @returns {Number} The cross product.\n */\nCartesian2.cross = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return left.x * right.y - left.y * right.x;\n};\n\n/**\n * Computes the componentwise product of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.multiplyComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x * right.x;\n  result.y = left.y * right.y;\n  return result;\n};\n\n/**\n * Computes the componentwise quotient of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.divideComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x / right.x;\n  result.y = left.y / right.y;\n  return result;\n};\n\n/**\n * Computes the componentwise sum of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  return result;\n};\n\n/**\n * Computes the componentwise difference of two Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  return result;\n};\n\n/**\n * Multiplies the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian2} cartesian The Cartesian to be scaled.\n * @param {Number} scalar The scalar to multiply with.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.multiplyByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x * scalar;\n  result.y = cartesian.y * scalar;\n  return result;\n};\n\n/**\n * Divides the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian2} cartesian The Cartesian to be divided.\n * @param {Number} scalar The scalar to divide by.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.divideByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x / scalar;\n  result.y = cartesian.y / scalar;\n  return result;\n};\n\n/**\n * Negates the provided Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian to be negated.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.negate = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = -cartesian.x;\n  result.y = -cartesian.y;\n  return result;\n};\n\n/**\n * Computes the absolute value of the provided Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian whose absolute value is to be computed.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.abs = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.abs(cartesian.x);\n  result.y = Math.abs(cartesian.y);\n  return result;\n};\n\nvar lerpScratch = new Cartesian2();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided cartesians.\n *\n * @param {Cartesian2} start The value corresponding to t at 0.0.\n * @param {Cartesian2} end The value corresponding to t at 1.0.\n * @param {Number} t The point along t at which to interpolate.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter.\n */\nCartesian2.lerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  Cartesian2.multiplyByScalar(end, t, lerpScratch);\n  result = Cartesian2.multiplyByScalar(start, 1.0 - t, result);\n  return Cartesian2.add(lerpScratch, result, result);\n};\n\nvar angleBetweenScratch = new Cartesian2();\nvar angleBetweenScratch2 = new Cartesian2();\n/**\n * Returns the angle, in radians, between the provided Cartesians.\n *\n * @param {Cartesian2} left The first Cartesian.\n * @param {Cartesian2} right The second Cartesian.\n * @returns {Number} The angle between the Cartesians.\n */\nCartesian2.angleBetween = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian2.normalize(left, angleBetweenScratch);\n  Cartesian2.normalize(right, angleBetweenScratch2);\n  return CesiumMath.acosClamped(\n    Cartesian2.dot(angleBetweenScratch, angleBetweenScratch2)\n  );\n};\n\nvar mostOrthogonalAxisScratch = new Cartesian2();\n/**\n * Returns the axis that is most orthogonal to the provided Cartesian.\n *\n * @param {Cartesian2} cartesian The Cartesian on which to find the most orthogonal axis.\n * @param {Cartesian2} result The object onto which to store the result.\n * @returns {Cartesian2} The most orthogonal axis.\n */\nCartesian2.mostOrthogonalAxis = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var f = Cartesian2.normalize(cartesian, mostOrthogonalAxisScratch);\n  Cartesian2.abs(f, f);\n\n  if (f.x <= f.y) {\n    result = Cartesian2.clone(Cartesian2.UNIT_X, result);\n  } else {\n    result = Cartesian2.clone(Cartesian2.UNIT_Y, result);\n  }\n\n  return result;\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian2} [left] The first Cartesian.\n * @param {Cartesian2} [right] The second Cartesian.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartesian2.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.x === right.x &&\n      left.y === right.y)\n  );\n};\n\n/**\n * @private\n */\nCartesian2.equalsArray = function (cartesian, array, offset) {\n  return cartesian.x === array[offset] && cartesian.y === array[offset + 1];\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian2} [left] The first Cartesian.\n * @param {Cartesian2} [right] The second Cartesian.\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian2.equalsEpsilon = function (\n  left,\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      CesiumMath.equalsEpsilon(\n        left.x,\n        right.x,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.y,\n        right.y,\n        relativeEpsilon,\n        absoluteEpsilon\n      ))\n  );\n};\n\n/**\n * An immutable Cartesian2 instance initialized to (0.0, 0.0).\n *\n * @type {Cartesian2}\n * @constant\n */\nCartesian2.ZERO = Object.freeze(new Cartesian2(0.0, 0.0));\n\n/**\n * An immutable Cartesian2 instance initialized to (1.0, 0.0).\n *\n * @type {Cartesian2}\n * @constant\n */\nCartesian2.UNIT_X = Object.freeze(new Cartesian2(1.0, 0.0));\n\n/**\n * An immutable Cartesian2 instance initialized to (0.0, 1.0).\n *\n * @type {Cartesian2}\n * @constant\n */\nCartesian2.UNIT_Y = Object.freeze(new Cartesian2(0.0, 1.0));\n\n/**\n * Duplicates this Cartesian2 instance.\n *\n * @param {Cartesian2} [result] The object onto which to store the result.\n * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.\n */\nCartesian2.prototype.clone = function (result) {\n  return Cartesian2.clone(this, result);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian2} [right] The right hand side Cartesian.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nCartesian2.prototype.equals = function (right) {\n  return Cartesian2.equals(this, right);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian2} [right] The right hand side Cartesian.\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian2.prototype.equalsEpsilon = function (\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return Cartesian2.equalsEpsilon(\n    this,\n    right,\n    relativeEpsilon,\n    absoluteEpsilon\n  );\n};\n\n/**\n * Creates a string representing this Cartesian in the format '(x, y)'.\n *\n * @returns {String} A string representing the provided Cartesian in the format '(x, y)'.\n */\nCartesian2.prototype.toString = function () {\n  return \"(\" + this.x + \", \" + this.y + \")\";\n};\nexport default Cartesian2;\n"]},"metadata":{},"sourceType":"module"}