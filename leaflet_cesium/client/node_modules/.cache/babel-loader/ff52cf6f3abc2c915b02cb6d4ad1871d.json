{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport ForEach from \"../ThirdParty/GltfPipeline/ForEach.js\";\nimport when from \"../ThirdParty/when.js\";\nimport Model from \"./Model.js\";\nimport ModelInstance from \"./ModelInstance.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\nvar LoadState = {\n  NEEDS_LOAD: 0,\n  LOADING: 1,\n  LOADED: 2,\n  FAILED: 3\n};\n/**\n * A 3D model instance collection. All instances reference the same underlying model, but have unique\n * per-instance properties like model matrix, pick id, etc.\n *\n * Instances are rendered relative-to-center and for best results instances should be positioned close to one another.\n * Otherwise there may be precision issues if, for example, instances are placed on opposite sides of the globe.\n *\n * @alias ModelInstanceCollection\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Object[]} [options.instances] An array of instances, where each instance contains a modelMatrix and optional batchId when options.batchTable is defined.\n * @param {Cesium3DTileBatchTable} [options.batchTable] The batch table of the instanced 3D Tile.\n * @param {Resource|String} [options.url] The url to the .gltf file.\n * @param {Object} [options.requestType] The request type, used for request prioritization\n * @param {Object|ArrayBuffer|Uint8Array} [options.gltf] A glTF JSON object, or a binary glTF buffer.\n * @param {Resource|String} [options.basePath=''] The base path that paths in the glTF JSON are relative to.\n * @param {Boolean} [options.dynamic=false] Hint if instance model matrices will be updated frequently.\n * @param {Boolean} [options.show=true] Determines if the collection will be shown.\n * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each instance is pickable with {@link Scene#pick}.\n * @param {Boolean} [options.asynchronous=true] Determines if model WebGL resource creation will be spread out over several frames or block until completion once all glTF files are loaded.\n * @param {Boolean} [options.incrementallyLoadTextures=true] Determine if textures may continue to stream in after the model is loaded.\n * @param {ShadowMode} [options.shadows=ShadowMode.ENABLED] Determines whether the collection casts or receives shadows from light sources.\n * @param {Cartesian2} [options.imageBasedLightingFactor=new Cartesian2(1.0, 1.0)] Scales the diffuse and specular image-based lighting from the earth, sky, atmosphere and star skybox.\n * @param {Cartesian3} [options.lightColor] The light color when shading models. When <code>undefined</code> the scene's light color is used instead.\n * @param {Number} [options.luminanceAtZenith=0.2] The sun's luminance at the zenith in kilo candela per meter squared to use for this model's procedural environment map.\n * @param {Cartesian3[]} [options.sphericalHarmonicCoefficients] The third order spherical harmonic coefficients used for the diffuse color of image-based lighting.\n * @param {String} [options.specularEnvironmentMaps] A URL to a KTX file that contains a cube map of the specular lighting and the convoluted specular mipmaps.\n * @param {Boolean} [options.backFaceCulling=true] Whether to cull back-facing geometry. When true, back face culling is determined by the glTF material's doubleSided property; when false, back face culling is disabled.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Draws the bounding sphere for the collection.\n * @param {Boolean} [options.debugWireframe=false] For debugging only. Draws the instances in wireframe.\n *\n * @exception {DeveloperError} Must specify either <options.gltf> or <options.url>, but not both.\n * @exception {DeveloperError} Shader program cannot be optimized for instancing. Parameters cannot have any of the following semantics: MODEL, MODELINVERSE, MODELVIEWINVERSE, MODELVIEWPROJECTIONINVERSE, MODELINVERSETRANSPOSE.\n *\n * @private\n */\n\nfunction ModelInstanceCollection(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT); //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(options.gltf) && !defined(options.url)) {\n    throw new DeveloperError(\"Either options.gltf or options.url is required.\");\n  }\n\n  if (defined(options.gltf) && defined(options.url)) {\n    throw new DeveloperError(\"Cannot pass in both options.gltf and options.url.\");\n  } //>>includeEnd('debug');\n\n\n  this.show = defaultValue(options.show, true);\n  this._instancingSupported = false;\n  this._dynamic = defaultValue(options.dynamic, false);\n  this._allowPicking = defaultValue(options.allowPicking, true);\n  this._ready = false;\n  this._readyPromise = when.defer();\n  this._state = LoadState.NEEDS_LOAD;\n  this._dirty = false; // Undocumented options\n\n  this._cull = defaultValue(options.cull, true);\n  this._opaquePass = defaultValue(options.opaquePass, Pass.OPAQUE);\n  this._instances = createInstances(this, options.instances); // When the model instance collection is backed by an i3dm tile,\n  // use its batch table resources to modify the shaders, attributes, and uniform maps.\n\n  this._batchTable = options.batchTable;\n  this._model = undefined;\n  this._vertexBufferTypedArray = undefined; // Hold onto the vertex buffer contents when dynamic is true\n\n  this._vertexBuffer = undefined;\n  this._batchIdBuffer = undefined;\n  this._instancedUniformsByProgram = undefined;\n  this._drawCommands = [];\n  this._modelCommands = undefined;\n  this._renderStates = undefined;\n  this._disableCullingRenderStates = undefined;\n  this._boundingSphere = createBoundingSphere(this);\n  this._center = Cartesian3.clone(this._boundingSphere.center);\n  this._rtcTransform = new Matrix4();\n  this._rtcModelView = new Matrix4(); // Holds onto uniform\n\n  this._mode = undefined;\n  this.modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n  this._modelMatrix = Matrix4.clone(this.modelMatrix); // Passed on to Model\n\n  this._url = Resource.createIfNeeded(options.url);\n  this._requestType = options.requestType;\n  this._gltf = options.gltf;\n  this._basePath = Resource.createIfNeeded(options.basePath);\n  this._asynchronous = options.asynchronous;\n  this._incrementallyLoadTextures = options.incrementallyLoadTextures;\n  this._upAxis = options.upAxis; // Undocumented option\n\n  this._forwardAxis = options.forwardAxis; // Undocumented option\n\n  this.shadows = defaultValue(options.shadows, ShadowMode.ENABLED);\n  this._shadows = this.shadows;\n  this._pickIdLoaded = options.pickIdLoaded;\n  this.debugShowBoundingVolume = defaultValue(options.debugShowBoundingVolume, false);\n  this._debugShowBoundingVolume = false;\n  this.debugWireframe = defaultValue(options.debugWireframe, false);\n  this._debugWireframe = false;\n  this._imageBasedLightingFactor = new Cartesian2(1.0, 1.0);\n  Cartesian2.clone(options.imageBasedLightingFactor, this._imageBasedLightingFactor);\n  this.lightColor = options.lightColor;\n  this.luminanceAtZenith = options.luminanceAtZenith;\n  this.sphericalHarmonicCoefficients = options.sphericalHarmonicCoefficients;\n  this.specularEnvironmentMaps = options.specularEnvironmentMaps;\n  this.backFaceCulling = defaultValue(options.backFaceCulling, true);\n  this._backFaceCulling = this.backFaceCulling;\n}\n\nObject.defineProperties(ModelInstanceCollection.prototype, {\n  allowPicking: {\n    get: function () {\n      return this._allowPicking;\n    }\n  },\n  length: {\n    get: function () {\n      return this._instances.length;\n    }\n  },\n  activeAnimations: {\n    get: function () {\n      return this._model.activeAnimations;\n    }\n  },\n  ready: {\n    get: function () {\n      return this._ready;\n    }\n  },\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    }\n  },\n  imageBasedLightingFactor: {\n    get: function () {\n      return this._imageBasedLightingFactor;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.object(\"imageBasedLightingFactor\", value);\n      Check.typeOf.number.greaterThanOrEquals(\"imageBasedLightingFactor.x\", value.x, 0.0);\n      Check.typeOf.number.lessThanOrEquals(\"imageBasedLightingFactor.x\", value.x, 1.0);\n      Check.typeOf.number.greaterThanOrEquals(\"imageBasedLightingFactor.y\", value.y, 0.0);\n      Check.typeOf.number.lessThanOrEquals(\"imageBasedLightingFactor.y\", value.y, 1.0); //>>includeEnd('debug');\n\n      Cartesian2.clone(value, this._imageBasedLightingFactor);\n    }\n  }\n});\n\nfunction createInstances(collection, instancesOptions) {\n  instancesOptions = defaultValue(instancesOptions, []);\n  var length = instancesOptions.length;\n  var instances = new Array(length);\n\n  for (var i = 0; i < length; ++i) {\n    var instanceOptions = instancesOptions[i];\n    var modelMatrix = instanceOptions.modelMatrix;\n    var instanceId = defaultValue(instanceOptions.batchId, i);\n    instances[i] = new ModelInstance(collection, modelMatrix, instanceId);\n  }\n\n  return instances;\n}\n\nfunction createBoundingSphere(collection) {\n  var instancesLength = collection.length;\n  var points = new Array(instancesLength);\n\n  for (var i = 0; i < instancesLength; ++i) {\n    points[i] = Matrix4.getTranslation(collection._instances[i]._modelMatrix, new Cartesian3());\n  }\n\n  return BoundingSphere.fromPoints(points);\n}\n\nvar scratchCartesian = new Cartesian3();\nvar scratchMatrix = new Matrix4();\n\nModelInstanceCollection.prototype.expandBoundingSphere = function (instanceModelMatrix) {\n  var translation = Matrix4.getTranslation(instanceModelMatrix, scratchCartesian);\n  BoundingSphere.expand(this._boundingSphere, translation, this._boundingSphere);\n};\n\nfunction getCheckUniformSemanticFunction(modelSemantics, supportedSemantics, programId, uniformMap) {\n  return function (uniform, uniformName) {\n    var semantic = uniform.semantic;\n\n    if (defined(semantic) && modelSemantics.indexOf(semantic) > -1) {\n      if (supportedSemantics.indexOf(semantic) > -1) {\n        uniformMap[uniformName] = semantic;\n      } else {\n        throw new RuntimeError(\"Shader program cannot be optimized for instancing. \" + 'Uniform \"' + uniformName + '\" in program \"' + programId + '\" uses unsupported semantic \"' + semantic + '\"');\n      }\n    }\n  };\n}\n\nfunction getInstancedUniforms(collection, programId) {\n  if (defined(collection._instancedUniformsByProgram)) {\n    return collection._instancedUniformsByProgram[programId];\n  }\n\n  var instancedUniformsByProgram = {};\n  collection._instancedUniformsByProgram = instancedUniformsByProgram; // When using CESIUM_RTC_MODELVIEW the CESIUM_RTC center is ignored. Instances are always rendered relative-to-center.\n\n  var modelSemantics = [\"MODEL\", \"MODELVIEW\", \"CESIUM_RTC_MODELVIEW\", \"MODELVIEWPROJECTION\", \"MODELINVERSE\", \"MODELVIEWINVERSE\", \"MODELVIEWPROJECTIONINVERSE\", \"MODELINVERSETRANSPOSE\", \"MODELVIEWINVERSETRANSPOSE\"];\n  var supportedSemantics = [\"MODELVIEW\", \"CESIUM_RTC_MODELVIEW\", \"MODELVIEWPROJECTION\", \"MODELVIEWINVERSETRANSPOSE\"];\n  var techniques = collection._model._sourceTechniques;\n\n  for (var techniqueId in techniques) {\n    if (techniques.hasOwnProperty(techniqueId)) {\n      var technique = techniques[techniqueId];\n      var program = technique.program; // Different techniques may share the same program, skip if already processed.\n      // This assumes techniques that share a program do not declare different semantics for the same uniforms.\n\n      if (!defined(instancedUniformsByProgram[program])) {\n        var uniformMap = {};\n        instancedUniformsByProgram[program] = uniformMap;\n        ForEach.techniqueUniform(technique, getCheckUniformSemanticFunction(modelSemantics, supportedSemantics, programId, uniformMap));\n      }\n    }\n  }\n\n  return instancedUniformsByProgram[programId];\n}\n\nfunction getVertexShaderCallback(collection) {\n  return function (vs, programId) {\n    var instancedUniforms = getInstancedUniforms(collection, programId);\n    var usesBatchTable = defined(collection._batchTable);\n    var renamedSource = ShaderSource.replaceMain(vs, \"czm_instancing_main\");\n    var globalVarsHeader = \"\";\n    var globalVarsMain = \"\";\n\n    for (var uniform in instancedUniforms) {\n      if (instancedUniforms.hasOwnProperty(uniform)) {\n        var semantic = instancedUniforms[uniform];\n        var varName;\n\n        if (semantic === \"MODELVIEW\" || semantic === \"CESIUM_RTC_MODELVIEW\") {\n          varName = \"czm_instanced_modelView\";\n        } else if (semantic === \"MODELVIEWPROJECTION\") {\n          varName = \"czm_instanced_modelViewProjection\";\n          globalVarsHeader += \"mat4 czm_instanced_modelViewProjection;\\n\";\n          globalVarsMain += \"czm_instanced_modelViewProjection = czm_projection * czm_instanced_modelView;\\n\";\n        } else if (semantic === \"MODELVIEWINVERSETRANSPOSE\") {\n          varName = \"czm_instanced_modelViewInverseTranspose\";\n          globalVarsHeader += \"mat3 czm_instanced_modelViewInverseTranspose;\\n\";\n          globalVarsMain += \"czm_instanced_modelViewInverseTranspose = mat3(czm_instanced_modelView);\\n\";\n        } // Remove the uniform declaration\n\n\n        var regex = new RegExp(\"uniform.*\" + uniform + \".*\");\n        renamedSource = renamedSource.replace(regex, \"\"); // Replace all occurrences of the uniform with the global variable\n\n        regex = new RegExp(uniform + \"\\\\b\", \"g\");\n        renamedSource = renamedSource.replace(regex, varName);\n      }\n    } // czm_instanced_model is the model matrix of the instance relative to center\n    // czm_instanced_modifiedModelView is the transform from the center to view\n    // czm_instanced_nodeTransform is the local offset of the node within the model\n\n\n    var uniforms = \"uniform mat4 czm_instanced_modifiedModelView;\\n\" + \"uniform mat4 czm_instanced_nodeTransform;\\n\";\n    var batchIdAttribute;\n    var pickAttribute;\n    var pickVarying;\n\n    if (usesBatchTable) {\n      batchIdAttribute = \"attribute float a_batchId;\\n\";\n      pickAttribute = \"\";\n      pickVarying = \"\";\n    } else {\n      batchIdAttribute = \"\";\n      pickAttribute = \"attribute vec4 pickColor;\\n\" + \"varying vec4 v_pickColor;\\n\";\n      pickVarying = \"    v_pickColor = pickColor;\\n\";\n    }\n\n    var instancedSource = uniforms + globalVarsHeader + \"mat4 czm_instanced_modelView;\\n\" + \"attribute vec4 czm_modelMatrixRow0;\\n\" + \"attribute vec4 czm_modelMatrixRow1;\\n\" + \"attribute vec4 czm_modelMatrixRow2;\\n\" + batchIdAttribute + pickAttribute + renamedSource + \"void main()\\n\" + \"{\\n\" + \"    mat4 czm_instanced_model = mat4(czm_modelMatrixRow0.x, czm_modelMatrixRow1.x, czm_modelMatrixRow2.x, 0.0, czm_modelMatrixRow0.y, czm_modelMatrixRow1.y, czm_modelMatrixRow2.y, 0.0, czm_modelMatrixRow0.z, czm_modelMatrixRow1.z, czm_modelMatrixRow2.z, 0.0, czm_modelMatrixRow0.w, czm_modelMatrixRow1.w, czm_modelMatrixRow2.w, 1.0);\\n\" + \"    czm_instanced_modelView = czm_instanced_modifiedModelView * czm_instanced_model * czm_instanced_nodeTransform;\\n\" + globalVarsMain + \"    czm_instancing_main();\\n\" + pickVarying + \"}\\n\";\n\n    if (usesBatchTable) {\n      var gltf = collection._model.gltf;\n      var diffuseAttributeOrUniformName = ModelUtility.getDiffuseAttributeOrUniform(gltf, programId);\n      instancedSource = collection._batchTable.getVertexShaderCallback(true, \"a_batchId\", diffuseAttributeOrUniformName)(instancedSource);\n    }\n\n    return instancedSource;\n  };\n}\n\nfunction getFragmentShaderCallback(collection) {\n  return function (fs, programId) {\n    var batchTable = collection._batchTable;\n\n    if (defined(batchTable)) {\n      var gltf = collection._model.gltf;\n      var diffuseAttributeOrUniformName = ModelUtility.getDiffuseAttributeOrUniform(gltf, programId);\n      fs = batchTable.getFragmentShaderCallback(true, diffuseAttributeOrUniformName)(fs);\n    } else {\n      fs = \"varying vec4 v_pickColor;\\n\" + fs;\n    }\n\n    return fs;\n  };\n}\n\nfunction createModifiedModelView(collection, context) {\n  return function () {\n    return Matrix4.multiply(context.uniformState.view, collection._rtcTransform, collection._rtcModelView);\n  };\n}\n\nfunction createNodeTransformFunction(node) {\n  return function () {\n    return node.computedMatrix;\n  };\n}\n\nfunction getUniformMapCallback(collection, context) {\n  return function (uniformMap, programId, node) {\n    uniformMap = clone(uniformMap);\n    uniformMap.czm_instanced_modifiedModelView = createModifiedModelView(collection, context);\n    uniformMap.czm_instanced_nodeTransform = createNodeTransformFunction(node); // Remove instanced uniforms from the uniform map\n\n    var instancedUniforms = getInstancedUniforms(collection, programId);\n\n    for (var uniform in instancedUniforms) {\n      if (instancedUniforms.hasOwnProperty(uniform)) {\n        delete uniformMap[uniform];\n      }\n    }\n\n    if (defined(collection._batchTable)) {\n      uniformMap = collection._batchTable.getUniformMapCallback()(uniformMap);\n    }\n\n    return uniformMap;\n  };\n}\n\nfunction getVertexShaderNonInstancedCallback(collection) {\n  return function (vs, programId) {\n    if (defined(collection._batchTable)) {\n      var gltf = collection._model.gltf;\n      var diffuseAttributeOrUniformName = ModelUtility.getDiffuseAttributeOrUniform(gltf, programId);\n      vs = collection._batchTable.getVertexShaderCallback(true, \"a_batchId\", diffuseAttributeOrUniformName)(vs); // Treat a_batchId as a uniform rather than a vertex attribute\n\n      vs = \"uniform float a_batchId\\n;\" + vs;\n    }\n\n    return vs;\n  };\n}\n\nfunction getFragmentShaderNonInstancedCallback(collection) {\n  return function (fs, programId) {\n    var batchTable = collection._batchTable;\n\n    if (defined(batchTable)) {\n      var gltf = collection._model.gltf;\n      var diffuseAttributeOrUniformName = ModelUtility.getDiffuseAttributeOrUniform(gltf, programId);\n      fs = batchTable.getFragmentShaderCallback(true, diffuseAttributeOrUniformName)(fs);\n    } else {\n      fs = \"uniform vec4 czm_pickColor;\\n\" + fs;\n    }\n\n    return fs;\n  };\n}\n\nfunction getUniformMapNonInstancedCallback(collection) {\n  return function (uniformMap) {\n    if (defined(collection._batchTable)) {\n      uniformMap = collection._batchTable.getUniformMapCallback()(uniformMap);\n    }\n\n    return uniformMap;\n  };\n}\n\nfunction getVertexBufferTypedArray(collection) {\n  var instances = collection._instances;\n  var instancesLength = collection.length;\n  var collectionCenter = collection._center;\n  var vertexSizeInFloats = 12;\n  var bufferData = collection._vertexBufferTypedArray;\n\n  if (!defined(bufferData)) {\n    bufferData = new Float32Array(instancesLength * vertexSizeInFloats);\n  }\n\n  if (collection._dynamic) {\n    // Hold onto the buffer data so we don't have to allocate new memory every frame.\n    collection._vertexBufferTypedArray = bufferData;\n  }\n\n  for (var i = 0; i < instancesLength; ++i) {\n    var modelMatrix = instances[i]._modelMatrix; // Instance matrix is relative to center\n\n    var instanceMatrix = Matrix4.clone(modelMatrix, scratchMatrix);\n    instanceMatrix[12] -= collectionCenter.x;\n    instanceMatrix[13] -= collectionCenter.y;\n    instanceMatrix[14] -= collectionCenter.z;\n    var offset = i * vertexSizeInFloats; // First three rows of the model matrix\n\n    bufferData[offset + 0] = instanceMatrix[0];\n    bufferData[offset + 1] = instanceMatrix[4];\n    bufferData[offset + 2] = instanceMatrix[8];\n    bufferData[offset + 3] = instanceMatrix[12];\n    bufferData[offset + 4] = instanceMatrix[1];\n    bufferData[offset + 5] = instanceMatrix[5];\n    bufferData[offset + 6] = instanceMatrix[9];\n    bufferData[offset + 7] = instanceMatrix[13];\n    bufferData[offset + 8] = instanceMatrix[2];\n    bufferData[offset + 9] = instanceMatrix[6];\n    bufferData[offset + 10] = instanceMatrix[10];\n    bufferData[offset + 11] = instanceMatrix[14];\n  }\n\n  return bufferData;\n}\n\nfunction createVertexBuffer(collection, context) {\n  var i;\n  var instances = collection._instances;\n  var instancesLength = collection.length;\n  var dynamic = collection._dynamic;\n  var usesBatchTable = defined(collection._batchTable);\n\n  if (usesBatchTable) {\n    var batchIdBufferData = new Uint16Array(instancesLength);\n\n    for (i = 0; i < instancesLength; ++i) {\n      batchIdBufferData[i] = instances[i]._instanceId;\n    }\n\n    collection._batchIdBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: batchIdBufferData,\n      usage: BufferUsage.STATIC_DRAW\n    });\n  }\n\n  if (!usesBatchTable) {\n    var pickIdBuffer = new Uint8Array(instancesLength * 4);\n\n    for (i = 0; i < instancesLength; ++i) {\n      var pickId = collection._pickIds[i];\n      var pickColor = pickId.color;\n      var offset = i * 4;\n      pickIdBuffer[offset] = Color.floatToByte(pickColor.red);\n      pickIdBuffer[offset + 1] = Color.floatToByte(pickColor.green);\n      pickIdBuffer[offset + 2] = Color.floatToByte(pickColor.blue);\n      pickIdBuffer[offset + 3] = Color.floatToByte(pickColor.alpha);\n    }\n\n    collection._pickIdBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: pickIdBuffer,\n      usage: BufferUsage.STATIC_DRAW\n    });\n  }\n\n  var vertexBufferTypedArray = getVertexBufferTypedArray(collection);\n  collection._vertexBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: vertexBufferTypedArray,\n    usage: dynamic ? BufferUsage.STREAM_DRAW : BufferUsage.STATIC_DRAW\n  });\n}\n\nfunction updateVertexBuffer(collection) {\n  var vertexBufferTypedArray = getVertexBufferTypedArray(collection);\n\n  collection._vertexBuffer.copyFromArrayView(vertexBufferTypedArray);\n}\n\nfunction createPickIds(collection, context) {\n  // PERFORMANCE_IDEA: we could skip the pick buffer completely by allocating\n  // a continuous range of pickIds and then converting the base pickId + batchId\n  // to RGBA in the shader.  The only consider is precision issues, which might\n  // not be an issue in WebGL 2.\n  var instances = collection._instances;\n  var instancesLength = instances.length;\n  var pickIds = new Array(instancesLength);\n\n  for (var i = 0; i < instancesLength; ++i) {\n    pickIds[i] = context.createPickId(instances[i]);\n  }\n\n  return pickIds;\n}\n\nfunction createModel(collection, context) {\n  var instancingSupported = collection._instancingSupported;\n  var usesBatchTable = defined(collection._batchTable);\n  var allowPicking = collection._allowPicking;\n  var modelOptions = {\n    url: collection._url,\n    requestType: collection._requestType,\n    gltf: collection._gltf,\n    basePath: collection._basePath,\n    shadows: collection._shadows,\n    cacheKey: undefined,\n    asynchronous: collection._asynchronous,\n    allowPicking: allowPicking,\n    incrementallyLoadTextures: collection._incrementallyLoadTextures,\n    upAxis: collection._upAxis,\n    forwardAxis: collection._forwardAxis,\n    precreatedAttributes: undefined,\n    vertexShaderLoaded: undefined,\n    fragmentShaderLoaded: undefined,\n    uniformMapLoaded: undefined,\n    pickIdLoaded: collection._pickIdLoaded,\n    ignoreCommands: true,\n    opaquePass: collection._opaquePass,\n    imageBasedLightingFactor: collection.imageBasedLightingFactor,\n    lightColor: collection.lightColor,\n    luminanceAtZenith: collection.luminanceAtZenith,\n    sphericalHarmonicCoefficients: collection.sphericalHarmonicCoefficients,\n    specularEnvironmentMaps: collection.specularEnvironmentMaps\n  };\n\n  if (!usesBatchTable) {\n    collection._pickIds = createPickIds(collection, context);\n  }\n\n  if (instancingSupported) {\n    createVertexBuffer(collection, context);\n    var vertexSizeInFloats = 12;\n    var componentSizeInBytes = ComponentDatatype.getSizeInBytes(ComponentDatatype.FLOAT);\n    var instancedAttributes = {\n      czm_modelMatrixRow0: {\n        index: 0,\n        // updated in Model\n        vertexBuffer: collection._vertexBuffer,\n        componentsPerAttribute: 4,\n        componentDatatype: ComponentDatatype.FLOAT,\n        normalize: false,\n        offsetInBytes: 0,\n        strideInBytes: componentSizeInBytes * vertexSizeInFloats,\n        instanceDivisor: 1\n      },\n      czm_modelMatrixRow1: {\n        index: 0,\n        // updated in Model\n        vertexBuffer: collection._vertexBuffer,\n        componentsPerAttribute: 4,\n        componentDatatype: ComponentDatatype.FLOAT,\n        normalize: false,\n        offsetInBytes: componentSizeInBytes * 4,\n        strideInBytes: componentSizeInBytes * vertexSizeInFloats,\n        instanceDivisor: 1\n      },\n      czm_modelMatrixRow2: {\n        index: 0,\n        // updated in Model\n        vertexBuffer: collection._vertexBuffer,\n        componentsPerAttribute: 4,\n        componentDatatype: ComponentDatatype.FLOAT,\n        normalize: false,\n        offsetInBytes: componentSizeInBytes * 8,\n        strideInBytes: componentSizeInBytes * vertexSizeInFloats,\n        instanceDivisor: 1\n      }\n    }; // When using a batch table, add a batch id attribute\n\n    if (usesBatchTable) {\n      instancedAttributes.a_batchId = {\n        index: 0,\n        // updated in Model\n        vertexBuffer: collection._batchIdBuffer,\n        componentsPerAttribute: 1,\n        componentDatatype: ComponentDatatype.UNSIGNED_SHORT,\n        normalize: false,\n        offsetInBytes: 0,\n        strideInBytes: 0,\n        instanceDivisor: 1\n      };\n    }\n\n    if (!usesBatchTable) {\n      instancedAttributes.pickColor = {\n        index: 0,\n        // updated in Model\n        vertexBuffer: collection._pickIdBuffer,\n        componentsPerAttribute: 4,\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        normalize: true,\n        offsetInBytes: 0,\n        strideInBytes: 0,\n        instanceDivisor: 1\n      };\n    }\n\n    modelOptions.precreatedAttributes = instancedAttributes;\n    modelOptions.vertexShaderLoaded = getVertexShaderCallback(collection);\n    modelOptions.fragmentShaderLoaded = getFragmentShaderCallback(collection);\n    modelOptions.uniformMapLoaded = getUniformMapCallback(collection, context);\n\n    if (defined(collection._url)) {\n      modelOptions.cacheKey = collection._url.getUrlComponent() + \"#instanced\";\n    }\n  } else {\n    modelOptions.vertexShaderLoaded = getVertexShaderNonInstancedCallback(collection);\n    modelOptions.fragmentShaderLoaded = getFragmentShaderNonInstancedCallback(collection);\n    modelOptions.uniformMapLoaded = getUniformMapNonInstancedCallback(collection, context);\n  }\n\n  if (defined(collection._url)) {\n    collection._model = Model.fromGltf(modelOptions);\n  } else {\n    collection._model = new Model(modelOptions);\n  }\n}\n\nfunction updateWireframe(collection, force) {\n  if (collection._debugWireframe !== collection.debugWireframe || force) {\n    collection._debugWireframe = collection.debugWireframe; // This assumes the original primitive was TRIANGLES and that the triangles\n    // are connected for the wireframe to look perfect.\n\n    var primitiveType = collection.debugWireframe ? PrimitiveType.LINES : PrimitiveType.TRIANGLES;\n    var commands = collection._drawCommands;\n    var length = commands.length;\n\n    for (var i = 0; i < length; ++i) {\n      commands[i].primitiveType = primitiveType;\n    }\n  }\n}\n\nfunction getDisableCullingRenderState(renderState) {\n  var rs = clone(renderState, true);\n  rs.cull.enabled = false;\n  return RenderState.fromCache(rs);\n}\n\nfunction updateBackFaceCulling(collection, force) {\n  if (collection._backFaceCulling !== collection.backFaceCulling || force) {\n    collection._backFaceCulling = collection.backFaceCulling;\n    var commands = collection._drawCommands;\n    var length = commands.length;\n    var i;\n\n    if (!defined(collection._disableCullingRenderStates)) {\n      collection._disableCullingRenderStates = new Array(length);\n      collection._renderStates = new Array(length);\n\n      for (i = 0; i < length; ++i) {\n        var renderState = commands[i].renderState;\n        var derivedRenderState = getDisableCullingRenderState(renderState);\n        collection._disableCullingRenderStates[i] = derivedRenderState;\n        collection._renderStates[i] = renderState;\n      }\n    }\n\n    for (i = 0; i < length; ++i) {\n      commands[i].renderState = collection._backFaceCulling ? collection._renderStates[i] : collection._disableCullingRenderStates[i];\n    }\n  }\n}\n\nfunction updateShowBoundingVolume(collection, force) {\n  if (collection.debugShowBoundingVolume !== collection._debugShowBoundingVolume || force) {\n    collection._debugShowBoundingVolume = collection.debugShowBoundingVolume;\n    var commands = collection._drawCommands;\n    var length = commands.length;\n\n    for (var i = 0; i < length; ++i) {\n      commands[i].debugShowBoundingVolume = collection.debugShowBoundingVolume;\n    }\n  }\n}\n\nfunction createCommands(collection, drawCommands) {\n  var commandsLength = drawCommands.length;\n  var instancesLength = collection.length;\n  var boundingSphere = collection._boundingSphere;\n  var cull = collection._cull;\n\n  for (var i = 0; i < commandsLength; ++i) {\n    var drawCommand = DrawCommand.shallowClone(drawCommands[i]);\n    drawCommand.instanceCount = instancesLength;\n    drawCommand.boundingVolume = boundingSphere;\n    drawCommand.cull = cull;\n\n    if (defined(collection._batchTable)) {\n      drawCommand.pickId = collection._batchTable.getPickId();\n    } else {\n      drawCommand.pickId = \"v_pickColor\";\n    }\n\n    collection._drawCommands.push(drawCommand);\n  }\n}\n\nfunction createBatchIdFunction(batchId) {\n  return function () {\n    return batchId;\n  };\n}\n\nfunction createPickColorFunction(color) {\n  return function () {\n    return color;\n  };\n}\n\nfunction createCommandsNonInstanced(collection, drawCommands) {\n  // When instancing is disabled, create commands for every instance.\n  var instances = collection._instances;\n  var commandsLength = drawCommands.length;\n  var instancesLength = collection.length;\n  var batchTable = collection._batchTable;\n  var usesBatchTable = defined(batchTable);\n  var cull = collection._cull;\n\n  for (var i = 0; i < commandsLength; ++i) {\n    for (var j = 0; j < instancesLength; ++j) {\n      var drawCommand = DrawCommand.shallowClone(drawCommands[i]);\n      drawCommand.modelMatrix = new Matrix4(); // Updated in updateCommandsNonInstanced\n\n      drawCommand.boundingVolume = new BoundingSphere(); // Updated in updateCommandsNonInstanced\n\n      drawCommand.cull = cull;\n      drawCommand.uniformMap = clone(drawCommand.uniformMap);\n\n      if (usesBatchTable) {\n        drawCommand.uniformMap.a_batchId = createBatchIdFunction(instances[j]._instanceId);\n      } else {\n        var pickId = collection._pickIds[j];\n        drawCommand.uniformMap.czm_pickColor = createPickColorFunction(pickId.color);\n      }\n\n      collection._drawCommands.push(drawCommand);\n    }\n  }\n}\n\nfunction updateCommandsNonInstanced(collection) {\n  var modelCommands = collection._modelCommands;\n  var commandsLength = modelCommands.length;\n  var instancesLength = collection.length;\n  var collectionTransform = collection._rtcTransform;\n  var collectionCenter = collection._center;\n\n  for (var i = 0; i < commandsLength; ++i) {\n    var modelCommand = modelCommands[i];\n\n    for (var j = 0; j < instancesLength; ++j) {\n      var commandIndex = i * instancesLength + j;\n      var drawCommand = collection._drawCommands[commandIndex];\n      var instanceMatrix = Matrix4.clone(collection._instances[j]._modelMatrix, scratchMatrix);\n      instanceMatrix[12] -= collectionCenter.x;\n      instanceMatrix[13] -= collectionCenter.y;\n      instanceMatrix[14] -= collectionCenter.z;\n      instanceMatrix = Matrix4.multiply(collectionTransform, instanceMatrix, scratchMatrix);\n      var nodeMatrix = modelCommand.modelMatrix;\n      var modelMatrix = drawCommand.modelMatrix;\n      Matrix4.multiply(instanceMatrix, nodeMatrix, modelMatrix);\n      var nodeBoundingSphere = modelCommand.boundingVolume;\n      var boundingSphere = drawCommand.boundingVolume;\n      BoundingSphere.transform(nodeBoundingSphere, instanceMatrix, boundingSphere);\n    }\n  }\n}\n\nfunction getModelCommands(model) {\n  var nodeCommands = model._nodeCommands;\n  var length = nodeCommands.length;\n  var drawCommands = [];\n\n  for (var i = 0; i < length; ++i) {\n    var nc = nodeCommands[i];\n\n    if (nc.show) {\n      drawCommands.push(nc.command);\n    }\n  }\n\n  return drawCommands;\n}\n\nfunction commandsDirty(model) {\n  var nodeCommands = model._nodeCommands;\n  var length = nodeCommands.length;\n  var commandsDirty = false;\n\n  for (var i = 0; i < length; i++) {\n    var nc = nodeCommands[i];\n\n    if (nc.command.dirty) {\n      nc.command.dirty = false;\n      commandsDirty = true;\n    }\n  }\n\n  return commandsDirty;\n}\n\nfunction generateModelCommands(modelInstanceCollection, instancingSupported) {\n  modelInstanceCollection._drawCommands = [];\n  var modelCommands = getModelCommands(modelInstanceCollection._model);\n\n  if (instancingSupported) {\n    createCommands(modelInstanceCollection, modelCommands);\n  } else {\n    createCommandsNonInstanced(modelInstanceCollection, modelCommands);\n    updateCommandsNonInstanced(modelInstanceCollection);\n  }\n}\n\nfunction updateShadows(collection, force) {\n  if (collection.shadows !== collection._shadows || force) {\n    collection._shadows = collection.shadows;\n    var castShadows = ShadowMode.castShadows(collection.shadows);\n    var receiveShadows = ShadowMode.receiveShadows(collection.shadows);\n    var drawCommands = collection._drawCommands;\n    var length = drawCommands.length;\n\n    for (var i = 0; i < length; ++i) {\n      var drawCommand = drawCommands[i];\n      drawCommand.castShadows = castShadows;\n      drawCommand.receiveShadows = receiveShadows;\n    }\n  }\n}\n\nModelInstanceCollection.prototype.update = function (frameState) {\n  if (frameState.mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  if (!this.show) {\n    return;\n  }\n\n  if (this.length === 0) {\n    return;\n  }\n\n  var context = frameState.context;\n\n  if (this._state === LoadState.NEEDS_LOAD) {\n    this._state = LoadState.LOADING;\n    this._instancingSupported = context.instancedArrays;\n    createModel(this, context);\n    var that = this;\n\n    this._model.readyPromise.otherwise(function (error) {\n      that._state = LoadState.FAILED;\n\n      that._readyPromise.reject(error);\n    });\n  }\n\n  var instancingSupported = this._instancingSupported;\n  var model = this._model;\n  model.imageBasedLightingFactor = this.imageBasedLightingFactor;\n  model.lightColor = this.lightColor;\n  model.luminanceAtZenith = this.luminanceAtZenith;\n  model.sphericalHarmonicCoefficients = this.sphericalHarmonicCoefficients;\n  model.specularEnvironmentMaps = this.specularEnvironmentMaps;\n  model.update(frameState);\n\n  if (model.ready && this._state === LoadState.LOADING) {\n    this._state = LoadState.LOADED;\n    this._ready = true; // Expand bounding volume to fit the radius of the loaded model including the model's offset from the center\n\n    var modelRadius = model.boundingSphere.radius + Cartesian3.magnitude(model.boundingSphere.center);\n    this._boundingSphere.radius += modelRadius;\n    this._modelCommands = getModelCommands(model);\n    generateModelCommands(this, instancingSupported);\n\n    this._readyPromise.resolve(this);\n\n    return;\n  }\n\n  if (this._state !== LoadState.LOADED) {\n    return;\n  }\n\n  var modeChanged = frameState.mode !== this._mode;\n  var modelMatrix = this.modelMatrix;\n  var modelMatrixChanged = !Matrix4.equals(this._modelMatrix, modelMatrix);\n\n  if (modeChanged || modelMatrixChanged) {\n    this._mode = frameState.mode;\n    Matrix4.clone(modelMatrix, this._modelMatrix);\n    var rtcTransform = Matrix4.multiplyByTranslation(this._modelMatrix, this._center, this._rtcTransform);\n\n    if (this._mode !== SceneMode.SCENE3D) {\n      rtcTransform = Transforms.basisTo2D(frameState.mapProjection, rtcTransform, rtcTransform);\n    }\n\n    Matrix4.getTranslation(rtcTransform, this._boundingSphere.center);\n  }\n\n  if (instancingSupported && this._dirty) {\n    // If at least one instance has moved assume the collection is now dynamic\n    this._dynamic = true;\n    this._dirty = false; // PERFORMANCE_IDEA: only update dirty sub-sections instead of the whole collection\n\n    updateVertexBuffer(this);\n  } // If the model was set to rebuild shaders during update, rebuild instanced commands.\n\n\n  var modelCommandsDirty = commandsDirty(model);\n\n  if (modelCommandsDirty) {\n    generateModelCommands(this, instancingSupported);\n  } // If any node changes due to an animation, update the commands. This could be inefficient if the model is\n  // composed of many nodes and only one changes, however it is probably fine in the general use case.\n  // Only applies when instancing is disabled. The instanced shader automatically handles node transformations.\n\n\n  if (!instancingSupported && (model.dirty || this._dirty || modeChanged || modelMatrixChanged)) {\n    updateCommandsNonInstanced(this);\n  }\n\n  updateShadows(this, modelCommandsDirty);\n  updateWireframe(this, modelCommandsDirty);\n  updateBackFaceCulling(this, modelCommandsDirty);\n  updateShowBoundingVolume(this, modelCommandsDirty);\n  var passes = frameState.passes;\n\n  if (!passes.render && !passes.pick) {\n    return;\n  }\n\n  var commandList = frameState.commandList;\n  var commands = this._drawCommands;\n  var commandsLength = commands.length;\n\n  for (var i = 0; i < commandsLength; ++i) {\n    commandList.push(commands[i]);\n  }\n};\n\nModelInstanceCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\nModelInstanceCollection.prototype.destroy = function () {\n  this._model = this._model && this._model.destroy();\n  var pickIds = this._pickIds;\n\n  if (defined(pickIds)) {\n    var length = pickIds.length;\n\n    for (var i = 0; i < length; ++i) {\n      pickIds[i].destroy();\n    }\n  }\n\n  return destroyObject(this);\n};\n\nexport default ModelInstanceCollection;","map":{"version":3,"sources":["/home/usuario/davi/thalamus/wms/3dmaptestes/leaflet_cesium/client/node_modules/cesium/Source/Scene/ModelInstanceCollection.js"],"names":["BoundingSphere","Cartesian2","Cartesian3","Check","clone","Color","ComponentDatatype","defaultValue","defined","destroyObject","DeveloperError","Matrix4","PrimitiveType","Resource","RuntimeError","Transforms","Buffer","BufferUsage","DrawCommand","Pass","RenderState","ShaderSource","ForEach","when","Model","ModelInstance","ModelUtility","SceneMode","ShadowMode","LoadState","NEEDS_LOAD","LOADING","LOADED","FAILED","ModelInstanceCollection","options","EMPTY_OBJECT","gltf","url","show","_instancingSupported","_dynamic","dynamic","_allowPicking","allowPicking","_ready","_readyPromise","defer","_state","_dirty","_cull","cull","_opaquePass","opaquePass","OPAQUE","_instances","createInstances","instances","_batchTable","batchTable","_model","undefined","_vertexBufferTypedArray","_vertexBuffer","_batchIdBuffer","_instancedUniformsByProgram","_drawCommands","_modelCommands","_renderStates","_disableCullingRenderStates","_boundingSphere","createBoundingSphere","_center","center","_rtcTransform","_rtcModelView","_mode","modelMatrix","IDENTITY","_modelMatrix","_url","createIfNeeded","_requestType","requestType","_gltf","_basePath","basePath","_asynchronous","asynchronous","_incrementallyLoadTextures","incrementallyLoadTextures","_upAxis","upAxis","_forwardAxis","forwardAxis","shadows","ENABLED","_shadows","_pickIdLoaded","pickIdLoaded","debugShowBoundingVolume","_debugShowBoundingVolume","debugWireframe","_debugWireframe","_imageBasedLightingFactor","imageBasedLightingFactor","lightColor","luminanceAtZenith","sphericalHarmonicCoefficients","specularEnvironmentMaps","backFaceCulling","_backFaceCulling","Object","defineProperties","prototype","get","length","activeAnimations","ready","readyPromise","promise","set","value","typeOf","object","number","greaterThanOrEquals","x","lessThanOrEquals","y","collection","instancesOptions","Array","i","instanceOptions","instanceId","batchId","instancesLength","points","getTranslation","fromPoints","scratchCartesian","scratchMatrix","expandBoundingSphere","instanceModelMatrix","translation","expand","getCheckUniformSemanticFunction","modelSemantics","supportedSemantics","programId","uniformMap","uniform","uniformName","semantic","indexOf","getInstancedUniforms","instancedUniformsByProgram","techniques","_sourceTechniques","techniqueId","hasOwnProperty","technique","program","techniqueUniform","getVertexShaderCallback","vs","instancedUniforms","usesBatchTable","renamedSource","replaceMain","globalVarsHeader","globalVarsMain","varName","regex","RegExp","replace","uniforms","batchIdAttribute","pickAttribute","pickVarying","instancedSource","diffuseAttributeOrUniformName","getDiffuseAttributeOrUniform","getFragmentShaderCallback","fs","createModifiedModelView","context","multiply","uniformState","view","createNodeTransformFunction","node","computedMatrix","getUniformMapCallback","czm_instanced_modifiedModelView","czm_instanced_nodeTransform","getVertexShaderNonInstancedCallback","getFragmentShaderNonInstancedCallback","getUniformMapNonInstancedCallback","getVertexBufferTypedArray","collectionCenter","vertexSizeInFloats","bufferData","Float32Array","instanceMatrix","z","offset","createVertexBuffer","batchIdBufferData","Uint16Array","_instanceId","typedArray","usage","STATIC_DRAW","pickIdBuffer","Uint8Array","pickId","_pickIds","pickColor","color","floatToByte","red","green","blue","alpha","_pickIdBuffer","vertexBufferTypedArray","STREAM_DRAW","updateVertexBuffer","copyFromArrayView","createPickIds","pickIds","createPickId","createModel","instancingSupported","modelOptions","cacheKey","precreatedAttributes","vertexShaderLoaded","fragmentShaderLoaded","uniformMapLoaded","ignoreCommands","componentSizeInBytes","getSizeInBytes","FLOAT","instancedAttributes","czm_modelMatrixRow0","index","vertexBuffer","componentsPerAttribute","componentDatatype","normalize","offsetInBytes","strideInBytes","instanceDivisor","czm_modelMatrixRow1","czm_modelMatrixRow2","a_batchId","UNSIGNED_SHORT","UNSIGNED_BYTE","getUrlComponent","fromGltf","updateWireframe","force","primitiveType","LINES","TRIANGLES","commands","getDisableCullingRenderState","renderState","rs","enabled","fromCache","updateBackFaceCulling","derivedRenderState","updateShowBoundingVolume","createCommands","drawCommands","commandsLength","boundingSphere","drawCommand","shallowClone","instanceCount","boundingVolume","getPickId","push","createBatchIdFunction","createPickColorFunction","createCommandsNonInstanced","j","czm_pickColor","updateCommandsNonInstanced","modelCommands","collectionTransform","modelCommand","commandIndex","nodeMatrix","nodeBoundingSphere","transform","getModelCommands","model","nodeCommands","_nodeCommands","nc","command","commandsDirty","dirty","generateModelCommands","modelInstanceCollection","updateShadows","castShadows","receiveShadows","update","frameState","mode","MORPHING","instancedArrays","that","otherwise","error","reject","modelRadius","radius","magnitude","resolve","modeChanged","modelMatrixChanged","equals","rtcTransform","multiplyByTranslation","SCENE3D","basisTo2D","mapProjection","modelCommandsDirty","passes","render","pick","commandList","isDestroyed","destroy"],"mappings":"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","sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport ForEach from \"../ThirdParty/GltfPipeline/ForEach.js\";\nimport when from \"../ThirdParty/when.js\";\nimport Model from \"./Model.js\";\nimport ModelInstance from \"./ModelInstance.js\";\nimport ModelUtility from \"./ModelUtility.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\n\nvar LoadState = {\n  NEEDS_LOAD: 0,\n  LOADING: 1,\n  LOADED: 2,\n  FAILED: 3,\n};\n\n/**\n * A 3D model instance collection. All instances reference the same underlying model, but have unique\n * per-instance properties like model matrix, pick id, etc.\n *\n * Instances are rendered relative-to-center and for best results instances should be positioned close to one another.\n * Otherwise there may be precision issues if, for example, instances are placed on opposite sides of the globe.\n *\n * @alias ModelInstanceCollection\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Object[]} [options.instances] An array of instances, where each instance contains a modelMatrix and optional batchId when options.batchTable is defined.\n * @param {Cesium3DTileBatchTable} [options.batchTable] The batch table of the instanced 3D Tile.\n * @param {Resource|String} [options.url] The url to the .gltf file.\n * @param {Object} [options.requestType] The request type, used for request prioritization\n * @param {Object|ArrayBuffer|Uint8Array} [options.gltf] A glTF JSON object, or a binary glTF buffer.\n * @param {Resource|String} [options.basePath=''] The base path that paths in the glTF JSON are relative to.\n * @param {Boolean} [options.dynamic=false] Hint if instance model matrices will be updated frequently.\n * @param {Boolean} [options.show=true] Determines if the collection will be shown.\n * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each instance is pickable with {@link Scene#pick}.\n * @param {Boolean} [options.asynchronous=true] Determines if model WebGL resource creation will be spread out over several frames or block until completion once all glTF files are loaded.\n * @param {Boolean} [options.incrementallyLoadTextures=true] Determine if textures may continue to stream in after the model is loaded.\n * @param {ShadowMode} [options.shadows=ShadowMode.ENABLED] Determines whether the collection casts or receives shadows from light sources.\n * @param {Cartesian2} [options.imageBasedLightingFactor=new Cartesian2(1.0, 1.0)] Scales the diffuse and specular image-based lighting from the earth, sky, atmosphere and star skybox.\n * @param {Cartesian3} [options.lightColor] The light color when shading models. When <code>undefined</code> the scene's light color is used instead.\n * @param {Number} [options.luminanceAtZenith=0.2] The sun's luminance at the zenith in kilo candela per meter squared to use for this model's procedural environment map.\n * @param {Cartesian3[]} [options.sphericalHarmonicCoefficients] The third order spherical harmonic coefficients used for the diffuse color of image-based lighting.\n * @param {String} [options.specularEnvironmentMaps] A URL to a KTX file that contains a cube map of the specular lighting and the convoluted specular mipmaps.\n * @param {Boolean} [options.backFaceCulling=true] Whether to cull back-facing geometry. When true, back face culling is determined by the glTF material's doubleSided property; when false, back face culling is disabled.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Draws the bounding sphere for the collection.\n * @param {Boolean} [options.debugWireframe=false] For debugging only. Draws the instances in wireframe.\n *\n * @exception {DeveloperError} Must specify either <options.gltf> or <options.url>, but not both.\n * @exception {DeveloperError} Shader program cannot be optimized for instancing. Parameters cannot have any of the following semantics: MODEL, MODELINVERSE, MODELVIEWINVERSE, MODELVIEWPROJECTIONINVERSE, MODELINVERSETRANSPOSE.\n *\n * @private\n */\nfunction ModelInstanceCollection(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options.gltf) && !defined(options.url)) {\n    throw new DeveloperError(\"Either options.gltf or options.url is required.\");\n  }\n\n  if (defined(options.gltf) && defined(options.url)) {\n    throw new DeveloperError(\n      \"Cannot pass in both options.gltf and options.url.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  this.show = defaultValue(options.show, true);\n\n  this._instancingSupported = false;\n  this._dynamic = defaultValue(options.dynamic, false);\n  this._allowPicking = defaultValue(options.allowPicking, true);\n  this._ready = false;\n  this._readyPromise = when.defer();\n  this._state = LoadState.NEEDS_LOAD;\n  this._dirty = false;\n\n  // Undocumented options\n  this._cull = defaultValue(options.cull, true);\n  this._opaquePass = defaultValue(options.opaquePass, Pass.OPAQUE);\n\n  this._instances = createInstances(this, options.instances);\n\n  // When the model instance collection is backed by an i3dm tile,\n  // use its batch table resources to modify the shaders, attributes, and uniform maps.\n  this._batchTable = options.batchTable;\n\n  this._model = undefined;\n  this._vertexBufferTypedArray = undefined; // Hold onto the vertex buffer contents when dynamic is true\n  this._vertexBuffer = undefined;\n  this._batchIdBuffer = undefined;\n  this._instancedUniformsByProgram = undefined;\n\n  this._drawCommands = [];\n  this._modelCommands = undefined;\n\n  this._renderStates = undefined;\n  this._disableCullingRenderStates = undefined;\n\n  this._boundingSphere = createBoundingSphere(this);\n  this._center = Cartesian3.clone(this._boundingSphere.center);\n  this._rtcTransform = new Matrix4();\n  this._rtcModelView = new Matrix4(); // Holds onto uniform\n\n  this._mode = undefined;\n\n  this.modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n  this._modelMatrix = Matrix4.clone(this.modelMatrix);\n\n  // Passed on to Model\n  this._url = Resource.createIfNeeded(options.url);\n  this._requestType = options.requestType;\n  this._gltf = options.gltf;\n  this._basePath = Resource.createIfNeeded(options.basePath);\n  this._asynchronous = options.asynchronous;\n  this._incrementallyLoadTextures = options.incrementallyLoadTextures;\n  this._upAxis = options.upAxis; // Undocumented option\n  this._forwardAxis = options.forwardAxis; // Undocumented option\n\n  this.shadows = defaultValue(options.shadows, ShadowMode.ENABLED);\n  this._shadows = this.shadows;\n\n  this._pickIdLoaded = options.pickIdLoaded;\n\n  this.debugShowBoundingVolume = defaultValue(\n    options.debugShowBoundingVolume,\n    false\n  );\n  this._debugShowBoundingVolume = false;\n\n  this.debugWireframe = defaultValue(options.debugWireframe, false);\n  this._debugWireframe = false;\n\n  this._imageBasedLightingFactor = new Cartesian2(1.0, 1.0);\n  Cartesian2.clone(\n    options.imageBasedLightingFactor,\n    this._imageBasedLightingFactor\n  );\n  this.lightColor = options.lightColor;\n  this.luminanceAtZenith = options.luminanceAtZenith;\n  this.sphericalHarmonicCoefficients = options.sphericalHarmonicCoefficients;\n  this.specularEnvironmentMaps = options.specularEnvironmentMaps;\n  this.backFaceCulling = defaultValue(options.backFaceCulling, true);\n  this._backFaceCulling = this.backFaceCulling;\n}\n\nObject.defineProperties(ModelInstanceCollection.prototype, {\n  allowPicking: {\n    get: function () {\n      return this._allowPicking;\n    },\n  },\n  length: {\n    get: function () {\n      return this._instances.length;\n    },\n  },\n  activeAnimations: {\n    get: function () {\n      return this._model.activeAnimations;\n    },\n  },\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    },\n  },\n  imageBasedLightingFactor: {\n    get: function () {\n      return this._imageBasedLightingFactor;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.typeOf.object(\"imageBasedLightingFactor\", value);\n      Check.typeOf.number.greaterThanOrEquals(\n        \"imageBasedLightingFactor.x\",\n        value.x,\n        0.0\n      );\n      Check.typeOf.number.lessThanOrEquals(\n        \"imageBasedLightingFactor.x\",\n        value.x,\n        1.0\n      );\n      Check.typeOf.number.greaterThanOrEquals(\n        \"imageBasedLightingFactor.y\",\n        value.y,\n        0.0\n      );\n      Check.typeOf.number.lessThanOrEquals(\n        \"imageBasedLightingFactor.y\",\n        value.y,\n        1.0\n      );\n      //>>includeEnd('debug');\n      Cartesian2.clone(value, this._imageBasedLightingFactor);\n    },\n  },\n});\n\nfunction createInstances(collection, instancesOptions) {\n  instancesOptions = defaultValue(instancesOptions, []);\n  var length = instancesOptions.length;\n  var instances = new Array(length);\n  for (var i = 0; i < length; ++i) {\n    var instanceOptions = instancesOptions[i];\n    var modelMatrix = instanceOptions.modelMatrix;\n    var instanceId = defaultValue(instanceOptions.batchId, i);\n    instances[i] = new ModelInstance(collection, modelMatrix, instanceId);\n  }\n  return instances;\n}\n\nfunction createBoundingSphere(collection) {\n  var instancesLength = collection.length;\n  var points = new Array(instancesLength);\n  for (var i = 0; i < instancesLength; ++i) {\n    points[i] = Matrix4.getTranslation(\n      collection._instances[i]._modelMatrix,\n      new Cartesian3()\n    );\n  }\n\n  return BoundingSphere.fromPoints(points);\n}\n\nvar scratchCartesian = new Cartesian3();\nvar scratchMatrix = new Matrix4();\n\nModelInstanceCollection.prototype.expandBoundingSphere = function (\n  instanceModelMatrix\n) {\n  var translation = Matrix4.getTranslation(\n    instanceModelMatrix,\n    scratchCartesian\n  );\n  BoundingSphere.expand(\n    this._boundingSphere,\n    translation,\n    this._boundingSphere\n  );\n};\n\nfunction getCheckUniformSemanticFunction(\n  modelSemantics,\n  supportedSemantics,\n  programId,\n  uniformMap\n) {\n  return function (uniform, uniformName) {\n    var semantic = uniform.semantic;\n    if (defined(semantic) && modelSemantics.indexOf(semantic) > -1) {\n      if (supportedSemantics.indexOf(semantic) > -1) {\n        uniformMap[uniformName] = semantic;\n      } else {\n        throw new RuntimeError(\n          \"Shader program cannot be optimized for instancing. \" +\n            'Uniform \"' +\n            uniformName +\n            '\" in program \"' +\n            programId +\n            '\" uses unsupported semantic \"' +\n            semantic +\n            '\"'\n        );\n      }\n    }\n  };\n}\n\nfunction getInstancedUniforms(collection, programId) {\n  if (defined(collection._instancedUniformsByProgram)) {\n    return collection._instancedUniformsByProgram[programId];\n  }\n\n  var instancedUniformsByProgram = {};\n  collection._instancedUniformsByProgram = instancedUniformsByProgram;\n\n  // When using CESIUM_RTC_MODELVIEW the CESIUM_RTC center is ignored. Instances are always rendered relative-to-center.\n  var modelSemantics = [\n    \"MODEL\",\n    \"MODELVIEW\",\n    \"CESIUM_RTC_MODELVIEW\",\n    \"MODELVIEWPROJECTION\",\n    \"MODELINVERSE\",\n    \"MODELVIEWINVERSE\",\n    \"MODELVIEWPROJECTIONINVERSE\",\n    \"MODELINVERSETRANSPOSE\",\n    \"MODELVIEWINVERSETRANSPOSE\",\n  ];\n  var supportedSemantics = [\n    \"MODELVIEW\",\n    \"CESIUM_RTC_MODELVIEW\",\n    \"MODELVIEWPROJECTION\",\n    \"MODELVIEWINVERSETRANSPOSE\",\n  ];\n\n  var techniques = collection._model._sourceTechniques;\n  for (var techniqueId in techniques) {\n    if (techniques.hasOwnProperty(techniqueId)) {\n      var technique = techniques[techniqueId];\n      var program = technique.program;\n\n      // Different techniques may share the same program, skip if already processed.\n      // This assumes techniques that share a program do not declare different semantics for the same uniforms.\n      if (!defined(instancedUniformsByProgram[program])) {\n        var uniformMap = {};\n        instancedUniformsByProgram[program] = uniformMap;\n        ForEach.techniqueUniform(\n          technique,\n          getCheckUniformSemanticFunction(\n            modelSemantics,\n            supportedSemantics,\n            programId,\n            uniformMap\n          )\n        );\n      }\n    }\n  }\n\n  return instancedUniformsByProgram[programId];\n}\n\nfunction getVertexShaderCallback(collection) {\n  return function (vs, programId) {\n    var instancedUniforms = getInstancedUniforms(collection, programId);\n    var usesBatchTable = defined(collection._batchTable);\n\n    var renamedSource = ShaderSource.replaceMain(vs, \"czm_instancing_main\");\n\n    var globalVarsHeader = \"\";\n    var globalVarsMain = \"\";\n    for (var uniform in instancedUniforms) {\n      if (instancedUniforms.hasOwnProperty(uniform)) {\n        var semantic = instancedUniforms[uniform];\n        var varName;\n        if (semantic === \"MODELVIEW\" || semantic === \"CESIUM_RTC_MODELVIEW\") {\n          varName = \"czm_instanced_modelView\";\n        } else if (semantic === \"MODELVIEWPROJECTION\") {\n          varName = \"czm_instanced_modelViewProjection\";\n          globalVarsHeader += \"mat4 czm_instanced_modelViewProjection;\\n\";\n          globalVarsMain +=\n            \"czm_instanced_modelViewProjection = czm_projection * czm_instanced_modelView;\\n\";\n        } else if (semantic === \"MODELVIEWINVERSETRANSPOSE\") {\n          varName = \"czm_instanced_modelViewInverseTranspose\";\n          globalVarsHeader += \"mat3 czm_instanced_modelViewInverseTranspose;\\n\";\n          globalVarsMain +=\n            \"czm_instanced_modelViewInverseTranspose = mat3(czm_instanced_modelView);\\n\";\n        }\n\n        // Remove the uniform declaration\n        var regex = new RegExp(\"uniform.*\" + uniform + \".*\");\n        renamedSource = renamedSource.replace(regex, \"\");\n\n        // Replace all occurrences of the uniform with the global variable\n        regex = new RegExp(uniform + \"\\\\b\", \"g\");\n        renamedSource = renamedSource.replace(regex, varName);\n      }\n    }\n\n    // czm_instanced_model is the model matrix of the instance relative to center\n    // czm_instanced_modifiedModelView is the transform from the center to view\n    // czm_instanced_nodeTransform is the local offset of the node within the model\n    var uniforms =\n      \"uniform mat4 czm_instanced_modifiedModelView;\\n\" +\n      \"uniform mat4 czm_instanced_nodeTransform;\\n\";\n\n    var batchIdAttribute;\n    var pickAttribute;\n    var pickVarying;\n\n    if (usesBatchTable) {\n      batchIdAttribute = \"attribute float a_batchId;\\n\";\n      pickAttribute = \"\";\n      pickVarying = \"\";\n    } else {\n      batchIdAttribute = \"\";\n      pickAttribute =\n        \"attribute vec4 pickColor;\\n\" + \"varying vec4 v_pickColor;\\n\";\n      pickVarying = \"    v_pickColor = pickColor;\\n\";\n    }\n\n    var instancedSource =\n      uniforms +\n      globalVarsHeader +\n      \"mat4 czm_instanced_modelView;\\n\" +\n      \"attribute vec4 czm_modelMatrixRow0;\\n\" +\n      \"attribute vec4 czm_modelMatrixRow1;\\n\" +\n      \"attribute vec4 czm_modelMatrixRow2;\\n\" +\n      batchIdAttribute +\n      pickAttribute +\n      renamedSource +\n      \"void main()\\n\" +\n      \"{\\n\" +\n      \"    mat4 czm_instanced_model = mat4(czm_modelMatrixRow0.x, czm_modelMatrixRow1.x, czm_modelMatrixRow2.x, 0.0, czm_modelMatrixRow0.y, czm_modelMatrixRow1.y, czm_modelMatrixRow2.y, 0.0, czm_modelMatrixRow0.z, czm_modelMatrixRow1.z, czm_modelMatrixRow2.z, 0.0, czm_modelMatrixRow0.w, czm_modelMatrixRow1.w, czm_modelMatrixRow2.w, 1.0);\\n\" +\n      \"    czm_instanced_modelView = czm_instanced_modifiedModelView * czm_instanced_model * czm_instanced_nodeTransform;\\n\" +\n      globalVarsMain +\n      \"    czm_instancing_main();\\n\" +\n      pickVarying +\n      \"}\\n\";\n\n    if (usesBatchTable) {\n      var gltf = collection._model.gltf;\n      var diffuseAttributeOrUniformName = ModelUtility.getDiffuseAttributeOrUniform(\n        gltf,\n        programId\n      );\n      instancedSource = collection._batchTable.getVertexShaderCallback(\n        true,\n        \"a_batchId\",\n        diffuseAttributeOrUniformName\n      )(instancedSource);\n    }\n\n    return instancedSource;\n  };\n}\n\nfunction getFragmentShaderCallback(collection) {\n  return function (fs, programId) {\n    var batchTable = collection._batchTable;\n    if (defined(batchTable)) {\n      var gltf = collection._model.gltf;\n      var diffuseAttributeOrUniformName = ModelUtility.getDiffuseAttributeOrUniform(\n        gltf,\n        programId\n      );\n      fs = batchTable.getFragmentShaderCallback(\n        true,\n        diffuseAttributeOrUniformName\n      )(fs);\n    } else {\n      fs = \"varying vec4 v_pickColor;\\n\" + fs;\n    }\n    return fs;\n  };\n}\n\nfunction createModifiedModelView(collection, context) {\n  return function () {\n    return Matrix4.multiply(\n      context.uniformState.view,\n      collection._rtcTransform,\n      collection._rtcModelView\n    );\n  };\n}\n\nfunction createNodeTransformFunction(node) {\n  return function () {\n    return node.computedMatrix;\n  };\n}\n\nfunction getUniformMapCallback(collection, context) {\n  return function (uniformMap, programId, node) {\n    uniformMap = clone(uniformMap);\n    uniformMap.czm_instanced_modifiedModelView = createModifiedModelView(\n      collection,\n      context\n    );\n    uniformMap.czm_instanced_nodeTransform = createNodeTransformFunction(node);\n\n    // Remove instanced uniforms from the uniform map\n    var instancedUniforms = getInstancedUniforms(collection, programId);\n    for (var uniform in instancedUniforms) {\n      if (instancedUniforms.hasOwnProperty(uniform)) {\n        delete uniformMap[uniform];\n      }\n    }\n\n    if (defined(collection._batchTable)) {\n      uniformMap = collection._batchTable.getUniformMapCallback()(uniformMap);\n    }\n\n    return uniformMap;\n  };\n}\n\nfunction getVertexShaderNonInstancedCallback(collection) {\n  return function (vs, programId) {\n    if (defined(collection._batchTable)) {\n      var gltf = collection._model.gltf;\n      var diffuseAttributeOrUniformName = ModelUtility.getDiffuseAttributeOrUniform(\n        gltf,\n        programId\n      );\n      vs = collection._batchTable.getVertexShaderCallback(\n        true,\n        \"a_batchId\",\n        diffuseAttributeOrUniformName\n      )(vs);\n      // Treat a_batchId as a uniform rather than a vertex attribute\n      vs = \"uniform float a_batchId\\n;\" + vs;\n    }\n    return vs;\n  };\n}\n\nfunction getFragmentShaderNonInstancedCallback(collection) {\n  return function (fs, programId) {\n    var batchTable = collection._batchTable;\n    if (defined(batchTable)) {\n      var gltf = collection._model.gltf;\n      var diffuseAttributeOrUniformName = ModelUtility.getDiffuseAttributeOrUniform(\n        gltf,\n        programId\n      );\n      fs = batchTable.getFragmentShaderCallback(\n        true,\n        diffuseAttributeOrUniformName\n      )(fs);\n    } else {\n      fs = \"uniform vec4 czm_pickColor;\\n\" + fs;\n    }\n    return fs;\n  };\n}\n\nfunction getUniformMapNonInstancedCallback(collection) {\n  return function (uniformMap) {\n    if (defined(collection._batchTable)) {\n      uniformMap = collection._batchTable.getUniformMapCallback()(uniformMap);\n    }\n\n    return uniformMap;\n  };\n}\n\nfunction getVertexBufferTypedArray(collection) {\n  var instances = collection._instances;\n  var instancesLength = collection.length;\n  var collectionCenter = collection._center;\n  var vertexSizeInFloats = 12;\n\n  var bufferData = collection._vertexBufferTypedArray;\n  if (!defined(bufferData)) {\n    bufferData = new Float32Array(instancesLength * vertexSizeInFloats);\n  }\n  if (collection._dynamic) {\n    // Hold onto the buffer data so we don't have to allocate new memory every frame.\n    collection._vertexBufferTypedArray = bufferData;\n  }\n\n  for (var i = 0; i < instancesLength; ++i) {\n    var modelMatrix = instances[i]._modelMatrix;\n\n    // Instance matrix is relative to center\n    var instanceMatrix = Matrix4.clone(modelMatrix, scratchMatrix);\n    instanceMatrix[12] -= collectionCenter.x;\n    instanceMatrix[13] -= collectionCenter.y;\n    instanceMatrix[14] -= collectionCenter.z;\n\n    var offset = i * vertexSizeInFloats;\n\n    // First three rows of the model matrix\n    bufferData[offset + 0] = instanceMatrix[0];\n    bufferData[offset + 1] = instanceMatrix[4];\n    bufferData[offset + 2] = instanceMatrix[8];\n    bufferData[offset + 3] = instanceMatrix[12];\n    bufferData[offset + 4] = instanceMatrix[1];\n    bufferData[offset + 5] = instanceMatrix[5];\n    bufferData[offset + 6] = instanceMatrix[9];\n    bufferData[offset + 7] = instanceMatrix[13];\n    bufferData[offset + 8] = instanceMatrix[2];\n    bufferData[offset + 9] = instanceMatrix[6];\n    bufferData[offset + 10] = instanceMatrix[10];\n    bufferData[offset + 11] = instanceMatrix[14];\n  }\n\n  return bufferData;\n}\n\nfunction createVertexBuffer(collection, context) {\n  var i;\n  var instances = collection._instances;\n  var instancesLength = collection.length;\n  var dynamic = collection._dynamic;\n  var usesBatchTable = defined(collection._batchTable);\n\n  if (usesBatchTable) {\n    var batchIdBufferData = new Uint16Array(instancesLength);\n    for (i = 0; i < instancesLength; ++i) {\n      batchIdBufferData[i] = instances[i]._instanceId;\n    }\n    collection._batchIdBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: batchIdBufferData,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n  }\n\n  if (!usesBatchTable) {\n    var pickIdBuffer = new Uint8Array(instancesLength * 4);\n    for (i = 0; i < instancesLength; ++i) {\n      var pickId = collection._pickIds[i];\n      var pickColor = pickId.color;\n      var offset = i * 4;\n      pickIdBuffer[offset] = Color.floatToByte(pickColor.red);\n      pickIdBuffer[offset + 1] = Color.floatToByte(pickColor.green);\n      pickIdBuffer[offset + 2] = Color.floatToByte(pickColor.blue);\n      pickIdBuffer[offset + 3] = Color.floatToByte(pickColor.alpha);\n    }\n    collection._pickIdBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: pickIdBuffer,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n  }\n\n  var vertexBufferTypedArray = getVertexBufferTypedArray(collection);\n  collection._vertexBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: vertexBufferTypedArray,\n    usage: dynamic ? BufferUsage.STREAM_DRAW : BufferUsage.STATIC_DRAW,\n  });\n}\n\nfunction updateVertexBuffer(collection) {\n  var vertexBufferTypedArray = getVertexBufferTypedArray(collection);\n  collection._vertexBuffer.copyFromArrayView(vertexBufferTypedArray);\n}\n\nfunction createPickIds(collection, context) {\n  // PERFORMANCE_IDEA: we could skip the pick buffer completely by allocating\n  // a continuous range of pickIds and then converting the base pickId + batchId\n  // to RGBA in the shader.  The only consider is precision issues, which might\n  // not be an issue in WebGL 2.\n  var instances = collection._instances;\n  var instancesLength = instances.length;\n  var pickIds = new Array(instancesLength);\n  for (var i = 0; i < instancesLength; ++i) {\n    pickIds[i] = context.createPickId(instances[i]);\n  }\n  return pickIds;\n}\n\nfunction createModel(collection, context) {\n  var instancingSupported = collection._instancingSupported;\n  var usesBatchTable = defined(collection._batchTable);\n  var allowPicking = collection._allowPicking;\n\n  var modelOptions = {\n    url: collection._url,\n    requestType: collection._requestType,\n    gltf: collection._gltf,\n    basePath: collection._basePath,\n    shadows: collection._shadows,\n    cacheKey: undefined,\n    asynchronous: collection._asynchronous,\n    allowPicking: allowPicking,\n    incrementallyLoadTextures: collection._incrementallyLoadTextures,\n    upAxis: collection._upAxis,\n    forwardAxis: collection._forwardAxis,\n    precreatedAttributes: undefined,\n    vertexShaderLoaded: undefined,\n    fragmentShaderLoaded: undefined,\n    uniformMapLoaded: undefined,\n    pickIdLoaded: collection._pickIdLoaded,\n    ignoreCommands: true,\n    opaquePass: collection._opaquePass,\n    imageBasedLightingFactor: collection.imageBasedLightingFactor,\n    lightColor: collection.lightColor,\n    luminanceAtZenith: collection.luminanceAtZenith,\n    sphericalHarmonicCoefficients: collection.sphericalHarmonicCoefficients,\n    specularEnvironmentMaps: collection.specularEnvironmentMaps,\n  };\n\n  if (!usesBatchTable) {\n    collection._pickIds = createPickIds(collection, context);\n  }\n\n  if (instancingSupported) {\n    createVertexBuffer(collection, context);\n\n    var vertexSizeInFloats = 12;\n    var componentSizeInBytes = ComponentDatatype.getSizeInBytes(\n      ComponentDatatype.FLOAT\n    );\n\n    var instancedAttributes = {\n      czm_modelMatrixRow0: {\n        index: 0, // updated in Model\n        vertexBuffer: collection._vertexBuffer,\n        componentsPerAttribute: 4,\n        componentDatatype: ComponentDatatype.FLOAT,\n        normalize: false,\n        offsetInBytes: 0,\n        strideInBytes: componentSizeInBytes * vertexSizeInFloats,\n        instanceDivisor: 1,\n      },\n      czm_modelMatrixRow1: {\n        index: 0, // updated in Model\n        vertexBuffer: collection._vertexBuffer,\n        componentsPerAttribute: 4,\n        componentDatatype: ComponentDatatype.FLOAT,\n        normalize: false,\n        offsetInBytes: componentSizeInBytes * 4,\n        strideInBytes: componentSizeInBytes * vertexSizeInFloats,\n        instanceDivisor: 1,\n      },\n      czm_modelMatrixRow2: {\n        index: 0, // updated in Model\n        vertexBuffer: collection._vertexBuffer,\n        componentsPerAttribute: 4,\n        componentDatatype: ComponentDatatype.FLOAT,\n        normalize: false,\n        offsetInBytes: componentSizeInBytes * 8,\n        strideInBytes: componentSizeInBytes * vertexSizeInFloats,\n        instanceDivisor: 1,\n      },\n    };\n\n    // When using a batch table, add a batch id attribute\n    if (usesBatchTable) {\n      instancedAttributes.a_batchId = {\n        index: 0, // updated in Model\n        vertexBuffer: collection._batchIdBuffer,\n        componentsPerAttribute: 1,\n        componentDatatype: ComponentDatatype.UNSIGNED_SHORT,\n        normalize: false,\n        offsetInBytes: 0,\n        strideInBytes: 0,\n        instanceDivisor: 1,\n      };\n    }\n\n    if (!usesBatchTable) {\n      instancedAttributes.pickColor = {\n        index: 0, // updated in Model\n        vertexBuffer: collection._pickIdBuffer,\n        componentsPerAttribute: 4,\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        normalize: true,\n        offsetInBytes: 0,\n        strideInBytes: 0,\n        instanceDivisor: 1,\n      };\n    }\n\n    modelOptions.precreatedAttributes = instancedAttributes;\n    modelOptions.vertexShaderLoaded = getVertexShaderCallback(collection);\n    modelOptions.fragmentShaderLoaded = getFragmentShaderCallback(collection);\n    modelOptions.uniformMapLoaded = getUniformMapCallback(collection, context);\n\n    if (defined(collection._url)) {\n      modelOptions.cacheKey = collection._url.getUrlComponent() + \"#instanced\";\n    }\n  } else {\n    modelOptions.vertexShaderLoaded = getVertexShaderNonInstancedCallback(\n      collection\n    );\n    modelOptions.fragmentShaderLoaded = getFragmentShaderNonInstancedCallback(\n      collection\n    );\n    modelOptions.uniformMapLoaded = getUniformMapNonInstancedCallback(\n      collection,\n      context\n    );\n  }\n\n  if (defined(collection._url)) {\n    collection._model = Model.fromGltf(modelOptions);\n  } else {\n    collection._model = new Model(modelOptions);\n  }\n}\n\nfunction updateWireframe(collection, force) {\n  if (collection._debugWireframe !== collection.debugWireframe || force) {\n    collection._debugWireframe = collection.debugWireframe;\n\n    // This assumes the original primitive was TRIANGLES and that the triangles\n    // are connected for the wireframe to look perfect.\n    var primitiveType = collection.debugWireframe\n      ? PrimitiveType.LINES\n      : PrimitiveType.TRIANGLES;\n    var commands = collection._drawCommands;\n    var length = commands.length;\n    for (var i = 0; i < length; ++i) {\n      commands[i].primitiveType = primitiveType;\n    }\n  }\n}\n\nfunction getDisableCullingRenderState(renderState) {\n  var rs = clone(renderState, true);\n  rs.cull.enabled = false;\n  return RenderState.fromCache(rs);\n}\n\nfunction updateBackFaceCulling(collection, force) {\n  if (collection._backFaceCulling !== collection.backFaceCulling || force) {\n    collection._backFaceCulling = collection.backFaceCulling;\n\n    var commands = collection._drawCommands;\n    var length = commands.length;\n    var i;\n\n    if (!defined(collection._disableCullingRenderStates)) {\n      collection._disableCullingRenderStates = new Array(length);\n      collection._renderStates = new Array(length);\n      for (i = 0; i < length; ++i) {\n        var renderState = commands[i].renderState;\n        var derivedRenderState = getDisableCullingRenderState(renderState);\n        collection._disableCullingRenderStates[i] = derivedRenderState;\n        collection._renderStates[i] = renderState;\n      }\n    }\n\n    for (i = 0; i < length; ++i) {\n      commands[i].renderState = collection._backFaceCulling\n        ? collection._renderStates[i]\n        : collection._disableCullingRenderStates[i];\n    }\n  }\n}\n\nfunction updateShowBoundingVolume(collection, force) {\n  if (\n    collection.debugShowBoundingVolume !==\n      collection._debugShowBoundingVolume ||\n    force\n  ) {\n    collection._debugShowBoundingVolume = collection.debugShowBoundingVolume;\n\n    var commands = collection._drawCommands;\n    var length = commands.length;\n    for (var i = 0; i < length; ++i) {\n      commands[i].debugShowBoundingVolume = collection.debugShowBoundingVolume;\n    }\n  }\n}\n\nfunction createCommands(collection, drawCommands) {\n  var commandsLength = drawCommands.length;\n  var instancesLength = collection.length;\n  var boundingSphere = collection._boundingSphere;\n  var cull = collection._cull;\n\n  for (var i = 0; i < commandsLength; ++i) {\n    var drawCommand = DrawCommand.shallowClone(drawCommands[i]);\n    drawCommand.instanceCount = instancesLength;\n    drawCommand.boundingVolume = boundingSphere;\n    drawCommand.cull = cull;\n    if (defined(collection._batchTable)) {\n      drawCommand.pickId = collection._batchTable.getPickId();\n    } else {\n      drawCommand.pickId = \"v_pickColor\";\n    }\n    collection._drawCommands.push(drawCommand);\n  }\n}\n\nfunction createBatchIdFunction(batchId) {\n  return function () {\n    return batchId;\n  };\n}\n\nfunction createPickColorFunction(color) {\n  return function () {\n    return color;\n  };\n}\n\nfunction createCommandsNonInstanced(collection, drawCommands) {\n  // When instancing is disabled, create commands for every instance.\n  var instances = collection._instances;\n  var commandsLength = drawCommands.length;\n  var instancesLength = collection.length;\n  var batchTable = collection._batchTable;\n  var usesBatchTable = defined(batchTable);\n  var cull = collection._cull;\n\n  for (var i = 0; i < commandsLength; ++i) {\n    for (var j = 0; j < instancesLength; ++j) {\n      var drawCommand = DrawCommand.shallowClone(drawCommands[i]);\n      drawCommand.modelMatrix = new Matrix4(); // Updated in updateCommandsNonInstanced\n      drawCommand.boundingVolume = new BoundingSphere(); // Updated in updateCommandsNonInstanced\n      drawCommand.cull = cull;\n      drawCommand.uniformMap = clone(drawCommand.uniformMap);\n      if (usesBatchTable) {\n        drawCommand.uniformMap.a_batchId = createBatchIdFunction(\n          instances[j]._instanceId\n        );\n      } else {\n        var pickId = collection._pickIds[j];\n        drawCommand.uniformMap.czm_pickColor = createPickColorFunction(\n          pickId.color\n        );\n      }\n      collection._drawCommands.push(drawCommand);\n    }\n  }\n}\n\nfunction updateCommandsNonInstanced(collection) {\n  var modelCommands = collection._modelCommands;\n  var commandsLength = modelCommands.length;\n  var instancesLength = collection.length;\n  var collectionTransform = collection._rtcTransform;\n  var collectionCenter = collection._center;\n\n  for (var i = 0; i < commandsLength; ++i) {\n    var modelCommand = modelCommands[i];\n    for (var j = 0; j < instancesLength; ++j) {\n      var commandIndex = i * instancesLength + j;\n      var drawCommand = collection._drawCommands[commandIndex];\n      var instanceMatrix = Matrix4.clone(\n        collection._instances[j]._modelMatrix,\n        scratchMatrix\n      );\n      instanceMatrix[12] -= collectionCenter.x;\n      instanceMatrix[13] -= collectionCenter.y;\n      instanceMatrix[14] -= collectionCenter.z;\n      instanceMatrix = Matrix4.multiply(\n        collectionTransform,\n        instanceMatrix,\n        scratchMatrix\n      );\n      var nodeMatrix = modelCommand.modelMatrix;\n      var modelMatrix = drawCommand.modelMatrix;\n      Matrix4.multiply(instanceMatrix, nodeMatrix, modelMatrix);\n\n      var nodeBoundingSphere = modelCommand.boundingVolume;\n      var boundingSphere = drawCommand.boundingVolume;\n      BoundingSphere.transform(\n        nodeBoundingSphere,\n        instanceMatrix,\n        boundingSphere\n      );\n    }\n  }\n}\n\nfunction getModelCommands(model) {\n  var nodeCommands = model._nodeCommands;\n  var length = nodeCommands.length;\n\n  var drawCommands = [];\n\n  for (var i = 0; i < length; ++i) {\n    var nc = nodeCommands[i];\n    if (nc.show) {\n      drawCommands.push(nc.command);\n    }\n  }\n\n  return drawCommands;\n}\n\nfunction commandsDirty(model) {\n  var nodeCommands = model._nodeCommands;\n  var length = nodeCommands.length;\n\n  var commandsDirty = false;\n\n  for (var i = 0; i < length; i++) {\n    var nc = nodeCommands[i];\n    if (nc.command.dirty) {\n      nc.command.dirty = false;\n      commandsDirty = true;\n    }\n  }\n  return commandsDirty;\n}\n\nfunction generateModelCommands(modelInstanceCollection, instancingSupported) {\n  modelInstanceCollection._drawCommands = [];\n\n  var modelCommands = getModelCommands(modelInstanceCollection._model);\n  if (instancingSupported) {\n    createCommands(modelInstanceCollection, modelCommands);\n  } else {\n    createCommandsNonInstanced(modelInstanceCollection, modelCommands);\n    updateCommandsNonInstanced(modelInstanceCollection);\n  }\n}\n\nfunction updateShadows(collection, force) {\n  if (collection.shadows !== collection._shadows || force) {\n    collection._shadows = collection.shadows;\n\n    var castShadows = ShadowMode.castShadows(collection.shadows);\n    var receiveShadows = ShadowMode.receiveShadows(collection.shadows);\n\n    var drawCommands = collection._drawCommands;\n    var length = drawCommands.length;\n    for (var i = 0; i < length; ++i) {\n      var drawCommand = drawCommands[i];\n      drawCommand.castShadows = castShadows;\n      drawCommand.receiveShadows = receiveShadows;\n    }\n  }\n}\n\nModelInstanceCollection.prototype.update = function (frameState) {\n  if (frameState.mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  if (!this.show) {\n    return;\n  }\n\n  if (this.length === 0) {\n    return;\n  }\n\n  var context = frameState.context;\n\n  if (this._state === LoadState.NEEDS_LOAD) {\n    this._state = LoadState.LOADING;\n    this._instancingSupported = context.instancedArrays;\n    createModel(this, context);\n    var that = this;\n    this._model.readyPromise.otherwise(function (error) {\n      that._state = LoadState.FAILED;\n      that._readyPromise.reject(error);\n    });\n  }\n\n  var instancingSupported = this._instancingSupported;\n  var model = this._model;\n\n  model.imageBasedLightingFactor = this.imageBasedLightingFactor;\n  model.lightColor = this.lightColor;\n  model.luminanceAtZenith = this.luminanceAtZenith;\n  model.sphericalHarmonicCoefficients = this.sphericalHarmonicCoefficients;\n  model.specularEnvironmentMaps = this.specularEnvironmentMaps;\n\n  model.update(frameState);\n\n  if (model.ready && this._state === LoadState.LOADING) {\n    this._state = LoadState.LOADED;\n    this._ready = true;\n\n    // Expand bounding volume to fit the radius of the loaded model including the model's offset from the center\n    var modelRadius =\n      model.boundingSphere.radius +\n      Cartesian3.magnitude(model.boundingSphere.center);\n    this._boundingSphere.radius += modelRadius;\n    this._modelCommands = getModelCommands(model);\n\n    generateModelCommands(this, instancingSupported);\n\n    this._readyPromise.resolve(this);\n    return;\n  }\n\n  if (this._state !== LoadState.LOADED) {\n    return;\n  }\n\n  var modeChanged = frameState.mode !== this._mode;\n  var modelMatrix = this.modelMatrix;\n  var modelMatrixChanged = !Matrix4.equals(this._modelMatrix, modelMatrix);\n\n  if (modeChanged || modelMatrixChanged) {\n    this._mode = frameState.mode;\n    Matrix4.clone(modelMatrix, this._modelMatrix);\n    var rtcTransform = Matrix4.multiplyByTranslation(\n      this._modelMatrix,\n      this._center,\n      this._rtcTransform\n    );\n    if (this._mode !== SceneMode.SCENE3D) {\n      rtcTransform = Transforms.basisTo2D(\n        frameState.mapProjection,\n        rtcTransform,\n        rtcTransform\n      );\n    }\n    Matrix4.getTranslation(rtcTransform, this._boundingSphere.center);\n  }\n\n  if (instancingSupported && this._dirty) {\n    // If at least one instance has moved assume the collection is now dynamic\n    this._dynamic = true;\n    this._dirty = false;\n\n    // PERFORMANCE_IDEA: only update dirty sub-sections instead of the whole collection\n    updateVertexBuffer(this);\n  }\n\n  // If the model was set to rebuild shaders during update, rebuild instanced commands.\n  var modelCommandsDirty = commandsDirty(model);\n  if (modelCommandsDirty) {\n    generateModelCommands(this, instancingSupported);\n  }\n\n  // If any node changes due to an animation, update the commands. This could be inefficient if the model is\n  // composed of many nodes and only one changes, however it is probably fine in the general use case.\n  // Only applies when instancing is disabled. The instanced shader automatically handles node transformations.\n  if (\n    !instancingSupported &&\n    (model.dirty || this._dirty || modeChanged || modelMatrixChanged)\n  ) {\n    updateCommandsNonInstanced(this);\n  }\n\n  updateShadows(this, modelCommandsDirty);\n  updateWireframe(this, modelCommandsDirty);\n  updateBackFaceCulling(this, modelCommandsDirty);\n  updateShowBoundingVolume(this, modelCommandsDirty);\n\n  var passes = frameState.passes;\n  if (!passes.render && !passes.pick) {\n    return;\n  }\n\n  var commandList = frameState.commandList;\n  var commands = this._drawCommands;\n  var commandsLength = commands.length;\n\n  for (var i = 0; i < commandsLength; ++i) {\n    commandList.push(commands[i]);\n  }\n};\n\nModelInstanceCollection.prototype.isDestroyed = function () {\n  return false;\n};\n\nModelInstanceCollection.prototype.destroy = function () {\n  this._model = this._model && this._model.destroy();\n\n  var pickIds = this._pickIds;\n  if (defined(pickIds)) {\n    var length = pickIds.length;\n    for (var i = 0; i < length; ++i) {\n      pickIds[i].destroy();\n    }\n  }\n\n  return destroyObject(this);\n};\nexport default ModelInstanceCollection;\n"]},"metadata":{},"sourceType":"module"}