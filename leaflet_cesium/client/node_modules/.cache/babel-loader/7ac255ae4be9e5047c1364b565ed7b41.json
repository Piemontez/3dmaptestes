{"ast":null,"code":"import combine from \"../Core/combine.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport CullFace from \"./CullFace.js\";\nimport SceneMode from \"./SceneMode.js\";\nvar DerivedCommandType = {\n  OPAQUE_FRONT_FACE: 0,\n  OPAQUE_BACK_FACE: 1,\n  DEPTH_ONLY_FRONT_FACE: 2,\n  DEPTH_ONLY_BACK_FACE: 3,\n  DEPTH_ONLY_FRONT_AND_BACK_FACE: 4,\n  TRANSLUCENT_FRONT_FACE: 5,\n  TRANSLUCENT_BACK_FACE: 6,\n  TRANSLUCENT_FRONT_FACE_MANUAL_DEPTH_TEST: 7,\n  TRANSLUCENT_BACK_FACE_MANUAL_DEPTH_TEST: 8,\n  PICK_FRONT_FACE: 9,\n  PICK_BACK_FACE: 10,\n  DERIVED_COMMANDS_MAXIMUM_LENGTH: 11\n};\nvar derivedCommandsMaximumLength = DerivedCommandType.DERIVED_COMMANDS_MAXIMUM_LENGTH;\nvar DerivedCommandNames = [\"opaqueFrontFaceCommand\", \"opaqueBackFaceCommand\", \"depthOnlyFrontFaceCommand\", \"depthOnlyBackFaceCommand\", \"depthOnlyFrontAndBackFaceCommand\", \"translucentFrontFaceCommand\", \"translucentBackFaceCommand\", \"translucentFrontFaceManualDepthTestCommand\", \"translucentBackFaceManualDepthTestCommand\", \"pickFrontFaceCommand\", \"pickBackFaceCommand\"];\n/**\n * @private\n */\n\nfunction GlobeTranslucencyState() {\n  this._frontFaceAlphaByDistance = new NearFarScalar(0.0, 1.0, 0.0, 1.0);\n  this._backFaceAlphaByDistance = new NearFarScalar(0.0, 1.0, 0.0, 1.0);\n  this._frontFaceTranslucent = false;\n  this._backFaceTranslucent = false;\n  this._requiresManualDepthTest = false;\n  this._sunVisibleThroughGlobe = false;\n  this._environmentVisible = false;\n  this._useDepthPlane = false;\n  this._numberOfTextureUniforms = 0;\n  this._globeTranslucencyFramebuffer = undefined;\n  this._rectangle = Rectangle.clone(Rectangle.MAX_VALUE);\n  this._derivedCommandKey = 0;\n  this._derivedCommandsDirty = false;\n  this._derivedCommandPacks = undefined;\n  this._derivedCommandTypes = new Array(derivedCommandsMaximumLength);\n  this._derivedBlendCommandTypes = new Array(derivedCommandsMaximumLength);\n  this._derivedPickCommandTypes = new Array(derivedCommandsMaximumLength);\n  this._derivedCommandTypesToUpdate = new Array(derivedCommandsMaximumLength);\n  this._derivedCommandsLength = 0;\n  this._derivedBlendCommandsLength = 0;\n  this._derivedPickCommandsLength = 0;\n  this._derivedCommandsToUpdateLength = 0;\n}\n\nObject.defineProperties(GlobeTranslucencyState.prototype, {\n  frontFaceAlphaByDistance: {\n    get: function () {\n      return this._frontFaceAlphaByDistance;\n    }\n  },\n  backFaceAlphaByDistance: {\n    get: function () {\n      return this._backFaceAlphaByDistance;\n    }\n  },\n  translucent: {\n    get: function () {\n      return this._frontFaceTranslucent;\n    }\n  },\n  sunVisibleThroughGlobe: {\n    get: function () {\n      return this._sunVisibleThroughGlobe;\n    }\n  },\n  environmentVisible: {\n    get: function () {\n      return this._environmentVisible;\n    }\n  },\n  useDepthPlane: {\n    get: function () {\n      return this._useDepthPlane;\n    }\n  },\n  numberOfTextureUniforms: {\n    get: function () {\n      return this._numberOfTextureUniforms;\n    }\n  },\n  rectangle: {\n    get: function () {\n      return this._rectangle;\n    }\n  }\n});\n\nGlobeTranslucencyState.prototype.update = function (scene) {\n  var globe = scene.globe;\n\n  if (!defined(globe) || !globe.show) {\n    this._frontFaceTranslucent = false;\n    this._backFaceTranslucent = false;\n    this._sunVisibleThroughGlobe = true;\n    this._environmentVisible = true;\n    this._useDepthPlane = false;\n    return;\n  }\n\n  this._frontFaceAlphaByDistance = updateAlphaByDistance(globe.translucency.enabled, globe.translucency.frontFaceAlpha, globe.translucency.frontFaceAlphaByDistance, this._frontFaceAlphaByDistance);\n  this._backFaceAlphaByDistance = updateAlphaByDistance(globe.translucency.enabled, globe.translucency.backFaceAlpha, globe.translucency.backFaceAlphaByDistance, this._backFaceAlphaByDistance);\n  this._frontFaceTranslucent = isFaceTranslucent(globe.translucency.enabled, this._frontFaceAlphaByDistance, globe);\n  this._backFaceTranslucent = isFaceTranslucent(globe.translucency.enabled, this._backFaceAlphaByDistance, globe);\n  this._requiresManualDepthTest = requiresManualDepthTest(this, scene, globe);\n  this._sunVisibleThroughGlobe = isSunVisibleThroughGlobe(this, scene);\n  this._environmentVisible = isEnvironmentVisible(this, scene);\n  this._useDepthPlane = useDepthPlane(this, scene);\n  this._numberOfTextureUniforms = getNumberOfTextureUniforms(this);\n  this._rectangle = Rectangle.clone(globe.translucency.rectangle, this._rectangle);\n  gatherDerivedCommandRequirements(this, scene);\n};\n\nfunction updateAlphaByDistance(enabled, alpha, alphaByDistance, result) {\n  if (!enabled) {\n    result.nearValue = 1.0;\n    result.farValue = 1.0;\n    return result;\n  }\n\n  if (!defined(alphaByDistance)) {\n    result.nearValue = alpha;\n    result.farValue = alpha;\n    return result;\n  }\n\n  NearFarScalar.clone(alphaByDistance, result);\n  result.nearValue *= alpha;\n  result.farValue *= alpha;\n  return result;\n}\n\nfunction isFaceTranslucent(translucencyEnabled, alphaByDistance, globe) {\n  return translucencyEnabled && (globe.baseColor.alpha < 1.0 || alphaByDistance.nearValue < 1.0 || alphaByDistance.farValue < 1.0);\n}\n\nfunction isSunVisibleThroughGlobe(state, scene) {\n  // The sun is visible through the globe if the front and back faces are translucent when above ground\n  // or if front faces are translucent when below ground\n  var frontTranslucent = state._frontFaceTranslucent;\n  var backTranslucent = state._backFaceTranslucent;\n  return frontTranslucent && (scene.cameraUnderground || backTranslucent);\n}\n\nfunction isEnvironmentVisible(state, scene) {\n  // The environment is visible if the camera is above ground or underground with translucency\n  return !scene.cameraUnderground || state._frontFaceTranslucent;\n}\n\nfunction useDepthPlane(state, scene) {\n  // Use the depth plane when the camera is above ground and the globe is opaque\n  return !scene.cameraUnderground && !state._frontFaceTranslucent;\n}\n\nfunction requiresManualDepthTest(state, scene, globe) {\n  return state._frontFaceTranslucent && !state._backFaceTranslucent && !globe.depthTestAgainstTerrain && scene.mode !== SceneMode.SCENE2D && scene.context.depthTexture;\n}\n\nfunction getNumberOfTextureUniforms(state) {\n  var numberOfTextureUniforms = 0;\n\n  if (state._frontFaceTranslucent) {\n    ++numberOfTextureUniforms; // classification texture\n  }\n\n  if (state._requiresManualDepthTest) {\n    ++numberOfTextureUniforms; // czm_globeDepthTexture for manual depth testing\n  }\n\n  return numberOfTextureUniforms;\n}\n\nfunction gatherDerivedCommandRequirements(state, scene) {\n  state._derivedCommandsLength = getDerivedCommandTypes(state, scene, false, false, state._derivedCommandTypes);\n  state._derivedBlendCommandsLength = getDerivedCommandTypes(state, scene, true, false, state._derivedBlendCommandTypes);\n  state._derivedPickCommandsLength = getDerivedCommandTypes(state, scene, false, true, state._derivedPickCommandTypes);\n  var i;\n  var derivedCommandKey = 0;\n\n  for (i = 0; i < state._derivedCommandsLength; ++i) {\n    derivedCommandKey |= 1 << state._derivedCommandTypes[i];\n  }\n\n  for (i = 0; i < state._derivedBlendCommandsLength; ++i) {\n    derivedCommandKey |= 1 << state._derivedBlendCommandTypes[i];\n  }\n\n  for (i = 0; i < state._derivedPickCommandsLength; ++i) {\n    derivedCommandKey |= 1 << state._derivedPickCommandTypes[i];\n  }\n\n  var derivedCommandsToUpdateLength = 0;\n\n  for (i = 0; i < derivedCommandsMaximumLength; ++i) {\n    if ((derivedCommandKey & 1 << i) > 0) {\n      state._derivedCommandTypesToUpdate[derivedCommandsToUpdateLength++] = i;\n    }\n  }\n\n  state._derivedCommandsToUpdateLength = derivedCommandsToUpdateLength;\n  var derivedCommandsDirty = derivedCommandKey !== state._derivedCommandKey;\n  state._derivedCommandKey = derivedCommandKey;\n  state._derivedCommandsDirty = derivedCommandsDirty;\n\n  if (!defined(state._derivedCommandPacks) && state._frontFaceTranslucent) {\n    state._derivedCommandPacks = createDerivedCommandPacks();\n  }\n}\n\nfunction getDerivedCommandTypes(state, scene, isBlendCommand, isPickCommand, types) {\n  var length = 0;\n  var frontTranslucent = state._frontFaceTranslucent;\n  var backTranslucent = state._backFaceTranslucent;\n\n  if (!frontTranslucent) {\n    // Don't use derived commands if the globe is opaque\n    return length;\n  }\n\n  var cameraUnderground = scene.cameraUnderground;\n  var requiresManualDepthTest = state._requiresManualDepthTest;\n  var translucentFrontFaceCommandType = isPickCommand ? DerivedCommandType.PICK_FRONT_FACE : requiresManualDepthTest ? DerivedCommandType.TRANSLUCENT_FRONT_FACE_MANUAL_DEPTH_TEST : DerivedCommandType.TRANSLUCENT_FRONT_FACE;\n  var translucentBackFaceCommandType = isPickCommand ? DerivedCommandType.PICK_BACK_FACE : requiresManualDepthTest ? DerivedCommandType.TRANSLUCENT_BACK_FACE_MANUAL_DEPTH_TEST : DerivedCommandType.TRANSLUCENT_BACK_FACE;\n\n  if (scene.mode === SceneMode.SCENE2D) {\n    types[length++] = DerivedCommandType.DEPTH_ONLY_FRONT_FACE;\n    types[length++] = translucentFrontFaceCommandType;\n    return length;\n  }\n\n  if (backTranslucent) {\n    // Push depth-only command for classification. Blend commands do not need to write depth.\n    // Push translucent commands for front and back faces.\n    if (!isBlendCommand) {\n      types[length++] = DerivedCommandType.DEPTH_ONLY_FRONT_AND_BACK_FACE;\n    }\n\n    if (cameraUnderground) {\n      types[length++] = translucentFrontFaceCommandType;\n      types[length++] = translucentBackFaceCommandType;\n    } else {\n      types[length++] = translucentBackFaceCommandType;\n      types[length++] = translucentFrontFaceCommandType;\n    }\n  } else {\n    // Push opaque command for the face that appears in back.\n    // Push depth-only command and translucent command for the face that appears in front.\n    // eslint-disable-next-line no-lonely-if\n    if (cameraUnderground) {\n      if (!isBlendCommand) {\n        types[length++] = DerivedCommandType.DEPTH_ONLY_BACK_FACE;\n      }\n\n      types[length++] = DerivedCommandType.OPAQUE_FRONT_FACE;\n      types[length++] = translucentBackFaceCommandType;\n    } else {\n      if (!isBlendCommand) {\n        types[length++] = DerivedCommandType.DEPTH_ONLY_FRONT_FACE;\n      }\n\n      types[length++] = DerivedCommandType.OPAQUE_BACK_FACE;\n      types[length++] = translucentFrontFaceCommandType;\n    }\n  }\n\n  return length;\n}\n\nfunction removeDefine(defines, defineToRemove) {\n  var index = defines.indexOf(defineToRemove);\n\n  if (index > -1) {\n    defines.splice(index, 1);\n  }\n}\n\nfunction hasDefine(defines, define) {\n  return defines.indexOf(define) > -1;\n}\n\nfunction getOpaqueFrontFaceShaderProgram(vs, fs) {\n  removeDefine(vs.defines, \"TRANSLUCENT\");\n  removeDefine(fs.defines, \"TRANSLUCENT\");\n}\n\nfunction getOpaqueBackFaceShaderProgram(vs, fs) {\n  removeDefine(vs.defines, \"GROUND_ATMOSPHERE\");\n  removeDefine(fs.defines, \"GROUND_ATMOSPHERE\");\n  removeDefine(vs.defines, \"FOG\");\n  removeDefine(fs.defines, \"FOG\");\n  removeDefine(vs.defines, \"TRANSLUCENT\");\n  removeDefine(fs.defines, \"TRANSLUCENT\");\n}\n\nfunction getDepthOnlyShaderProgram(vs, fs) {\n  if (hasDefine(fs.defines, \"TILE_LIMIT_RECTANGLE\") || hasDefine(fs.defines, \"ENABLE_CLIPPING_PLANES\")) {\n    // Need to execute the full shader if discard is called\n    return;\n  }\n\n  var depthOnlyShader = \"void main() \\n\" + \"{ \\n\" + \"    gl_FragColor = vec4(1.0); \\n\" + \"} \\n\";\n  fs.sources = [depthOnlyShader];\n}\n\nfunction getTranslucentShaderProgram(vs, fs) {\n  var sources = fs.sources;\n  var length = sources.length;\n\n  for (var i = 0; i < length; ++i) {\n    sources[i] = ShaderSource.replaceMain(sources[i], \"czm_globe_translucency_main\");\n  }\n\n  var globeTranslucencyMain = \"\\n\\n\" + \"uniform sampler2D u_classificationTexture; \\n\" + \"void main() \\n\" + \"{ \\n\" + \"    vec2 st = gl_FragCoord.xy / czm_viewport.zw; \\n\" + \"#ifdef MANUAL_DEPTH_TEST \\n\" + \"    float logDepthOrDepth = czm_unpackDepth(texture2D(czm_globeDepthTexture, st)); \\n\" + \"    if (logDepthOrDepth != 0.0) \\n\" + \"    { \\n\" + \"        vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth); \\n\" + \"        float depthEC = eyeCoordinate.z / eyeCoordinate.w; \\n\" + \"        if (v_positionEC.z < depthEC) \\n\" + \"        { \\n\" + \"            discard; \\n\" + \"        } \\n\" + \"    } \\n\" + \"#endif \\n\" + \"    czm_globe_translucency_main(); \\n\" + \"    vec4 classificationColor = texture2D(u_classificationTexture, st); \\n\" + \"    if (classificationColor.a > 0.0) \\n\" + \"    { \\n\" + \"        // Reverse premultiplication process to get the correct composited result of the classification primitives \\n\" + \"        classificationColor.rgb /= classificationColor.a; \\n\" + \"    } \\n\" + \"    gl_FragColor = classificationColor * vec4(classificationColor.aaa, 1.0) + gl_FragColor * (1.0 - classificationColor.a); \\n\" + \"} \\n\";\n  sources.push(globeTranslucencyMain);\n}\n\nfunction getTranslucentBackFaceShaderProgram(vs, fs) {\n  getTranslucentShaderProgram(vs, fs);\n  removeDefine(vs.defines, \"GROUND_ATMOSPHERE\");\n  removeDefine(fs.defines, \"GROUND_ATMOSPHERE\");\n  removeDefine(vs.defines, \"FOG\");\n  removeDefine(fs.defines, \"FOG\");\n}\n\nfunction getTranslucentFrontFaceManualDepthTestShaderProgram(vs, fs) {\n  getTranslucentShaderProgram(vs, fs);\n  vs.defines.push(\"GENERATE_POSITION\");\n  fs.defines.push(\"MANUAL_DEPTH_TEST\");\n}\n\nfunction getTranslucentBackFaceManualDepthTestShaderProgram(vs, fs) {\n  getTranslucentBackFaceShaderProgram(vs, fs);\n  vs.defines.push(\"GENERATE_POSITION\");\n  fs.defines.push(\"MANUAL_DEPTH_TEST\");\n}\n\nfunction getPickShaderProgram(vs, fs) {\n  var pickShader = \"uniform sampler2D u_classificationTexture; \\n\" + \"void main() \\n\" + \"{ \\n\" + \"    vec2 st = gl_FragCoord.xy / czm_viewport.zw; \\n\" + \"    vec4 pickColor = texture2D(u_classificationTexture, st); \\n\" + \"    if (pickColor == vec4(0.0)) \\n\" + \"    { \\n\" + \"        discard; \\n\" + \"    } \\n\" + \"    gl_FragColor = pickColor; \\n\" + \"} \\n\";\n  fs.sources = [pickShader];\n}\n\nfunction getDerivedShaderProgram(context, shaderProgram, derivedShaderProgram, shaderProgramDirty, getShaderProgramFunction, cacheName) {\n  if (!defined(getShaderProgramFunction)) {\n    return shaderProgram;\n  }\n\n  if (!shaderProgramDirty && defined(derivedShaderProgram)) {\n    return derivedShaderProgram;\n  }\n\n  var shader = context.shaderCache.getDerivedShaderProgram(shaderProgram, cacheName);\n\n  if (!defined(shader)) {\n    var attributeLocations = shaderProgram._attributeLocations;\n    var vs = shaderProgram.vertexShaderSource.clone();\n    var fs = shaderProgram.fragmentShaderSource.clone();\n    vs.defines = defined(vs.defines) ? vs.defines.slice(0) : [];\n    fs.defines = defined(fs.defines) ? fs.defines.slice(0) : [];\n    getShaderProgramFunction(vs, fs);\n    shader = context.shaderCache.createDerivedShaderProgram(shaderProgram, cacheName, {\n      vertexShaderSource: vs,\n      fragmentShaderSource: fs,\n      attributeLocations: attributeLocations\n    });\n  }\n\n  return shader;\n}\n\nfunction getOpaqueFrontFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.BACK;\n  renderState.cull.enabled = true;\n}\n\nfunction getOpaqueBackFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.FRONT;\n  renderState.cull.enabled = true;\n}\n\nfunction getDepthOnlyFrontFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.BACK;\n  renderState.cull.enabled = true;\n  renderState.colorMask = {\n    red: false,\n    green: false,\n    blue: false,\n    alpha: false\n  };\n}\n\nfunction getDepthOnlyBackFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.FRONT;\n  renderState.cull.enabled = true;\n  renderState.colorMask = {\n    red: false,\n    green: false,\n    blue: false,\n    alpha: false\n  };\n}\n\nfunction getDepthOnlyFrontAndBackFaceRenderState(renderState) {\n  renderState.cull.enabled = false;\n  renderState.colorMask = {\n    red: false,\n    green: false,\n    blue: false,\n    alpha: false\n  };\n}\n\nfunction getTranslucentFrontFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.BACK;\n  renderState.cull.enabled = true;\n  renderState.depthMask = false;\n  renderState.blending = BlendingState.ALPHA_BLEND;\n}\n\nfunction getTranslucentBackFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.FRONT;\n  renderState.cull.enabled = true;\n  renderState.depthMask = false;\n  renderState.blending = BlendingState.ALPHA_BLEND;\n}\n\nfunction getPickFrontFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.BACK;\n  renderState.cull.enabled = true;\n  renderState.blending.enabled = false;\n}\n\nfunction getPickBackFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.FRONT;\n  renderState.cull.enabled = true;\n  renderState.blending.enabled = false;\n}\n\nfunction getDerivedRenderState(renderState, derivedRenderState, renderStateDirty, getRenderStateFunction, cache) {\n  if (!defined(getRenderStateFunction)) {\n    return renderState;\n  }\n\n  if (!renderStateDirty && defined(derivedRenderState)) {\n    return derivedRenderState;\n  }\n\n  var cachedRenderState = cache[renderState.id];\n\n  if (!defined(cachedRenderState)) {\n    var rs = RenderState.getState(renderState);\n    getRenderStateFunction(rs);\n    cachedRenderState = RenderState.fromCache(rs);\n    cache[renderState.id] = cachedRenderState;\n  }\n\n  return cachedRenderState;\n}\n\nfunction getTranslucencyUniformMap(state) {\n  return {\n    u_classificationTexture: function () {\n      return state._globeTranslucencyFramebuffer.classificationTexture;\n    }\n  };\n}\n\nfunction getDerivedUniformMap(state, uniformMap, derivedUniformMap, uniformMapDirty, getDerivedUniformMapFunction) {\n  if (!defined(getDerivedUniformMapFunction)) {\n    return uniformMap;\n  }\n\n  if (!uniformMapDirty && defined(derivedUniformMap)) {\n    return derivedUniformMap;\n  }\n\n  return combine(uniformMap, getDerivedUniformMapFunction(state), false);\n}\n\nfunction DerivedCommandPack(options) {\n  this.pass = options.pass;\n  this.pickOnly = options.pickOnly;\n  this.getShaderProgramFunction = options.getShaderProgramFunction;\n  this.getRenderStateFunction = options.getRenderStateFunction;\n  this.getUniformMapFunction = options.getUniformMapFunction;\n  this.renderStateCache = {};\n}\n\nfunction createDerivedCommandPacks() {\n  return [// opaqueFrontFaceCommand\n  new DerivedCommandPack({\n    pass: Pass.GLOBE,\n    pickOnly: false,\n    getShaderProgramFunction: getOpaqueFrontFaceShaderProgram,\n    getRenderStateFunction: getOpaqueFrontFaceRenderState,\n    getUniformMapFunction: undefined\n  }), // opaqueBackFaceCommand\n  new DerivedCommandPack({\n    pass: Pass.GLOBE,\n    pickOnly: false,\n    getShaderProgramFunction: getOpaqueBackFaceShaderProgram,\n    getRenderStateFunction: getOpaqueBackFaceRenderState,\n    getUniformMapFunction: undefined\n  }), // depthOnlyFrontFaceCommand\n  new DerivedCommandPack({\n    pass: Pass.GLOBE,\n    pickOnly: false,\n    getShaderProgramFunction: getDepthOnlyShaderProgram,\n    getRenderStateFunction: getDepthOnlyFrontFaceRenderState,\n    getUniformMapFunction: undefined\n  }), // depthOnlyBackFaceCommand\n  new DerivedCommandPack({\n    pass: Pass.GLOBE,\n    pickOnly: false,\n    getShaderProgramFunction: getDepthOnlyShaderProgram,\n    getRenderStateFunction: getDepthOnlyBackFaceRenderState,\n    getUniformMapFunction: undefined\n  }), // depthOnlyFrontAndBackFaceCommand\n  new DerivedCommandPack({\n    pass: Pass.GLOBE,\n    pickOnly: false,\n    getShaderProgramFunction: getDepthOnlyShaderProgram,\n    getRenderStateFunction: getDepthOnlyFrontAndBackFaceRenderState,\n    getUniformMapFunction: undefined\n  }), // translucentFrontFaceCommand\n  new DerivedCommandPack({\n    pass: Pass.TRANSLUCENT,\n    pickOnly: false,\n    getShaderProgramFunction: getTranslucentShaderProgram,\n    getRenderStateFunction: getTranslucentFrontFaceRenderState,\n    getUniformMapFunction: getTranslucencyUniformMap\n  }), // translucentBackFaceCommand\n  new DerivedCommandPack({\n    pass: Pass.TRANSLUCENT,\n    pickOnly: false,\n    getShaderProgramFunction: getTranslucentBackFaceShaderProgram,\n    getRenderStateFunction: getTranslucentBackFaceRenderState,\n    getUniformMapFunction: getTranslucencyUniformMap\n  }), // translucentFrontFaceManualDepthTestCommand\n  new DerivedCommandPack({\n    pass: Pass.TRANSLUCENT,\n    pickOnly: false,\n    getShaderProgramFunction: getTranslucentFrontFaceManualDepthTestShaderProgram,\n    getRenderStateFunction: getTranslucentFrontFaceRenderState,\n    getUniformMapFunction: getTranslucencyUniformMap\n  }), // translucentBackFaceManualDepthTestCommand\n  new DerivedCommandPack({\n    pass: Pass.TRANSLUCENT,\n    pickOnly: false,\n    getShaderProgramFunction: getTranslucentBackFaceManualDepthTestShaderProgram,\n    getRenderStateFunction: getTranslucentBackFaceRenderState,\n    getUniformMapFunction: getTranslucencyUniformMap\n  }), // pickFrontFaceCommand\n  new DerivedCommandPack({\n    pass: Pass.TRANSLUCENT,\n    pickOnly: true,\n    getShaderProgramFunction: getPickShaderProgram,\n    getRenderStateFunction: getPickFrontFaceRenderState,\n    getUniformMapFunction: getTranslucencyUniformMap\n  }), // pickBackFaceCommand\n  new DerivedCommandPack({\n    pass: Pass.TRANSLUCENT,\n    pickOnly: true,\n    getShaderProgramFunction: getPickShaderProgram,\n    getRenderStateFunction: getPickBackFaceRenderState,\n    getUniformMapFunction: getTranslucencyUniformMap\n  })];\n}\n\nvar derivedCommandNames = new Array(derivedCommandsMaximumLength);\nvar derivedCommandPacks = new Array(derivedCommandsMaximumLength);\n\nGlobeTranslucencyState.prototype.updateDerivedCommands = function (command, frameState) {\n  var derivedCommandTypes = this._derivedCommandTypesToUpdate;\n  var derivedCommandsLength = this._derivedCommandsToUpdateLength;\n\n  if (derivedCommandsLength === 0) {\n    return;\n  }\n\n  for (var i = 0; i < derivedCommandsLength; ++i) {\n    derivedCommandPacks[i] = this._derivedCommandPacks[derivedCommandTypes[i]];\n    derivedCommandNames[i] = DerivedCommandNames[derivedCommandTypes[i]];\n  }\n\n  updateDerivedCommands(this, command, derivedCommandsLength, derivedCommandTypes, derivedCommandNames, derivedCommandPacks, frameState);\n};\n\nfunction updateDerivedCommands(state, command, derivedCommandsLength, derivedCommandTypes, derivedCommandNames, derivedCommandPacks, frameState) {\n  var derivedCommandsObject = command.derivedCommands.globeTranslucency;\n  var derivedCommandsDirty = state._derivedCommandsDirty;\n\n  if (command.dirty || !defined(derivedCommandsObject) || derivedCommandsDirty) {\n    command.dirty = false;\n\n    if (!defined(derivedCommandsObject)) {\n      derivedCommandsObject = {};\n      command.derivedCommands.globeTranslucency = derivedCommandsObject;\n    }\n\n    var frameNumber = frameState.frameNumber;\n    var uniformMapDirtyFrame = defaultValue(derivedCommandsObject.uniformMapDirtyFrame, 0);\n    var shaderProgramDirtyFrame = defaultValue(derivedCommandsObject.shaderProgramDirtyFrame, 0);\n    var renderStateDirtyFrame = defaultValue(derivedCommandsObject.renderStateDirtyFrame, 0);\n    var uniformMapDirty = derivedCommandsObject.uniformMap !== command.uniformMap;\n    var shaderProgramDirty = derivedCommandsObject.shaderProgramId !== command.shaderProgram.id;\n    var renderStateDirty = derivedCommandsObject.renderStateId !== command.renderState.id;\n\n    if (uniformMapDirty) {\n      derivedCommandsObject.uniformMapDirtyFrame = frameNumber;\n    }\n\n    if (shaderProgramDirty) {\n      derivedCommandsObject.shaderProgramDirtyFrame = frameNumber;\n    }\n\n    if (renderStateDirty) {\n      derivedCommandsObject.renderStateDirtyFrame = frameNumber;\n    }\n\n    derivedCommandsObject.uniformMap = command.uniformMap;\n    derivedCommandsObject.shaderProgramId = command.shaderProgram.id;\n    derivedCommandsObject.renderStateId = command.renderState.id;\n\n    for (var i = 0; i < derivedCommandsLength; ++i) {\n      var derivedCommandPack = derivedCommandPacks[i];\n      var derivedCommandType = derivedCommandTypes[i];\n      var derivedCommandName = derivedCommandNames[i];\n      var derivedCommand = derivedCommandsObject[derivedCommandName];\n      var derivedUniformMap;\n      var derivedShaderProgram;\n      var derivedRenderState;\n\n      if (defined(derivedCommand)) {\n        derivedUniformMap = derivedCommand.uniformMap;\n        derivedShaderProgram = derivedCommand.shaderProgram;\n        derivedRenderState = derivedCommand.renderState;\n      } else {\n        derivedUniformMap = undefined;\n        derivedShaderProgram = undefined;\n        derivedRenderState = undefined;\n      }\n\n      derivedCommand = DrawCommand.shallowClone(command, derivedCommand);\n      derivedCommandsObject[derivedCommandName] = derivedCommand;\n      var derivedUniformMapDirtyFrame = defaultValue(derivedCommand.derivedCommands.uniformMapDirtyFrame, 0);\n      var derivedShaderProgramDirtyFrame = defaultValue(derivedCommand.derivedCommands.shaderProgramDirtyFrame, 0);\n      var derivedRenderStateDirtyFrame = defaultValue(derivedCommand.derivedCommands.renderStateDirtyFrame, 0);\n      var derivedUniformMapDirty = uniformMapDirty || derivedUniformMapDirtyFrame < uniformMapDirtyFrame;\n      var derivedShaderProgramDirty = shaderProgramDirty || derivedShaderProgramDirtyFrame < shaderProgramDirtyFrame;\n      var derivedRenderStateDirty = renderStateDirty || derivedRenderStateDirtyFrame < renderStateDirtyFrame;\n\n      if (derivedUniformMapDirty) {\n        derivedCommand.derivedCommands.uniformMapDirtyFrame = frameNumber;\n      }\n\n      if (derivedShaderProgramDirty) {\n        derivedCommand.derivedCommands.shaderProgramDirtyFrame = frameNumber;\n      }\n\n      if (derivedRenderStateDirty) {\n        derivedCommand.derivedCommands.renderStateDirtyFrame = frameNumber;\n      }\n\n      derivedCommand.derivedCommands.type = derivedCommandType;\n      derivedCommand.pass = derivedCommandPack.pass;\n      derivedCommand.pickOnly = derivedCommandPack.pickOnly;\n      derivedCommand.uniformMap = getDerivedUniformMap(state, command.uniformMap, derivedUniformMap, derivedUniformMapDirty, derivedCommandPack.getUniformMapFunction);\n      derivedCommand.shaderProgram = getDerivedShaderProgram(frameState.context, command.shaderProgram, derivedShaderProgram, derivedShaderProgramDirty, derivedCommandPack.getShaderProgramFunction, derivedCommandName);\n      derivedCommand.renderState = getDerivedRenderState(command.renderState, derivedRenderState, derivedRenderStateDirty, derivedCommandPack.getRenderStateFunction, derivedCommandPack.renderStateCache);\n    }\n  }\n}\n\nGlobeTranslucencyState.prototype.pushDerivedCommands = function (command, isBlendCommand, frameState) {\n  var picking = frameState.passes.pick;\n\n  if (picking && isBlendCommand) {\n    // No need to push blend commands in the pick pass\n    return;\n  }\n\n  var derivedCommandTypes = this._derivedCommandTypes;\n  var derivedCommandsLength = this._derivedCommandsLength;\n\n  if (picking) {\n    derivedCommandTypes = this._derivedPickCommandTypes;\n    derivedCommandsLength = this._derivedPickCommandsLength;\n  } else if (isBlendCommand) {\n    derivedCommandTypes = this._derivedBlendCommandTypes;\n    derivedCommandsLength = this._derivedBlendCommandsLength;\n  }\n\n  if (derivedCommandsLength === 0) {\n    // No derived commands to push so just push the globe command\n    frameState.commandList.push(command);\n    return;\n  } // Push derived commands\n\n\n  var derivedCommands = command.derivedCommands.globeTranslucency;\n\n  for (var i = 0; i < derivedCommandsLength; ++i) {\n    var derivedCommandName = DerivedCommandNames[derivedCommandTypes[i]];\n    frameState.commandList.push(derivedCommands[derivedCommandName]);\n  }\n};\n\nfunction executeCommandsMatchingType(commands, commandsLength, executeCommandFunction, scene, context, passState, types) {\n  for (var i = 0; i < commandsLength; ++i) {\n    var command = commands[i];\n    var type = command.derivedCommands.type;\n\n    if (!defined(types) || types.indexOf(type) > -1) {\n      executeCommandFunction(command, scene, context, passState);\n    }\n  }\n}\n\nfunction executeCommands(commands, commandsLength, executeCommandFunction, scene, context, passState) {\n  for (var i = 0; i < commandsLength; ++i) {\n    executeCommandFunction(commands[i], scene, context, passState);\n  }\n}\n\nvar opaqueTypes = [DerivedCommandType.OPAQUE_FRONT_FACE, DerivedCommandType.OPAQUE_BACK_FACE];\nvar depthOnlyTypes = [DerivedCommandType.DEPTH_ONLY_FRONT_FACE, DerivedCommandType.DEPTH_ONLY_BACK_FACE, DerivedCommandType.DEPTH_ONLY_FRONT_AND_BACK_FACE];\n\nGlobeTranslucencyState.prototype.executeGlobeCommands = function (frustumCommands, executeCommandFunction, globeTranslucencyFramebuffer, scene, passState) {\n  var context = scene.context;\n  var globeCommands = frustumCommands.commands[Pass.GLOBE];\n  var globeCommandsLength = frustumCommands.indices[Pass.GLOBE];\n\n  if (globeCommandsLength === 0) {\n    return;\n  }\n\n  this._globeTranslucencyFramebuffer = globeTranslucencyFramebuffer;\n  globeTranslucencyFramebuffer.clearClassification(context, passState); // Render opaque commands like normal\n\n  executeCommandsMatchingType(globeCommands, globeCommandsLength, executeCommandFunction, scene, context, passState, opaqueTypes);\n};\n\nGlobeTranslucencyState.prototype.executeGlobeClassificationCommands = function (frustumCommands, executeCommandFunction, globeTranslucencyFramebuffer, scene, passState) {\n  var context = scene.context;\n  var globeCommands = frustumCommands.commands[Pass.GLOBE];\n  var globeCommandsLength = frustumCommands.indices[Pass.GLOBE];\n  var classificationCommands = frustumCommands.commands[Pass.TERRAIN_CLASSIFICATION];\n  var classificationCommandsLength = frustumCommands.indices[Pass.TERRAIN_CLASSIFICATION];\n\n  if (globeCommandsLength === 0 || classificationCommandsLength === 0) {\n    return;\n  }\n\n  var frontTranslucent = this._frontFaceTranslucent;\n  var backTranslucent = this._backFaceTranslucent;\n\n  if (!frontTranslucent || !backTranslucent) {\n    // Render classification on opaque faces like normal\n    executeCommands(classificationCommands, classificationCommandsLength, executeCommandFunction, scene, context, passState);\n  }\n\n  if (!frontTranslucent && !backTranslucent) {\n    // No translucent commands to render. Skip translucent classification.\n    return;\n  }\n\n  this._globeTranslucencyFramebuffer = globeTranslucencyFramebuffer;\n  var originalGlobeDepthTexture = context.uniformState.globeDepthTexture;\n  var originalFramebuffer = passState.framebuffer; // Render to internal framebuffer and get the first depth peel\n\n  passState.framebuffer = globeTranslucencyFramebuffer.classificationFramebuffer;\n  executeCommandsMatchingType(globeCommands, globeCommandsLength, executeCommandFunction, scene, context, passState, depthOnlyTypes);\n\n  if (context.depthTexture) {\n    // Pack depth into separate texture for ground polylines and textured ground primitives\n    var packedDepthTexture = globeTranslucencyFramebuffer.packDepth(context, passState);\n    context.uniformState.globeDepthTexture = packedDepthTexture;\n  } // Render classification on translucent faces\n\n\n  executeCommands(classificationCommands, classificationCommandsLength, executeCommandFunction, scene, context, passState); // Unset temporary state\n\n  context.uniformState.globeDepthTexture = originalGlobeDepthTexture;\n  passState.framebuffer = originalFramebuffer;\n};\n\nexport default GlobeTranslucencyState;","map":{"version":3,"sources":["/home/usuario/davi/thalamus/wms/3dmaptestes/leaflet_cesium/client/node_modules/cesium/Source/Scene/GlobeTranslucencyState.js"],"names":["combine","defaultValue","defined","NearFarScalar","Rectangle","DrawCommand","Pass","RenderState","ShaderSource","BlendingState","CullFace","SceneMode","DerivedCommandType","OPAQUE_FRONT_FACE","OPAQUE_BACK_FACE","DEPTH_ONLY_FRONT_FACE","DEPTH_ONLY_BACK_FACE","DEPTH_ONLY_FRONT_AND_BACK_FACE","TRANSLUCENT_FRONT_FACE","TRANSLUCENT_BACK_FACE","TRANSLUCENT_FRONT_FACE_MANUAL_DEPTH_TEST","TRANSLUCENT_BACK_FACE_MANUAL_DEPTH_TEST","PICK_FRONT_FACE","PICK_BACK_FACE","DERIVED_COMMANDS_MAXIMUM_LENGTH","derivedCommandsMaximumLength","DerivedCommandNames","GlobeTranslucencyState","_frontFaceAlphaByDistance","_backFaceAlphaByDistance","_frontFaceTranslucent","_backFaceTranslucent","_requiresManualDepthTest","_sunVisibleThroughGlobe","_environmentVisible","_useDepthPlane","_numberOfTextureUniforms","_globeTranslucencyFramebuffer","undefined","_rectangle","clone","MAX_VALUE","_derivedCommandKey","_derivedCommandsDirty","_derivedCommandPacks","_derivedCommandTypes","Array","_derivedBlendCommandTypes","_derivedPickCommandTypes","_derivedCommandTypesToUpdate","_derivedCommandsLength","_derivedBlendCommandsLength","_derivedPickCommandsLength","_derivedCommandsToUpdateLength","Object","defineProperties","prototype","frontFaceAlphaByDistance","get","backFaceAlphaByDistance","translucent","sunVisibleThroughGlobe","environmentVisible","useDepthPlane","numberOfTextureUniforms","rectangle","update","scene","globe","show","updateAlphaByDistance","translucency","enabled","frontFaceAlpha","backFaceAlpha","isFaceTranslucent","requiresManualDepthTest","isSunVisibleThroughGlobe","isEnvironmentVisible","getNumberOfTextureUniforms","gatherDerivedCommandRequirements","alpha","alphaByDistance","result","nearValue","farValue","translucencyEnabled","baseColor","state","frontTranslucent","backTranslucent","cameraUnderground","depthTestAgainstTerrain","mode","SCENE2D","context","depthTexture","getDerivedCommandTypes","i","derivedCommandKey","derivedCommandsToUpdateLength","derivedCommandsDirty","createDerivedCommandPacks","isBlendCommand","isPickCommand","types","length","translucentFrontFaceCommandType","translucentBackFaceCommandType","removeDefine","defines","defineToRemove","index","indexOf","splice","hasDefine","define","getOpaqueFrontFaceShaderProgram","vs","fs","getOpaqueBackFaceShaderProgram","getDepthOnlyShaderProgram","depthOnlyShader","sources","getTranslucentShaderProgram","replaceMain","globeTranslucencyMain","push","getTranslucentBackFaceShaderProgram","getTranslucentFrontFaceManualDepthTestShaderProgram","getTranslucentBackFaceManualDepthTestShaderProgram","getPickShaderProgram","pickShader","getDerivedShaderProgram","shaderProgram","derivedShaderProgram","shaderProgramDirty","getShaderProgramFunction","cacheName","shader","shaderCache","attributeLocations","_attributeLocations","vertexShaderSource","fragmentShaderSource","slice","createDerivedShaderProgram","getOpaqueFrontFaceRenderState","renderState","cull","face","BACK","getOpaqueBackFaceRenderState","FRONT","getDepthOnlyFrontFaceRenderState","colorMask","red","green","blue","getDepthOnlyBackFaceRenderState","getDepthOnlyFrontAndBackFaceRenderState","getTranslucentFrontFaceRenderState","depthMask","blending","ALPHA_BLEND","getTranslucentBackFaceRenderState","getPickFrontFaceRenderState","getPickBackFaceRenderState","getDerivedRenderState","derivedRenderState","renderStateDirty","getRenderStateFunction","cache","cachedRenderState","id","rs","getState","fromCache","getTranslucencyUniformMap","u_classificationTexture","classificationTexture","getDerivedUniformMap","uniformMap","derivedUniformMap","uniformMapDirty","getDerivedUniformMapFunction","DerivedCommandPack","options","pass","pickOnly","getUniformMapFunction","renderStateCache","GLOBE","TRANSLUCENT","derivedCommandNames","derivedCommandPacks","updateDerivedCommands","command","frameState","derivedCommandTypes","derivedCommandsLength","derivedCommandsObject","derivedCommands","globeTranslucency","dirty","frameNumber","uniformMapDirtyFrame","shaderProgramDirtyFrame","renderStateDirtyFrame","shaderProgramId","renderStateId","derivedCommandPack","derivedCommandType","derivedCommandName","derivedCommand","shallowClone","derivedUniformMapDirtyFrame","derivedShaderProgramDirtyFrame","derivedRenderStateDirtyFrame","derivedUniformMapDirty","derivedShaderProgramDirty","derivedRenderStateDirty","type","pushDerivedCommands","picking","passes","pick","commandList","executeCommandsMatchingType","commands","commandsLength","executeCommandFunction","passState","executeCommands","opaqueTypes","depthOnlyTypes","executeGlobeCommands","frustumCommands","globeTranslucencyFramebuffer","globeCommands","globeCommandsLength","indices","clearClassification","executeGlobeClassificationCommands","classificationCommands","TERRAIN_CLASSIFICATION","classificationCommandsLength","originalGlobeDepthTexture","uniformState","globeDepthTexture","originalFramebuffer","framebuffer","classificationFramebuffer","packedDepthTexture","packDepth"],"mappings":"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","sourcesContent":["import combine from \"../Core/combine.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport CullFace from \"./CullFace.js\";\nimport SceneMode from \"./SceneMode.js\";\n\nvar DerivedCommandType = {\n  OPAQUE_FRONT_FACE: 0,\n  OPAQUE_BACK_FACE: 1,\n  DEPTH_ONLY_FRONT_FACE: 2,\n  DEPTH_ONLY_BACK_FACE: 3,\n  DEPTH_ONLY_FRONT_AND_BACK_FACE: 4,\n  TRANSLUCENT_FRONT_FACE: 5,\n  TRANSLUCENT_BACK_FACE: 6,\n  TRANSLUCENT_FRONT_FACE_MANUAL_DEPTH_TEST: 7,\n  TRANSLUCENT_BACK_FACE_MANUAL_DEPTH_TEST: 8,\n  PICK_FRONT_FACE: 9,\n  PICK_BACK_FACE: 10,\n  DERIVED_COMMANDS_MAXIMUM_LENGTH: 11,\n};\n\nvar derivedCommandsMaximumLength =\n  DerivedCommandType.DERIVED_COMMANDS_MAXIMUM_LENGTH;\n\nvar DerivedCommandNames = [\n  \"opaqueFrontFaceCommand\",\n  \"opaqueBackFaceCommand\",\n  \"depthOnlyFrontFaceCommand\",\n  \"depthOnlyBackFaceCommand\",\n  \"depthOnlyFrontAndBackFaceCommand\",\n  \"translucentFrontFaceCommand\",\n  \"translucentBackFaceCommand\",\n  \"translucentFrontFaceManualDepthTestCommand\",\n  \"translucentBackFaceManualDepthTestCommand\",\n  \"pickFrontFaceCommand\",\n  \"pickBackFaceCommand\",\n];\n\n/**\n * @private\n */\nfunction GlobeTranslucencyState() {\n  this._frontFaceAlphaByDistance = new NearFarScalar(0.0, 1.0, 0.0, 1.0);\n  this._backFaceAlphaByDistance = new NearFarScalar(0.0, 1.0, 0.0, 1.0);\n\n  this._frontFaceTranslucent = false;\n  this._backFaceTranslucent = false;\n  this._requiresManualDepthTest = false;\n  this._sunVisibleThroughGlobe = false;\n  this._environmentVisible = false;\n  this._useDepthPlane = false;\n  this._numberOfTextureUniforms = 0;\n  this._globeTranslucencyFramebuffer = undefined;\n  this._rectangle = Rectangle.clone(Rectangle.MAX_VALUE);\n\n  this._derivedCommandKey = 0;\n  this._derivedCommandsDirty = false;\n  this._derivedCommandPacks = undefined;\n\n  this._derivedCommandTypes = new Array(derivedCommandsMaximumLength);\n  this._derivedBlendCommandTypes = new Array(derivedCommandsMaximumLength);\n  this._derivedPickCommandTypes = new Array(derivedCommandsMaximumLength);\n  this._derivedCommandTypesToUpdate = new Array(derivedCommandsMaximumLength);\n\n  this._derivedCommandsLength = 0;\n  this._derivedBlendCommandsLength = 0;\n  this._derivedPickCommandsLength = 0;\n  this._derivedCommandsToUpdateLength = 0;\n}\n\nObject.defineProperties(GlobeTranslucencyState.prototype, {\n  frontFaceAlphaByDistance: {\n    get: function () {\n      return this._frontFaceAlphaByDistance;\n    },\n  },\n  backFaceAlphaByDistance: {\n    get: function () {\n      return this._backFaceAlphaByDistance;\n    },\n  },\n  translucent: {\n    get: function () {\n      return this._frontFaceTranslucent;\n    },\n  },\n  sunVisibleThroughGlobe: {\n    get: function () {\n      return this._sunVisibleThroughGlobe;\n    },\n  },\n  environmentVisible: {\n    get: function () {\n      return this._environmentVisible;\n    },\n  },\n  useDepthPlane: {\n    get: function () {\n      return this._useDepthPlane;\n    },\n  },\n  numberOfTextureUniforms: {\n    get: function () {\n      return this._numberOfTextureUniforms;\n    },\n  },\n  rectangle: {\n    get: function () {\n      return this._rectangle;\n    },\n  },\n});\n\nGlobeTranslucencyState.prototype.update = function (scene) {\n  var globe = scene.globe;\n  if (!defined(globe) || !globe.show) {\n    this._frontFaceTranslucent = false;\n    this._backFaceTranslucent = false;\n    this._sunVisibleThroughGlobe = true;\n    this._environmentVisible = true;\n    this._useDepthPlane = false;\n    return;\n  }\n\n  this._frontFaceAlphaByDistance = updateAlphaByDistance(\n    globe.translucency.enabled,\n    globe.translucency.frontFaceAlpha,\n    globe.translucency.frontFaceAlphaByDistance,\n    this._frontFaceAlphaByDistance\n  );\n  this._backFaceAlphaByDistance = updateAlphaByDistance(\n    globe.translucency.enabled,\n    globe.translucency.backFaceAlpha,\n    globe.translucency.backFaceAlphaByDistance,\n    this._backFaceAlphaByDistance\n  );\n\n  this._frontFaceTranslucent = isFaceTranslucent(\n    globe.translucency.enabled,\n    this._frontFaceAlphaByDistance,\n    globe\n  );\n  this._backFaceTranslucent = isFaceTranslucent(\n    globe.translucency.enabled,\n    this._backFaceAlphaByDistance,\n    globe\n  );\n\n  this._requiresManualDepthTest = requiresManualDepthTest(this, scene, globe);\n\n  this._sunVisibleThroughGlobe = isSunVisibleThroughGlobe(this, scene);\n  this._environmentVisible = isEnvironmentVisible(this, scene);\n  this._useDepthPlane = useDepthPlane(this, scene);\n  this._numberOfTextureUniforms = getNumberOfTextureUniforms(this);\n\n  this._rectangle = Rectangle.clone(\n    globe.translucency.rectangle,\n    this._rectangle\n  );\n\n  gatherDerivedCommandRequirements(this, scene);\n};\n\nfunction updateAlphaByDistance(enabled, alpha, alphaByDistance, result) {\n  if (!enabled) {\n    result.nearValue = 1.0;\n    result.farValue = 1.0;\n    return result;\n  }\n\n  if (!defined(alphaByDistance)) {\n    result.nearValue = alpha;\n    result.farValue = alpha;\n    return result;\n  }\n\n  NearFarScalar.clone(alphaByDistance, result);\n  result.nearValue *= alpha;\n  result.farValue *= alpha;\n  return result;\n}\n\nfunction isFaceTranslucent(translucencyEnabled, alphaByDistance, globe) {\n  return (\n    translucencyEnabled &&\n    (globe.baseColor.alpha < 1.0 ||\n      alphaByDistance.nearValue < 1.0 ||\n      alphaByDistance.farValue < 1.0)\n  );\n}\n\nfunction isSunVisibleThroughGlobe(state, scene) {\n  // The sun is visible through the globe if the front and back faces are translucent when above ground\n  // or if front faces are translucent when below ground\n  var frontTranslucent = state._frontFaceTranslucent;\n  var backTranslucent = state._backFaceTranslucent;\n  return frontTranslucent && (scene.cameraUnderground || backTranslucent);\n}\n\nfunction isEnvironmentVisible(state, scene) {\n  // The environment is visible if the camera is above ground or underground with translucency\n  return !scene.cameraUnderground || state._frontFaceTranslucent;\n}\n\nfunction useDepthPlane(state, scene) {\n  // Use the depth plane when the camera is above ground and the globe is opaque\n  return !scene.cameraUnderground && !state._frontFaceTranslucent;\n}\n\nfunction requiresManualDepthTest(state, scene, globe) {\n  return (\n    state._frontFaceTranslucent &&\n    !state._backFaceTranslucent &&\n    !globe.depthTestAgainstTerrain &&\n    scene.mode !== SceneMode.SCENE2D &&\n    scene.context.depthTexture\n  );\n}\n\nfunction getNumberOfTextureUniforms(state) {\n  var numberOfTextureUniforms = 0;\n\n  if (state._frontFaceTranslucent) {\n    ++numberOfTextureUniforms; // classification texture\n  }\n\n  if (state._requiresManualDepthTest) {\n    ++numberOfTextureUniforms; // czm_globeDepthTexture for manual depth testing\n  }\n\n  return numberOfTextureUniforms;\n}\n\nfunction gatherDerivedCommandRequirements(state, scene) {\n  state._derivedCommandsLength = getDerivedCommandTypes(\n    state,\n    scene,\n    false,\n    false,\n    state._derivedCommandTypes\n  );\n\n  state._derivedBlendCommandsLength = getDerivedCommandTypes(\n    state,\n    scene,\n    true,\n    false,\n    state._derivedBlendCommandTypes\n  );\n\n  state._derivedPickCommandsLength = getDerivedCommandTypes(\n    state,\n    scene,\n    false,\n    true,\n    state._derivedPickCommandTypes\n  );\n\n  var i;\n\n  var derivedCommandKey = 0;\n  for (i = 0; i < state._derivedCommandsLength; ++i) {\n    derivedCommandKey |= 1 << state._derivedCommandTypes[i];\n  }\n  for (i = 0; i < state._derivedBlendCommandsLength; ++i) {\n    derivedCommandKey |= 1 << state._derivedBlendCommandTypes[i];\n  }\n  for (i = 0; i < state._derivedPickCommandsLength; ++i) {\n    derivedCommandKey |= 1 << state._derivedPickCommandTypes[i];\n  }\n\n  var derivedCommandsToUpdateLength = 0;\n  for (i = 0; i < derivedCommandsMaximumLength; ++i) {\n    if ((derivedCommandKey & (1 << i)) > 0) {\n      state._derivedCommandTypesToUpdate[derivedCommandsToUpdateLength++] = i;\n    }\n  }\n  state._derivedCommandsToUpdateLength = derivedCommandsToUpdateLength;\n\n  var derivedCommandsDirty = derivedCommandKey !== state._derivedCommandKey;\n  state._derivedCommandKey = derivedCommandKey;\n  state._derivedCommandsDirty = derivedCommandsDirty;\n\n  if (!defined(state._derivedCommandPacks) && state._frontFaceTranslucent) {\n    state._derivedCommandPacks = createDerivedCommandPacks();\n  }\n}\n\nfunction getDerivedCommandTypes(\n  state,\n  scene,\n  isBlendCommand,\n  isPickCommand,\n  types\n) {\n  var length = 0;\n\n  var frontTranslucent = state._frontFaceTranslucent;\n  var backTranslucent = state._backFaceTranslucent;\n\n  if (!frontTranslucent) {\n    // Don't use derived commands if the globe is opaque\n    return length;\n  }\n\n  var cameraUnderground = scene.cameraUnderground;\n  var requiresManualDepthTest = state._requiresManualDepthTest;\n\n  var translucentFrontFaceCommandType = isPickCommand\n    ? DerivedCommandType.PICK_FRONT_FACE\n    : requiresManualDepthTest\n    ? DerivedCommandType.TRANSLUCENT_FRONT_FACE_MANUAL_DEPTH_TEST\n    : DerivedCommandType.TRANSLUCENT_FRONT_FACE;\n\n  var translucentBackFaceCommandType = isPickCommand\n    ? DerivedCommandType.PICK_BACK_FACE\n    : requiresManualDepthTest\n    ? DerivedCommandType.TRANSLUCENT_BACK_FACE_MANUAL_DEPTH_TEST\n    : DerivedCommandType.TRANSLUCENT_BACK_FACE;\n\n  if (scene.mode === SceneMode.SCENE2D) {\n    types[length++] = DerivedCommandType.DEPTH_ONLY_FRONT_FACE;\n    types[length++] = translucentFrontFaceCommandType;\n    return length;\n  }\n\n  if (backTranslucent) {\n    // Push depth-only command for classification. Blend commands do not need to write depth.\n    // Push translucent commands for front and back faces.\n    if (!isBlendCommand) {\n      types[length++] = DerivedCommandType.DEPTH_ONLY_FRONT_AND_BACK_FACE;\n    }\n    if (cameraUnderground) {\n      types[length++] = translucentFrontFaceCommandType;\n      types[length++] = translucentBackFaceCommandType;\n    } else {\n      types[length++] = translucentBackFaceCommandType;\n      types[length++] = translucentFrontFaceCommandType;\n    }\n  } else {\n    // Push opaque command for the face that appears in back.\n    // Push depth-only command and translucent command for the face that appears in front.\n    // eslint-disable-next-line no-lonely-if\n    if (cameraUnderground) {\n      if (!isBlendCommand) {\n        types[length++] = DerivedCommandType.DEPTH_ONLY_BACK_FACE;\n      }\n      types[length++] = DerivedCommandType.OPAQUE_FRONT_FACE;\n      types[length++] = translucentBackFaceCommandType;\n    } else {\n      if (!isBlendCommand) {\n        types[length++] = DerivedCommandType.DEPTH_ONLY_FRONT_FACE;\n      }\n      types[length++] = DerivedCommandType.OPAQUE_BACK_FACE;\n      types[length++] = translucentFrontFaceCommandType;\n    }\n  }\n\n  return length;\n}\n\nfunction removeDefine(defines, defineToRemove) {\n  var index = defines.indexOf(defineToRemove);\n  if (index > -1) {\n    defines.splice(index, 1);\n  }\n}\n\nfunction hasDefine(defines, define) {\n  return defines.indexOf(define) > -1;\n}\n\nfunction getOpaqueFrontFaceShaderProgram(vs, fs) {\n  removeDefine(vs.defines, \"TRANSLUCENT\");\n  removeDefine(fs.defines, \"TRANSLUCENT\");\n}\n\nfunction getOpaqueBackFaceShaderProgram(vs, fs) {\n  removeDefine(vs.defines, \"GROUND_ATMOSPHERE\");\n  removeDefine(fs.defines, \"GROUND_ATMOSPHERE\");\n  removeDefine(vs.defines, \"FOG\");\n  removeDefine(fs.defines, \"FOG\");\n  removeDefine(vs.defines, \"TRANSLUCENT\");\n  removeDefine(fs.defines, \"TRANSLUCENT\");\n}\n\nfunction getDepthOnlyShaderProgram(vs, fs) {\n  if (\n    hasDefine(fs.defines, \"TILE_LIMIT_RECTANGLE\") ||\n    hasDefine(fs.defines, \"ENABLE_CLIPPING_PLANES\")\n  ) {\n    // Need to execute the full shader if discard is called\n    return;\n  }\n\n  var depthOnlyShader =\n    \"void main() \\n\" + \"{ \\n\" + \"    gl_FragColor = vec4(1.0); \\n\" + \"} \\n\";\n\n  fs.sources = [depthOnlyShader];\n}\n\nfunction getTranslucentShaderProgram(vs, fs) {\n  var sources = fs.sources;\n  var length = sources.length;\n  for (var i = 0; i < length; ++i) {\n    sources[i] = ShaderSource.replaceMain(\n      sources[i],\n      \"czm_globe_translucency_main\"\n    );\n  }\n\n  var globeTranslucencyMain =\n    \"\\n\\n\" +\n    \"uniform sampler2D u_classificationTexture; \\n\" +\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    vec2 st = gl_FragCoord.xy / czm_viewport.zw; \\n\" +\n    \"#ifdef MANUAL_DEPTH_TEST \\n\" +\n    \"    float logDepthOrDepth = czm_unpackDepth(texture2D(czm_globeDepthTexture, st)); \\n\" +\n    \"    if (logDepthOrDepth != 0.0) \\n\" +\n    \"    { \\n\" +\n    \"        vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth); \\n\" +\n    \"        float depthEC = eyeCoordinate.z / eyeCoordinate.w; \\n\" +\n    \"        if (v_positionEC.z < depthEC) \\n\" +\n    \"        { \\n\" +\n    \"            discard; \\n\" +\n    \"        } \\n\" +\n    \"    } \\n\" +\n    \"#endif \\n\" +\n    \"    czm_globe_translucency_main(); \\n\" +\n    \"    vec4 classificationColor = texture2D(u_classificationTexture, st); \\n\" +\n    \"    if (classificationColor.a > 0.0) \\n\" +\n    \"    { \\n\" +\n    \"        // Reverse premultiplication process to get the correct composited result of the classification primitives \\n\" +\n    \"        classificationColor.rgb /= classificationColor.a; \\n\" +\n    \"    } \\n\" +\n    \"    gl_FragColor = classificationColor * vec4(classificationColor.aaa, 1.0) + gl_FragColor * (1.0 - classificationColor.a); \\n\" +\n    \"} \\n\";\n\n  sources.push(globeTranslucencyMain);\n}\n\nfunction getTranslucentBackFaceShaderProgram(vs, fs) {\n  getTranslucentShaderProgram(vs, fs);\n  removeDefine(vs.defines, \"GROUND_ATMOSPHERE\");\n  removeDefine(fs.defines, \"GROUND_ATMOSPHERE\");\n  removeDefine(vs.defines, \"FOG\");\n  removeDefine(fs.defines, \"FOG\");\n}\n\nfunction getTranslucentFrontFaceManualDepthTestShaderProgram(vs, fs) {\n  getTranslucentShaderProgram(vs, fs);\n  vs.defines.push(\"GENERATE_POSITION\");\n  fs.defines.push(\"MANUAL_DEPTH_TEST\");\n}\n\nfunction getTranslucentBackFaceManualDepthTestShaderProgram(vs, fs) {\n  getTranslucentBackFaceShaderProgram(vs, fs);\n  vs.defines.push(\"GENERATE_POSITION\");\n  fs.defines.push(\"MANUAL_DEPTH_TEST\");\n}\n\nfunction getPickShaderProgram(vs, fs) {\n  var pickShader =\n    \"uniform sampler2D u_classificationTexture; \\n\" +\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    vec2 st = gl_FragCoord.xy / czm_viewport.zw; \\n\" +\n    \"    vec4 pickColor = texture2D(u_classificationTexture, st); \\n\" +\n    \"    if (pickColor == vec4(0.0)) \\n\" +\n    \"    { \\n\" +\n    \"        discard; \\n\" +\n    \"    } \\n\" +\n    \"    gl_FragColor = pickColor; \\n\" +\n    \"} \\n\";\n\n  fs.sources = [pickShader];\n}\n\nfunction getDerivedShaderProgram(\n  context,\n  shaderProgram,\n  derivedShaderProgram,\n  shaderProgramDirty,\n  getShaderProgramFunction,\n  cacheName\n) {\n  if (!defined(getShaderProgramFunction)) {\n    return shaderProgram;\n  }\n\n  if (!shaderProgramDirty && defined(derivedShaderProgram)) {\n    return derivedShaderProgram;\n  }\n\n  var shader = context.shaderCache.getDerivedShaderProgram(\n    shaderProgram,\n    cacheName\n  );\n  if (!defined(shader)) {\n    var attributeLocations = shaderProgram._attributeLocations;\n    var vs = shaderProgram.vertexShaderSource.clone();\n    var fs = shaderProgram.fragmentShaderSource.clone();\n    vs.defines = defined(vs.defines) ? vs.defines.slice(0) : [];\n    fs.defines = defined(fs.defines) ? fs.defines.slice(0) : [];\n\n    getShaderProgramFunction(vs, fs);\n\n    shader = context.shaderCache.createDerivedShaderProgram(\n      shaderProgram,\n      cacheName,\n      {\n        vertexShaderSource: vs,\n        fragmentShaderSource: fs,\n        attributeLocations: attributeLocations,\n      }\n    );\n  }\n\n  return shader;\n}\n\nfunction getOpaqueFrontFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.BACK;\n  renderState.cull.enabled = true;\n}\n\nfunction getOpaqueBackFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.FRONT;\n  renderState.cull.enabled = true;\n}\n\nfunction getDepthOnlyFrontFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.BACK;\n  renderState.cull.enabled = true;\n  renderState.colorMask = {\n    red: false,\n    green: false,\n    blue: false,\n    alpha: false,\n  };\n}\n\nfunction getDepthOnlyBackFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.FRONT;\n  renderState.cull.enabled = true;\n  renderState.colorMask = {\n    red: false,\n    green: false,\n    blue: false,\n    alpha: false,\n  };\n}\n\nfunction getDepthOnlyFrontAndBackFaceRenderState(renderState) {\n  renderState.cull.enabled = false;\n  renderState.colorMask = {\n    red: false,\n    green: false,\n    blue: false,\n    alpha: false,\n  };\n}\n\nfunction getTranslucentFrontFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.BACK;\n  renderState.cull.enabled = true;\n  renderState.depthMask = false;\n  renderState.blending = BlendingState.ALPHA_BLEND;\n}\n\nfunction getTranslucentBackFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.FRONT;\n  renderState.cull.enabled = true;\n  renderState.depthMask = false;\n  renderState.blending = BlendingState.ALPHA_BLEND;\n}\n\nfunction getPickFrontFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.BACK;\n  renderState.cull.enabled = true;\n  renderState.blending.enabled = false;\n}\n\nfunction getPickBackFaceRenderState(renderState) {\n  renderState.cull.face = CullFace.FRONT;\n  renderState.cull.enabled = true;\n  renderState.blending.enabled = false;\n}\n\nfunction getDerivedRenderState(\n  renderState,\n  derivedRenderState,\n  renderStateDirty,\n  getRenderStateFunction,\n  cache\n) {\n  if (!defined(getRenderStateFunction)) {\n    return renderState;\n  }\n\n  if (!renderStateDirty && defined(derivedRenderState)) {\n    return derivedRenderState;\n  }\n\n  var cachedRenderState = cache[renderState.id];\n  if (!defined(cachedRenderState)) {\n    var rs = RenderState.getState(renderState);\n    getRenderStateFunction(rs);\n    cachedRenderState = RenderState.fromCache(rs);\n    cache[renderState.id] = cachedRenderState;\n  }\n\n  return cachedRenderState;\n}\n\nfunction getTranslucencyUniformMap(state) {\n  return {\n    u_classificationTexture: function () {\n      return state._globeTranslucencyFramebuffer.classificationTexture;\n    },\n  };\n}\n\nfunction getDerivedUniformMap(\n  state,\n  uniformMap,\n  derivedUniformMap,\n  uniformMapDirty,\n  getDerivedUniformMapFunction\n) {\n  if (!defined(getDerivedUniformMapFunction)) {\n    return uniformMap;\n  }\n\n  if (!uniformMapDirty && defined(derivedUniformMap)) {\n    return derivedUniformMap;\n  }\n\n  return combine(uniformMap, getDerivedUniformMapFunction(state), false);\n}\n\nfunction DerivedCommandPack(options) {\n  this.pass = options.pass;\n  this.pickOnly = options.pickOnly;\n  this.getShaderProgramFunction = options.getShaderProgramFunction;\n  this.getRenderStateFunction = options.getRenderStateFunction;\n  this.getUniformMapFunction = options.getUniformMapFunction;\n  this.renderStateCache = {};\n}\n\nfunction createDerivedCommandPacks() {\n  return [\n    // opaqueFrontFaceCommand\n    new DerivedCommandPack({\n      pass: Pass.GLOBE,\n      pickOnly: false,\n      getShaderProgramFunction: getOpaqueFrontFaceShaderProgram,\n      getRenderStateFunction: getOpaqueFrontFaceRenderState,\n      getUniformMapFunction: undefined,\n    }),\n    // opaqueBackFaceCommand\n    new DerivedCommandPack({\n      pass: Pass.GLOBE,\n      pickOnly: false,\n      getShaderProgramFunction: getOpaqueBackFaceShaderProgram,\n      getRenderStateFunction: getOpaqueBackFaceRenderState,\n      getUniformMapFunction: undefined,\n    }),\n    // depthOnlyFrontFaceCommand\n    new DerivedCommandPack({\n      pass: Pass.GLOBE,\n      pickOnly: false,\n      getShaderProgramFunction: getDepthOnlyShaderProgram,\n      getRenderStateFunction: getDepthOnlyFrontFaceRenderState,\n      getUniformMapFunction: undefined,\n    }),\n    // depthOnlyBackFaceCommand\n    new DerivedCommandPack({\n      pass: Pass.GLOBE,\n      pickOnly: false,\n      getShaderProgramFunction: getDepthOnlyShaderProgram,\n      getRenderStateFunction: getDepthOnlyBackFaceRenderState,\n      getUniformMapFunction: undefined,\n    }),\n    // depthOnlyFrontAndBackFaceCommand\n    new DerivedCommandPack({\n      pass: Pass.GLOBE,\n      pickOnly: false,\n      getShaderProgramFunction: getDepthOnlyShaderProgram,\n      getRenderStateFunction: getDepthOnlyFrontAndBackFaceRenderState,\n      getUniformMapFunction: undefined,\n    }),\n    // translucentFrontFaceCommand\n    new DerivedCommandPack({\n      pass: Pass.TRANSLUCENT,\n      pickOnly: false,\n      getShaderProgramFunction: getTranslucentShaderProgram,\n      getRenderStateFunction: getTranslucentFrontFaceRenderState,\n      getUniformMapFunction: getTranslucencyUniformMap,\n    }),\n    // translucentBackFaceCommand\n    new DerivedCommandPack({\n      pass: Pass.TRANSLUCENT,\n      pickOnly: false,\n      getShaderProgramFunction: getTranslucentBackFaceShaderProgram,\n      getRenderStateFunction: getTranslucentBackFaceRenderState,\n      getUniformMapFunction: getTranslucencyUniformMap,\n    }),\n    // translucentFrontFaceManualDepthTestCommand\n    new DerivedCommandPack({\n      pass: Pass.TRANSLUCENT,\n      pickOnly: false,\n      getShaderProgramFunction: getTranslucentFrontFaceManualDepthTestShaderProgram,\n      getRenderStateFunction: getTranslucentFrontFaceRenderState,\n      getUniformMapFunction: getTranslucencyUniformMap,\n    }),\n    // translucentBackFaceManualDepthTestCommand\n    new DerivedCommandPack({\n      pass: Pass.TRANSLUCENT,\n      pickOnly: false,\n      getShaderProgramFunction: getTranslucentBackFaceManualDepthTestShaderProgram,\n      getRenderStateFunction: getTranslucentBackFaceRenderState,\n      getUniformMapFunction: getTranslucencyUniformMap,\n    }),\n    // pickFrontFaceCommand\n    new DerivedCommandPack({\n      pass: Pass.TRANSLUCENT,\n      pickOnly: true,\n      getShaderProgramFunction: getPickShaderProgram,\n      getRenderStateFunction: getPickFrontFaceRenderState,\n      getUniformMapFunction: getTranslucencyUniformMap,\n    }),\n    // pickBackFaceCommand\n    new DerivedCommandPack({\n      pass: Pass.TRANSLUCENT,\n      pickOnly: true,\n      getShaderProgramFunction: getPickShaderProgram,\n      getRenderStateFunction: getPickBackFaceRenderState,\n      getUniformMapFunction: getTranslucencyUniformMap,\n    }),\n  ];\n}\n\nvar derivedCommandNames = new Array(derivedCommandsMaximumLength);\nvar derivedCommandPacks = new Array(derivedCommandsMaximumLength);\n\nGlobeTranslucencyState.prototype.updateDerivedCommands = function (\n  command,\n  frameState\n) {\n  var derivedCommandTypes = this._derivedCommandTypesToUpdate;\n  var derivedCommandsLength = this._derivedCommandsToUpdateLength;\n\n  if (derivedCommandsLength === 0) {\n    return;\n  }\n\n  for (var i = 0; i < derivedCommandsLength; ++i) {\n    derivedCommandPacks[i] = this._derivedCommandPacks[derivedCommandTypes[i]];\n    derivedCommandNames[i] = DerivedCommandNames[derivedCommandTypes[i]];\n  }\n\n  updateDerivedCommands(\n    this,\n    command,\n    derivedCommandsLength,\n    derivedCommandTypes,\n    derivedCommandNames,\n    derivedCommandPacks,\n    frameState\n  );\n};\n\nfunction updateDerivedCommands(\n  state,\n  command,\n  derivedCommandsLength,\n  derivedCommandTypes,\n  derivedCommandNames,\n  derivedCommandPacks,\n  frameState\n) {\n  var derivedCommandsObject = command.derivedCommands.globeTranslucency;\n  var derivedCommandsDirty = state._derivedCommandsDirty;\n\n  if (\n    command.dirty ||\n    !defined(derivedCommandsObject) ||\n    derivedCommandsDirty\n  ) {\n    command.dirty = false;\n\n    if (!defined(derivedCommandsObject)) {\n      derivedCommandsObject = {};\n      command.derivedCommands.globeTranslucency = derivedCommandsObject;\n    }\n\n    var frameNumber = frameState.frameNumber;\n\n    var uniformMapDirtyFrame = defaultValue(\n      derivedCommandsObject.uniformMapDirtyFrame,\n      0\n    );\n    var shaderProgramDirtyFrame = defaultValue(\n      derivedCommandsObject.shaderProgramDirtyFrame,\n      0\n    );\n    var renderStateDirtyFrame = defaultValue(\n      derivedCommandsObject.renderStateDirtyFrame,\n      0\n    );\n\n    var uniformMapDirty =\n      derivedCommandsObject.uniformMap !== command.uniformMap;\n\n    var shaderProgramDirty =\n      derivedCommandsObject.shaderProgramId !== command.shaderProgram.id;\n\n    var renderStateDirty =\n      derivedCommandsObject.renderStateId !== command.renderState.id;\n\n    if (uniformMapDirty) {\n      derivedCommandsObject.uniformMapDirtyFrame = frameNumber;\n    }\n    if (shaderProgramDirty) {\n      derivedCommandsObject.shaderProgramDirtyFrame = frameNumber;\n    }\n    if (renderStateDirty) {\n      derivedCommandsObject.renderStateDirtyFrame = frameNumber;\n    }\n\n    derivedCommandsObject.uniformMap = command.uniformMap;\n    derivedCommandsObject.shaderProgramId = command.shaderProgram.id;\n    derivedCommandsObject.renderStateId = command.renderState.id;\n\n    for (var i = 0; i < derivedCommandsLength; ++i) {\n      var derivedCommandPack = derivedCommandPacks[i];\n      var derivedCommandType = derivedCommandTypes[i];\n      var derivedCommandName = derivedCommandNames[i];\n      var derivedCommand = derivedCommandsObject[derivedCommandName];\n\n      var derivedUniformMap;\n      var derivedShaderProgram;\n      var derivedRenderState;\n\n      if (defined(derivedCommand)) {\n        derivedUniformMap = derivedCommand.uniformMap;\n        derivedShaderProgram = derivedCommand.shaderProgram;\n        derivedRenderState = derivedCommand.renderState;\n      } else {\n        derivedUniformMap = undefined;\n        derivedShaderProgram = undefined;\n        derivedRenderState = undefined;\n      }\n\n      derivedCommand = DrawCommand.shallowClone(command, derivedCommand);\n      derivedCommandsObject[derivedCommandName] = derivedCommand;\n\n      var derivedUniformMapDirtyFrame = defaultValue(\n        derivedCommand.derivedCommands.uniformMapDirtyFrame,\n        0\n      );\n      var derivedShaderProgramDirtyFrame = defaultValue(\n        derivedCommand.derivedCommands.shaderProgramDirtyFrame,\n        0\n      );\n      var derivedRenderStateDirtyFrame = defaultValue(\n        derivedCommand.derivedCommands.renderStateDirtyFrame,\n        0\n      );\n\n      var derivedUniformMapDirty =\n        uniformMapDirty || derivedUniformMapDirtyFrame < uniformMapDirtyFrame;\n      var derivedShaderProgramDirty =\n        shaderProgramDirty ||\n        derivedShaderProgramDirtyFrame < shaderProgramDirtyFrame;\n      var derivedRenderStateDirty =\n        renderStateDirty ||\n        derivedRenderStateDirtyFrame < renderStateDirtyFrame;\n\n      if (derivedUniformMapDirty) {\n        derivedCommand.derivedCommands.uniformMapDirtyFrame = frameNumber;\n      }\n      if (derivedShaderProgramDirty) {\n        derivedCommand.derivedCommands.shaderProgramDirtyFrame = frameNumber;\n      }\n      if (derivedRenderStateDirty) {\n        derivedCommand.derivedCommands.renderStateDirtyFrame = frameNumber;\n      }\n\n      derivedCommand.derivedCommands.type = derivedCommandType;\n      derivedCommand.pass = derivedCommandPack.pass;\n      derivedCommand.pickOnly = derivedCommandPack.pickOnly;\n      derivedCommand.uniformMap = getDerivedUniformMap(\n        state,\n        command.uniformMap,\n        derivedUniformMap,\n        derivedUniformMapDirty,\n        derivedCommandPack.getUniformMapFunction\n      );\n      derivedCommand.shaderProgram = getDerivedShaderProgram(\n        frameState.context,\n        command.shaderProgram,\n        derivedShaderProgram,\n        derivedShaderProgramDirty,\n        derivedCommandPack.getShaderProgramFunction,\n        derivedCommandName\n      );\n      derivedCommand.renderState = getDerivedRenderState(\n        command.renderState,\n        derivedRenderState,\n        derivedRenderStateDirty,\n        derivedCommandPack.getRenderStateFunction,\n        derivedCommandPack.renderStateCache\n      );\n    }\n  }\n}\n\nGlobeTranslucencyState.prototype.pushDerivedCommands = function (\n  command,\n  isBlendCommand,\n  frameState\n) {\n  var picking = frameState.passes.pick;\n  if (picking && isBlendCommand) {\n    // No need to push blend commands in the pick pass\n    return;\n  }\n\n  var derivedCommandTypes = this._derivedCommandTypes;\n  var derivedCommandsLength = this._derivedCommandsLength;\n\n  if (picking) {\n    derivedCommandTypes = this._derivedPickCommandTypes;\n    derivedCommandsLength = this._derivedPickCommandsLength;\n  } else if (isBlendCommand) {\n    derivedCommandTypes = this._derivedBlendCommandTypes;\n    derivedCommandsLength = this._derivedBlendCommandsLength;\n  }\n\n  if (derivedCommandsLength === 0) {\n    // No derived commands to push so just push the globe command\n    frameState.commandList.push(command);\n    return;\n  }\n\n  // Push derived commands\n  var derivedCommands = command.derivedCommands.globeTranslucency;\n  for (var i = 0; i < derivedCommandsLength; ++i) {\n    var derivedCommandName = DerivedCommandNames[derivedCommandTypes[i]];\n    frameState.commandList.push(derivedCommands[derivedCommandName]);\n  }\n};\n\nfunction executeCommandsMatchingType(\n  commands,\n  commandsLength,\n  executeCommandFunction,\n  scene,\n  context,\n  passState,\n  types\n) {\n  for (var i = 0; i < commandsLength; ++i) {\n    var command = commands[i];\n    var type = command.derivedCommands.type;\n    if (!defined(types) || types.indexOf(type) > -1) {\n      executeCommandFunction(command, scene, context, passState);\n    }\n  }\n}\n\nfunction executeCommands(\n  commands,\n  commandsLength,\n  executeCommandFunction,\n  scene,\n  context,\n  passState\n) {\n  for (var i = 0; i < commandsLength; ++i) {\n    executeCommandFunction(commands[i], scene, context, passState);\n  }\n}\n\nvar opaqueTypes = [\n  DerivedCommandType.OPAQUE_FRONT_FACE,\n  DerivedCommandType.OPAQUE_BACK_FACE,\n];\nvar depthOnlyTypes = [\n  DerivedCommandType.DEPTH_ONLY_FRONT_FACE,\n  DerivedCommandType.DEPTH_ONLY_BACK_FACE,\n  DerivedCommandType.DEPTH_ONLY_FRONT_AND_BACK_FACE,\n];\n\nGlobeTranslucencyState.prototype.executeGlobeCommands = function (\n  frustumCommands,\n  executeCommandFunction,\n  globeTranslucencyFramebuffer,\n  scene,\n  passState\n) {\n  var context = scene.context;\n  var globeCommands = frustumCommands.commands[Pass.GLOBE];\n  var globeCommandsLength = frustumCommands.indices[Pass.GLOBE];\n\n  if (globeCommandsLength === 0) {\n    return;\n  }\n\n  this._globeTranslucencyFramebuffer = globeTranslucencyFramebuffer;\n  globeTranslucencyFramebuffer.clearClassification(context, passState);\n\n  // Render opaque commands like normal\n  executeCommandsMatchingType(\n    globeCommands,\n    globeCommandsLength,\n    executeCommandFunction,\n    scene,\n    context,\n    passState,\n    opaqueTypes\n  );\n};\n\nGlobeTranslucencyState.prototype.executeGlobeClassificationCommands = function (\n  frustumCommands,\n  executeCommandFunction,\n  globeTranslucencyFramebuffer,\n  scene,\n  passState\n) {\n  var context = scene.context;\n  var globeCommands = frustumCommands.commands[Pass.GLOBE];\n  var globeCommandsLength = frustumCommands.indices[Pass.GLOBE];\n  var classificationCommands =\n    frustumCommands.commands[Pass.TERRAIN_CLASSIFICATION];\n  var classificationCommandsLength =\n    frustumCommands.indices[Pass.TERRAIN_CLASSIFICATION];\n\n  if (globeCommandsLength === 0 || classificationCommandsLength === 0) {\n    return;\n  }\n\n  var frontTranslucent = this._frontFaceTranslucent;\n  var backTranslucent = this._backFaceTranslucent;\n\n  if (!frontTranslucent || !backTranslucent) {\n    // Render classification on opaque faces like normal\n    executeCommands(\n      classificationCommands,\n      classificationCommandsLength,\n      executeCommandFunction,\n      scene,\n      context,\n      passState\n    );\n  }\n\n  if (!frontTranslucent && !backTranslucent) {\n    // No translucent commands to render. Skip translucent classification.\n    return;\n  }\n\n  this._globeTranslucencyFramebuffer = globeTranslucencyFramebuffer;\n\n  var originalGlobeDepthTexture = context.uniformState.globeDepthTexture;\n  var originalFramebuffer = passState.framebuffer;\n\n  // Render to internal framebuffer and get the first depth peel\n  passState.framebuffer =\n    globeTranslucencyFramebuffer.classificationFramebuffer;\n\n  executeCommandsMatchingType(\n    globeCommands,\n    globeCommandsLength,\n    executeCommandFunction,\n    scene,\n    context,\n    passState,\n    depthOnlyTypes\n  );\n\n  if (context.depthTexture) {\n    // Pack depth into separate texture for ground polylines and textured ground primitives\n    var packedDepthTexture = globeTranslucencyFramebuffer.packDepth(\n      context,\n      passState\n    );\n    context.uniformState.globeDepthTexture = packedDepthTexture;\n  }\n\n  // Render classification on translucent faces\n  executeCommands(\n    classificationCommands,\n    classificationCommandsLength,\n    executeCommandFunction,\n    scene,\n    context,\n    passState\n  );\n\n  // Unset temporary state\n  context.uniformState.globeDepthTexture = originalGlobeDepthTexture;\n  passState.framebuffer = originalFramebuffer;\n};\n\nexport default GlobeTranslucencyState;\n"]},"metadata":{},"sourceType":"module"}