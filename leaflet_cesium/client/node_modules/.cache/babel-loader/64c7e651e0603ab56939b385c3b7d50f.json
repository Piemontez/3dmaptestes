{"ast":null,"code":"import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport Intersections2D from \"./Intersections2D.js\";\nimport CesiumMath from \"./Math.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\nimport QuantizedMeshTerrainData from \"./QuantizedMeshTerrainData.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport TaskProcessor from \"./TaskProcessor.js\";\nimport TerrainData from \"./TerrainData.js\";\nimport TerrainEncoding from \"./TerrainEncoding.js\";\nimport TerrainMesh from \"./TerrainMesh.js\";\n/**\n * Terrain data for a single tile from a Google Earth Enterprise server.\n *\n * @alias GoogleEarthEnterpriseTerrainData\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {ArrayBuffer} options.buffer The buffer containing terrain data.\n * @param {Number} options.negativeAltitudeExponentBias Multiplier for negative terrain heights that are encoded as very small positive values.\n * @param {Number} options.negativeElevationThreshold Threshold for negative values\n * @param {Number} [options.childTileMask=15] A bit mask indicating which of this tile's four children exist.\n *                 If a child's bit is set, geometry will be requested for that tile as well when it\n *                 is needed.  If the bit is cleared, the child tile is not requested and geometry is\n *                 instead upsampled from the parent.  The bit values are as follows:\n *                 <table>\n *                  <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>\n *                  <tr><td>0</td><td>1</td><td>Southwest</td></tr>\n *                  <tr><td>1</td><td>2</td><td>Southeast</td></tr>\n *                  <tr><td>2</td><td>4</td><td>Northeast</td></tr>\n *                  <tr><td>3</td><td>8</td><td>Northwest</td></tr>\n *                 </table>\n * @param {Boolean} [options.createdByUpsampling=false] True if this instance was created by upsampling another instance;\n *                  otherwise, false.\n * @param {Credit[]} [options.credits] Array of credits for this tile.\n *\n *\n * @example\n * var buffer = ...\n * var childTileMask = ...\n * var terrainData = new Cesium.GoogleEarthEnterpriseTerrainData({\n *   buffer : heightBuffer,\n *   childTileMask : childTileMask\n * });\n *\n * @see TerrainData\n * @see HeightmapTerrainData\n * @see QuantizedMeshTerrainData\n */\n\nfunction GoogleEarthEnterpriseTerrainData(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT); //>>includeStart('debug', pragmas.debug);\n\n  Check.typeOf.object(\"options.buffer\", options.buffer);\n  Check.typeOf.number(\"options.negativeAltitudeExponentBias\", options.negativeAltitudeExponentBias);\n  Check.typeOf.number(\"options.negativeElevationThreshold\", options.negativeElevationThreshold); //>>includeEnd('debug');\n\n  this._buffer = options.buffer;\n  this._credits = options.credits;\n  this._negativeAltitudeExponentBias = options.negativeAltitudeExponentBias;\n  this._negativeElevationThreshold = options.negativeElevationThreshold; // Convert from google layout to layout of other providers\n  // 3 2 -> 2 3\n  // 0 1 -> 0 1\n\n  var googleChildTileMask = defaultValue(options.childTileMask, 15);\n  var childTileMask = googleChildTileMask & 3; // Bottom row is identical\n\n  childTileMask |= googleChildTileMask & 4 ? 8 : 0; // NE\n\n  childTileMask |= googleChildTileMask & 8 ? 4 : 0; // NW\n\n  this._childTileMask = childTileMask;\n  this._createdByUpsampling = defaultValue(options.createdByUpsampling, false);\n  this._skirtHeight = undefined;\n  this._bufferType = this._buffer.constructor;\n  this._mesh = undefined;\n  this._minimumHeight = undefined;\n  this._maximumHeight = undefined;\n}\n\nObject.defineProperties(GoogleEarthEnterpriseTerrainData.prototype, {\n  /**\n   * An array of credits for this tile\n   * @memberof GoogleEarthEnterpriseTerrainData.prototype\n   * @type {Credit[]}\n   */\n  credits: {\n    get: function () {\n      return this._credits;\n    }\n  },\n\n  /**\n   * The water mask included in this terrain data, if any.  A water mask is a rectangular\n   * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.\n   * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.\n   * @memberof GoogleEarthEnterpriseTerrainData.prototype\n   * @type {Uint8Array|HTMLImageElement|HTMLCanvasElement}\n   */\n  waterMask: {\n    get: function () {\n      return undefined;\n    }\n  }\n});\nvar createMeshTaskName = \"createVerticesFromGoogleEarthEnterpriseBuffer\";\nvar createMeshTaskProcessorNoThrottle = new TaskProcessor(createMeshTaskName);\nvar createMeshTaskProcessorThrottle = new TaskProcessor(createMeshTaskName, TerrainData.maximumAsynchronousTasks);\nvar nativeRectangleScratch = new Rectangle();\nvar rectangleScratch = new Rectangle();\n/**\n * Creates a {@link TerrainMesh} from this terrain data.\n *\n * @private\n *\n * @param {Object} options Object with the following properties:\n * @param {TilingScheme} options.tilingScheme The tiling scheme to which this tile belongs.\n * @param {Number} options.x The X coordinate of the tile for which to create the terrain data.\n * @param {Number} options.y The Y coordinate of the tile for which to create the terrain data.\n * @param {Number} options.level The level of the tile for which to create the terrain data.\n * @param {Number} [options.exaggeration=1.0] The scale used to exaggerate the terrain.\n * @param {Boolean} [options.throttle=true] If true, indicates that this operation will need to be retried if too many asynchronous mesh creations are already in progress.\n * @returns {Promise.<TerrainMesh>|undefined} A promise for the terrain mesh, or undefined if too many\n *          asynchronous mesh creations are already in progress and the operation should\n *          be retried later.\n */\n\nGoogleEarthEnterpriseTerrainData.prototype.createMesh = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT); //>>includeStart('debug', pragmas.debug);\n\n  Check.typeOf.object(\"options.tilingScheme\", options.tilingScheme);\n  Check.typeOf.number(\"options.x\", options.x);\n  Check.typeOf.number(\"options.y\", options.y);\n  Check.typeOf.number(\"options.level\", options.level); //>>includeEnd('debug');\n\n  var tilingScheme = options.tilingScheme;\n  var x = options.x;\n  var y = options.y;\n  var level = options.level;\n  var exaggeration = defaultValue(options.exaggeration, 1.0);\n  var throttle = defaultValue(options.throttle, true);\n  var ellipsoid = tilingScheme.ellipsoid;\n  tilingScheme.tileXYToNativeRectangle(x, y, level, nativeRectangleScratch);\n  tilingScheme.tileXYToRectangle(x, y, level, rectangleScratch); // Compute the center of the tile for RTC rendering.\n\n  var center = ellipsoid.cartographicToCartesian(Rectangle.center(rectangleScratch));\n  var levelZeroMaxError = 40075.16; // From Google's Doc\n\n  var thisLevelMaxError = levelZeroMaxError / (1 << level);\n  this._skirtHeight = Math.min(thisLevelMaxError * 8.0, 1000.0);\n  var createMeshTaskProcessor = throttle ? createMeshTaskProcessorThrottle : createMeshTaskProcessorNoThrottle;\n  var verticesPromise = createMeshTaskProcessor.scheduleTask({\n    buffer: this._buffer,\n    nativeRectangle: nativeRectangleScratch,\n    rectangle: rectangleScratch,\n    relativeToCenter: center,\n    ellipsoid: ellipsoid,\n    skirtHeight: this._skirtHeight,\n    exaggeration: exaggeration,\n    includeWebMercatorT: true,\n    negativeAltitudeExponentBias: this._negativeAltitudeExponentBias,\n    negativeElevationThreshold: this._negativeElevationThreshold\n  });\n\n  if (!defined(verticesPromise)) {\n    // Postponed\n    return undefined;\n  }\n\n  var that = this;\n  return verticesPromise.then(function (result) {\n    // Clone complex result objects because the transfer from the web worker\n    // has stripped them down to JSON-style objects.\n    that._mesh = new TerrainMesh(center, new Float32Array(result.vertices), new Uint16Array(result.indices), result.indexCountWithoutSkirts, result.vertexCountWithoutSkirts, result.minimumHeight, result.maximumHeight, BoundingSphere.clone(result.boundingSphere3D), Cartesian3.clone(result.occludeePointInScaledSpace), result.numberOfAttributes, OrientedBoundingBox.clone(result.orientedBoundingBox), TerrainEncoding.clone(result.encoding), exaggeration, result.westIndicesSouthToNorth, result.southIndicesEastToWest, result.eastIndicesNorthToSouth, result.northIndicesWestToEast);\n    that._minimumHeight = result.minimumHeight;\n    that._maximumHeight = result.maximumHeight; // Free memory received from server after mesh is created.\n\n    that._buffer = undefined;\n    return that._mesh;\n  });\n};\n/**\n * Computes the terrain height at a specified longitude and latitude.\n *\n * @param {Rectangle} rectangle The rectangle covered by this terrain data.\n * @param {Number} longitude The longitude in radians.\n * @param {Number} latitude The latitude in radians.\n * @returns {Number} The terrain height at the specified position.  If the position\n *          is outside the rectangle, this method will extrapolate the height, which is likely to be wildly\n *          incorrect for positions far outside the rectangle.\n */\n\n\nGoogleEarthEnterpriseTerrainData.prototype.interpolateHeight = function (rectangle, longitude, latitude) {\n  var u = CesiumMath.clamp((longitude - rectangle.west) / rectangle.width, 0.0, 1.0);\n  var v = CesiumMath.clamp((latitude - rectangle.south) / rectangle.height, 0.0, 1.0);\n\n  if (!defined(this._mesh)) {\n    return interpolateHeight(this, u, v, rectangle);\n  }\n\n  return interpolateMeshHeight(this, u, v);\n};\n\nvar upsampleTaskProcessor = new TaskProcessor(\"upsampleQuantizedTerrainMesh\", TerrainData.maximumAsynchronousTasks);\n/**\n * Upsamples this terrain data for use by a descendant tile.  The resulting instance will contain a subset of the\n * height samples in this instance, interpolated if necessary.\n *\n * @param {TilingScheme} tilingScheme The tiling scheme of this terrain data.\n * @param {Number} thisX The X coordinate of this tile in the tiling scheme.\n * @param {Number} thisY The Y coordinate of this tile in the tiling scheme.\n * @param {Number} thisLevel The level of this tile in the tiling scheme.\n * @param {Number} descendantX The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {Number} descendantY The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {Number} descendantLevel The level within the tiling scheme of the descendant tile for which we are upsampling.\n * @returns {Promise.<HeightmapTerrainData>|undefined} A promise for upsampled heightmap terrain data for the descendant tile,\n *          or undefined if too many asynchronous upsample operations are in progress and the request has been\n *          deferred.\n */\n\nGoogleEarthEnterpriseTerrainData.prototype.upsample = function (tilingScheme, thisX, thisY, thisLevel, descendantX, descendantY, descendantLevel) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"tilingScheme\", tilingScheme);\n  Check.typeOf.number(\"thisX\", thisX);\n  Check.typeOf.number(\"thisY\", thisY);\n  Check.typeOf.number(\"thisLevel\", thisLevel);\n  Check.typeOf.number(\"descendantX\", descendantX);\n  Check.typeOf.number(\"descendantY\", descendantY);\n  Check.typeOf.number(\"descendantLevel\", descendantLevel);\n  var levelDifference = descendantLevel - thisLevel;\n\n  if (levelDifference > 1) {\n    throw new DeveloperError(\"Upsampling through more than one level at a time is not currently supported.\");\n  } //>>includeEnd('debug');\n\n\n  var mesh = this._mesh;\n\n  if (!defined(this._mesh)) {\n    return undefined;\n  }\n\n  var isEastChild = thisX * 2 !== descendantX;\n  var isNorthChild = thisY * 2 === descendantY;\n  var ellipsoid = tilingScheme.ellipsoid;\n  var childRectangle = tilingScheme.tileXYToRectangle(descendantX, descendantY, descendantLevel);\n  var upsamplePromise = upsampleTaskProcessor.scheduleTask({\n    vertices: mesh.vertices,\n    indices: mesh.indices,\n    indexCountWithoutSkirts: mesh.indexCountWithoutSkirts,\n    vertexCountWithoutSkirts: mesh.vertexCountWithoutSkirts,\n    encoding: mesh.encoding,\n    minimumHeight: this._minimumHeight,\n    maximumHeight: this._maximumHeight,\n    isEastChild: isEastChild,\n    isNorthChild: isNorthChild,\n    childRectangle: childRectangle,\n    ellipsoid: ellipsoid,\n    exaggeration: mesh.exaggeration\n  });\n\n  if (!defined(upsamplePromise)) {\n    // Postponed\n    return undefined;\n  }\n\n  var that = this;\n  return upsamplePromise.then(function (result) {\n    var quantizedVertices = new Uint16Array(result.vertices);\n    var indicesTypedArray = IndexDatatype.createTypedArray(quantizedVertices.length / 3, result.indices);\n    var skirtHeight = that._skirtHeight; // Use QuantizedMeshTerrainData since we have what we need already parsed\n\n    return new QuantizedMeshTerrainData({\n      quantizedVertices: quantizedVertices,\n      indices: indicesTypedArray,\n      minimumHeight: result.minimumHeight,\n      maximumHeight: result.maximumHeight,\n      boundingSphere: BoundingSphere.clone(result.boundingSphere),\n      orientedBoundingBox: OrientedBoundingBox.clone(result.orientedBoundingBox),\n      horizonOcclusionPoint: Cartesian3.clone(result.horizonOcclusionPoint),\n      westIndices: result.westIndices,\n      southIndices: result.southIndices,\n      eastIndices: result.eastIndices,\n      northIndices: result.northIndices,\n      westSkirtHeight: skirtHeight,\n      southSkirtHeight: skirtHeight,\n      eastSkirtHeight: skirtHeight,\n      northSkirtHeight: skirtHeight,\n      childTileMask: 0,\n      createdByUpsampling: true,\n      credits: that._credits\n    });\n  });\n};\n/**\n * Determines if a given child tile is available, based on the\n * {@link HeightmapTerrainData.childTileMask}.  The given child tile coordinates are assumed\n * to be one of the four children of this tile.  If non-child tile coordinates are\n * given, the availability of the southeast child tile is returned.\n *\n * @param {Number} thisX The tile X coordinate of this (the parent) tile.\n * @param {Number} thisY The tile Y coordinate of this (the parent) tile.\n * @param {Number} childX The tile X coordinate of the child tile to check for availability.\n * @param {Number} childY The tile Y coordinate of the child tile to check for availability.\n * @returns {Boolean} True if the child tile is available; otherwise, false.\n */\n\n\nGoogleEarthEnterpriseTerrainData.prototype.isChildAvailable = function (thisX, thisY, childX, childY) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"thisX\", thisX);\n  Check.typeOf.number(\"thisY\", thisY);\n  Check.typeOf.number(\"childX\", childX);\n  Check.typeOf.number(\"childY\", childY); //>>includeEnd('debug');\n\n  var bitNumber = 2; // northwest child\n\n  if (childX !== thisX * 2) {\n    ++bitNumber; // east child\n  }\n\n  if (childY !== thisY * 2) {\n    bitNumber -= 2; // south child\n  }\n\n  return (this._childTileMask & 1 << bitNumber) !== 0;\n};\n/**\n * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution\n * terrain data.  If this value is false, the data was obtained from some other source, such\n * as by downloading it from a remote server.  This method should return true for instances\n * returned from a call to {@link HeightmapTerrainData#upsample}.\n *\n * @returns {Boolean} True if this instance was created by upsampling; otherwise, false.\n */\n\n\nGoogleEarthEnterpriseTerrainData.prototype.wasCreatedByUpsampling = function () {\n  return this._createdByUpsampling;\n};\n\nvar texCoordScratch0 = new Cartesian2();\nvar texCoordScratch1 = new Cartesian2();\nvar texCoordScratch2 = new Cartesian2();\nvar barycentricCoordinateScratch = new Cartesian3();\n\nfunction interpolateMeshHeight(terrainData, u, v) {\n  var mesh = terrainData._mesh;\n  var vertices = mesh.vertices;\n  var encoding = mesh.encoding;\n  var indices = mesh.indices;\n\n  for (var i = 0, len = indices.length; i < len; i += 3) {\n    var i0 = indices[i];\n    var i1 = indices[i + 1];\n    var i2 = indices[i + 2];\n    var uv0 = encoding.decodeTextureCoordinates(vertices, i0, texCoordScratch0);\n    var uv1 = encoding.decodeTextureCoordinates(vertices, i1, texCoordScratch1);\n    var uv2 = encoding.decodeTextureCoordinates(vertices, i2, texCoordScratch2);\n    var barycentric = Intersections2D.computeBarycentricCoordinates(u, v, uv0.x, uv0.y, uv1.x, uv1.y, uv2.x, uv2.y, barycentricCoordinateScratch);\n\n    if (barycentric.x >= -1e-15 && barycentric.y >= -1e-15 && barycentric.z >= -1e-15) {\n      var h0 = encoding.decodeHeight(vertices, i0);\n      var h1 = encoding.decodeHeight(vertices, i1);\n      var h2 = encoding.decodeHeight(vertices, i2);\n      return barycentric.x * h0 + barycentric.y * h1 + barycentric.z * h2;\n    }\n  } // Position does not lie in any triangle in this mesh.\n\n\n  return undefined;\n}\n\nvar sizeOfUint16 = Uint16Array.BYTES_PER_ELEMENT;\nvar sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;\nvar sizeOfInt32 = Int32Array.BYTES_PER_ELEMENT;\nvar sizeOfFloat = Float32Array.BYTES_PER_ELEMENT;\nvar sizeOfDouble = Float64Array.BYTES_PER_ELEMENT;\n\nfunction interpolateHeight(terrainData, u, v, rectangle) {\n  var buffer = terrainData._buffer;\n  var quad = 0; // SW\n\n  var uStart = 0.0;\n  var vStart = 0.0;\n\n  if (v > 0.5) {\n    // Upper row\n    if (u > 0.5) {\n      // NE\n      quad = 2;\n      uStart = 0.5;\n    } else {\n      // NW\n      quad = 3;\n    }\n\n    vStart = 0.5;\n  } else if (u > 0.5) {\n    // SE\n    quad = 1;\n    uStart = 0.5;\n  }\n\n  var dv = new DataView(buffer);\n  var offset = 0;\n\n  for (var q = 0; q < quad; ++q) {\n    offset += dv.getUint32(offset, true);\n    offset += sizeOfUint32;\n  }\n\n  offset += sizeOfUint32; // Skip length of quad\n\n  offset += 2 * sizeOfDouble; // Skip origin\n  // Read sizes\n\n  var xSize = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\n  offset += sizeOfDouble;\n  var ySize = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\n  offset += sizeOfDouble; // Samples per quad\n\n  var xScale = rectangle.width / xSize / 2;\n  var yScale = rectangle.height / ySize / 2; // Number of points\n\n  var numPoints = dv.getInt32(offset, true);\n  offset += sizeOfInt32; // Number of faces\n\n  var numIndices = dv.getInt32(offset, true) * 3;\n  offset += sizeOfInt32;\n  offset += sizeOfInt32; // Skip Level\n\n  var uBuffer = new Array(numPoints);\n  var vBuffer = new Array(numPoints);\n  var heights = new Array(numPoints);\n  var i;\n\n  for (i = 0; i < numPoints; ++i) {\n    uBuffer[i] = uStart + dv.getUint8(offset++) * xScale;\n    vBuffer[i] = vStart + dv.getUint8(offset++) * yScale; // Height is stored in units of (1/EarthRadius) or (1/6371010.0)\n\n    heights[i] = dv.getFloat32(offset, true) * 6371010.0;\n    offset += sizeOfFloat;\n  }\n\n  var indices = new Array(numIndices);\n\n  for (i = 0; i < numIndices; ++i) {\n    indices[i] = dv.getUint16(offset, true);\n    offset += sizeOfUint16;\n  }\n\n  for (i = 0; i < numIndices; i += 3) {\n    var i0 = indices[i];\n    var i1 = indices[i + 1];\n    var i2 = indices[i + 2];\n    var u0 = uBuffer[i0];\n    var u1 = uBuffer[i1];\n    var u2 = uBuffer[i2];\n    var v0 = vBuffer[i0];\n    var v1 = vBuffer[i1];\n    var v2 = vBuffer[i2];\n    var barycentric = Intersections2D.computeBarycentricCoordinates(u, v, u0, v0, u1, v1, u2, v2, barycentricCoordinateScratch);\n\n    if (barycentric.x >= -1e-15 && barycentric.y >= -1e-15 && barycentric.z >= -1e-15) {\n      return barycentric.x * heights[i0] + barycentric.y * heights[i1] + barycentric.z * heights[i2];\n    }\n  } // Position does not lie in any triangle in this mesh.\n\n\n  return undefined;\n}\n\nexport default GoogleEarthEnterpriseTerrainData;","map":{"version":3,"sources":["/home/usuario/davi/thalamus/wms/3dmaptestes/leaflet_cesium/client/node_modules/cesium/Source/Core/GoogleEarthEnterpriseTerrainData.js"],"names":["BoundingSphere","Cartesian2","Cartesian3","Check","defaultValue","defined","DeveloperError","IndexDatatype","Intersections2D","CesiumMath","OrientedBoundingBox","QuantizedMeshTerrainData","Rectangle","TaskProcessor","TerrainData","TerrainEncoding","TerrainMesh","GoogleEarthEnterpriseTerrainData","options","EMPTY_OBJECT","typeOf","object","buffer","number","negativeAltitudeExponentBias","negativeElevationThreshold","_buffer","_credits","credits","_negativeAltitudeExponentBias","_negativeElevationThreshold","googleChildTileMask","childTileMask","_childTileMask","_createdByUpsampling","createdByUpsampling","_skirtHeight","undefined","_bufferType","constructor","_mesh","_minimumHeight","_maximumHeight","Object","defineProperties","prototype","get","waterMask","createMeshTaskName","createMeshTaskProcessorNoThrottle","createMeshTaskProcessorThrottle","maximumAsynchronousTasks","nativeRectangleScratch","rectangleScratch","createMesh","tilingScheme","x","y","level","exaggeration","throttle","ellipsoid","tileXYToNativeRectangle","tileXYToRectangle","center","cartographicToCartesian","levelZeroMaxError","thisLevelMaxError","Math","min","createMeshTaskProcessor","verticesPromise","scheduleTask","nativeRectangle","rectangle","relativeToCenter","skirtHeight","includeWebMercatorT","that","then","result","Float32Array","vertices","Uint16Array","indices","indexCountWithoutSkirts","vertexCountWithoutSkirts","minimumHeight","maximumHeight","clone","boundingSphere3D","occludeePointInScaledSpace","numberOfAttributes","orientedBoundingBox","encoding","westIndicesSouthToNorth","southIndicesEastToWest","eastIndicesNorthToSouth","northIndicesWestToEast","interpolateHeight","longitude","latitude","u","clamp","west","width","v","south","height","interpolateMeshHeight","upsampleTaskProcessor","upsample","thisX","thisY","thisLevel","descendantX","descendantY","descendantLevel","levelDifference","mesh","isEastChild","isNorthChild","childRectangle","upsamplePromise","quantizedVertices","indicesTypedArray","createTypedArray","length","boundingSphere","horizonOcclusionPoint","westIndices","southIndices","eastIndices","northIndices","westSkirtHeight","southSkirtHeight","eastSkirtHeight","northSkirtHeight","isChildAvailable","childX","childY","bitNumber","wasCreatedByUpsampling","texCoordScratch0","texCoordScratch1","texCoordScratch2","barycentricCoordinateScratch","terrainData","i","len","i0","i1","i2","uv0","decodeTextureCoordinates","uv1","uv2","barycentric","computeBarycentricCoordinates","z","h0","decodeHeight","h1","h2","sizeOfUint16","BYTES_PER_ELEMENT","sizeOfUint32","Uint32Array","sizeOfInt32","Int32Array","sizeOfFloat","sizeOfDouble","Float64Array","quad","uStart","vStart","dv","DataView","offset","q","getUint32","xSize","toRadians","getFloat64","ySize","xScale","yScale","numPoints","getInt32","numIndices","uBuffer","Array","vBuffer","heights","getUint8","getFloat32","getUint16","u0","u1","u2","v0","v1","v2"],"mappings":"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","sourcesContent":["import BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport Intersections2D from \"./Intersections2D.js\";\nimport CesiumMath from \"./Math.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\nimport QuantizedMeshTerrainData from \"./QuantizedMeshTerrainData.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport TaskProcessor from \"./TaskProcessor.js\";\nimport TerrainData from \"./TerrainData.js\";\nimport TerrainEncoding from \"./TerrainEncoding.js\";\nimport TerrainMesh from \"./TerrainMesh.js\";\n\n/**\n * Terrain data for a single tile from a Google Earth Enterprise server.\n *\n * @alias GoogleEarthEnterpriseTerrainData\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {ArrayBuffer} options.buffer The buffer containing terrain data.\n * @param {Number} options.negativeAltitudeExponentBias Multiplier for negative terrain heights that are encoded as very small positive values.\n * @param {Number} options.negativeElevationThreshold Threshold for negative values\n * @param {Number} [options.childTileMask=15] A bit mask indicating which of this tile's four children exist.\n *                 If a child's bit is set, geometry will be requested for that tile as well when it\n *                 is needed.  If the bit is cleared, the child tile is not requested and geometry is\n *                 instead upsampled from the parent.  The bit values are as follows:\n *                 <table>\n *                  <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>\n *                  <tr><td>0</td><td>1</td><td>Southwest</td></tr>\n *                  <tr><td>1</td><td>2</td><td>Southeast</td></tr>\n *                  <tr><td>2</td><td>4</td><td>Northeast</td></tr>\n *                  <tr><td>3</td><td>8</td><td>Northwest</td></tr>\n *                 </table>\n * @param {Boolean} [options.createdByUpsampling=false] True if this instance was created by upsampling another instance;\n *                  otherwise, false.\n * @param {Credit[]} [options.credits] Array of credits for this tile.\n *\n *\n * @example\n * var buffer = ...\n * var childTileMask = ...\n * var terrainData = new Cesium.GoogleEarthEnterpriseTerrainData({\n *   buffer : heightBuffer,\n *   childTileMask : childTileMask\n * });\n *\n * @see TerrainData\n * @see HeightmapTerrainData\n * @see QuantizedMeshTerrainData\n */\nfunction GoogleEarthEnterpriseTerrainData(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.buffer\", options.buffer);\n  Check.typeOf.number(\n    \"options.negativeAltitudeExponentBias\",\n    options.negativeAltitudeExponentBias\n  );\n  Check.typeOf.number(\n    \"options.negativeElevationThreshold\",\n    options.negativeElevationThreshold\n  );\n  //>>includeEnd('debug');\n\n  this._buffer = options.buffer;\n  this._credits = options.credits;\n  this._negativeAltitudeExponentBias = options.negativeAltitudeExponentBias;\n  this._negativeElevationThreshold = options.negativeElevationThreshold;\n\n  // Convert from google layout to layout of other providers\n  // 3 2 -> 2 3\n  // 0 1 -> 0 1\n  var googleChildTileMask = defaultValue(options.childTileMask, 15);\n  var childTileMask = googleChildTileMask & 3; // Bottom row is identical\n  childTileMask |= googleChildTileMask & 4 ? 8 : 0; // NE\n  childTileMask |= googleChildTileMask & 8 ? 4 : 0; // NW\n\n  this._childTileMask = childTileMask;\n\n  this._createdByUpsampling = defaultValue(options.createdByUpsampling, false);\n\n  this._skirtHeight = undefined;\n  this._bufferType = this._buffer.constructor;\n  this._mesh = undefined;\n  this._minimumHeight = undefined;\n  this._maximumHeight = undefined;\n}\n\nObject.defineProperties(GoogleEarthEnterpriseTerrainData.prototype, {\n  /**\n   * An array of credits for this tile\n   * @memberof GoogleEarthEnterpriseTerrainData.prototype\n   * @type {Credit[]}\n   */\n  credits: {\n    get: function () {\n      return this._credits;\n    },\n  },\n  /**\n   * The water mask included in this terrain data, if any.  A water mask is a rectangular\n   * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.\n   * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.\n   * @memberof GoogleEarthEnterpriseTerrainData.prototype\n   * @type {Uint8Array|HTMLImageElement|HTMLCanvasElement}\n   */\n  waterMask: {\n    get: function () {\n      return undefined;\n    },\n  },\n});\n\nvar createMeshTaskName = \"createVerticesFromGoogleEarthEnterpriseBuffer\";\nvar createMeshTaskProcessorNoThrottle = new TaskProcessor(createMeshTaskName);\nvar createMeshTaskProcessorThrottle = new TaskProcessor(\n  createMeshTaskName,\n  TerrainData.maximumAsynchronousTasks\n);\n\nvar nativeRectangleScratch = new Rectangle();\nvar rectangleScratch = new Rectangle();\n\n/**\n * Creates a {@link TerrainMesh} from this terrain data.\n *\n * @private\n *\n * @param {Object} options Object with the following properties:\n * @param {TilingScheme} options.tilingScheme The tiling scheme to which this tile belongs.\n * @param {Number} options.x The X coordinate of the tile for which to create the terrain data.\n * @param {Number} options.y The Y coordinate of the tile for which to create the terrain data.\n * @param {Number} options.level The level of the tile for which to create the terrain data.\n * @param {Number} [options.exaggeration=1.0] The scale used to exaggerate the terrain.\n * @param {Boolean} [options.throttle=true] If true, indicates that this operation will need to be retried if too many asynchronous mesh creations are already in progress.\n * @returns {Promise.<TerrainMesh>|undefined} A promise for the terrain mesh, or undefined if too many\n *          asynchronous mesh creations are already in progress and the operation should\n *          be retried later.\n */\nGoogleEarthEnterpriseTerrainData.prototype.createMesh = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.tilingScheme\", options.tilingScheme);\n  Check.typeOf.number(\"options.x\", options.x);\n  Check.typeOf.number(\"options.y\", options.y);\n  Check.typeOf.number(\"options.level\", options.level);\n  //>>includeEnd('debug');\n\n  var tilingScheme = options.tilingScheme;\n  var x = options.x;\n  var y = options.y;\n  var level = options.level;\n  var exaggeration = defaultValue(options.exaggeration, 1.0);\n  var throttle = defaultValue(options.throttle, true);\n\n  var ellipsoid = tilingScheme.ellipsoid;\n  tilingScheme.tileXYToNativeRectangle(x, y, level, nativeRectangleScratch);\n  tilingScheme.tileXYToRectangle(x, y, level, rectangleScratch);\n\n  // Compute the center of the tile for RTC rendering.\n  var center = ellipsoid.cartographicToCartesian(\n    Rectangle.center(rectangleScratch)\n  );\n\n  var levelZeroMaxError = 40075.16; // From Google's Doc\n  var thisLevelMaxError = levelZeroMaxError / (1 << level);\n  this._skirtHeight = Math.min(thisLevelMaxError * 8.0, 1000.0);\n\n  var createMeshTaskProcessor = throttle\n    ? createMeshTaskProcessorThrottle\n    : createMeshTaskProcessorNoThrottle;\n\n  var verticesPromise = createMeshTaskProcessor.scheduleTask({\n    buffer: this._buffer,\n    nativeRectangle: nativeRectangleScratch,\n    rectangle: rectangleScratch,\n    relativeToCenter: center,\n    ellipsoid: ellipsoid,\n    skirtHeight: this._skirtHeight,\n    exaggeration: exaggeration,\n    includeWebMercatorT: true,\n    negativeAltitudeExponentBias: this._negativeAltitudeExponentBias,\n    negativeElevationThreshold: this._negativeElevationThreshold,\n  });\n\n  if (!defined(verticesPromise)) {\n    // Postponed\n    return undefined;\n  }\n\n  var that = this;\n  return verticesPromise.then(function (result) {\n    // Clone complex result objects because the transfer from the web worker\n    // has stripped them down to JSON-style objects.\n    that._mesh = new TerrainMesh(\n      center,\n      new Float32Array(result.vertices),\n      new Uint16Array(result.indices),\n      result.indexCountWithoutSkirts,\n      result.vertexCountWithoutSkirts,\n      result.minimumHeight,\n      result.maximumHeight,\n      BoundingSphere.clone(result.boundingSphere3D),\n      Cartesian3.clone(result.occludeePointInScaledSpace),\n      result.numberOfAttributes,\n      OrientedBoundingBox.clone(result.orientedBoundingBox),\n      TerrainEncoding.clone(result.encoding),\n      exaggeration,\n      result.westIndicesSouthToNorth,\n      result.southIndicesEastToWest,\n      result.eastIndicesNorthToSouth,\n      result.northIndicesWestToEast\n    );\n\n    that._minimumHeight = result.minimumHeight;\n    that._maximumHeight = result.maximumHeight;\n\n    // Free memory received from server after mesh is created.\n    that._buffer = undefined;\n    return that._mesh;\n  });\n};\n\n/**\n * Computes the terrain height at a specified longitude and latitude.\n *\n * @param {Rectangle} rectangle The rectangle covered by this terrain data.\n * @param {Number} longitude The longitude in radians.\n * @param {Number} latitude The latitude in radians.\n * @returns {Number} The terrain height at the specified position.  If the position\n *          is outside the rectangle, this method will extrapolate the height, which is likely to be wildly\n *          incorrect for positions far outside the rectangle.\n */\nGoogleEarthEnterpriseTerrainData.prototype.interpolateHeight = function (\n  rectangle,\n  longitude,\n  latitude\n) {\n  var u = CesiumMath.clamp(\n    (longitude - rectangle.west) / rectangle.width,\n    0.0,\n    1.0\n  );\n  var v = CesiumMath.clamp(\n    (latitude - rectangle.south) / rectangle.height,\n    0.0,\n    1.0\n  );\n\n  if (!defined(this._mesh)) {\n    return interpolateHeight(this, u, v, rectangle);\n  }\n\n  return interpolateMeshHeight(this, u, v);\n};\n\nvar upsampleTaskProcessor = new TaskProcessor(\n  \"upsampleQuantizedTerrainMesh\",\n  TerrainData.maximumAsynchronousTasks\n);\n\n/**\n * Upsamples this terrain data for use by a descendant tile.  The resulting instance will contain a subset of the\n * height samples in this instance, interpolated if necessary.\n *\n * @param {TilingScheme} tilingScheme The tiling scheme of this terrain data.\n * @param {Number} thisX The X coordinate of this tile in the tiling scheme.\n * @param {Number} thisY The Y coordinate of this tile in the tiling scheme.\n * @param {Number} thisLevel The level of this tile in the tiling scheme.\n * @param {Number} descendantX The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {Number} descendantY The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {Number} descendantLevel The level within the tiling scheme of the descendant tile for which we are upsampling.\n * @returns {Promise.<HeightmapTerrainData>|undefined} A promise for upsampled heightmap terrain data for the descendant tile,\n *          or undefined if too many asynchronous upsample operations are in progress and the request has been\n *          deferred.\n */\nGoogleEarthEnterpriseTerrainData.prototype.upsample = function (\n  tilingScheme,\n  thisX,\n  thisY,\n  thisLevel,\n  descendantX,\n  descendantY,\n  descendantLevel\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"tilingScheme\", tilingScheme);\n  Check.typeOf.number(\"thisX\", thisX);\n  Check.typeOf.number(\"thisY\", thisY);\n  Check.typeOf.number(\"thisLevel\", thisLevel);\n  Check.typeOf.number(\"descendantX\", descendantX);\n  Check.typeOf.number(\"descendantY\", descendantY);\n  Check.typeOf.number(\"descendantLevel\", descendantLevel);\n  var levelDifference = descendantLevel - thisLevel;\n  if (levelDifference > 1) {\n    throw new DeveloperError(\n      \"Upsampling through more than one level at a time is not currently supported.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var mesh = this._mesh;\n  if (!defined(this._mesh)) {\n    return undefined;\n  }\n\n  var isEastChild = thisX * 2 !== descendantX;\n  var isNorthChild = thisY * 2 === descendantY;\n\n  var ellipsoid = tilingScheme.ellipsoid;\n  var childRectangle = tilingScheme.tileXYToRectangle(\n    descendantX,\n    descendantY,\n    descendantLevel\n  );\n\n  var upsamplePromise = upsampleTaskProcessor.scheduleTask({\n    vertices: mesh.vertices,\n    indices: mesh.indices,\n    indexCountWithoutSkirts: mesh.indexCountWithoutSkirts,\n    vertexCountWithoutSkirts: mesh.vertexCountWithoutSkirts,\n    encoding: mesh.encoding,\n    minimumHeight: this._minimumHeight,\n    maximumHeight: this._maximumHeight,\n    isEastChild: isEastChild,\n    isNorthChild: isNorthChild,\n    childRectangle: childRectangle,\n    ellipsoid: ellipsoid,\n    exaggeration: mesh.exaggeration,\n  });\n\n  if (!defined(upsamplePromise)) {\n    // Postponed\n    return undefined;\n  }\n\n  var that = this;\n  return upsamplePromise.then(function (result) {\n    var quantizedVertices = new Uint16Array(result.vertices);\n    var indicesTypedArray = IndexDatatype.createTypedArray(\n      quantizedVertices.length / 3,\n      result.indices\n    );\n\n    var skirtHeight = that._skirtHeight;\n\n    // Use QuantizedMeshTerrainData since we have what we need already parsed\n    return new QuantizedMeshTerrainData({\n      quantizedVertices: quantizedVertices,\n      indices: indicesTypedArray,\n      minimumHeight: result.minimumHeight,\n      maximumHeight: result.maximumHeight,\n      boundingSphere: BoundingSphere.clone(result.boundingSphere),\n      orientedBoundingBox: OrientedBoundingBox.clone(\n        result.orientedBoundingBox\n      ),\n      horizonOcclusionPoint: Cartesian3.clone(result.horizonOcclusionPoint),\n      westIndices: result.westIndices,\n      southIndices: result.southIndices,\n      eastIndices: result.eastIndices,\n      northIndices: result.northIndices,\n      westSkirtHeight: skirtHeight,\n      southSkirtHeight: skirtHeight,\n      eastSkirtHeight: skirtHeight,\n      northSkirtHeight: skirtHeight,\n      childTileMask: 0,\n      createdByUpsampling: true,\n      credits: that._credits,\n    });\n  });\n};\n\n/**\n * Determines if a given child tile is available, based on the\n * {@link HeightmapTerrainData.childTileMask}.  The given child tile coordinates are assumed\n * to be one of the four children of this tile.  If non-child tile coordinates are\n * given, the availability of the southeast child tile is returned.\n *\n * @param {Number} thisX The tile X coordinate of this (the parent) tile.\n * @param {Number} thisY The tile Y coordinate of this (the parent) tile.\n * @param {Number} childX The tile X coordinate of the child tile to check for availability.\n * @param {Number} childY The tile Y coordinate of the child tile to check for availability.\n * @returns {Boolean} True if the child tile is available; otherwise, false.\n */\nGoogleEarthEnterpriseTerrainData.prototype.isChildAvailable = function (\n  thisX,\n  thisY,\n  childX,\n  childY\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"thisX\", thisX);\n  Check.typeOf.number(\"thisY\", thisY);\n  Check.typeOf.number(\"childX\", childX);\n  Check.typeOf.number(\"childY\", childY);\n  //>>includeEnd('debug');\n\n  var bitNumber = 2; // northwest child\n  if (childX !== thisX * 2) {\n    ++bitNumber; // east child\n  }\n  if (childY !== thisY * 2) {\n    bitNumber -= 2; // south child\n  }\n\n  return (this._childTileMask & (1 << bitNumber)) !== 0;\n};\n\n/**\n * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution\n * terrain data.  If this value is false, the data was obtained from some other source, such\n * as by downloading it from a remote server.  This method should return true for instances\n * returned from a call to {@link HeightmapTerrainData#upsample}.\n *\n * @returns {Boolean} True if this instance was created by upsampling; otherwise, false.\n */\nGoogleEarthEnterpriseTerrainData.prototype.wasCreatedByUpsampling = function () {\n  return this._createdByUpsampling;\n};\n\nvar texCoordScratch0 = new Cartesian2();\nvar texCoordScratch1 = new Cartesian2();\nvar texCoordScratch2 = new Cartesian2();\nvar barycentricCoordinateScratch = new Cartesian3();\n\nfunction interpolateMeshHeight(terrainData, u, v) {\n  var mesh = terrainData._mesh;\n  var vertices = mesh.vertices;\n  var encoding = mesh.encoding;\n  var indices = mesh.indices;\n\n  for (var i = 0, len = indices.length; i < len; i += 3) {\n    var i0 = indices[i];\n    var i1 = indices[i + 1];\n    var i2 = indices[i + 2];\n\n    var uv0 = encoding.decodeTextureCoordinates(vertices, i0, texCoordScratch0);\n    var uv1 = encoding.decodeTextureCoordinates(vertices, i1, texCoordScratch1);\n    var uv2 = encoding.decodeTextureCoordinates(vertices, i2, texCoordScratch2);\n\n    var barycentric = Intersections2D.computeBarycentricCoordinates(\n      u,\n      v,\n      uv0.x,\n      uv0.y,\n      uv1.x,\n      uv1.y,\n      uv2.x,\n      uv2.y,\n      barycentricCoordinateScratch\n    );\n    if (\n      barycentric.x >= -1e-15 &&\n      barycentric.y >= -1e-15 &&\n      barycentric.z >= -1e-15\n    ) {\n      var h0 = encoding.decodeHeight(vertices, i0);\n      var h1 = encoding.decodeHeight(vertices, i1);\n      var h2 = encoding.decodeHeight(vertices, i2);\n      return barycentric.x * h0 + barycentric.y * h1 + barycentric.z * h2;\n    }\n  }\n\n  // Position does not lie in any triangle in this mesh.\n  return undefined;\n}\n\nvar sizeOfUint16 = Uint16Array.BYTES_PER_ELEMENT;\nvar sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;\nvar sizeOfInt32 = Int32Array.BYTES_PER_ELEMENT;\nvar sizeOfFloat = Float32Array.BYTES_PER_ELEMENT;\nvar sizeOfDouble = Float64Array.BYTES_PER_ELEMENT;\n\nfunction interpolateHeight(terrainData, u, v, rectangle) {\n  var buffer = terrainData._buffer;\n  var quad = 0; // SW\n  var uStart = 0.0;\n  var vStart = 0.0;\n  if (v > 0.5) {\n    // Upper row\n    if (u > 0.5) {\n      // NE\n      quad = 2;\n      uStart = 0.5;\n    } else {\n      // NW\n      quad = 3;\n    }\n    vStart = 0.5;\n  } else if (u > 0.5) {\n    // SE\n    quad = 1;\n    uStart = 0.5;\n  }\n\n  var dv = new DataView(buffer);\n  var offset = 0;\n  for (var q = 0; q < quad; ++q) {\n    offset += dv.getUint32(offset, true);\n    offset += sizeOfUint32;\n  }\n  offset += sizeOfUint32; // Skip length of quad\n  offset += 2 * sizeOfDouble; // Skip origin\n\n  // Read sizes\n  var xSize = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\n  offset += sizeOfDouble;\n  var ySize = CesiumMath.toRadians(dv.getFloat64(offset, true) * 180.0);\n  offset += sizeOfDouble;\n\n  // Samples per quad\n  var xScale = rectangle.width / xSize / 2;\n  var yScale = rectangle.height / ySize / 2;\n\n  // Number of points\n  var numPoints = dv.getInt32(offset, true);\n  offset += sizeOfInt32;\n\n  // Number of faces\n  var numIndices = dv.getInt32(offset, true) * 3;\n  offset += sizeOfInt32;\n\n  offset += sizeOfInt32; // Skip Level\n\n  var uBuffer = new Array(numPoints);\n  var vBuffer = new Array(numPoints);\n  var heights = new Array(numPoints);\n  var i;\n  for (i = 0; i < numPoints; ++i) {\n    uBuffer[i] = uStart + dv.getUint8(offset++) * xScale;\n    vBuffer[i] = vStart + dv.getUint8(offset++) * yScale;\n\n    // Height is stored in units of (1/EarthRadius) or (1/6371010.0)\n    heights[i] = dv.getFloat32(offset, true) * 6371010.0;\n    offset += sizeOfFloat;\n  }\n\n  var indices = new Array(numIndices);\n  for (i = 0; i < numIndices; ++i) {\n    indices[i] = dv.getUint16(offset, true);\n    offset += sizeOfUint16;\n  }\n\n  for (i = 0; i < numIndices; i += 3) {\n    var i0 = indices[i];\n    var i1 = indices[i + 1];\n    var i2 = indices[i + 2];\n\n    var u0 = uBuffer[i0];\n    var u1 = uBuffer[i1];\n    var u2 = uBuffer[i2];\n\n    var v0 = vBuffer[i0];\n    var v1 = vBuffer[i1];\n    var v2 = vBuffer[i2];\n\n    var barycentric = Intersections2D.computeBarycentricCoordinates(\n      u,\n      v,\n      u0,\n      v0,\n      u1,\n      v1,\n      u2,\n      v2,\n      barycentricCoordinateScratch\n    );\n    if (\n      barycentric.x >= -1e-15 &&\n      barycentric.y >= -1e-15 &&\n      barycentric.z >= -1e-15\n    ) {\n      return (\n        barycentric.x * heights[i0] +\n        barycentric.y * heights[i1] +\n        barycentric.z * heights[i2]\n      );\n    }\n  }\n\n  // Position does not lie in any triangle in this mesh.\n  return undefined;\n}\nexport default GoogleEarthEnterpriseTerrainData;\n"]},"metadata":{},"sourceType":"module"}