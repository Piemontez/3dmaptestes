{"ast":null,"code":"import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport HeadingPitchRoll from \"../Core/HeadingPitchRoll.js\";\nimport IntersectionTests from \"../Core/IntersectionTests.js\";\nimport KeyboardEventModifier from \"../Core/KeyboardEventModifier.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport Plane from \"../Core/Plane.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport Ray from \"../Core/Ray.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport CameraEventAggregator from \"./CameraEventAggregator.js\";\nimport CameraEventType from \"./CameraEventType.js\";\nimport MapMode2D from \"./MapMode2D.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport SceneTransforms from \"./SceneTransforms.js\";\nimport TweenCollection from \"./TweenCollection.js\";\n/**\n * Modifies the camera position and orientation based on mouse input to a canvas.\n * @alias ScreenSpaceCameraController\n * @constructor\n *\n * @param {Scene} scene The scene.\n */\n\nfunction ScreenSpaceCameraController(scene) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  } //>>includeEnd('debug');\n\n  /**\n   * If true, inputs are allowed conditionally with the flags enableTranslate, enableZoom,\n   * enableRotate, enableTilt, and enableLook.  If false, all inputs are disabled.\n   *\n   * NOTE: This setting is for temporary use cases, such as camera flights and\n   * drag-selection of regions (see Picking demo).  It is typically set to false at the\n   * start of such events, and set true on completion.  To keep inputs disabled\n   * past the end of camera flights, you must use the other booleans (enableTranslate,\n   * enableZoom, enableRotate, enableTilt, and enableLook).\n   * @type {Boolean}\n   * @default true\n   */\n\n\n  this.enableInputs = true;\n  /**\n   * If true, allows the user to pan around the map.  If false, the camera stays locked at the current position.\n   * This flag only applies in 2D and Columbus view modes.\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.enableTranslate = true;\n  /**\n   * If true, allows the user to zoom in and out.  If false, the camera is locked to the current distance from the ellipsoid.\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.enableZoom = true;\n  /**\n   * If true, allows the user to rotate the world which translates the user's position.\n   * This flag only applies in 2D and 3D.\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.enableRotate = true;\n  /**\n   * If true, allows the user to tilt the camera.  If false, the camera is locked to the current heading.\n   * This flag only applies in 3D and Columbus view.\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.enableTilt = true;\n  /**\n   * If true, allows the user to use free-look. If false, the camera view direction can only be changed through translating\n   * or rotating. This flag only applies in 3D and Columbus view modes.\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.enableLook = true;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to determine how long\n   * the camera will continue to spin because of inertia.\n   * With value of zero, the camera will have no inertia.\n   * @type {Number}\n   * @default 0.9\n   */\n\n  this.inertiaSpin = 0.9;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to determine how long\n   * the camera will continue to translate because of inertia.\n   * With value of zero, the camera will have no inertia.\n   * @type {Number}\n   * @default 0.9\n   */\n\n  this.inertiaTranslate = 0.9;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to determine how long\n   * the camera will continue to zoom because of inertia.\n   * With value of zero, the camera will have no inertia.\n   * @type {Number}\n   * @default 0.8\n   */\n\n  this.inertiaZoom = 0.8;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to limit the range\n   * of various user inputs to a percentage of the window width/height per animation frame.\n   * This helps keep the camera under control in low-frame-rate situations.\n   * @type {Number}\n   * @default 0.1\n   */\n\n  this.maximumMovementRatio = 0.1;\n  /**\n   * Sets the duration, in seconds, of the bounce back animations in 2D and Columbus view.\n   * @type {Number}\n   * @default 3.0\n   */\n\n  this.bounceAnimationTime = 3.0;\n  /**\n   * The minimum magnitude, in meters, of the camera position when zooming. Defaults to 1.0.\n   * @type {Number}\n   * @default 1.0\n   */\n\n  this.minimumZoomDistance = 1.0;\n  /**\n   * The maximum magnitude, in meters, of the camera position when zooming. Defaults to positive infinity.\n   * @type {Number}\n   * @default {@link Number.POSITIVE_INFINITY}\n   */\n\n  this.maximumZoomDistance = Number.POSITIVE_INFINITY;\n  /**\n   * The input that allows the user to pan around the map. This only applies in 2D and Columbus view modes.\n   * <p>\n   * The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default {@link CameraEventType.LEFT_DRAG}\n   */\n\n  this.translateEventTypes = CameraEventType.LEFT_DRAG;\n  /**\n   * The input that allows the user to zoom in/out.\n   * <p>\n   * The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default [{@link CameraEventType.RIGHT_DRAG}, {@link CameraEventType.WHEEL}, {@link CameraEventType.PINCH}]\n   */\n\n  this.zoomEventTypes = [CameraEventType.RIGHT_DRAG, CameraEventType.WHEEL, CameraEventType.PINCH];\n  /**\n   * The input that allows the user to rotate around the globe or another object. This only applies in 3D and Columbus view modes.\n   * <p>\n   * The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default {@link CameraEventType.LEFT_DRAG}\n   */\n\n  this.rotateEventTypes = CameraEventType.LEFT_DRAG;\n  /**\n   * The input that allows the user to tilt in 3D and Columbus view or twist in 2D.\n   * <p>\n   * The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default [{@link CameraEventType.MIDDLE_DRAG}, {@link CameraEventType.PINCH}, {\n   *     eventType : {@link CameraEventType.LEFT_DRAG},\n   *     modifier : {@link KeyboardEventModifier.CTRL}\n   * }, {\n   *     eventType : {@link CameraEventType.RIGHT_DRAG},\n   *     modifier : {@link KeyboardEventModifier.CTRL}\n   * }]\n   */\n\n  this.tiltEventTypes = [CameraEventType.MIDDLE_DRAG, CameraEventType.PINCH, {\n    eventType: CameraEventType.LEFT_DRAG,\n    modifier: KeyboardEventModifier.CTRL\n  }, {\n    eventType: CameraEventType.RIGHT_DRAG,\n    modifier: KeyboardEventModifier.CTRL\n  }];\n  /**\n   * The input that allows the user to change the direction the camera is viewing. This only applies in 3D and Columbus view modes.\n   * <p>\n   * The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default { eventType : {@link CameraEventType.LEFT_DRAG}, modifier : {@link KeyboardEventModifier.SHIFT} }\n   */\n\n  this.lookEventTypes = {\n    eventType: CameraEventType.LEFT_DRAG,\n    modifier: KeyboardEventModifier.SHIFT\n  };\n  /**\n   * The minimum height the camera must be before picking the terrain instead of the ellipsoid.\n   * @type {Number}\n   * @default 150000.0\n   */\n\n  this.minimumPickingTerrainHeight = 150000.0;\n  this._minimumPickingTerrainHeight = this.minimumPickingTerrainHeight;\n  /**\n   * The minimum height the camera must be before testing for collision with terrain.\n   * @type {Number}\n   * @default 15000.0\n   */\n\n  this.minimumCollisionTerrainHeight = 15000.0;\n  this._minimumCollisionTerrainHeight = this.minimumCollisionTerrainHeight;\n  /**\n   * The minimum height the camera must be before switching from rotating a track ball to\n   * free look when clicks originate on the sky or in space.\n   * @type {Number}\n   * @default 7500000.0\n   */\n\n  this.minimumTrackBallHeight = 7500000.0;\n  this._minimumTrackBallHeight = this.minimumTrackBallHeight;\n  /**\n   * Enables or disables camera collision detection with terrain.\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.enableCollisionDetection = true;\n  this._scene = scene;\n  this._globe = undefined;\n  this._ellipsoid = undefined;\n  this._aggregator = new CameraEventAggregator(scene.canvas);\n  this._lastInertiaSpinMovement = undefined;\n  this._lastInertiaZoomMovement = undefined;\n  this._lastInertiaTranslateMovement = undefined;\n  this._lastInertiaTiltMovement = undefined; // Zoom disables tilt, spin, and translate inertia\n  // Tilt disables spin and translate inertia\n\n  this._inertiaDisablers = {\n    _lastInertiaZoomMovement: [\"_lastInertiaSpinMovement\", \"_lastInertiaTranslateMovement\", \"_lastInertiaTiltMovement\"],\n    _lastInertiaTiltMovement: [\"_lastInertiaSpinMovement\", \"_lastInertiaTranslateMovement\"]\n  };\n  this._tweens = new TweenCollection();\n  this._tween = undefined;\n  this._horizontalRotationAxis = undefined;\n  this._tiltCenterMousePosition = new Cartesian2(-1.0, -1.0);\n  this._tiltCenter = new Cartesian3();\n  this._rotateMousePosition = new Cartesian2(-1.0, -1.0);\n  this._rotateStartPosition = new Cartesian3();\n  this._strafeStartPosition = new Cartesian3();\n  this._strafeMousePosition = new Cartesian2();\n  this._strafeEndMousePosition = new Cartesian2();\n  this._zoomMouseStart = new Cartesian2(-1.0, -1.0);\n  this._zoomWorldPosition = new Cartesian3();\n  this._useZoomWorldPosition = false;\n  this._tiltCVOffMap = false;\n  this._looking = false;\n  this._rotating = false;\n  this._strafing = false;\n  this._zoomingOnVector = false;\n  this._zoomingUnderground = false;\n  this._rotatingZoom = false;\n  this._adjustedHeightForTerrain = false;\n  this._cameraUnderground = false;\n  var projection = scene.mapProjection;\n  this._maxCoord = projection.project(new Cartographic(Math.PI, CesiumMath.PI_OVER_TWO)); // Constants, Make any of these public?\n\n  this._zoomFactor = 5.0;\n  this._rotateFactor = undefined;\n  this._rotateRateRangeAdjustment = undefined;\n  this._maximumRotateRate = 1.77;\n  this._minimumRotateRate = 1.0 / 5000.0;\n  this._minimumZoomRate = 20.0;\n  this._maximumZoomRate = 5906376272000.0; // distance from the Sun to Pluto in meters.\n\n  this._minimumUndergroundPickDistance = 2000.0;\n  this._maximumUndergroundPickDistance = 10000.0;\n}\n\nfunction decay(time, coefficient) {\n  if (time < 0) {\n    return 0.0;\n  }\n\n  var tau = (1.0 - coefficient) * 25.0;\n  return Math.exp(-tau * time);\n}\n\nfunction sameMousePosition(movement) {\n  return Cartesian2.equalsEpsilon(movement.startPosition, movement.endPosition, CesiumMath.EPSILON14);\n} // If the time between mouse down and mouse up is not between\n// these thresholds, the camera will not move with inertia.\n// This value is probably dependent on the browser and/or the\n// hardware. Should be investigated further.\n\n\nvar inertiaMaxClickTimeThreshold = 0.4;\n\nfunction maintainInertia(aggregator, type, modifier, decayCoef, action, object, lastMovementName) {\n  var movementState = object[lastMovementName];\n\n  if (!defined(movementState)) {\n    movementState = object[lastMovementName] = {\n      startPosition: new Cartesian2(),\n      endPosition: new Cartesian2(),\n      motion: new Cartesian2(),\n      inertiaEnabled: true\n    };\n  }\n\n  var ts = aggregator.getButtonPressTime(type, modifier);\n  var tr = aggregator.getButtonReleaseTime(type, modifier);\n  var threshold = ts && tr && (tr.getTime() - ts.getTime()) / 1000.0;\n  var now = new Date();\n  var fromNow = tr && (now.getTime() - tr.getTime()) / 1000.0;\n\n  if (ts && tr && threshold < inertiaMaxClickTimeThreshold) {\n    var d = decay(fromNow, decayCoef);\n    var lastMovement = aggregator.getLastMovement(type, modifier);\n\n    if (!defined(lastMovement) || sameMousePosition(lastMovement) || !movementState.inertiaEnabled) {\n      return;\n    }\n\n    movementState.motion.x = (lastMovement.endPosition.x - lastMovement.startPosition.x) * 0.5;\n    movementState.motion.y = (lastMovement.endPosition.y - lastMovement.startPosition.y) * 0.5;\n    movementState.startPosition = Cartesian2.clone(lastMovement.startPosition, movementState.startPosition);\n    movementState.endPosition = Cartesian2.multiplyByScalar(movementState.motion, d, movementState.endPosition);\n    movementState.endPosition = Cartesian2.add(movementState.startPosition, movementState.endPosition, movementState.endPosition); // If value from the decreasing exponential function is close to zero,\n    // the end coordinates may be NaN.\n\n    if (isNaN(movementState.endPosition.x) || isNaN(movementState.endPosition.y) || Cartesian2.distance(movementState.startPosition, movementState.endPosition) < 0.5) {\n      return;\n    }\n\n    if (!aggregator.isButtonDown(type, modifier)) {\n      var startPosition = aggregator.getStartMousePosition(type, modifier);\n      action(object, startPosition, movementState);\n    }\n  }\n}\n\nfunction activateInertia(controller, inertiaStateName) {\n  if (defined(inertiaStateName)) {\n    // Re-enable inertia if it was disabled\n    var movementState = controller[inertiaStateName];\n\n    if (defined(movementState)) {\n      movementState.inertiaEnabled = true;\n    } // Disable inertia on other movements\n\n\n    var inertiasToDisable = controller._inertiaDisablers[inertiaStateName];\n\n    if (defined(inertiasToDisable)) {\n      var length = inertiasToDisable.length;\n\n      for (var i = 0; i < length; ++i) {\n        movementState = controller[inertiasToDisable[i]];\n\n        if (defined(movementState)) {\n          movementState.inertiaEnabled = false;\n        }\n      }\n    }\n  }\n}\n\nvar scratchEventTypeArray = [];\n\nfunction reactToInput(controller, enabled, eventTypes, action, inertiaConstant, inertiaStateName) {\n  if (!defined(eventTypes)) {\n    return;\n  }\n\n  var aggregator = controller._aggregator;\n\n  if (!Array.isArray(eventTypes)) {\n    scratchEventTypeArray[0] = eventTypes;\n    eventTypes = scratchEventTypeArray;\n  }\n\n  var length = eventTypes.length;\n\n  for (var i = 0; i < length; ++i) {\n    var eventType = eventTypes[i];\n    var type = defined(eventType.eventType) ? eventType.eventType : eventType;\n    var modifier = eventType.modifier;\n    var movement = aggregator.isMoving(type, modifier) && aggregator.getMovement(type, modifier);\n    var startPosition = aggregator.getStartMousePosition(type, modifier);\n\n    if (controller.enableInputs && enabled) {\n      if (movement) {\n        action(controller, startPosition, movement);\n        activateInertia(controller, inertiaStateName);\n      } else if (inertiaConstant < 1.0) {\n        maintainInertia(aggregator, type, modifier, inertiaConstant, action, controller, inertiaStateName);\n      }\n    }\n  }\n}\n\nvar scratchZoomPickRay = new Ray();\nvar scratchPickCartesian = new Cartesian3();\nvar scratchZoomOffset = new Cartesian2();\nvar scratchZoomDirection = new Cartesian3();\nvar scratchCenterPixel = new Cartesian2();\nvar scratchCenterPosition = new Cartesian3();\nvar scratchPositionNormal = new Cartesian3();\nvar scratchPickNormal = new Cartesian3();\nvar scratchZoomAxis = new Cartesian3();\nvar scratchCameraPositionNormal = new Cartesian3(); // Scratch variables used in zooming algorithm\n\nvar scratchTargetNormal = new Cartesian3();\nvar scratchCameraPosition = new Cartesian3();\nvar scratchCameraUpNormal = new Cartesian3();\nvar scratchCameraRightNormal = new Cartesian3();\nvar scratchForwardNormal = new Cartesian3();\nvar scratchPositionToTarget = new Cartesian3();\nvar scratchPositionToTargetNormal = new Cartesian3();\nvar scratchPan = new Cartesian3();\nvar scratchCenterMovement = new Cartesian3();\nvar scratchCenter = new Cartesian3();\nvar scratchCartesian = new Cartesian3();\nvar scratchCartesianTwo = new Cartesian3();\nvar scratchCartesianThree = new Cartesian3();\nvar scratchZoomViewOptions = {\n  orientation: new HeadingPitchRoll()\n};\n\nfunction handleZoom(object, startPosition, movement, zoomFactor, distanceMeasure, unitPositionDotDirection) {\n  var percentage = 1.0;\n\n  if (defined(unitPositionDotDirection)) {\n    percentage = CesiumMath.clamp(Math.abs(unitPositionDotDirection), 0.25, 1.0);\n  } // distanceMeasure should be the height above the ellipsoid.\n  // The zoomRate slows as it approaches the surface and stops minimumZoomDistance above it.\n\n\n  var minHeight = object.minimumZoomDistance * percentage;\n  var maxHeight = object.maximumZoomDistance;\n  var minDistance = distanceMeasure - minHeight;\n  var zoomRate = zoomFactor * minDistance;\n  zoomRate = CesiumMath.clamp(zoomRate, object._minimumZoomRate, object._maximumZoomRate);\n  var diff = movement.endPosition.y - movement.startPosition.y;\n  var rangeWindowRatio = diff / object._scene.canvas.clientHeight;\n  rangeWindowRatio = Math.min(rangeWindowRatio, object.maximumMovementRatio);\n  var distance = zoomRate * rangeWindowRatio;\n\n  if (object.enableCollisionDetection || object.minimumZoomDistance === 0.0 || !defined(object._globe) // look-at mode\n  ) {\n      if (distance > 0.0 && Math.abs(distanceMeasure - minHeight) < 1.0) {\n        return;\n      }\n\n      if (distance < 0.0 && Math.abs(distanceMeasure - maxHeight) < 1.0) {\n        return;\n      }\n\n      if (distanceMeasure - distance < minHeight) {\n        distance = distanceMeasure - minHeight - 1.0;\n      } else if (distanceMeasure - distance > maxHeight) {\n        distance = distanceMeasure - maxHeight;\n      }\n    }\n\n  var scene = object._scene;\n  var camera = scene.camera;\n  var mode = scene.mode;\n  var orientation = scratchZoomViewOptions.orientation;\n  orientation.heading = camera.heading;\n  orientation.pitch = camera.pitch;\n  orientation.roll = camera.roll;\n\n  if (camera.frustum instanceof OrthographicFrustum) {\n    if (Math.abs(distance) > 0.0) {\n      camera.zoomIn(distance);\n\n      camera._adjustOrthographicFrustum();\n    }\n\n    return;\n  }\n\n  var sameStartPosition = Cartesian2.equals(startPosition, object._zoomMouseStart);\n  var zoomingOnVector = object._zoomingOnVector;\n  var rotatingZoom = object._rotatingZoom;\n  var pickedPosition;\n\n  if (!sameStartPosition) {\n    object._zoomMouseStart = Cartesian2.clone(startPosition, object._zoomMouseStart);\n\n    if (defined(object._globe)) {\n      if (mode === SceneMode.SCENE2D) {\n        pickedPosition = camera.getPickRay(startPosition, scratchZoomPickRay).origin;\n        pickedPosition = Cartesian3.fromElements(pickedPosition.y, pickedPosition.z, pickedPosition.x);\n      } else {\n        pickedPosition = pickGlobe(object, startPosition, scratchPickCartesian);\n      }\n    }\n\n    if (defined(pickedPosition)) {\n      object._useZoomWorldPosition = true;\n      object._zoomWorldPosition = Cartesian3.clone(pickedPosition, object._zoomWorldPosition);\n    } else {\n      object._useZoomWorldPosition = false;\n    }\n\n    zoomingOnVector = object._zoomingOnVector = false;\n    rotatingZoom = object._rotatingZoom = false;\n    object._zoomingUnderground = object._cameraUnderground;\n  }\n\n  if (!object._useZoomWorldPosition) {\n    camera.zoomIn(distance);\n    return;\n  }\n\n  var zoomOnVector = mode === SceneMode.COLUMBUS_VIEW;\n\n  if (camera.positionCartographic.height < 2000000) {\n    rotatingZoom = true;\n  }\n\n  if (!sameStartPosition || rotatingZoom) {\n    if (mode === SceneMode.SCENE2D) {\n      var worldPosition = object._zoomWorldPosition;\n      var endPosition = camera.position;\n\n      if (!Cartesian3.equals(worldPosition, endPosition) && camera.positionCartographic.height < object._maxCoord.x * 2.0) {\n        var savedX = camera.position.x;\n        var direction = Cartesian3.subtract(worldPosition, endPosition, scratchZoomDirection);\n        Cartesian3.normalize(direction, direction);\n        var d = Cartesian3.distance(worldPosition, endPosition) * distance / (camera.getMagnitude() * 0.5);\n        camera.move(direction, d * 0.5);\n\n        if (camera.position.x < 0.0 && savedX > 0.0 || camera.position.x > 0.0 && savedX < 0.0) {\n          pickedPosition = camera.getPickRay(startPosition, scratchZoomPickRay).origin;\n          pickedPosition = Cartesian3.fromElements(pickedPosition.y, pickedPosition.z, pickedPosition.x);\n          object._zoomWorldPosition = Cartesian3.clone(pickedPosition, object._zoomWorldPosition);\n        }\n      }\n    } else if (mode === SceneMode.SCENE3D) {\n      var cameraPositionNormal = Cartesian3.normalize(camera.position, scratchCameraPositionNormal);\n\n      if (object._cameraUnderground || object._zoomingUnderground || camera.positionCartographic.height < 3000.0 && Math.abs(Cartesian3.dot(camera.direction, cameraPositionNormal)) < 0.6) {\n        zoomOnVector = true;\n      } else {\n        var canvas = scene.canvas;\n        var centerPixel = scratchCenterPixel;\n        centerPixel.x = canvas.clientWidth / 2;\n        centerPixel.y = canvas.clientHeight / 2;\n        var centerPosition = pickGlobe(object, centerPixel, scratchCenterPosition); // If centerPosition is not defined, it means the globe does not cover the center position of screen\n\n        if (!defined(centerPosition)) {\n          zoomOnVector = true;\n        } else if (camera.positionCartographic.height < 1000000) {\n          // The math in the else block assumes the camera\n          // points toward the earth surface, so we check it here.\n          // Theoretically, we should check for 90 degree, but it doesn't behave well when parallel\n          // to the earth surface\n          if (Cartesian3.dot(camera.direction, cameraPositionNormal) >= -0.5) {\n            zoomOnVector = true;\n          } else {\n            var cameraPosition = scratchCameraPosition;\n            Cartesian3.clone(camera.position, cameraPosition);\n            var target = object._zoomWorldPosition;\n            var targetNormal = scratchTargetNormal;\n            targetNormal = Cartesian3.normalize(target, targetNormal);\n\n            if (Cartesian3.dot(targetNormal, cameraPositionNormal) < 0.0) {\n              return;\n            }\n\n            var center = scratchCenter;\n            var forward = scratchForwardNormal;\n            Cartesian3.clone(camera.direction, forward);\n            Cartesian3.add(cameraPosition, Cartesian3.multiplyByScalar(forward, 1000, scratchCartesian), center);\n            var positionToTarget = scratchPositionToTarget;\n            var positionToTargetNormal = scratchPositionToTargetNormal;\n            Cartesian3.subtract(target, cameraPosition, positionToTarget);\n            Cartesian3.normalize(positionToTarget, positionToTargetNormal);\n            var alphaDot = Cartesian3.dot(cameraPositionNormal, positionToTargetNormal);\n\n            if (alphaDot >= 0.0) {\n              // We zoomed past the target, and this zoom is not valid anymore.\n              // This line causes the next zoom movement to pick a new starting point.\n              object._zoomMouseStart.x = -1;\n              return;\n            }\n\n            var alpha = Math.acos(-alphaDot);\n            var cameraDistance = Cartesian3.magnitude(cameraPosition);\n            var targetDistance = Cartesian3.magnitude(target);\n            var remainingDistance = cameraDistance - distance;\n            var positionToTargetDistance = Cartesian3.magnitude(positionToTarget);\n            var gamma = Math.asin(CesiumMath.clamp(positionToTargetDistance / targetDistance * Math.sin(alpha), -1.0, 1.0));\n            var delta = Math.asin(CesiumMath.clamp(remainingDistance / targetDistance * Math.sin(alpha), -1.0, 1.0));\n            var beta = gamma - delta + alpha;\n            var up = scratchCameraUpNormal;\n            Cartesian3.normalize(cameraPosition, up);\n            var right = scratchCameraRightNormal;\n            right = Cartesian3.cross(positionToTargetNormal, up, right);\n            right = Cartesian3.normalize(right, right);\n            Cartesian3.normalize(Cartesian3.cross(up, right, scratchCartesian), forward); // Calculate new position to move to\n\n            Cartesian3.multiplyByScalar(Cartesian3.normalize(center, scratchCartesian), Cartesian3.magnitude(center) - distance, center);\n            Cartesian3.normalize(cameraPosition, cameraPosition);\n            Cartesian3.multiplyByScalar(cameraPosition, remainingDistance, cameraPosition); // Pan\n\n            var pMid = scratchPan;\n            Cartesian3.multiplyByScalar(Cartesian3.add(Cartesian3.multiplyByScalar(up, Math.cos(beta) - 1, scratchCartesianTwo), Cartesian3.multiplyByScalar(forward, Math.sin(beta), scratchCartesianThree), scratchCartesian), remainingDistance, pMid);\n            Cartesian3.add(cameraPosition, pMid, cameraPosition);\n            Cartesian3.normalize(center, up);\n            Cartesian3.normalize(Cartesian3.cross(up, right, scratchCartesian), forward);\n            var cMid = scratchCenterMovement;\n            Cartesian3.multiplyByScalar(Cartesian3.add(Cartesian3.multiplyByScalar(up, Math.cos(beta) - 1, scratchCartesianTwo), Cartesian3.multiplyByScalar(forward, Math.sin(beta), scratchCartesianThree), scratchCartesian), Cartesian3.magnitude(center), cMid);\n            Cartesian3.add(center, cMid, center); // Update camera\n            // Set new position\n\n            Cartesian3.clone(cameraPosition, camera.position); // Set new direction\n\n            Cartesian3.normalize(Cartesian3.subtract(center, cameraPosition, scratchCartesian), camera.direction);\n            Cartesian3.clone(camera.direction, camera.direction); // Set new right & up vectors\n\n            Cartesian3.cross(camera.direction, camera.up, camera.right);\n            Cartesian3.cross(camera.right, camera.direction, camera.up);\n            camera.setView(scratchZoomViewOptions);\n            return;\n          }\n        } else {\n          var positionNormal = Cartesian3.normalize(centerPosition, scratchPositionNormal);\n          var pickedNormal = Cartesian3.normalize(object._zoomWorldPosition, scratchPickNormal);\n          var dotProduct = Cartesian3.dot(pickedNormal, positionNormal);\n\n          if (dotProduct > 0.0 && dotProduct < 1.0) {\n            var angle = CesiumMath.acosClamped(dotProduct);\n            var axis = Cartesian3.cross(pickedNormal, positionNormal, scratchZoomAxis);\n            var denom = Math.abs(angle) > CesiumMath.toRadians(20.0) ? camera.positionCartographic.height * 0.75 : camera.positionCartographic.height - distance;\n            var scalar = distance / denom;\n            camera.rotate(axis, angle * scalar);\n          }\n        }\n      }\n    }\n\n    object._rotatingZoom = !zoomOnVector;\n  }\n\n  if (!sameStartPosition && zoomOnVector || zoomingOnVector) {\n    var ray;\n    var zoomMouseStart = SceneTransforms.wgs84ToWindowCoordinates(scene, object._zoomWorldPosition, scratchZoomOffset);\n\n    if (mode !== SceneMode.COLUMBUS_VIEW && Cartesian2.equals(startPosition, object._zoomMouseStart) && defined(zoomMouseStart)) {\n      ray = camera.getPickRay(zoomMouseStart, scratchZoomPickRay);\n    } else {\n      ray = camera.getPickRay(startPosition, scratchZoomPickRay);\n    }\n\n    var rayDirection = ray.direction;\n\n    if (mode === SceneMode.COLUMBUS_VIEW || mode === SceneMode.SCENE2D) {\n      Cartesian3.fromElements(rayDirection.y, rayDirection.z, rayDirection.x, rayDirection);\n    }\n\n    camera.move(rayDirection, distance);\n    object._zoomingOnVector = true;\n  } else {\n    camera.zoomIn(distance);\n  }\n\n  if (!object._cameraUnderground) {\n    camera.setView(scratchZoomViewOptions);\n  }\n}\n\nvar translate2DStart = new Ray();\nvar translate2DEnd = new Ray();\nvar scratchTranslateP0 = new Cartesian3();\n\nfunction translate2D(controller, startPosition, movement) {\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var start = camera.getPickRay(movement.startPosition, translate2DStart).origin;\n  var end = camera.getPickRay(movement.endPosition, translate2DEnd).origin;\n  start = Cartesian3.fromElements(start.y, start.z, start.x, start);\n  end = Cartesian3.fromElements(end.y, end.z, end.x, end);\n  var direction = Cartesian3.subtract(start, end, scratchTranslateP0);\n  var distance = Cartesian3.magnitude(direction);\n\n  if (distance > 0.0) {\n    Cartesian3.normalize(direction, direction);\n    camera.move(direction, distance);\n  }\n}\n\nfunction zoom2D(controller, startPosition, movement) {\n  if (defined(movement.distance)) {\n    movement = movement.distance;\n  }\n\n  var scene = controller._scene;\n  var camera = scene.camera;\n  handleZoom(controller, startPosition, movement, controller._zoomFactor, camera.getMagnitude());\n}\n\nvar twist2DStart = new Cartesian2();\nvar twist2DEnd = new Cartesian2();\n\nfunction twist2D(controller, startPosition, movement) {\n  if (defined(movement.angleAndHeight)) {\n    singleAxisTwist2D(controller, startPosition, movement.angleAndHeight);\n    return;\n  }\n\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var canvas = scene.canvas;\n  var width = canvas.clientWidth;\n  var height = canvas.clientHeight;\n  var start = twist2DStart;\n  start.x = 2.0 / width * movement.startPosition.x - 1.0;\n  start.y = 2.0 / height * (height - movement.startPosition.y) - 1.0;\n  start = Cartesian2.normalize(start, start);\n  var end = twist2DEnd;\n  end.x = 2.0 / width * movement.endPosition.x - 1.0;\n  end.y = 2.0 / height * (height - movement.endPosition.y) - 1.0;\n  end = Cartesian2.normalize(end, end);\n  var startTheta = CesiumMath.acosClamped(start.x);\n\n  if (start.y < 0) {\n    startTheta = CesiumMath.TWO_PI - startTheta;\n  }\n\n  var endTheta = CesiumMath.acosClamped(end.x);\n\n  if (end.y < 0) {\n    endTheta = CesiumMath.TWO_PI - endTheta;\n  }\n\n  var theta = endTheta - startTheta;\n  camera.twistRight(theta);\n}\n\nfunction singleAxisTwist2D(controller, startPosition, movement) {\n  var rotateRate = controller._rotateFactor * controller._rotateRateRangeAdjustment;\n\n  if (rotateRate > controller._maximumRotateRate) {\n    rotateRate = controller._maximumRotateRate;\n  }\n\n  if (rotateRate < controller._minimumRotateRate) {\n    rotateRate = controller._minimumRotateRate;\n  }\n\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var canvas = scene.canvas;\n  var phiWindowRatio = (movement.endPosition.x - movement.startPosition.x) / canvas.clientWidth;\n  phiWindowRatio = Math.min(phiWindowRatio, controller.maximumMovementRatio);\n  var deltaPhi = rotateRate * phiWindowRatio * Math.PI * 4.0;\n  camera.twistRight(deltaPhi);\n}\n\nfunction update2D(controller) {\n  var rotatable2D = controller._scene.mapMode2D === MapMode2D.ROTATE;\n\n  if (!Matrix4.equals(Matrix4.IDENTITY, controller._scene.camera.transform)) {\n    reactToInput(controller, controller.enableZoom, controller.zoomEventTypes, zoom2D, controller.inertiaZoom, \"_lastInertiaZoomMovement\");\n\n    if (rotatable2D) {\n      reactToInput(controller, controller.enableRotate, controller.translateEventTypes, twist2D, controller.inertiaSpin, \"_lastInertiaSpinMovement\");\n    }\n  } else {\n    reactToInput(controller, controller.enableTranslate, controller.translateEventTypes, translate2D, controller.inertiaTranslate, \"_lastInertiaTranslateMovement\");\n    reactToInput(controller, controller.enableZoom, controller.zoomEventTypes, zoom2D, controller.inertiaZoom, \"_lastInertiaZoomMovement\");\n\n    if (rotatable2D) {\n      reactToInput(controller, controller.enableRotate, controller.tiltEventTypes, twist2D, controller.inertiaSpin, \"_lastInertiaTiltMovement\");\n    }\n  }\n}\n\nvar pickGlobeScratchRay = new Ray();\nvar scratchDepthIntersection = new Cartesian3();\nvar scratchRayIntersection = new Cartesian3();\n\nfunction pickGlobe(controller, mousePosition, result) {\n  var scene = controller._scene;\n  var globe = controller._globe;\n  var camera = scene.camera;\n\n  if (!defined(globe)) {\n    return undefined;\n  }\n\n  var cullBackFaces = !controller._cameraUnderground;\n  var depthIntersection;\n\n  if (scene.pickPositionSupported) {\n    depthIntersection = scene.pickPositionWorldCoordinates(mousePosition, scratchDepthIntersection);\n  }\n\n  var ray = camera.getPickRay(mousePosition, pickGlobeScratchRay);\n  var rayIntersection = globe.pickWorldCoordinates(ray, scene, cullBackFaces, scratchRayIntersection);\n  var pickDistance = defined(depthIntersection) ? Cartesian3.distance(depthIntersection, camera.positionWC) : Number.POSITIVE_INFINITY;\n  var rayDistance = defined(rayIntersection) ? Cartesian3.distance(rayIntersection, camera.positionWC) : Number.POSITIVE_INFINITY;\n\n  if (pickDistance < rayDistance) {\n    return Cartesian3.clone(depthIntersection, result);\n  }\n\n  return Cartesian3.clone(rayIntersection, result);\n}\n\nvar scratchDistanceCartographic = new Cartographic();\n\nfunction getDistanceFromSurface(controller) {\n  var ellipsoid = controller._ellipsoid;\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var mode = scene.mode;\n  var height = 0.0;\n\n  if (mode === SceneMode.SCENE3D) {\n    var cartographic = ellipsoid.cartesianToCartographic(camera.position, scratchDistanceCartographic);\n\n    if (defined(cartographic)) {\n      height = cartographic.height;\n    }\n  } else {\n    height = camera.position.z;\n  }\n\n  var globeHeight = defaultValue(controller._scene.globeHeight, 0.0);\n  var distanceFromSurface = Math.abs(globeHeight - height);\n  return distanceFromSurface;\n}\n\nvar scratchSurfaceNormal = new Cartesian3();\n\nfunction getZoomDistanceUnderground(controller, ray) {\n  var origin = ray.origin;\n  var direction = ray.direction;\n  var distanceFromSurface = getDistanceFromSurface(controller); // Weight zoom distance based on how strongly the pick ray is pointing inward.\n  // Geocentric normal is accurate enough for these purposes\n\n  var surfaceNormal = Cartesian3.normalize(origin, scratchSurfaceNormal);\n  var strength = Math.abs(Cartesian3.dot(surfaceNormal, direction));\n  strength = Math.max(strength, 0.5) * 2.0;\n  return distanceFromSurface * strength;\n}\n\nfunction getTiltCenterUnderground(controller, ray, pickedPosition, result) {\n  var distance = Cartesian3.distance(ray.origin, pickedPosition);\n  var distanceFromSurface = getDistanceFromSurface(controller);\n  var maximumDistance = CesiumMath.clamp(distanceFromSurface * 5.0, controller._minimumUndergroundPickDistance, controller._maximumUndergroundPickDistance);\n\n  if (distance > maximumDistance) {\n    // Simulate look-at behavior by tilting around a small invisible sphere\n    distance = Math.min(distance, distanceFromSurface / 5.0);\n    distance = Math.max(distance, 100.0);\n  }\n\n  return Ray.getPoint(ray, distance, result);\n}\n\nfunction getStrafeStartPositionUnderground(controller, ray, pickedPosition, result) {\n  var distance;\n\n  if (!defined(pickedPosition)) {\n    distance = getDistanceFromSurface(controller);\n  } else {\n    distance = Cartesian3.distance(ray.origin, pickedPosition);\n\n    if (distance > controller._maximumUndergroundPickDistance) {\n      // If the picked position is too far away set the strafe speed based on the\n      // camera's height from the globe surface\n      distance = getDistanceFromSurface(controller);\n    }\n  }\n\n  return Ray.getPoint(ray, distance, result);\n}\n\nvar scratchInertialDelta = new Cartesian2();\n\nfunction continueStrafing(controller, movement) {\n  // Update the end position continually based on the inertial delta\n  var originalEndPosition = movement.endPosition;\n  var inertialDelta = Cartesian2.subtract(movement.endPosition, movement.startPosition, scratchInertialDelta);\n  var endPosition = controller._strafeEndMousePosition;\n  Cartesian2.add(endPosition, inertialDelta, endPosition);\n  movement.endPosition = endPosition;\n  strafe(controller, movement, controller._strafeStartPosition);\n  movement.endPosition = originalEndPosition;\n}\n\nvar translateCVStartRay = new Ray();\nvar translateCVEndRay = new Ray();\nvar translateCVStartPos = new Cartesian3();\nvar translateCVEndPos = new Cartesian3();\nvar translateCVDifference = new Cartesian3();\nvar translateCVOrigin = new Cartesian3();\nvar translateCVPlane = new Plane(Cartesian3.UNIT_X, 0.0);\nvar translateCVStartMouse = new Cartesian2();\nvar translateCVEndMouse = new Cartesian2();\n\nfunction translateCV(controller, startPosition, movement) {\n  if (!Cartesian3.equals(startPosition, controller._translateMousePosition)) {\n    controller._looking = false;\n  }\n\n  if (!Cartesian3.equals(startPosition, controller._strafeMousePosition)) {\n    controller._strafing = false;\n  }\n\n  if (controller._looking) {\n    look3D(controller, startPosition, movement);\n    return;\n  }\n\n  if (controller._strafing) {\n    continueStrafing(controller, movement);\n    return;\n  }\n\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var cameraUnderground = controller._cameraUnderground;\n  var startMouse = Cartesian2.clone(movement.startPosition, translateCVStartMouse);\n  var endMouse = Cartesian2.clone(movement.endPosition, translateCVEndMouse);\n  var startRay = camera.getPickRay(startMouse, translateCVStartRay);\n  var origin = Cartesian3.clone(Cartesian3.ZERO, translateCVOrigin);\n  var normal = Cartesian3.UNIT_X;\n  var globePos;\n\n  if (camera.position.z < controller._minimumPickingTerrainHeight) {\n    globePos = pickGlobe(controller, startMouse, translateCVStartPos);\n\n    if (defined(globePos)) {\n      origin.x = globePos.x;\n    }\n  }\n\n  if (cameraUnderground || origin.x > camera.position.z && defined(globePos)) {\n    var pickPosition = globePos;\n\n    if (cameraUnderground) {\n      pickPosition = getStrafeStartPositionUnderground(controller, startRay, globePos, translateCVStartPos);\n    }\n\n    Cartesian2.clone(startPosition, controller._strafeMousePosition);\n    Cartesian2.clone(startPosition, controller._strafeEndMousePosition);\n    Cartesian3.clone(pickPosition, controller._strafeStartPosition);\n    controller._strafing = true;\n    strafe(controller, movement, controller._strafeStartPosition);\n    return;\n  }\n\n  var plane = Plane.fromPointNormal(origin, normal, translateCVPlane);\n  startRay = camera.getPickRay(startMouse, translateCVStartRay);\n  var startPlanePos = IntersectionTests.rayPlane(startRay, plane, translateCVStartPos);\n  var endRay = camera.getPickRay(endMouse, translateCVEndRay);\n  var endPlanePos = IntersectionTests.rayPlane(endRay, plane, translateCVEndPos);\n\n  if (!defined(startPlanePos) || !defined(endPlanePos)) {\n    controller._looking = true;\n    look3D(controller, startPosition, movement);\n    Cartesian2.clone(startPosition, controller._translateMousePosition);\n    return;\n  }\n\n  var diff = Cartesian3.subtract(startPlanePos, endPlanePos, translateCVDifference);\n  var temp = diff.x;\n  diff.x = diff.y;\n  diff.y = diff.z;\n  diff.z = temp;\n  var mag = Cartesian3.magnitude(diff);\n\n  if (mag > CesiumMath.EPSILON6) {\n    Cartesian3.normalize(diff, diff);\n    camera.move(diff, mag);\n  }\n}\n\nvar rotateCVWindowPos = new Cartesian2();\nvar rotateCVWindowRay = new Ray();\nvar rotateCVCenter = new Cartesian3();\nvar rotateCVVerticalCenter = new Cartesian3();\nvar rotateCVTransform = new Matrix4();\nvar rotateCVVerticalTransform = new Matrix4();\nvar rotateCVOrigin = new Cartesian3();\nvar rotateCVPlane = new Plane(Cartesian3.UNIT_X, 0.0);\nvar rotateCVCartesian3 = new Cartesian3();\nvar rotateCVCart = new Cartographic();\nvar rotateCVOldTransform = new Matrix4();\nvar rotateCVQuaternion = new Quaternion();\nvar rotateCVMatrix = new Matrix3();\nvar tilt3DCartesian3 = new Cartesian3();\n\nfunction rotateCV(controller, startPosition, movement) {\n  if (defined(movement.angleAndHeight)) {\n    movement = movement.angleAndHeight;\n  }\n\n  if (!Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    controller._tiltCVOffMap = false;\n    controller._looking = false;\n  }\n\n  if (controller._looking) {\n    look3D(controller, startPosition, movement);\n    return;\n  }\n\n  var scene = controller._scene;\n  var camera = scene.camera;\n\n  if (controller._tiltCVOffMap || !controller.onMap() || Math.abs(camera.position.z) > controller._minimumPickingTerrainHeight) {\n    controller._tiltCVOffMap = true;\n    rotateCVOnPlane(controller, startPosition, movement);\n  } else {\n    rotateCVOnTerrain(controller, startPosition, movement);\n  }\n}\n\nfunction rotateCVOnPlane(controller, startPosition, movement) {\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var canvas = scene.canvas;\n  var windowPosition = rotateCVWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = canvas.clientHeight / 2;\n  var ray = camera.getPickRay(windowPosition, rotateCVWindowRay);\n  var normal = Cartesian3.UNIT_X;\n  var position = ray.origin;\n  var direction = ray.direction;\n  var scalar;\n  var normalDotDirection = Cartesian3.dot(normal, direction);\n\n  if (Math.abs(normalDotDirection) > CesiumMath.EPSILON6) {\n    scalar = -Cartesian3.dot(normal, position) / normalDotDirection;\n  }\n\n  if (!defined(scalar) || scalar <= 0.0) {\n    controller._looking = true;\n    look3D(controller, startPosition, movement);\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    return;\n  }\n\n  var center = Cartesian3.multiplyByScalar(direction, scalar, rotateCVCenter);\n  Cartesian3.add(position, center, center);\n  var projection = scene.mapProjection;\n  var ellipsoid = projection.ellipsoid;\n  Cartesian3.fromElements(center.y, center.z, center.x, center);\n  var cart = projection.unproject(center, rotateCVCart);\n  ellipsoid.cartographicToCartesian(cart, center);\n  var transform = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, rotateCVTransform);\n  var oldGlobe = controller._globe;\n  var oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n  var oldTransform = Matrix4.clone(camera.transform, rotateCVOldTransform);\n\n  camera._setTransform(transform);\n\n  rotate3D(controller, startPosition, movement, Cartesian3.UNIT_Z);\n\n  camera._setTransform(oldTransform);\n\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n  var radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n}\n\nfunction rotateCVOnTerrain(controller, startPosition, movement) {\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var cameraUnderground = controller._cameraUnderground;\n  var center;\n  var ray;\n  var normal = Cartesian3.UNIT_X;\n\n  if (Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    center = Cartesian3.clone(controller._tiltCenter, rotateCVCenter);\n  } else {\n    if (camera.position.z < controller._minimumPickingTerrainHeight) {\n      center = pickGlobe(controller, startPosition, rotateCVCenter);\n    }\n\n    if (!defined(center)) {\n      ray = camera.getPickRay(startPosition, rotateCVWindowRay);\n      var position = ray.origin;\n      var direction = ray.direction;\n      var scalar;\n      var normalDotDirection = Cartesian3.dot(normal, direction);\n\n      if (Math.abs(normalDotDirection) > CesiumMath.EPSILON6) {\n        scalar = -Cartesian3.dot(normal, position) / normalDotDirection;\n      }\n\n      if (!defined(scalar) || scalar <= 0.0) {\n        controller._looking = true;\n        look3D(controller, startPosition, movement);\n        Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n        return;\n      }\n\n      center = Cartesian3.multiplyByScalar(direction, scalar, rotateCVCenter);\n      Cartesian3.add(position, center, center);\n    }\n\n    if (cameraUnderground) {\n      if (!defined(ray)) {\n        ray = camera.getPickRay(startPosition, rotateCVWindowRay);\n      }\n\n      getTiltCenterUnderground(controller, ray, center, center);\n    }\n\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    Cartesian3.clone(center, controller._tiltCenter);\n  }\n\n  var canvas = scene.canvas;\n  var windowPosition = rotateCVWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = controller._tiltCenterMousePosition.y;\n  ray = camera.getPickRay(windowPosition, rotateCVWindowRay);\n  var origin = Cartesian3.clone(Cartesian3.ZERO, rotateCVOrigin);\n  origin.x = center.x;\n  var plane = Plane.fromPointNormal(origin, normal, rotateCVPlane);\n  var verticalCenter = IntersectionTests.rayPlane(ray, plane, rotateCVVerticalCenter);\n  var projection = camera._projection;\n  var ellipsoid = projection.ellipsoid;\n  Cartesian3.fromElements(center.y, center.z, center.x, center);\n  var cart = projection.unproject(center, rotateCVCart);\n  ellipsoid.cartographicToCartesian(cart, center);\n  var transform = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, rotateCVTransform);\n  var verticalTransform;\n\n  if (defined(verticalCenter)) {\n    Cartesian3.fromElements(verticalCenter.y, verticalCenter.z, verticalCenter.x, verticalCenter);\n    cart = projection.unproject(verticalCenter, rotateCVCart);\n    ellipsoid.cartographicToCartesian(cart, verticalCenter);\n    verticalTransform = Transforms.eastNorthUpToFixedFrame(verticalCenter, ellipsoid, rotateCVVerticalTransform);\n  } else {\n    verticalTransform = transform;\n  }\n\n  var oldGlobe = controller._globe;\n  var oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n  var constrainedAxis = Cartesian3.UNIT_Z;\n  var oldTransform = Matrix4.clone(camera.transform, rotateCVOldTransform);\n\n  camera._setTransform(transform);\n\n  var tangent = Cartesian3.cross(Cartesian3.UNIT_Z, Cartesian3.normalize(camera.position, rotateCVCartesian3), rotateCVCartesian3);\n  var dot = Cartesian3.dot(camera.right, tangent);\n  rotate3D(controller, startPosition, movement, constrainedAxis, false, true);\n\n  camera._setTransform(verticalTransform);\n\n  if (dot < 0.0) {\n    var movementDelta = movement.startPosition.y - movement.endPosition.y;\n\n    if (cameraUnderground && movementDelta < 0.0 || !cameraUnderground && movementDelta > 0.0) {\n      // Prevent camera from flipping past the up axis\n      constrainedAxis = undefined;\n    }\n\n    var oldConstrainedAxis = camera.constrainedAxis;\n    camera.constrainedAxis = undefined;\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n    camera.constrainedAxis = oldConstrainedAxis;\n  } else {\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n  }\n\n  if (defined(camera.constrainedAxis)) {\n    var right = Cartesian3.cross(camera.direction, camera.constrainedAxis, tilt3DCartesian3);\n\n    if (!Cartesian3.equalsEpsilon(right, Cartesian3.ZERO, CesiumMath.EPSILON6)) {\n      if (Cartesian3.dot(right, camera.right) < 0.0) {\n        Cartesian3.negate(right, right);\n      }\n\n      Cartesian3.cross(right, camera.direction, camera.up);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n      Cartesian3.normalize(camera.up, camera.up);\n      Cartesian3.normalize(camera.right, camera.right);\n    }\n  }\n\n  camera._setTransform(oldTransform);\n\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n  var radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n  var originalPosition = Cartesian3.clone(camera.positionWC, rotateCVCartesian3);\n\n  if (controller.enableCollisionDetection) {\n    adjustHeightForTerrain(controller);\n  }\n\n  if (!Cartesian3.equals(camera.positionWC, originalPosition)) {\n    camera._setTransform(verticalTransform);\n\n    camera.worldToCameraCoordinatesPoint(originalPosition, originalPosition);\n    var magSqrd = Cartesian3.magnitudeSquared(originalPosition);\n\n    if (Cartesian3.magnitudeSquared(camera.position) > magSqrd) {\n      Cartesian3.normalize(camera.position, camera.position);\n      Cartesian3.multiplyByScalar(camera.position, Math.sqrt(magSqrd), camera.position);\n    }\n\n    var angle = Cartesian3.angleBetween(originalPosition, camera.position);\n    var axis = Cartesian3.cross(originalPosition, camera.position, originalPosition);\n    Cartesian3.normalize(axis, axis);\n    var quaternion = Quaternion.fromAxisAngle(axis, angle, rotateCVQuaternion);\n    var rotation = Matrix3.fromQuaternion(quaternion, rotateCVMatrix);\n    Matrix3.multiplyByVector(rotation, camera.direction, camera.direction);\n    Matrix3.multiplyByVector(rotation, camera.up, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n    Cartesian3.cross(camera.right, camera.direction, camera.up);\n\n    camera._setTransform(oldTransform);\n  }\n}\n\nvar zoomCVWindowPos = new Cartesian2();\nvar zoomCVWindowRay = new Ray();\nvar zoomCVIntersection = new Cartesian3();\n\nfunction zoomCV(controller, startPosition, movement) {\n  if (defined(movement.distance)) {\n    movement = movement.distance;\n  }\n\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var canvas = scene.canvas;\n  var cameraUnderground = controller._cameraUnderground;\n  var windowPosition;\n\n  if (cameraUnderground) {\n    windowPosition = startPosition;\n  } else {\n    windowPosition = zoomCVWindowPos;\n    windowPosition.x = canvas.clientWidth / 2;\n    windowPosition.y = canvas.clientHeight / 2;\n  }\n\n  var ray = camera.getPickRay(windowPosition, zoomCVWindowRay);\n  var position = ray.origin;\n  var direction = ray.direction;\n  var height = camera.position.z;\n  var intersection;\n\n  if (height < controller._minimumPickingTerrainHeight) {\n    intersection = pickGlobe(controller, windowPosition, zoomCVIntersection);\n  }\n\n  var distance;\n\n  if (defined(intersection)) {\n    distance = Cartesian3.distance(position, intersection);\n  }\n\n  if (cameraUnderground) {\n    var distanceUnderground = getZoomDistanceUnderground(controller, ray, height);\n\n    if (defined(distance)) {\n      distance = Math.min(distance, distanceUnderground);\n    } else {\n      distance = distanceUnderground;\n    }\n  }\n\n  if (!defined(distance)) {\n    var normal = Cartesian3.UNIT_X;\n    distance = -Cartesian3.dot(normal, position) / Cartesian3.dot(normal, direction);\n  }\n\n  handleZoom(controller, startPosition, movement, controller._zoomFactor, distance);\n}\n\nfunction updateCV(controller) {\n  var scene = controller._scene;\n  var camera = scene.camera;\n\n  if (!Matrix4.equals(Matrix4.IDENTITY, camera.transform)) {\n    reactToInput(controller, controller.enableRotate, controller.rotateEventTypes, rotate3D, controller.inertiaSpin, \"_lastInertiaSpinMovement\");\n    reactToInput(controller, controller.enableZoom, controller.zoomEventTypes, zoom3D, controller.inertiaZoom, \"_lastInertiaZoomMovement\");\n  } else {\n    var tweens = controller._tweens;\n\n    if (controller._aggregator.anyButtonDown) {\n      tweens.removeAll();\n    }\n\n    reactToInput(controller, controller.enableTilt, controller.tiltEventTypes, rotateCV, controller.inertiaSpin, \"_lastInertiaTiltMovement\");\n    reactToInput(controller, controller.enableTranslate, controller.translateEventTypes, translateCV, controller.inertiaTranslate, \"_lastInertiaTranslateMovement\");\n    reactToInput(controller, controller.enableZoom, controller.zoomEventTypes, zoomCV, controller.inertiaZoom, \"_lastInertiaZoomMovement\");\n    reactToInput(controller, controller.enableLook, controller.lookEventTypes, look3D);\n\n    if (!controller._aggregator.anyButtonDown && !tweens.contains(controller._tween)) {\n      var tween = camera.createCorrectPositionTween(controller.bounceAnimationTime);\n\n      if (defined(tween)) {\n        controller._tween = tweens.add(tween);\n      }\n    }\n\n    tweens.update();\n  }\n}\n\nvar scratchStrafeRay = new Ray();\nvar scratchStrafePlane = new Plane(Cartesian3.UNIT_X, 0.0);\nvar scratchStrafeIntersection = new Cartesian3();\nvar scratchStrafeDirection = new Cartesian3();\nvar scratchMousePos = new Cartesian3();\n\nfunction strafe(controller, movement, strafeStartPosition) {\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var ray = camera.getPickRay(movement.endPosition, scratchStrafeRay);\n  var direction = Cartesian3.clone(camera.direction, scratchStrafeDirection);\n\n  if (scene.mode === SceneMode.COLUMBUS_VIEW) {\n    Cartesian3.fromElements(direction.z, direction.x, direction.y, direction);\n  }\n\n  var plane = Plane.fromPointNormal(strafeStartPosition, direction, scratchStrafePlane);\n  var intersection = IntersectionTests.rayPlane(ray, plane, scratchStrafeIntersection);\n\n  if (!defined(intersection)) {\n    return;\n  }\n\n  direction = Cartesian3.subtract(strafeStartPosition, intersection, direction);\n\n  if (scene.mode === SceneMode.COLUMBUS_VIEW) {\n    Cartesian3.fromElements(direction.y, direction.z, direction.x, direction);\n  }\n\n  Cartesian3.add(camera.position, direction, camera.position);\n}\n\nvar spin3DPick = new Cartesian3();\nvar scratchCartographic = new Cartographic();\nvar scratchRadii = new Cartesian3();\nvar scratchEllipsoid = new Ellipsoid();\nvar scratchLookUp = new Cartesian3();\nvar scratchNormal = new Cartesian3();\n\nfunction spin3D(controller, startPosition, movement) {\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var cameraUnderground = controller._cameraUnderground;\n  var ellipsoid = controller._ellipsoid;\n\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    rotate3D(controller, startPosition, movement);\n    return;\n  }\n\n  var magnitude;\n  var radii;\n  var up = ellipsoid.geodeticSurfaceNormal(camera.position, scratchLookUp);\n\n  if (Cartesian2.equals(startPosition, controller._rotateMousePosition)) {\n    if (controller._looking) {\n      look3D(controller, startPosition, movement, up);\n    } else if (controller._rotating) {\n      rotate3D(controller, startPosition, movement);\n    } else if (controller._strafing) {\n      continueStrafing(controller, movement);\n    } else {\n      if (Cartesian3.magnitude(camera.position) < Cartesian3.magnitude(controller._rotateStartPosition)) {\n        // Pan action is no longer valid if camera moves below the pan ellipsoid\n        return;\n      }\n\n      magnitude = Cartesian3.magnitude(controller._rotateStartPosition);\n      radii = scratchRadii;\n      radii.x = radii.y = radii.z = magnitude;\n      ellipsoid = Ellipsoid.fromCartesian3(radii, scratchEllipsoid);\n      pan3D(controller, startPosition, movement, ellipsoid);\n    }\n\n    return;\n  }\n\n  controller._looking = false;\n  controller._rotating = false;\n  controller._strafing = false;\n  var height = ellipsoid.cartesianToCartographic(camera.positionWC, scratchCartographic).height;\n  var globe = controller._globe;\n\n  if (defined(globe) && height < controller._minimumPickingTerrainHeight) {\n    var mousePos = pickGlobe(controller, movement.startPosition, scratchMousePos);\n\n    if (defined(mousePos)) {\n      var strafing = false;\n      var ray = camera.getPickRay(movement.startPosition, pickGlobeScratchRay);\n\n      if (cameraUnderground) {\n        strafing = true;\n        getStrafeStartPositionUnderground(controller, ray, mousePos, mousePos);\n      } else {\n        var normal = ellipsoid.geodeticSurfaceNormal(mousePos, scratchNormal);\n        var tangentPick = Math.abs(Cartesian3.dot(ray.direction, normal)) < 0.05;\n\n        if (tangentPick) {\n          strafing = true;\n        } else {\n          strafing = Cartesian3.magnitude(camera.position) < Cartesian3.magnitude(mousePos);\n        }\n      }\n\n      if (strafing) {\n        Cartesian2.clone(startPosition, controller._strafeEndMousePosition);\n        Cartesian3.clone(mousePos, controller._strafeStartPosition);\n        controller._strafing = true;\n        strafe(controller, movement, controller._strafeStartPosition);\n      } else {\n        magnitude = Cartesian3.magnitude(mousePos);\n        radii = scratchRadii;\n        radii.x = radii.y = radii.z = magnitude;\n        ellipsoid = Ellipsoid.fromCartesian3(radii, scratchEllipsoid);\n        pan3D(controller, startPosition, movement, ellipsoid);\n        Cartesian3.clone(mousePos, controller._rotateStartPosition);\n      }\n    } else {\n      controller._looking = true;\n      look3D(controller, startPosition, movement, up);\n    }\n  } else if (defined(camera.pickEllipsoid(movement.startPosition, controller._ellipsoid, spin3DPick))) {\n    pan3D(controller, startPosition, movement, controller._ellipsoid);\n    Cartesian3.clone(spin3DPick, controller._rotateStartPosition);\n  } else if (height > controller._minimumTrackBallHeight) {\n    controller._rotating = true;\n    rotate3D(controller, startPosition, movement);\n  } else {\n    controller._looking = true;\n    look3D(controller, startPosition, movement, up);\n  }\n\n  Cartesian2.clone(startPosition, controller._rotateMousePosition);\n}\n\nfunction rotate3D(controller, startPosition, movement, constrainedAxis, rotateOnlyVertical, rotateOnlyHorizontal) {\n  rotateOnlyVertical = defaultValue(rotateOnlyVertical, false);\n  rotateOnlyHorizontal = defaultValue(rotateOnlyHorizontal, false);\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var canvas = scene.canvas;\n  var oldAxis = camera.constrainedAxis;\n\n  if (defined(constrainedAxis)) {\n    camera.constrainedAxis = constrainedAxis;\n  }\n\n  var rho = Cartesian3.magnitude(camera.position);\n  var rotateRate = controller._rotateFactor * (rho - controller._rotateRateRangeAdjustment);\n\n  if (rotateRate > controller._maximumRotateRate) {\n    rotateRate = controller._maximumRotateRate;\n  }\n\n  if (rotateRate < controller._minimumRotateRate) {\n    rotateRate = controller._minimumRotateRate;\n  }\n\n  var phiWindowRatio = (movement.startPosition.x - movement.endPosition.x) / canvas.clientWidth;\n  var thetaWindowRatio = (movement.startPosition.y - movement.endPosition.y) / canvas.clientHeight;\n  phiWindowRatio = Math.min(phiWindowRatio, controller.maximumMovementRatio);\n  thetaWindowRatio = Math.min(thetaWindowRatio, controller.maximumMovementRatio);\n  var deltaPhi = rotateRate * phiWindowRatio * Math.PI * 2.0;\n  var deltaTheta = rotateRate * thetaWindowRatio * Math.PI;\n\n  if (!rotateOnlyVertical) {\n    camera.rotateRight(deltaPhi);\n  }\n\n  if (!rotateOnlyHorizontal) {\n    camera.rotateUp(deltaTheta);\n  }\n\n  camera.constrainedAxis = oldAxis;\n}\n\nvar pan3DP0 = Cartesian4.clone(Cartesian4.UNIT_W);\nvar pan3DP1 = Cartesian4.clone(Cartesian4.UNIT_W);\nvar pan3DTemp0 = new Cartesian3();\nvar pan3DTemp1 = new Cartesian3();\nvar pan3DTemp2 = new Cartesian3();\nvar pan3DTemp3 = new Cartesian3();\nvar pan3DStartMousePosition = new Cartesian2();\nvar pan3DEndMousePosition = new Cartesian2();\n\nfunction pan3D(controller, startPosition, movement, ellipsoid) {\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var startMousePosition = Cartesian2.clone(movement.startPosition, pan3DStartMousePosition);\n  var endMousePosition = Cartesian2.clone(movement.endPosition, pan3DEndMousePosition);\n  var p0 = camera.pickEllipsoid(startMousePosition, ellipsoid, pan3DP0);\n  var p1 = camera.pickEllipsoid(endMousePosition, ellipsoid, pan3DP1);\n\n  if (!defined(p0) || !defined(p1)) {\n    controller._rotating = true;\n    rotate3D(controller, startPosition, movement);\n    return;\n  }\n\n  p0 = camera.worldToCameraCoordinates(p0, p0);\n  p1 = camera.worldToCameraCoordinates(p1, p1);\n\n  if (!defined(camera.constrainedAxis)) {\n    Cartesian3.normalize(p0, p0);\n    Cartesian3.normalize(p1, p1);\n    var dot = Cartesian3.dot(p0, p1);\n    var axis = Cartesian3.cross(p0, p1, pan3DTemp0);\n\n    if (dot < 1.0 && !Cartesian3.equalsEpsilon(axis, Cartesian3.ZERO, CesiumMath.EPSILON14)) {\n      // dot is in [0, 1]\n      var angle = Math.acos(dot);\n      camera.rotate(axis, angle);\n    }\n  } else {\n    var basis0 = camera.constrainedAxis;\n    var basis1 = Cartesian3.mostOrthogonalAxis(basis0, pan3DTemp0);\n    Cartesian3.cross(basis1, basis0, basis1);\n    Cartesian3.normalize(basis1, basis1);\n    var basis2 = Cartesian3.cross(basis0, basis1, pan3DTemp1);\n    var startRho = Cartesian3.magnitude(p0);\n    var startDot = Cartesian3.dot(basis0, p0);\n    var startTheta = Math.acos(startDot / startRho);\n    var startRej = Cartesian3.multiplyByScalar(basis0, startDot, pan3DTemp2);\n    Cartesian3.subtract(p0, startRej, startRej);\n    Cartesian3.normalize(startRej, startRej);\n    var endRho = Cartesian3.magnitude(p1);\n    var endDot = Cartesian3.dot(basis0, p1);\n    var endTheta = Math.acos(endDot / endRho);\n    var endRej = Cartesian3.multiplyByScalar(basis0, endDot, pan3DTemp3);\n    Cartesian3.subtract(p1, endRej, endRej);\n    Cartesian3.normalize(endRej, endRej);\n    var startPhi = Math.acos(Cartesian3.dot(startRej, basis1));\n\n    if (Cartesian3.dot(startRej, basis2) < 0) {\n      startPhi = CesiumMath.TWO_PI - startPhi;\n    }\n\n    var endPhi = Math.acos(Cartesian3.dot(endRej, basis1));\n\n    if (Cartesian3.dot(endRej, basis2) < 0) {\n      endPhi = CesiumMath.TWO_PI - endPhi;\n    }\n\n    var deltaPhi = startPhi - endPhi;\n    var east;\n\n    if (Cartesian3.equalsEpsilon(basis0, camera.position, CesiumMath.EPSILON2)) {\n      east = camera.right;\n    } else {\n      east = Cartesian3.cross(basis0, camera.position, pan3DTemp0);\n    }\n\n    var planeNormal = Cartesian3.cross(basis0, east, pan3DTemp0);\n    var side0 = Cartesian3.dot(planeNormal, Cartesian3.subtract(p0, basis0, pan3DTemp1));\n    var side1 = Cartesian3.dot(planeNormal, Cartesian3.subtract(p1, basis0, pan3DTemp1));\n    var deltaTheta;\n\n    if (side0 > 0 && side1 > 0) {\n      deltaTheta = endTheta - startTheta;\n    } else if (side0 > 0 && side1 <= 0) {\n      if (Cartesian3.dot(camera.position, basis0) > 0) {\n        deltaTheta = -startTheta - endTheta;\n      } else {\n        deltaTheta = startTheta + endTheta;\n      }\n    } else {\n      deltaTheta = startTheta - endTheta;\n    }\n\n    camera.rotateRight(deltaPhi);\n    camera.rotateUp(deltaTheta);\n  }\n}\n\nvar zoom3DUnitPosition = new Cartesian3();\nvar zoom3DCartographic = new Cartographic();\n\nfunction zoom3D(controller, startPosition, movement) {\n  if (defined(movement.distance)) {\n    movement = movement.distance;\n  }\n\n  var ellipsoid = controller._ellipsoid;\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var canvas = scene.canvas;\n  var cameraUnderground = controller._cameraUnderground;\n  var windowPosition;\n\n  if (cameraUnderground) {\n    windowPosition = startPosition;\n  } else {\n    windowPosition = zoomCVWindowPos;\n    windowPosition.x = canvas.clientWidth / 2;\n    windowPosition.y = canvas.clientHeight / 2;\n  }\n\n  var ray = camera.getPickRay(windowPosition, zoomCVWindowRay);\n  var intersection;\n  var height = ellipsoid.cartesianToCartographic(camera.position, zoom3DCartographic).height;\n\n  if (height < controller._minimumPickingTerrainHeight) {\n    intersection = pickGlobe(controller, windowPosition, zoomCVIntersection);\n  }\n\n  var distance;\n\n  if (defined(intersection)) {\n    distance = Cartesian3.distance(ray.origin, intersection);\n  }\n\n  if (cameraUnderground) {\n    var distanceUnderground = getZoomDistanceUnderground(controller, ray, height);\n\n    if (defined(distance)) {\n      distance = Math.min(distance, distanceUnderground);\n    } else {\n      distance = distanceUnderground;\n    }\n  }\n\n  if (!defined(distance)) {\n    distance = height;\n  }\n\n  var unitPosition = Cartesian3.normalize(camera.position, zoom3DUnitPosition);\n  handleZoom(controller, startPosition, movement, controller._zoomFactor, distance, Cartesian3.dot(unitPosition, camera.direction));\n}\n\nvar tilt3DWindowPos = new Cartesian2();\nvar tilt3DRay = new Ray();\nvar tilt3DCenter = new Cartesian3();\nvar tilt3DVerticalCenter = new Cartesian3();\nvar tilt3DTransform = new Matrix4();\nvar tilt3DVerticalTransform = new Matrix4();\nvar tilt3DOldTransform = new Matrix4();\nvar tilt3DQuaternion = new Quaternion();\nvar tilt3DMatrix = new Matrix3();\nvar tilt3DCart = new Cartographic();\nvar tilt3DLookUp = new Cartesian3();\n\nfunction tilt3D(controller, startPosition, movement) {\n  var scene = controller._scene;\n  var camera = scene.camera;\n\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    return;\n  }\n\n  if (defined(movement.angleAndHeight)) {\n    movement = movement.angleAndHeight;\n  }\n\n  if (!Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    controller._tiltOnEllipsoid = false;\n    controller._looking = false;\n  }\n\n  if (controller._looking) {\n    var up = controller._ellipsoid.geodeticSurfaceNormal(camera.position, tilt3DLookUp);\n\n    look3D(controller, startPosition, movement, up);\n    return;\n  }\n\n  var ellipsoid = controller._ellipsoid;\n  var cartographic = ellipsoid.cartesianToCartographic(camera.position, tilt3DCart);\n\n  if (controller._tiltOnEllipsoid || cartographic.height > controller._minimumCollisionTerrainHeight) {\n    controller._tiltOnEllipsoid = true;\n    tilt3DOnEllipsoid(controller, startPosition, movement);\n  } else {\n    tilt3DOnTerrain(controller, startPosition, movement);\n  }\n}\n\nvar tilt3DOnEllipsoidCartographic = new Cartographic();\n\nfunction tilt3DOnEllipsoid(controller, startPosition, movement) {\n  var ellipsoid = controller._ellipsoid;\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var minHeight = controller.minimumZoomDistance * 0.25;\n  var height = ellipsoid.cartesianToCartographic(camera.positionWC, tilt3DOnEllipsoidCartographic).height;\n\n  if (height - minHeight - 1.0 < CesiumMath.EPSILON3 && movement.endPosition.y - movement.startPosition.y < 0) {\n    return;\n  }\n\n  var canvas = scene.canvas;\n  var windowPosition = tilt3DWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = canvas.clientHeight / 2;\n  var ray = camera.getPickRay(windowPosition, tilt3DRay);\n  var center;\n  var intersection = IntersectionTests.rayEllipsoid(ray, ellipsoid);\n\n  if (defined(intersection)) {\n    center = Ray.getPoint(ray, intersection.start, tilt3DCenter);\n  } else if (height > controller._minimumTrackBallHeight) {\n    var grazingAltitudeLocation = IntersectionTests.grazingAltitudeLocation(ray, ellipsoid);\n\n    if (!defined(grazingAltitudeLocation)) {\n      return;\n    }\n\n    var grazingAltitudeCart = ellipsoid.cartesianToCartographic(grazingAltitudeLocation, tilt3DCart);\n    grazingAltitudeCart.height = 0.0;\n    center = ellipsoid.cartographicToCartesian(grazingAltitudeCart, tilt3DCenter);\n  } else {\n    controller._looking = true;\n\n    var up = controller._ellipsoid.geodeticSurfaceNormal(camera.position, tilt3DLookUp);\n\n    look3D(controller, startPosition, movement, up);\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    return;\n  }\n\n  var transform = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, tilt3DTransform);\n  var oldGlobe = controller._globe;\n  var oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n  var oldTransform = Matrix4.clone(camera.transform, tilt3DOldTransform);\n\n  camera._setTransform(transform);\n\n  rotate3D(controller, startPosition, movement, Cartesian3.UNIT_Z);\n\n  camera._setTransform(oldTransform);\n\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n  var radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n}\n\nfunction tilt3DOnTerrain(controller, startPosition, movement) {\n  var ellipsoid = controller._ellipsoid;\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var cameraUnderground = controller._cameraUnderground;\n  var center;\n  var ray;\n  var intersection;\n\n  if (Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    center = Cartesian3.clone(controller._tiltCenter, tilt3DCenter);\n  } else {\n    center = pickGlobe(controller, startPosition, tilt3DCenter);\n\n    if (!defined(center)) {\n      ray = camera.getPickRay(startPosition, tilt3DRay);\n      intersection = IntersectionTests.rayEllipsoid(ray, ellipsoid);\n\n      if (!defined(intersection)) {\n        var cartographic = ellipsoid.cartesianToCartographic(camera.position, tilt3DCart);\n\n        if (cartographic.height <= controller._minimumTrackBallHeight) {\n          controller._looking = true;\n\n          var up = controller._ellipsoid.geodeticSurfaceNormal(camera.position, tilt3DLookUp);\n\n          look3D(controller, startPosition, movement, up);\n          Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n        }\n\n        return;\n      }\n\n      center = Ray.getPoint(ray, intersection.start, tilt3DCenter);\n    }\n\n    if (cameraUnderground) {\n      if (!defined(ray)) {\n        ray = camera.getPickRay(startPosition, tilt3DRay);\n      }\n\n      getTiltCenterUnderground(controller, ray, center, center);\n    }\n\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    Cartesian3.clone(center, controller._tiltCenter);\n  }\n\n  var canvas = scene.canvas;\n  var windowPosition = tilt3DWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = controller._tiltCenterMousePosition.y;\n  ray = camera.getPickRay(windowPosition, tilt3DRay);\n  var mag = Cartesian3.magnitude(center);\n  var radii = Cartesian3.fromElements(mag, mag, mag, scratchRadii);\n  var newEllipsoid = Ellipsoid.fromCartesian3(radii, scratchEllipsoid);\n  intersection = IntersectionTests.rayEllipsoid(ray, newEllipsoid);\n\n  if (!defined(intersection)) {\n    return;\n  }\n\n  var t = Cartesian3.magnitude(ray.origin) > mag ? intersection.start : intersection.stop;\n  var verticalCenter = Ray.getPoint(ray, t, tilt3DVerticalCenter);\n  var transform = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, tilt3DTransform);\n  var verticalTransform = Transforms.eastNorthUpToFixedFrame(verticalCenter, newEllipsoid, tilt3DVerticalTransform);\n  var oldGlobe = controller._globe;\n  var oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n  var constrainedAxis = Cartesian3.UNIT_Z;\n  var oldTransform = Matrix4.clone(camera.transform, tilt3DOldTransform);\n\n  camera._setTransform(transform);\n\n  var tangent = Cartesian3.cross(verticalCenter, camera.positionWC, tilt3DCartesian3);\n  var dot = Cartesian3.dot(camera.rightWC, tangent);\n  rotate3D(controller, startPosition, movement, constrainedAxis, false, true);\n\n  camera._setTransform(verticalTransform);\n\n  if (dot < 0.0) {\n    var movementDelta = movement.startPosition.y - movement.endPosition.y;\n\n    if (cameraUnderground && movementDelta < 0.0 || !cameraUnderground && movementDelta > 0.0) {\n      // Prevent camera from flipping past the up axis\n      constrainedAxis = undefined;\n    }\n\n    var oldConstrainedAxis = camera.constrainedAxis;\n    camera.constrainedAxis = undefined;\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n    camera.constrainedAxis = oldConstrainedAxis;\n  } else {\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n  }\n\n  if (defined(camera.constrainedAxis)) {\n    var right = Cartesian3.cross(camera.direction, camera.constrainedAxis, tilt3DCartesian3);\n\n    if (!Cartesian3.equalsEpsilon(right, Cartesian3.ZERO, CesiumMath.EPSILON6)) {\n      if (Cartesian3.dot(right, camera.right) < 0.0) {\n        Cartesian3.negate(right, right);\n      }\n\n      Cartesian3.cross(right, camera.direction, camera.up);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n      Cartesian3.normalize(camera.up, camera.up);\n      Cartesian3.normalize(camera.right, camera.right);\n    }\n  }\n\n  camera._setTransform(oldTransform);\n\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n  var radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n  var originalPosition = Cartesian3.clone(camera.positionWC, tilt3DCartesian3);\n\n  if (controller.enableCollisionDetection) {\n    adjustHeightForTerrain(controller);\n  }\n\n  if (!Cartesian3.equals(camera.positionWC, originalPosition)) {\n    camera._setTransform(verticalTransform);\n\n    camera.worldToCameraCoordinatesPoint(originalPosition, originalPosition);\n    var magSqrd = Cartesian3.magnitudeSquared(originalPosition);\n\n    if (Cartesian3.magnitudeSquared(camera.position) > magSqrd) {\n      Cartesian3.normalize(camera.position, camera.position);\n      Cartesian3.multiplyByScalar(camera.position, Math.sqrt(magSqrd), camera.position);\n    }\n\n    var angle = Cartesian3.angleBetween(originalPosition, camera.position);\n    var axis = Cartesian3.cross(originalPosition, camera.position, originalPosition);\n    Cartesian3.normalize(axis, axis);\n    var quaternion = Quaternion.fromAxisAngle(axis, angle, tilt3DQuaternion);\n    var rotation = Matrix3.fromQuaternion(quaternion, tilt3DMatrix);\n    Matrix3.multiplyByVector(rotation, camera.direction, camera.direction);\n    Matrix3.multiplyByVector(rotation, camera.up, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n    Cartesian3.cross(camera.right, camera.direction, camera.up);\n\n    camera._setTransform(oldTransform);\n  }\n}\n\nvar look3DStartPos = new Cartesian2();\nvar look3DEndPos = new Cartesian2();\nvar look3DStartRay = new Ray();\nvar look3DEndRay = new Ray();\nvar look3DNegativeRot = new Cartesian3();\nvar look3DTan = new Cartesian3();\n\nfunction look3D(controller, startPosition, movement, rotationAxis) {\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var startPos = look3DStartPos;\n  startPos.x = movement.startPosition.x;\n  startPos.y = 0.0;\n  var endPos = look3DEndPos;\n  endPos.x = movement.endPosition.x;\n  endPos.y = 0.0;\n  var startRay = camera.getPickRay(startPos, look3DStartRay);\n  var endRay = camera.getPickRay(endPos, look3DEndRay);\n  var angle = 0.0;\n  var start;\n  var end;\n\n  if (camera.frustum instanceof OrthographicFrustum) {\n    start = startRay.origin;\n    end = endRay.origin;\n    Cartesian3.add(camera.direction, start, start);\n    Cartesian3.add(camera.direction, end, end);\n    Cartesian3.subtract(start, camera.position, start);\n    Cartesian3.subtract(end, camera.position, end);\n    Cartesian3.normalize(start, start);\n    Cartesian3.normalize(end, end);\n  } else {\n    start = startRay.direction;\n    end = endRay.direction;\n  }\n\n  var dot = Cartesian3.dot(start, end);\n\n  if (dot < 1.0) {\n    // dot is in [0, 1]\n    angle = Math.acos(dot);\n  }\n\n  angle = movement.startPosition.x > movement.endPosition.x ? -angle : angle;\n  var horizontalRotationAxis = controller._horizontalRotationAxis;\n\n  if (defined(rotationAxis)) {\n    camera.look(rotationAxis, -angle);\n  } else if (defined(horizontalRotationAxis)) {\n    camera.look(horizontalRotationAxis, -angle);\n  } else {\n    camera.lookLeft(angle);\n  }\n\n  startPos.x = 0.0;\n  startPos.y = movement.startPosition.y;\n  endPos.x = 0.0;\n  endPos.y = movement.endPosition.y;\n  startRay = camera.getPickRay(startPos, look3DStartRay);\n  endRay = camera.getPickRay(endPos, look3DEndRay);\n  angle = 0.0;\n\n  if (camera.frustum instanceof OrthographicFrustum) {\n    start = startRay.origin;\n    end = endRay.origin;\n    Cartesian3.add(camera.direction, start, start);\n    Cartesian3.add(camera.direction, end, end);\n    Cartesian3.subtract(start, camera.position, start);\n    Cartesian3.subtract(end, camera.position, end);\n    Cartesian3.normalize(start, start);\n    Cartesian3.normalize(end, end);\n  } else {\n    start = startRay.direction;\n    end = endRay.direction;\n  }\n\n  dot = Cartesian3.dot(start, end);\n\n  if (dot < 1.0) {\n    // dot is in [0, 1]\n    angle = Math.acos(dot);\n  }\n\n  angle = movement.startPosition.y > movement.endPosition.y ? -angle : angle;\n  rotationAxis = defaultValue(rotationAxis, horizontalRotationAxis);\n\n  if (defined(rotationAxis)) {\n    var direction = camera.direction;\n    var negativeRotationAxis = Cartesian3.negate(rotationAxis, look3DNegativeRot);\n    var northParallel = Cartesian3.equalsEpsilon(direction, rotationAxis, CesiumMath.EPSILON2);\n    var southParallel = Cartesian3.equalsEpsilon(direction, negativeRotationAxis, CesiumMath.EPSILON2);\n\n    if (!northParallel && !southParallel) {\n      dot = Cartesian3.dot(direction, rotationAxis);\n      var angleToAxis = CesiumMath.acosClamped(dot);\n\n      if (angle > 0 && angle > angleToAxis) {\n        angle = angleToAxis - CesiumMath.EPSILON4;\n      }\n\n      dot = Cartesian3.dot(direction, negativeRotationAxis);\n      angleToAxis = CesiumMath.acosClamped(dot);\n\n      if (angle < 0 && -angle > angleToAxis) {\n        angle = -angleToAxis + CesiumMath.EPSILON4;\n      }\n\n      var tangent = Cartesian3.cross(rotationAxis, direction, look3DTan);\n      camera.look(tangent, angle);\n    } else if (northParallel && angle < 0 || southParallel && angle > 0) {\n      camera.look(camera.right, -angle);\n    }\n  } else {\n    camera.lookUp(angle);\n  }\n}\n\nfunction update3D(controller) {\n  reactToInput(controller, controller.enableRotate, controller.rotateEventTypes, spin3D, controller.inertiaSpin, \"_lastInertiaSpinMovement\");\n  reactToInput(controller, controller.enableZoom, controller.zoomEventTypes, zoom3D, controller.inertiaZoom, \"_lastInertiaZoomMovement\");\n  reactToInput(controller, controller.enableTilt, controller.tiltEventTypes, tilt3D, controller.inertiaSpin, \"_lastInertiaTiltMovement\");\n  reactToInput(controller, controller.enableLook, controller.lookEventTypes, look3D);\n}\n\nvar scratchAdjustHeightTransform = new Matrix4();\nvar scratchAdjustHeightCartographic = new Cartographic();\n\nfunction adjustHeightForTerrain(controller) {\n  controller._adjustedHeightForTerrain = true;\n  var scene = controller._scene;\n  var mode = scene.mode;\n  var globe = scene.globe;\n\n  if (!defined(globe) || mode === SceneMode.SCENE2D || mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  var camera = scene.camera;\n  var ellipsoid = globe.ellipsoid;\n  var projection = scene.mapProjection;\n  var transform;\n  var mag;\n\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    transform = Matrix4.clone(camera.transform, scratchAdjustHeightTransform);\n    mag = Cartesian3.magnitude(camera.position);\n\n    camera._setTransform(Matrix4.IDENTITY);\n  }\n\n  var cartographic = scratchAdjustHeightCartographic;\n\n  if (mode === SceneMode.SCENE3D) {\n    ellipsoid.cartesianToCartographic(camera.position, cartographic);\n  } else {\n    projection.unproject(camera.position, cartographic);\n  }\n\n  var heightUpdated = false;\n\n  if (cartographic.height < controller._minimumCollisionTerrainHeight) {\n    var globeHeight = controller._scene.globeHeight;\n\n    if (defined(globeHeight)) {\n      var height = globeHeight + controller.minimumZoomDistance;\n\n      if (cartographic.height < height) {\n        cartographic.height = height;\n\n        if (mode === SceneMode.SCENE3D) {\n          ellipsoid.cartographicToCartesian(cartographic, camera.position);\n        } else {\n          projection.project(cartographic, camera.position);\n        }\n\n        heightUpdated = true;\n      }\n    }\n  }\n\n  if (defined(transform)) {\n    camera._setTransform(transform);\n\n    if (heightUpdated) {\n      Cartesian3.normalize(camera.position, camera.position);\n      Cartesian3.negate(camera.position, camera.direction);\n      Cartesian3.multiplyByScalar(camera.position, Math.max(mag, controller.minimumZoomDistance), camera.position);\n      Cartesian3.normalize(camera.direction, camera.direction);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n      Cartesian3.cross(camera.right, camera.direction, camera.up);\n    }\n  }\n}\n/**\n * @private\n */\n\n\nScreenSpaceCameraController.prototype.onMap = function () {\n  var scene = this._scene;\n  var mode = scene.mode;\n  var camera = scene.camera;\n\n  if (mode === SceneMode.COLUMBUS_VIEW) {\n    return Math.abs(camera.position.x) - this._maxCoord.x < 0 && Math.abs(camera.position.y) - this._maxCoord.y < 0;\n  }\n\n  return true;\n};\n\nvar scratchPreviousPosition = new Cartesian3();\nvar scratchPreviousDirection = new Cartesian3();\n/**\n * @private\n */\n\nScreenSpaceCameraController.prototype.update = function () {\n  var scene = this._scene;\n  var camera = scene.camera;\n  var globe = scene.globe;\n  var mode = scene.mode;\n\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    this._globe = undefined;\n    this._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  } else {\n    this._globe = globe;\n    this._ellipsoid = defined(this._globe) ? this._globe.ellipsoid : scene.mapProjection.ellipsoid;\n  }\n\n  this._cameraUnderground = scene.cameraUnderground && defined(this._globe);\n  this._minimumCollisionTerrainHeight = this.minimumCollisionTerrainHeight * scene.terrainExaggeration;\n  this._minimumPickingTerrainHeight = this.minimumPickingTerrainHeight * scene.terrainExaggeration;\n  this._minimumTrackBallHeight = this.minimumTrackBallHeight * scene.terrainExaggeration;\n  var radius = this._ellipsoid.maximumRadius;\n  this._rotateFactor = 1.0 / radius;\n  this._rotateRateRangeAdjustment = radius;\n  this._adjustedHeightForTerrain = false;\n  var previousPosition = Cartesian3.clone(camera.positionWC, scratchPreviousPosition);\n  var previousDirection = Cartesian3.clone(camera.directionWC, scratchPreviousDirection);\n\n  if (mode === SceneMode.SCENE2D) {\n    update2D(this);\n  } else if (mode === SceneMode.COLUMBUS_VIEW) {\n    this._horizontalRotationAxis = Cartesian3.UNIT_Z;\n    updateCV(this);\n  } else if (mode === SceneMode.SCENE3D) {\n    this._horizontalRotationAxis = undefined;\n    update3D(this);\n  }\n\n  if (this.enableCollisionDetection && !this._adjustedHeightForTerrain) {\n    // Adjust the camera height if the camera moved at all (user input or inertia) and an action didn't already adjust the camera height\n    var cameraChanged = !Cartesian3.equals(previousPosition, camera.positionWC) || !Cartesian3.equals(previousDirection, camera.directionWC);\n\n    if (cameraChanged) {\n      adjustHeightForTerrain(this);\n    }\n  }\n\n  this._aggregator.reset();\n};\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see ScreenSpaceCameraController#destroy\n */\n\n\nScreenSpaceCameraController.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Removes mouse listeners held by this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * controller = controller && controller.destroy();\n *\n * @see ScreenSpaceCameraController#isDestroyed\n */\n\n\nScreenSpaceCameraController.prototype.destroy = function () {\n  this._tweens.removeAll();\n\n  this._aggregator = this._aggregator && this._aggregator.destroy();\n  return destroyObject(this);\n};\n\nexport default ScreenSpaceCameraController;","map":{"version":3,"sources":["/home/usuario/davi/thalamus/wms/3dmaptestes/leaflet_cesium/client/node_modules/cesium/Source/Scene/ScreenSpaceCameraController.js"],"names":["Cartesian2","Cartesian3","Cartesian4","Cartographic","defaultValue","defined","destroyObject","DeveloperError","Ellipsoid","HeadingPitchRoll","IntersectionTests","KeyboardEventModifier","CesiumMath","Matrix3","Matrix4","OrthographicFrustum","Plane","Quaternion","Ray","Transforms","CameraEventAggregator","CameraEventType","MapMode2D","SceneMode","SceneTransforms","TweenCollection","ScreenSpaceCameraController","scene","enableInputs","enableTranslate","enableZoom","enableRotate","enableTilt","enableLook","inertiaSpin","inertiaTranslate","inertiaZoom","maximumMovementRatio","bounceAnimationTime","minimumZoomDistance","maximumZoomDistance","Number","POSITIVE_INFINITY","translateEventTypes","LEFT_DRAG","zoomEventTypes","RIGHT_DRAG","WHEEL","PINCH","rotateEventTypes","tiltEventTypes","MIDDLE_DRAG","eventType","modifier","CTRL","lookEventTypes","SHIFT","minimumPickingTerrainHeight","_minimumPickingTerrainHeight","minimumCollisionTerrainHeight","_minimumCollisionTerrainHeight","minimumTrackBallHeight","_minimumTrackBallHeight","enableCollisionDetection","_scene","_globe","undefined","_ellipsoid","_aggregator","canvas","_lastInertiaSpinMovement","_lastInertiaZoomMovement","_lastInertiaTranslateMovement","_lastInertiaTiltMovement","_inertiaDisablers","_tweens","_tween","_horizontalRotationAxis","_tiltCenterMousePosition","_tiltCenter","_rotateMousePosition","_rotateStartPosition","_strafeStartPosition","_strafeMousePosition","_strafeEndMousePosition","_zoomMouseStart","_zoomWorldPosition","_useZoomWorldPosition","_tiltCVOffMap","_looking","_rotating","_strafing","_zoomingOnVector","_zoomingUnderground","_rotatingZoom","_adjustedHeightForTerrain","_cameraUnderground","projection","mapProjection","_maxCoord","project","Math","PI","PI_OVER_TWO","_zoomFactor","_rotateFactor","_rotateRateRangeAdjustment","_maximumRotateRate","_minimumRotateRate","_minimumZoomRate","_maximumZoomRate","_minimumUndergroundPickDistance","_maximumUndergroundPickDistance","decay","time","coefficient","tau","exp","sameMousePosition","movement","equalsEpsilon","startPosition","endPosition","EPSILON14","inertiaMaxClickTimeThreshold","maintainInertia","aggregator","type","decayCoef","action","object","lastMovementName","movementState","motion","inertiaEnabled","ts","getButtonPressTime","tr","getButtonReleaseTime","threshold","getTime","now","Date","fromNow","d","lastMovement","getLastMovement","x","y","clone","multiplyByScalar","add","isNaN","distance","isButtonDown","getStartMousePosition","activateInertia","controller","inertiaStateName","inertiasToDisable","length","i","scratchEventTypeArray","reactToInput","enabled","eventTypes","inertiaConstant","Array","isArray","isMoving","getMovement","scratchZoomPickRay","scratchPickCartesian","scratchZoomOffset","scratchZoomDirection","scratchCenterPixel","scratchCenterPosition","scratchPositionNormal","scratchPickNormal","scratchZoomAxis","scratchCameraPositionNormal","scratchTargetNormal","scratchCameraPosition","scratchCameraUpNormal","scratchCameraRightNormal","scratchForwardNormal","scratchPositionToTarget","scratchPositionToTargetNormal","scratchPan","scratchCenterMovement","scratchCenter","scratchCartesian","scratchCartesianTwo","scratchCartesianThree","scratchZoomViewOptions","orientation","handleZoom","zoomFactor","distanceMeasure","unitPositionDotDirection","percentage","clamp","abs","minHeight","maxHeight","minDistance","zoomRate","diff","rangeWindowRatio","clientHeight","min","camera","mode","heading","pitch","roll","frustum","zoomIn","_adjustOrthographicFrustum","sameStartPosition","equals","zoomingOnVector","rotatingZoom","pickedPosition","SCENE2D","getPickRay","origin","fromElements","z","pickGlobe","zoomOnVector","COLUMBUS_VIEW","positionCartographic","height","worldPosition","position","savedX","direction","subtract","normalize","getMagnitude","move","SCENE3D","cameraPositionNormal","dot","centerPixel","clientWidth","centerPosition","cameraPosition","target","targetNormal","center","forward","positionToTarget","positionToTargetNormal","alphaDot","alpha","acos","cameraDistance","magnitude","targetDistance","remainingDistance","positionToTargetDistance","gamma","asin","sin","delta","beta","up","right","cross","pMid","cos","cMid","setView","positionNormal","pickedNormal","dotProduct","angle","acosClamped","axis","denom","toRadians","scalar","rotate","ray","zoomMouseStart","wgs84ToWindowCoordinates","rayDirection","translate2DStart","translate2DEnd","scratchTranslateP0","translate2D","start","end","zoom2D","twist2DStart","twist2DEnd","twist2D","angleAndHeight","singleAxisTwist2D","width","startTheta","TWO_PI","endTheta","theta","twistRight","rotateRate","phiWindowRatio","deltaPhi","update2D","rotatable2D","mapMode2D","ROTATE","IDENTITY","transform","pickGlobeScratchRay","scratchDepthIntersection","scratchRayIntersection","mousePosition","result","globe","cullBackFaces","depthIntersection","pickPositionSupported","pickPositionWorldCoordinates","rayIntersection","pickWorldCoordinates","pickDistance","positionWC","rayDistance","scratchDistanceCartographic","getDistanceFromSurface","ellipsoid","cartographic","cartesianToCartographic","globeHeight","distanceFromSurface","scratchSurfaceNormal","getZoomDistanceUnderground","surfaceNormal","strength","max","getTiltCenterUnderground","maximumDistance","getPoint","getStrafeStartPositionUnderground","scratchInertialDelta","continueStrafing","originalEndPosition","inertialDelta","strafe","translateCVStartRay","translateCVEndRay","translateCVStartPos","translateCVEndPos","translateCVDifference","translateCVOrigin","translateCVPlane","UNIT_X","translateCVStartMouse","translateCVEndMouse","translateCV","_translateMousePosition","look3D","cameraUnderground","startMouse","endMouse","startRay","ZERO","normal","globePos","pickPosition","plane","fromPointNormal","startPlanePos","rayPlane","endRay","endPlanePos","temp","mag","EPSILON6","rotateCVWindowPos","rotateCVWindowRay","rotateCVCenter","rotateCVVerticalCenter","rotateCVTransform","rotateCVVerticalTransform","rotateCVOrigin","rotateCVPlane","rotateCVCartesian3","rotateCVCart","rotateCVOldTransform","rotateCVQuaternion","rotateCVMatrix","tilt3DCartesian3","rotateCV","onMap","rotateCVOnPlane","rotateCVOnTerrain","windowPosition","normalDotDirection","cart","unproject","cartographicToCartesian","eastNorthUpToFixedFrame","oldGlobe","oldEllipsoid","UNIT_SPHERE","oldTransform","_setTransform","rotate3D","UNIT_Z","radius","maximumRadius","verticalCenter","_projection","verticalTransform","constrainedAxis","tangent","movementDelta","oldConstrainedAxis","negate","originalPosition","adjustHeightForTerrain","worldToCameraCoordinatesPoint","magSqrd","magnitudeSquared","sqrt","angleBetween","quaternion","fromAxisAngle","rotation","fromQuaternion","multiplyByVector","zoomCVWindowPos","zoomCVWindowRay","zoomCVIntersection","zoomCV","intersection","distanceUnderground","updateCV","zoom3D","tweens","anyButtonDown","removeAll","contains","tween","createCorrectPositionTween","update","scratchStrafeRay","scratchStrafePlane","scratchStrafeIntersection","scratchStrafeDirection","scratchMousePos","strafeStartPosition","spin3DPick","scratchCartographic","scratchRadii","scratchEllipsoid","scratchLookUp","scratchNormal","spin3D","radii","geodeticSurfaceNormal","fromCartesian3","pan3D","mousePos","strafing","tangentPick","pickEllipsoid","rotateOnlyVertical","rotateOnlyHorizontal","oldAxis","rho","thetaWindowRatio","deltaTheta","rotateRight","rotateUp","pan3DP0","UNIT_W","pan3DP1","pan3DTemp0","pan3DTemp1","pan3DTemp2","pan3DTemp3","pan3DStartMousePosition","pan3DEndMousePosition","startMousePosition","endMousePosition","p0","p1","worldToCameraCoordinates","basis0","basis1","mostOrthogonalAxis","basis2","startRho","startDot","startRej","endRho","endDot","endRej","startPhi","endPhi","east","EPSILON2","planeNormal","side0","side1","zoom3DUnitPosition","zoom3DCartographic","unitPosition","tilt3DWindowPos","tilt3DRay","tilt3DCenter","tilt3DVerticalCenter","tilt3DTransform","tilt3DVerticalTransform","tilt3DOldTransform","tilt3DQuaternion","tilt3DMatrix","tilt3DCart","tilt3DLookUp","tilt3D","_tiltOnEllipsoid","tilt3DOnEllipsoid","tilt3DOnTerrain","tilt3DOnEllipsoidCartographic","EPSILON3","rayEllipsoid","grazingAltitudeLocation","grazingAltitudeCart","newEllipsoid","t","stop","rightWC","look3DStartPos","look3DEndPos","look3DStartRay","look3DEndRay","look3DNegativeRot","look3DTan","rotationAxis","startPos","endPos","horizontalRotationAxis","look","lookLeft","negativeRotationAxis","northParallel","southParallel","angleToAxis","EPSILON4","lookUp","update3D","scratchAdjustHeightTransform","scratchAdjustHeightCartographic","MORPHING","heightUpdated","prototype","scratchPreviousPosition","scratchPreviousDirection","terrainExaggeration","previousPosition","previousDirection","directionWC","cameraChanged","reset","isDestroyed","destroy"],"mappings":"AAAA,OAAOA,UAAP,MAAuB,uBAAvB;AACA,OAAOC,UAAP,MAAuB,uBAAvB;AACA,OAAOC,UAAP,MAAuB,uBAAvB;AACA,OAAOC,YAAP,MAAyB,yBAAzB;AACA,OAAOC,YAAP,MAAyB,yBAAzB;AACA,OAAOC,OAAP,MAAoB,oBAApB;AACA,OAAOC,aAAP,MAA0B,0BAA1B;AACA,OAAOC,cAAP,MAA2B,2BAA3B;AACA,OAAOC,SAAP,MAAsB,sBAAtB;AACA,OAAOC,gBAAP,MAA6B,6BAA7B;AACA,OAAOC,iBAAP,MAA8B,8BAA9B;AACA,OAAOC,qBAAP,MAAkC,kCAAlC;AACA,OAAOC,UAAP,MAAuB,iBAAvB;AACA,OAAOC,OAAP,MAAoB,oBAApB;AACA,OAAOC,OAAP,MAAoB,oBAApB;AACA,OAAOC,mBAAP,MAAgC,gCAAhC;AACA,OAAOC,KAAP,MAAkB,kBAAlB;AACA,OAAOC,UAAP,MAAuB,uBAAvB;AACA,OAAOC,GAAP,MAAgB,gBAAhB;AACA,OAAOC,UAAP,MAAuB,uBAAvB;AACA,OAAOC,qBAAP,MAAkC,4BAAlC;AACA,OAAOC,eAAP,MAA4B,sBAA5B;AACA,OAAOC,SAAP,MAAsB,gBAAtB;AACA,OAAOC,SAAP,MAAsB,gBAAtB;AACA,OAAOC,eAAP,MAA4B,sBAA5B;AACA,OAAOC,eAAP,MAA4B,sBAA5B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,2BAAT,CAAqCC,KAArC,EAA4C;AAC1C;AACA,MAAI,CAACtB,OAAO,CAACsB,KAAD,CAAZ,EAAqB;AACnB,UAAM,IAAIpB,cAAJ,CAAmB,oBAAnB,CAAN;AACD,GAJyC,CAK1C;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE,OAAKqB,YAAL,GAAoB,IAApB;AACA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,eAAL,GAAuB,IAAvB;AACA;AACF;AACA;AACA;AACA;;AACE,OAAKC,UAAL,GAAkB,IAAlB;AACA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,YAAL,GAAoB,IAApB;AACA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,UAAL,GAAkB,IAAlB;AACA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,UAAL,GAAkB,IAAlB;AACA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,WAAL,GAAmB,GAAnB;AACA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,gBAAL,GAAwB,GAAxB;AACA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,WAAL,GAAmB,GAAnB;AACA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,oBAAL,GAA4B,GAA5B;AACA;AACF;AACA;AACA;AACA;;AACE,OAAKC,mBAAL,GAA2B,GAA3B;AACA;AACF;AACA;AACA;AACA;;AACE,OAAKC,mBAAL,GAA2B,GAA3B;AACA;AACF;AACA;AACA;AACA;;AACE,OAAKC,mBAAL,GAA2BC,MAAM,CAACC,iBAAlC;AACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,mBAAL,GAA2BtB,eAAe,CAACuB,SAA3C;AACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,cAAL,GAAsB,CACpBxB,eAAe,CAACyB,UADI,EAEpBzB,eAAe,CAAC0B,KAFI,EAGpB1B,eAAe,CAAC2B,KAHI,CAAtB;AAKA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,gBAAL,GAAwB5B,eAAe,CAACuB,SAAxC;AACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKM,cAAL,GAAsB,CACpB7B,eAAe,CAAC8B,WADI,EAEpB9B,eAAe,CAAC2B,KAFI,EAGpB;AACEI,IAAAA,SAAS,EAAE/B,eAAe,CAACuB,SAD7B;AAEES,IAAAA,QAAQ,EAAE1C,qBAAqB,CAAC2C;AAFlC,GAHoB,EAOpB;AACEF,IAAAA,SAAS,EAAE/B,eAAe,CAACyB,UAD7B;A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","sourcesContent":["import Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport HeadingPitchRoll from \"../Core/HeadingPitchRoll.js\";\nimport IntersectionTests from \"../Core/IntersectionTests.js\";\nimport KeyboardEventModifier from \"../Core/KeyboardEventModifier.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport Plane from \"../Core/Plane.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport Ray from \"../Core/Ray.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport CameraEventAggregator from \"./CameraEventAggregator.js\";\nimport CameraEventType from \"./CameraEventType.js\";\nimport MapMode2D from \"./MapMode2D.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport SceneTransforms from \"./SceneTransforms.js\";\nimport TweenCollection from \"./TweenCollection.js\";\n\n/**\n * Modifies the camera position and orientation based on mouse input to a canvas.\n * @alias ScreenSpaceCameraController\n * @constructor\n *\n * @param {Scene} scene The scene.\n */\nfunction ScreenSpaceCameraController(scene) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * If true, inputs are allowed conditionally with the flags enableTranslate, enableZoom,\n   * enableRotate, enableTilt, and enableLook.  If false, all inputs are disabled.\n   *\n   * NOTE: This setting is for temporary use cases, such as camera flights and\n   * drag-selection of regions (see Picking demo).  It is typically set to false at the\n   * start of such events, and set true on completion.  To keep inputs disabled\n   * past the end of camera flights, you must use the other booleans (enableTranslate,\n   * enableZoom, enableRotate, enableTilt, and enableLook).\n   * @type {Boolean}\n   * @default true\n   */\n  this.enableInputs = true;\n  /**\n   * If true, allows the user to pan around the map.  If false, the camera stays locked at the current position.\n   * This flag only applies in 2D and Columbus view modes.\n   * @type {Boolean}\n   * @default true\n   */\n  this.enableTranslate = true;\n  /**\n   * If true, allows the user to zoom in and out.  If false, the camera is locked to the current distance from the ellipsoid.\n   * @type {Boolean}\n   * @default true\n   */\n  this.enableZoom = true;\n  /**\n   * If true, allows the user to rotate the world which translates the user's position.\n   * This flag only applies in 2D and 3D.\n   * @type {Boolean}\n   * @default true\n   */\n  this.enableRotate = true;\n  /**\n   * If true, allows the user to tilt the camera.  If false, the camera is locked to the current heading.\n   * This flag only applies in 3D and Columbus view.\n   * @type {Boolean}\n   * @default true\n   */\n  this.enableTilt = true;\n  /**\n   * If true, allows the user to use free-look. If false, the camera view direction can only be changed through translating\n   * or rotating. This flag only applies in 3D and Columbus view modes.\n   * @type {Boolean}\n   * @default true\n   */\n  this.enableLook = true;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to determine how long\n   * the camera will continue to spin because of inertia.\n   * With value of zero, the camera will have no inertia.\n   * @type {Number}\n   * @default 0.9\n   */\n  this.inertiaSpin = 0.9;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to determine how long\n   * the camera will continue to translate because of inertia.\n   * With value of zero, the camera will have no inertia.\n   * @type {Number}\n   * @default 0.9\n   */\n  this.inertiaTranslate = 0.9;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to determine how long\n   * the camera will continue to zoom because of inertia.\n   * With value of zero, the camera will have no inertia.\n   * @type {Number}\n   * @default 0.8\n   */\n  this.inertiaZoom = 0.8;\n  /**\n   * A parameter in the range <code>[0, 1)</code> used to limit the range\n   * of various user inputs to a percentage of the window width/height per animation frame.\n   * This helps keep the camera under control in low-frame-rate situations.\n   * @type {Number}\n   * @default 0.1\n   */\n  this.maximumMovementRatio = 0.1;\n  /**\n   * Sets the duration, in seconds, of the bounce back animations in 2D and Columbus view.\n   * @type {Number}\n   * @default 3.0\n   */\n  this.bounceAnimationTime = 3.0;\n  /**\n   * The minimum magnitude, in meters, of the camera position when zooming. Defaults to 1.0.\n   * @type {Number}\n   * @default 1.0\n   */\n  this.minimumZoomDistance = 1.0;\n  /**\n   * The maximum magnitude, in meters, of the camera position when zooming. Defaults to positive infinity.\n   * @type {Number}\n   * @default {@link Number.POSITIVE_INFINITY}\n   */\n  this.maximumZoomDistance = Number.POSITIVE_INFINITY;\n  /**\n   * The input that allows the user to pan around the map. This only applies in 2D and Columbus view modes.\n   * <p>\n   * The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default {@link CameraEventType.LEFT_DRAG}\n   */\n  this.translateEventTypes = CameraEventType.LEFT_DRAG;\n  /**\n   * The input that allows the user to zoom in/out.\n   * <p>\n   * The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default [{@link CameraEventType.RIGHT_DRAG}, {@link CameraEventType.WHEEL}, {@link CameraEventType.PINCH}]\n   */\n  this.zoomEventTypes = [\n    CameraEventType.RIGHT_DRAG,\n    CameraEventType.WHEEL,\n    CameraEventType.PINCH,\n  ];\n  /**\n   * The input that allows the user to rotate around the globe or another object. This only applies in 3D and Columbus view modes.\n   * <p>\n   * The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default {@link CameraEventType.LEFT_DRAG}\n   */\n  this.rotateEventTypes = CameraEventType.LEFT_DRAG;\n  /**\n   * The input that allows the user to tilt in 3D and Columbus view or twist in 2D.\n   * <p>\n   * The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default [{@link CameraEventType.MIDDLE_DRAG}, {@link CameraEventType.PINCH}, {\n   *     eventType : {@link CameraEventType.LEFT_DRAG},\n   *     modifier : {@link KeyboardEventModifier.CTRL}\n   * }, {\n   *     eventType : {@link CameraEventType.RIGHT_DRAG},\n   *     modifier : {@link KeyboardEventModifier.CTRL}\n   * }]\n   */\n  this.tiltEventTypes = [\n    CameraEventType.MIDDLE_DRAG,\n    CameraEventType.PINCH,\n    {\n      eventType: CameraEventType.LEFT_DRAG,\n      modifier: KeyboardEventModifier.CTRL,\n    },\n    {\n      eventType: CameraEventType.RIGHT_DRAG,\n      modifier: KeyboardEventModifier.CTRL,\n    },\n  ];\n  /**\n   * The input that allows the user to change the direction the camera is viewing. This only applies in 3D and Columbus view modes.\n   * <p>\n   * The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>\n   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},\n   * or an array of any of the preceding.\n   * </p>\n   * @type {CameraEventType|Array|undefined}\n   * @default { eventType : {@link CameraEventType.LEFT_DRAG}, modifier : {@link KeyboardEventModifier.SHIFT} }\n   */\n  this.lookEventTypes = {\n    eventType: CameraEventType.LEFT_DRAG,\n    modifier: KeyboardEventModifier.SHIFT,\n  };\n  /**\n   * The minimum height the camera must be before picking the terrain instead of the ellipsoid.\n   * @type {Number}\n   * @default 150000.0\n   */\n  this.minimumPickingTerrainHeight = 150000.0;\n  this._minimumPickingTerrainHeight = this.minimumPickingTerrainHeight;\n  /**\n   * The minimum height the camera must be before testing for collision with terrain.\n   * @type {Number}\n   * @default 15000.0\n   */\n  this.minimumCollisionTerrainHeight = 15000.0;\n  this._minimumCollisionTerrainHeight = this.minimumCollisionTerrainHeight;\n  /**\n   * The minimum height the camera must be before switching from rotating a track ball to\n   * free look when clicks originate on the sky or in space.\n   * @type {Number}\n   * @default 7500000.0\n   */\n  this.minimumTrackBallHeight = 7500000.0;\n  this._minimumTrackBallHeight = this.minimumTrackBallHeight;\n  /**\n   * Enables or disables camera collision detection with terrain.\n   * @type {Boolean}\n   * @default true\n   */\n  this.enableCollisionDetection = true;\n\n  this._scene = scene;\n  this._globe = undefined;\n  this._ellipsoid = undefined;\n\n  this._aggregator = new CameraEventAggregator(scene.canvas);\n\n  this._lastInertiaSpinMovement = undefined;\n  this._lastInertiaZoomMovement = undefined;\n  this._lastInertiaTranslateMovement = undefined;\n  this._lastInertiaTiltMovement = undefined;\n\n  // Zoom disables tilt, spin, and translate inertia\n  // Tilt disables spin and translate inertia\n  this._inertiaDisablers = {\n    _lastInertiaZoomMovement: [\n      \"_lastInertiaSpinMovement\",\n      \"_lastInertiaTranslateMovement\",\n      \"_lastInertiaTiltMovement\",\n    ],\n    _lastInertiaTiltMovement: [\n      \"_lastInertiaSpinMovement\",\n      \"_lastInertiaTranslateMovement\",\n    ],\n  };\n\n  this._tweens = new TweenCollection();\n  this._tween = undefined;\n\n  this._horizontalRotationAxis = undefined;\n\n  this._tiltCenterMousePosition = new Cartesian2(-1.0, -1.0);\n  this._tiltCenter = new Cartesian3();\n  this._rotateMousePosition = new Cartesian2(-1.0, -1.0);\n  this._rotateStartPosition = new Cartesian3();\n  this._strafeStartPosition = new Cartesian3();\n  this._strafeMousePosition = new Cartesian2();\n  this._strafeEndMousePosition = new Cartesian2();\n  this._zoomMouseStart = new Cartesian2(-1.0, -1.0);\n  this._zoomWorldPosition = new Cartesian3();\n  this._useZoomWorldPosition = false;\n  this._tiltCVOffMap = false;\n  this._looking = false;\n  this._rotating = false;\n  this._strafing = false;\n  this._zoomingOnVector = false;\n  this._zoomingUnderground = false;\n  this._rotatingZoom = false;\n  this._adjustedHeightForTerrain = false;\n  this._cameraUnderground = false;\n\n  var projection = scene.mapProjection;\n  this._maxCoord = projection.project(\n    new Cartographic(Math.PI, CesiumMath.PI_OVER_TWO)\n  );\n\n  // Constants, Make any of these public?\n  this._zoomFactor = 5.0;\n  this._rotateFactor = undefined;\n  this._rotateRateRangeAdjustment = undefined;\n  this._maximumRotateRate = 1.77;\n  this._minimumRotateRate = 1.0 / 5000.0;\n  this._minimumZoomRate = 20.0;\n  this._maximumZoomRate = 5906376272000.0; // distance from the Sun to Pluto in meters.\n  this._minimumUndergroundPickDistance = 2000.0;\n  this._maximumUndergroundPickDistance = 10000.0;\n}\n\nfunction decay(time, coefficient) {\n  if (time < 0) {\n    return 0.0;\n  }\n\n  var tau = (1.0 - coefficient) * 25.0;\n  return Math.exp(-tau * time);\n}\n\nfunction sameMousePosition(movement) {\n  return Cartesian2.equalsEpsilon(\n    movement.startPosition,\n    movement.endPosition,\n    CesiumMath.EPSILON14\n  );\n}\n\n// If the time between mouse down and mouse up is not between\n// these thresholds, the camera will not move with inertia.\n// This value is probably dependent on the browser and/or the\n// hardware. Should be investigated further.\nvar inertiaMaxClickTimeThreshold = 0.4;\n\nfunction maintainInertia(\n  aggregator,\n  type,\n  modifier,\n  decayCoef,\n  action,\n  object,\n  lastMovementName\n) {\n  var movementState = object[lastMovementName];\n  if (!defined(movementState)) {\n    movementState = object[lastMovementName] = {\n      startPosition: new Cartesian2(),\n      endPosition: new Cartesian2(),\n      motion: new Cartesian2(),\n      inertiaEnabled: true,\n    };\n  }\n\n  var ts = aggregator.getButtonPressTime(type, modifier);\n  var tr = aggregator.getButtonReleaseTime(type, modifier);\n\n  var threshold = ts && tr && (tr.getTime() - ts.getTime()) / 1000.0;\n  var now = new Date();\n  var fromNow = tr && (now.getTime() - tr.getTime()) / 1000.0;\n\n  if (ts && tr && threshold < inertiaMaxClickTimeThreshold) {\n    var d = decay(fromNow, decayCoef);\n\n    var lastMovement = aggregator.getLastMovement(type, modifier);\n    if (\n      !defined(lastMovement) ||\n      sameMousePosition(lastMovement) ||\n      !movementState.inertiaEnabled\n    ) {\n      return;\n    }\n\n    movementState.motion.x =\n      (lastMovement.endPosition.x - lastMovement.startPosition.x) * 0.5;\n    movementState.motion.y =\n      (lastMovement.endPosition.y - lastMovement.startPosition.y) * 0.5;\n\n    movementState.startPosition = Cartesian2.clone(\n      lastMovement.startPosition,\n      movementState.startPosition\n    );\n\n    movementState.endPosition = Cartesian2.multiplyByScalar(\n      movementState.motion,\n      d,\n      movementState.endPosition\n    );\n    movementState.endPosition = Cartesian2.add(\n      movementState.startPosition,\n      movementState.endPosition,\n      movementState.endPosition\n    );\n\n    // If value from the decreasing exponential function is close to zero,\n    // the end coordinates may be NaN.\n    if (\n      isNaN(movementState.endPosition.x) ||\n      isNaN(movementState.endPosition.y) ||\n      Cartesian2.distance(\n        movementState.startPosition,\n        movementState.endPosition\n      ) < 0.5\n    ) {\n      return;\n    }\n\n    if (!aggregator.isButtonDown(type, modifier)) {\n      var startPosition = aggregator.getStartMousePosition(type, modifier);\n      action(object, startPosition, movementState);\n    }\n  }\n}\n\nfunction activateInertia(controller, inertiaStateName) {\n  if (defined(inertiaStateName)) {\n    // Re-enable inertia if it was disabled\n    var movementState = controller[inertiaStateName];\n    if (defined(movementState)) {\n      movementState.inertiaEnabled = true;\n    }\n    // Disable inertia on other movements\n    var inertiasToDisable = controller._inertiaDisablers[inertiaStateName];\n    if (defined(inertiasToDisable)) {\n      var length = inertiasToDisable.length;\n      for (var i = 0; i < length; ++i) {\n        movementState = controller[inertiasToDisable[i]];\n        if (defined(movementState)) {\n          movementState.inertiaEnabled = false;\n        }\n      }\n    }\n  }\n}\n\nvar scratchEventTypeArray = [];\n\nfunction reactToInput(\n  controller,\n  enabled,\n  eventTypes,\n  action,\n  inertiaConstant,\n  inertiaStateName\n) {\n  if (!defined(eventTypes)) {\n    return;\n  }\n\n  var aggregator = controller._aggregator;\n\n  if (!Array.isArray(eventTypes)) {\n    scratchEventTypeArray[0] = eventTypes;\n    eventTypes = scratchEventTypeArray;\n  }\n\n  var length = eventTypes.length;\n  for (var i = 0; i < length; ++i) {\n    var eventType = eventTypes[i];\n    var type = defined(eventType.eventType) ? eventType.eventType : eventType;\n    var modifier = eventType.modifier;\n\n    var movement =\n      aggregator.isMoving(type, modifier) &&\n      aggregator.getMovement(type, modifier);\n    var startPosition = aggregator.getStartMousePosition(type, modifier);\n\n    if (controller.enableInputs && enabled) {\n      if (movement) {\n        action(controller, startPosition, movement);\n        activateInertia(controller, inertiaStateName);\n      } else if (inertiaConstant < 1.0) {\n        maintainInertia(\n          aggregator,\n          type,\n          modifier,\n          inertiaConstant,\n          action,\n          controller,\n          inertiaStateName\n        );\n      }\n    }\n  }\n}\n\nvar scratchZoomPickRay = new Ray();\nvar scratchPickCartesian = new Cartesian3();\nvar scratchZoomOffset = new Cartesian2();\nvar scratchZoomDirection = new Cartesian3();\nvar scratchCenterPixel = new Cartesian2();\nvar scratchCenterPosition = new Cartesian3();\nvar scratchPositionNormal = new Cartesian3();\nvar scratchPickNormal = new Cartesian3();\nvar scratchZoomAxis = new Cartesian3();\nvar scratchCameraPositionNormal = new Cartesian3();\n\n// Scratch variables used in zooming algorithm\nvar scratchTargetNormal = new Cartesian3();\nvar scratchCameraPosition = new Cartesian3();\nvar scratchCameraUpNormal = new Cartesian3();\nvar scratchCameraRightNormal = new Cartesian3();\nvar scratchForwardNormal = new Cartesian3();\nvar scratchPositionToTarget = new Cartesian3();\nvar scratchPositionToTargetNormal = new Cartesian3();\nvar scratchPan = new Cartesian3();\nvar scratchCenterMovement = new Cartesian3();\nvar scratchCenter = new Cartesian3();\nvar scratchCartesian = new Cartesian3();\nvar scratchCartesianTwo = new Cartesian3();\nvar scratchCartesianThree = new Cartesian3();\nvar scratchZoomViewOptions = {\n  orientation: new HeadingPitchRoll(),\n};\n\nfunction handleZoom(\n  object,\n  startPosition,\n  movement,\n  zoomFactor,\n  distanceMeasure,\n  unitPositionDotDirection\n) {\n  var percentage = 1.0;\n  if (defined(unitPositionDotDirection)) {\n    percentage = CesiumMath.clamp(\n      Math.abs(unitPositionDotDirection),\n      0.25,\n      1.0\n    );\n  }\n\n  // distanceMeasure should be the height above the ellipsoid.\n  // The zoomRate slows as it approaches the surface and stops minimumZoomDistance above it.\n  var minHeight = object.minimumZoomDistance * percentage;\n  var maxHeight = object.maximumZoomDistance;\n\n  var minDistance = distanceMeasure - minHeight;\n  var zoomRate = zoomFactor * minDistance;\n  zoomRate = CesiumMath.clamp(\n    zoomRate,\n    object._minimumZoomRate,\n    object._maximumZoomRate\n  );\n\n  var diff = movement.endPosition.y - movement.startPosition.y;\n  var rangeWindowRatio = diff / object._scene.canvas.clientHeight;\n  rangeWindowRatio = Math.min(rangeWindowRatio, object.maximumMovementRatio);\n  var distance = zoomRate * rangeWindowRatio;\n\n  if (\n    object.enableCollisionDetection ||\n    object.minimumZoomDistance === 0.0 ||\n    !defined(object._globe) // look-at mode\n  ) {\n    if (distance > 0.0 && Math.abs(distanceMeasure - minHeight) < 1.0) {\n      return;\n    }\n\n    if (distance < 0.0 && Math.abs(distanceMeasure - maxHeight) < 1.0) {\n      return;\n    }\n\n    if (distanceMeasure - distance < minHeight) {\n      distance = distanceMeasure - minHeight - 1.0;\n    } else if (distanceMeasure - distance > maxHeight) {\n      distance = distanceMeasure - maxHeight;\n    }\n  }\n\n  var scene = object._scene;\n  var camera = scene.camera;\n  var mode = scene.mode;\n\n  var orientation = scratchZoomViewOptions.orientation;\n  orientation.heading = camera.heading;\n  orientation.pitch = camera.pitch;\n  orientation.roll = camera.roll;\n\n  if (camera.frustum instanceof OrthographicFrustum) {\n    if (Math.abs(distance) > 0.0) {\n      camera.zoomIn(distance);\n      camera._adjustOrthographicFrustum();\n    }\n    return;\n  }\n\n  var sameStartPosition = Cartesian2.equals(\n    startPosition,\n    object._zoomMouseStart\n  );\n  var zoomingOnVector = object._zoomingOnVector;\n  var rotatingZoom = object._rotatingZoom;\n  var pickedPosition;\n\n  if (!sameStartPosition) {\n    object._zoomMouseStart = Cartesian2.clone(\n      startPosition,\n      object._zoomMouseStart\n    );\n\n    if (defined(object._globe)) {\n      if (mode === SceneMode.SCENE2D) {\n        pickedPosition = camera.getPickRay(startPosition, scratchZoomPickRay)\n          .origin;\n        pickedPosition = Cartesian3.fromElements(\n          pickedPosition.y,\n          pickedPosition.z,\n          pickedPosition.x\n        );\n      } else {\n        pickedPosition = pickGlobe(object, startPosition, scratchPickCartesian);\n      }\n    }\n    if (defined(pickedPosition)) {\n      object._useZoomWorldPosition = true;\n      object._zoomWorldPosition = Cartesian3.clone(\n        pickedPosition,\n        object._zoomWorldPosition\n      );\n    } else {\n      object._useZoomWorldPosition = false;\n    }\n\n    zoomingOnVector = object._zoomingOnVector = false;\n    rotatingZoom = object._rotatingZoom = false;\n    object._zoomingUnderground = object._cameraUnderground;\n  }\n\n  if (!object._useZoomWorldPosition) {\n    camera.zoomIn(distance);\n    return;\n  }\n\n  var zoomOnVector = mode === SceneMode.COLUMBUS_VIEW;\n\n  if (camera.positionCartographic.height < 2000000) {\n    rotatingZoom = true;\n  }\n\n  if (!sameStartPosition || rotatingZoom) {\n    if (mode === SceneMode.SCENE2D) {\n      var worldPosition = object._zoomWorldPosition;\n      var endPosition = camera.position;\n\n      if (\n        !Cartesian3.equals(worldPosition, endPosition) &&\n        camera.positionCartographic.height < object._maxCoord.x * 2.0\n      ) {\n        var savedX = camera.position.x;\n\n        var direction = Cartesian3.subtract(\n          worldPosition,\n          endPosition,\n          scratchZoomDirection\n        );\n        Cartesian3.normalize(direction, direction);\n\n        var d =\n          (Cartesian3.distance(worldPosition, endPosition) * distance) /\n          (camera.getMagnitude() * 0.5);\n        camera.move(direction, d * 0.5);\n\n        if (\n          (camera.position.x < 0.0 && savedX > 0.0) ||\n          (camera.position.x > 0.0 && savedX < 0.0)\n        ) {\n          pickedPosition = camera.getPickRay(startPosition, scratchZoomPickRay)\n            .origin;\n          pickedPosition = Cartesian3.fromElements(\n            pickedPosition.y,\n            pickedPosition.z,\n            pickedPosition.x\n          );\n          object._zoomWorldPosition = Cartesian3.clone(\n            pickedPosition,\n            object._zoomWorldPosition\n          );\n        }\n      }\n    } else if (mode === SceneMode.SCENE3D) {\n      var cameraPositionNormal = Cartesian3.normalize(\n        camera.position,\n        scratchCameraPositionNormal\n      );\n      if (\n        object._cameraUnderground ||\n        object._zoomingUnderground ||\n        (camera.positionCartographic.height < 3000.0 &&\n          Math.abs(Cartesian3.dot(camera.direction, cameraPositionNormal)) <\n            0.6)\n      ) {\n        zoomOnVector = true;\n      } else {\n        var canvas = scene.canvas;\n\n        var centerPixel = scratchCenterPixel;\n        centerPixel.x = canvas.clientWidth / 2;\n        centerPixel.y = canvas.clientHeight / 2;\n        var centerPosition = pickGlobe(\n          object,\n          centerPixel,\n          scratchCenterPosition\n        );\n        // If centerPosition is not defined, it means the globe does not cover the center position of screen\n\n        if (!defined(centerPosition)) {\n          zoomOnVector = true;\n        } else if (camera.positionCartographic.height < 1000000) {\n          // The math in the else block assumes the camera\n          // points toward the earth surface, so we check it here.\n          // Theoretically, we should check for 90 degree, but it doesn't behave well when parallel\n          // to the earth surface\n          if (Cartesian3.dot(camera.direction, cameraPositionNormal) >= -0.5) {\n            zoomOnVector = true;\n          } else {\n            var cameraPosition = scratchCameraPosition;\n            Cartesian3.clone(camera.position, cameraPosition);\n            var target = object._zoomWorldPosition;\n\n            var targetNormal = scratchTargetNormal;\n\n            targetNormal = Cartesian3.normalize(target, targetNormal);\n\n            if (Cartesian3.dot(targetNormal, cameraPositionNormal) < 0.0) {\n              return;\n            }\n\n            var center = scratchCenter;\n            var forward = scratchForwardNormal;\n            Cartesian3.clone(camera.direction, forward);\n            Cartesian3.add(\n              cameraPosition,\n              Cartesian3.multiplyByScalar(forward, 1000, scratchCartesian),\n              center\n            );\n\n            var positionToTarget = scratchPositionToTarget;\n            var positionToTargetNormal = scratchPositionToTargetNormal;\n            Cartesian3.subtract(target, cameraPosition, positionToTarget);\n\n            Cartesian3.normalize(positionToTarget, positionToTargetNormal);\n\n            var alphaDot = Cartesian3.dot(\n              cameraPositionNormal,\n              positionToTargetNormal\n            );\n            if (alphaDot >= 0.0) {\n              // We zoomed past the target, and this zoom is not valid anymore.\n              // This line causes the next zoom movement to pick a new starting point.\n              object._zoomMouseStart.x = -1;\n              return;\n            }\n            var alpha = Math.acos(-alphaDot);\n            var cameraDistance = Cartesian3.magnitude(cameraPosition);\n            var targetDistance = Cartesian3.magnitude(target);\n            var remainingDistance = cameraDistance - distance;\n            var positionToTargetDistance = Cartesian3.magnitude(\n              positionToTarget\n            );\n\n            var gamma = Math.asin(\n              CesiumMath.clamp(\n                (positionToTargetDistance / targetDistance) * Math.sin(alpha),\n                -1.0,\n                1.0\n              )\n            );\n            var delta = Math.asin(\n              CesiumMath.clamp(\n                (remainingDistance / targetDistance) * Math.sin(alpha),\n                -1.0,\n                1.0\n              )\n            );\n            var beta = gamma - delta + alpha;\n\n            var up = scratchCameraUpNormal;\n            Cartesian3.normalize(cameraPosition, up);\n            var right = scratchCameraRightNormal;\n            right = Cartesian3.cross(positionToTargetNormal, up, right);\n            right = Cartesian3.normalize(right, right);\n\n            Cartesian3.normalize(\n              Cartesian3.cross(up, right, scratchCartesian),\n              forward\n            );\n\n            // Calculate new position to move to\n            Cartesian3.multiplyByScalar(\n              Cartesian3.normalize(center, scratchCartesian),\n              Cartesian3.magnitude(center) - distance,\n              center\n            );\n            Cartesian3.normalize(cameraPosition, cameraPosition);\n            Cartesian3.multiplyByScalar(\n              cameraPosition,\n              remainingDistance,\n              cameraPosition\n            );\n\n            // Pan\n            var pMid = scratchPan;\n            Cartesian3.multiplyByScalar(\n              Cartesian3.add(\n                Cartesian3.multiplyByScalar(\n                  up,\n                  Math.cos(beta) - 1,\n                  scratchCartesianTwo\n                ),\n                Cartesian3.multiplyByScalar(\n                  forward,\n                  Math.sin(beta),\n                  scratchCartesianThree\n                ),\n                scratchCartesian\n              ),\n              remainingDistance,\n              pMid\n            );\n            Cartesian3.add(cameraPosition, pMid, cameraPosition);\n\n            Cartesian3.normalize(center, up);\n            Cartesian3.normalize(\n              Cartesian3.cross(up, right, scratchCartesian),\n              forward\n            );\n\n            var cMid = scratchCenterMovement;\n            Cartesian3.multiplyByScalar(\n              Cartesian3.add(\n                Cartesian3.multiplyByScalar(\n                  up,\n                  Math.cos(beta) - 1,\n                  scratchCartesianTwo\n                ),\n                Cartesian3.multiplyByScalar(\n                  forward,\n                  Math.sin(beta),\n                  scratchCartesianThree\n                ),\n                scratchCartesian\n              ),\n              Cartesian3.magnitude(center),\n              cMid\n            );\n            Cartesian3.add(center, cMid, center);\n\n            // Update camera\n\n            // Set new position\n            Cartesian3.clone(cameraPosition, camera.position);\n\n            // Set new direction\n            Cartesian3.normalize(\n              Cartesian3.subtract(center, cameraPosition, scratchCartesian),\n              camera.direction\n            );\n            Cartesian3.clone(camera.direction, camera.direction);\n\n            // Set new right & up vectors\n            Cartesian3.cross(camera.direction, camera.up, camera.right);\n            Cartesian3.cross(camera.right, camera.direction, camera.up);\n\n            camera.setView(scratchZoomViewOptions);\n            return;\n          }\n        } else {\n          var positionNormal = Cartesian3.normalize(\n            centerPosition,\n            scratchPositionNormal\n          );\n          var pickedNormal = Cartesian3.normalize(\n            object._zoomWorldPosition,\n            scratchPickNormal\n          );\n          var dotProduct = Cartesian3.dot(pickedNormal, positionNormal);\n\n          if (dotProduct > 0.0 && dotProduct < 1.0) {\n            var angle = CesiumMath.acosClamped(dotProduct);\n            var axis = Cartesian3.cross(\n              pickedNormal,\n              positionNormal,\n              scratchZoomAxis\n            );\n\n            var denom =\n              Math.abs(angle) > CesiumMath.toRadians(20.0)\n                ? camera.positionCartographic.height * 0.75\n                : camera.positionCartographic.height - distance;\n            var scalar = distance / denom;\n            camera.rotate(axis, angle * scalar);\n          }\n        }\n      }\n    }\n\n    object._rotatingZoom = !zoomOnVector;\n  }\n\n  if ((!sameStartPosition && zoomOnVector) || zoomingOnVector) {\n    var ray;\n    var zoomMouseStart = SceneTransforms.wgs84ToWindowCoordinates(\n      scene,\n      object._zoomWorldPosition,\n      scratchZoomOffset\n    );\n    if (\n      mode !== SceneMode.COLUMBUS_VIEW &&\n      Cartesian2.equals(startPosition, object._zoomMouseStart) &&\n      defined(zoomMouseStart)\n    ) {\n      ray = camera.getPickRay(zoomMouseStart, scratchZoomPickRay);\n    } else {\n      ray = camera.getPickRay(startPosition, scratchZoomPickRay);\n    }\n\n    var rayDirection = ray.direction;\n    if (mode === SceneMode.COLUMBUS_VIEW || mode === SceneMode.SCENE2D) {\n      Cartesian3.fromElements(\n        rayDirection.y,\n        rayDirection.z,\n        rayDirection.x,\n        rayDirection\n      );\n    }\n\n    camera.move(rayDirection, distance);\n\n    object._zoomingOnVector = true;\n  } else {\n    camera.zoomIn(distance);\n  }\n\n  if (!object._cameraUnderground) {\n    camera.setView(scratchZoomViewOptions);\n  }\n}\n\nvar translate2DStart = new Ray();\nvar translate2DEnd = new Ray();\nvar scratchTranslateP0 = new Cartesian3();\n\nfunction translate2D(controller, startPosition, movement) {\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var start = camera.getPickRay(movement.startPosition, translate2DStart)\n    .origin;\n  var end = camera.getPickRay(movement.endPosition, translate2DEnd).origin;\n\n  start = Cartesian3.fromElements(start.y, start.z, start.x, start);\n  end = Cartesian3.fromElements(end.y, end.z, end.x, end);\n\n  var direction = Cartesian3.subtract(start, end, scratchTranslateP0);\n  var distance = Cartesian3.magnitude(direction);\n\n  if (distance > 0.0) {\n    Cartesian3.normalize(direction, direction);\n    camera.move(direction, distance);\n  }\n}\n\nfunction zoom2D(controller, startPosition, movement) {\n  if (defined(movement.distance)) {\n    movement = movement.distance;\n  }\n\n  var scene = controller._scene;\n  var camera = scene.camera;\n\n  handleZoom(\n    controller,\n    startPosition,\n    movement,\n    controller._zoomFactor,\n    camera.getMagnitude()\n  );\n}\n\nvar twist2DStart = new Cartesian2();\nvar twist2DEnd = new Cartesian2();\n\nfunction twist2D(controller, startPosition, movement) {\n  if (defined(movement.angleAndHeight)) {\n    singleAxisTwist2D(controller, startPosition, movement.angleAndHeight);\n    return;\n  }\n\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var canvas = scene.canvas;\n  var width = canvas.clientWidth;\n  var height = canvas.clientHeight;\n\n  var start = twist2DStart;\n  start.x = (2.0 / width) * movement.startPosition.x - 1.0;\n  start.y = (2.0 / height) * (height - movement.startPosition.y) - 1.0;\n  start = Cartesian2.normalize(start, start);\n\n  var end = twist2DEnd;\n  end.x = (2.0 / width) * movement.endPosition.x - 1.0;\n  end.y = (2.0 / height) * (height - movement.endPosition.y) - 1.0;\n  end = Cartesian2.normalize(end, end);\n\n  var startTheta = CesiumMath.acosClamped(start.x);\n  if (start.y < 0) {\n    startTheta = CesiumMath.TWO_PI - startTheta;\n  }\n  var endTheta = CesiumMath.acosClamped(end.x);\n  if (end.y < 0) {\n    endTheta = CesiumMath.TWO_PI - endTheta;\n  }\n  var theta = endTheta - startTheta;\n\n  camera.twistRight(theta);\n}\n\nfunction singleAxisTwist2D(controller, startPosition, movement) {\n  var rotateRate =\n    controller._rotateFactor * controller._rotateRateRangeAdjustment;\n\n  if (rotateRate > controller._maximumRotateRate) {\n    rotateRate = controller._maximumRotateRate;\n  }\n\n  if (rotateRate < controller._minimumRotateRate) {\n    rotateRate = controller._minimumRotateRate;\n  }\n\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var canvas = scene.canvas;\n\n  var phiWindowRatio =\n    (movement.endPosition.x - movement.startPosition.x) / canvas.clientWidth;\n  phiWindowRatio = Math.min(phiWindowRatio, controller.maximumMovementRatio);\n\n  var deltaPhi = rotateRate * phiWindowRatio * Math.PI * 4.0;\n\n  camera.twistRight(deltaPhi);\n}\n\nfunction update2D(controller) {\n  var rotatable2D = controller._scene.mapMode2D === MapMode2D.ROTATE;\n  if (!Matrix4.equals(Matrix4.IDENTITY, controller._scene.camera.transform)) {\n    reactToInput(\n      controller,\n      controller.enableZoom,\n      controller.zoomEventTypes,\n      zoom2D,\n      controller.inertiaZoom,\n      \"_lastInertiaZoomMovement\"\n    );\n    if (rotatable2D) {\n      reactToInput(\n        controller,\n        controller.enableRotate,\n        controller.translateEventTypes,\n        twist2D,\n        controller.inertiaSpin,\n        \"_lastInertiaSpinMovement\"\n      );\n    }\n  } else {\n    reactToInput(\n      controller,\n      controller.enableTranslate,\n      controller.translateEventTypes,\n      translate2D,\n      controller.inertiaTranslate,\n      \"_lastInertiaTranslateMovement\"\n    );\n    reactToInput(\n      controller,\n      controller.enableZoom,\n      controller.zoomEventTypes,\n      zoom2D,\n      controller.inertiaZoom,\n      \"_lastInertiaZoomMovement\"\n    );\n    if (rotatable2D) {\n      reactToInput(\n        controller,\n        controller.enableRotate,\n        controller.tiltEventTypes,\n        twist2D,\n        controller.inertiaSpin,\n        \"_lastInertiaTiltMovement\"\n      );\n    }\n  }\n}\n\nvar pickGlobeScratchRay = new Ray();\nvar scratchDepthIntersection = new Cartesian3();\nvar scratchRayIntersection = new Cartesian3();\n\nfunction pickGlobe(controller, mousePosition, result) {\n  var scene = controller._scene;\n  var globe = controller._globe;\n  var camera = scene.camera;\n\n  if (!defined(globe)) {\n    return undefined;\n  }\n\n  var cullBackFaces = !controller._cameraUnderground;\n\n  var depthIntersection;\n  if (scene.pickPositionSupported) {\n    depthIntersection = scene.pickPositionWorldCoordinates(\n      mousePosition,\n      scratchDepthIntersection\n    );\n  }\n\n  var ray = camera.getPickRay(mousePosition, pickGlobeScratchRay);\n  var rayIntersection = globe.pickWorldCoordinates(\n    ray,\n    scene,\n    cullBackFaces,\n    scratchRayIntersection\n  );\n\n  var pickDistance = defined(depthIntersection)\n    ? Cartesian3.distance(depthIntersection, camera.positionWC)\n    : Number.POSITIVE_INFINITY;\n  var rayDistance = defined(rayIntersection)\n    ? Cartesian3.distance(rayIntersection, camera.positionWC)\n    : Number.POSITIVE_INFINITY;\n\n  if (pickDistance < rayDistance) {\n    return Cartesian3.clone(depthIntersection, result);\n  }\n\n  return Cartesian3.clone(rayIntersection, result);\n}\n\nvar scratchDistanceCartographic = new Cartographic();\n\nfunction getDistanceFromSurface(controller) {\n  var ellipsoid = controller._ellipsoid;\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var mode = scene.mode;\n\n  var height = 0.0;\n  if (mode === SceneMode.SCENE3D) {\n    var cartographic = ellipsoid.cartesianToCartographic(\n      camera.position,\n      scratchDistanceCartographic\n    );\n    if (defined(cartographic)) {\n      height = cartographic.height;\n    }\n  } else {\n    height = camera.position.z;\n  }\n  var globeHeight = defaultValue(controller._scene.globeHeight, 0.0);\n  var distanceFromSurface = Math.abs(globeHeight - height);\n  return distanceFromSurface;\n}\n\nvar scratchSurfaceNormal = new Cartesian3();\n\nfunction getZoomDistanceUnderground(controller, ray) {\n  var origin = ray.origin;\n  var direction = ray.direction;\n  var distanceFromSurface = getDistanceFromSurface(controller);\n\n  // Weight zoom distance based on how strongly the pick ray is pointing inward.\n  // Geocentric normal is accurate enough for these purposes\n  var surfaceNormal = Cartesian3.normalize(origin, scratchSurfaceNormal);\n  var strength = Math.abs(Cartesian3.dot(surfaceNormal, direction));\n  strength = Math.max(strength, 0.5) * 2.0;\n  return distanceFromSurface * strength;\n}\n\nfunction getTiltCenterUnderground(controller, ray, pickedPosition, result) {\n  var distance = Cartesian3.distance(ray.origin, pickedPosition);\n  var distanceFromSurface = getDistanceFromSurface(controller);\n\n  var maximumDistance = CesiumMath.clamp(\n    distanceFromSurface * 5.0,\n    controller._minimumUndergroundPickDistance,\n    controller._maximumUndergroundPickDistance\n  );\n\n  if (distance > maximumDistance) {\n    // Simulate look-at behavior by tilting around a small invisible sphere\n    distance = Math.min(distance, distanceFromSurface / 5.0);\n    distance = Math.max(distance, 100.0);\n  }\n\n  return Ray.getPoint(ray, distance, result);\n}\n\nfunction getStrafeStartPositionUnderground(\n  controller,\n  ray,\n  pickedPosition,\n  result\n) {\n  var distance;\n  if (!defined(pickedPosition)) {\n    distance = getDistanceFromSurface(controller);\n  } else {\n    distance = Cartesian3.distance(ray.origin, pickedPosition);\n    if (distance > controller._maximumUndergroundPickDistance) {\n      // If the picked position is too far away set the strafe speed based on the\n      // camera's height from the globe surface\n      distance = getDistanceFromSurface(controller);\n    }\n  }\n\n  return Ray.getPoint(ray, distance, result);\n}\n\nvar scratchInertialDelta = new Cartesian2();\n\nfunction continueStrafing(controller, movement) {\n  // Update the end position continually based on the inertial delta\n  var originalEndPosition = movement.endPosition;\n  var inertialDelta = Cartesian2.subtract(\n    movement.endPosition,\n    movement.startPosition,\n    scratchInertialDelta\n  );\n  var endPosition = controller._strafeEndMousePosition;\n  Cartesian2.add(endPosition, inertialDelta, endPosition);\n  movement.endPosition = endPosition;\n  strafe(controller, movement, controller._strafeStartPosition);\n  movement.endPosition = originalEndPosition;\n}\n\nvar translateCVStartRay = new Ray();\nvar translateCVEndRay = new Ray();\nvar translateCVStartPos = new Cartesian3();\nvar translateCVEndPos = new Cartesian3();\nvar translateCVDifference = new Cartesian3();\nvar translateCVOrigin = new Cartesian3();\nvar translateCVPlane = new Plane(Cartesian3.UNIT_X, 0.0);\nvar translateCVStartMouse = new Cartesian2();\nvar translateCVEndMouse = new Cartesian2();\n\nfunction translateCV(controller, startPosition, movement) {\n  if (!Cartesian3.equals(startPosition, controller._translateMousePosition)) {\n    controller._looking = false;\n  }\n\n  if (!Cartesian3.equals(startPosition, controller._strafeMousePosition)) {\n    controller._strafing = false;\n  }\n\n  if (controller._looking) {\n    look3D(controller, startPosition, movement);\n    return;\n  }\n\n  if (controller._strafing) {\n    continueStrafing(controller, movement);\n    return;\n  }\n\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var cameraUnderground = controller._cameraUnderground;\n  var startMouse = Cartesian2.clone(\n    movement.startPosition,\n    translateCVStartMouse\n  );\n  var endMouse = Cartesian2.clone(movement.endPosition, translateCVEndMouse);\n  var startRay = camera.getPickRay(startMouse, translateCVStartRay);\n\n  var origin = Cartesian3.clone(Cartesian3.ZERO, translateCVOrigin);\n  var normal = Cartesian3.UNIT_X;\n\n  var globePos;\n  if (camera.position.z < controller._minimumPickingTerrainHeight) {\n    globePos = pickGlobe(controller, startMouse, translateCVStartPos);\n    if (defined(globePos)) {\n      origin.x = globePos.x;\n    }\n  }\n\n  if (\n    cameraUnderground ||\n    (origin.x > camera.position.z && defined(globePos))\n  ) {\n    var pickPosition = globePos;\n    if (cameraUnderground) {\n      pickPosition = getStrafeStartPositionUnderground(\n        controller,\n        startRay,\n        globePos,\n        translateCVStartPos\n      );\n    }\n    Cartesian2.clone(startPosition, controller._strafeMousePosition);\n    Cartesian2.clone(startPosition, controller._strafeEndMousePosition);\n    Cartesian3.clone(pickPosition, controller._strafeStartPosition);\n    controller._strafing = true;\n    strafe(controller, movement, controller._strafeStartPosition);\n    return;\n  }\n\n  var plane = Plane.fromPointNormal(origin, normal, translateCVPlane);\n\n  startRay = camera.getPickRay(startMouse, translateCVStartRay);\n  var startPlanePos = IntersectionTests.rayPlane(\n    startRay,\n    plane,\n    translateCVStartPos\n  );\n\n  var endRay = camera.getPickRay(endMouse, translateCVEndRay);\n  var endPlanePos = IntersectionTests.rayPlane(\n    endRay,\n    plane,\n    translateCVEndPos\n  );\n\n  if (!defined(startPlanePos) || !defined(endPlanePos)) {\n    controller._looking = true;\n    look3D(controller, startPosition, movement);\n    Cartesian2.clone(startPosition, controller._translateMousePosition);\n    return;\n  }\n\n  var diff = Cartesian3.subtract(\n    startPlanePos,\n    endPlanePos,\n    translateCVDifference\n  );\n  var temp = diff.x;\n  diff.x = diff.y;\n  diff.y = diff.z;\n  diff.z = temp;\n  var mag = Cartesian3.magnitude(diff);\n  if (mag > CesiumMath.EPSILON6) {\n    Cartesian3.normalize(diff, diff);\n    camera.move(diff, mag);\n  }\n}\n\nvar rotateCVWindowPos = new Cartesian2();\nvar rotateCVWindowRay = new Ray();\nvar rotateCVCenter = new Cartesian3();\nvar rotateCVVerticalCenter = new Cartesian3();\nvar rotateCVTransform = new Matrix4();\nvar rotateCVVerticalTransform = new Matrix4();\nvar rotateCVOrigin = new Cartesian3();\nvar rotateCVPlane = new Plane(Cartesian3.UNIT_X, 0.0);\nvar rotateCVCartesian3 = new Cartesian3();\nvar rotateCVCart = new Cartographic();\nvar rotateCVOldTransform = new Matrix4();\nvar rotateCVQuaternion = new Quaternion();\nvar rotateCVMatrix = new Matrix3();\nvar tilt3DCartesian3 = new Cartesian3();\n\nfunction rotateCV(controller, startPosition, movement) {\n  if (defined(movement.angleAndHeight)) {\n    movement = movement.angleAndHeight;\n  }\n\n  if (!Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    controller._tiltCVOffMap = false;\n    controller._looking = false;\n  }\n\n  if (controller._looking) {\n    look3D(controller, startPosition, movement);\n    return;\n  }\n\n  var scene = controller._scene;\n  var camera = scene.camera;\n\n  if (\n    controller._tiltCVOffMap ||\n    !controller.onMap() ||\n    Math.abs(camera.position.z) > controller._minimumPickingTerrainHeight\n  ) {\n    controller._tiltCVOffMap = true;\n    rotateCVOnPlane(controller, startPosition, movement);\n  } else {\n    rotateCVOnTerrain(controller, startPosition, movement);\n  }\n}\n\nfunction rotateCVOnPlane(controller, startPosition, movement) {\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var canvas = scene.canvas;\n\n  var windowPosition = rotateCVWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = canvas.clientHeight / 2;\n  var ray = camera.getPickRay(windowPosition, rotateCVWindowRay);\n  var normal = Cartesian3.UNIT_X;\n\n  var position = ray.origin;\n  var direction = ray.direction;\n  var scalar;\n  var normalDotDirection = Cartesian3.dot(normal, direction);\n  if (Math.abs(normalDotDirection) > CesiumMath.EPSILON6) {\n    scalar = -Cartesian3.dot(normal, position) / normalDotDirection;\n  }\n\n  if (!defined(scalar) || scalar <= 0.0) {\n    controller._looking = true;\n    look3D(controller, startPosition, movement);\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    return;\n  }\n\n  var center = Cartesian3.multiplyByScalar(direction, scalar, rotateCVCenter);\n  Cartesian3.add(position, center, center);\n\n  var projection = scene.mapProjection;\n  var ellipsoid = projection.ellipsoid;\n\n  Cartesian3.fromElements(center.y, center.z, center.x, center);\n  var cart = projection.unproject(center, rotateCVCart);\n  ellipsoid.cartographicToCartesian(cart, center);\n\n  var transform = Transforms.eastNorthUpToFixedFrame(\n    center,\n    ellipsoid,\n    rotateCVTransform\n  );\n\n  var oldGlobe = controller._globe;\n  var oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n\n  var oldTransform = Matrix4.clone(camera.transform, rotateCVOldTransform);\n  camera._setTransform(transform);\n\n  rotate3D(controller, startPosition, movement, Cartesian3.UNIT_Z);\n\n  camera._setTransform(oldTransform);\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n\n  var radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n}\n\nfunction rotateCVOnTerrain(controller, startPosition, movement) {\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var cameraUnderground = controller._cameraUnderground;\n\n  var center;\n  var ray;\n  var normal = Cartesian3.UNIT_X;\n\n  if (Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    center = Cartesian3.clone(controller._tiltCenter, rotateCVCenter);\n  } else {\n    if (camera.position.z < controller._minimumPickingTerrainHeight) {\n      center = pickGlobe(controller, startPosition, rotateCVCenter);\n    }\n\n    if (!defined(center)) {\n      ray = camera.getPickRay(startPosition, rotateCVWindowRay);\n      var position = ray.origin;\n      var direction = ray.direction;\n\n      var scalar;\n      var normalDotDirection = Cartesian3.dot(normal, direction);\n      if (Math.abs(normalDotDirection) > CesiumMath.EPSILON6) {\n        scalar = -Cartesian3.dot(normal, position) / normalDotDirection;\n      }\n\n      if (!defined(scalar) || scalar <= 0.0) {\n        controller._looking = true;\n        look3D(controller, startPosition, movement);\n        Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n        return;\n      }\n\n      center = Cartesian3.multiplyByScalar(direction, scalar, rotateCVCenter);\n      Cartesian3.add(position, center, center);\n    }\n\n    if (cameraUnderground) {\n      if (!defined(ray)) {\n        ray = camera.getPickRay(startPosition, rotateCVWindowRay);\n      }\n      getTiltCenterUnderground(controller, ray, center, center);\n    }\n\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    Cartesian3.clone(center, controller._tiltCenter);\n  }\n\n  var canvas = scene.canvas;\n\n  var windowPosition = rotateCVWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = controller._tiltCenterMousePosition.y;\n  ray = camera.getPickRay(windowPosition, rotateCVWindowRay);\n\n  var origin = Cartesian3.clone(Cartesian3.ZERO, rotateCVOrigin);\n  origin.x = center.x;\n\n  var plane = Plane.fromPointNormal(origin, normal, rotateCVPlane);\n  var verticalCenter = IntersectionTests.rayPlane(\n    ray,\n    plane,\n    rotateCVVerticalCenter\n  );\n\n  var projection = camera._projection;\n  var ellipsoid = projection.ellipsoid;\n\n  Cartesian3.fromElements(center.y, center.z, center.x, center);\n  var cart = projection.unproject(center, rotateCVCart);\n  ellipsoid.cartographicToCartesian(cart, center);\n\n  var transform = Transforms.eastNorthUpToFixedFrame(\n    center,\n    ellipsoid,\n    rotateCVTransform\n  );\n\n  var verticalTransform;\n  if (defined(verticalCenter)) {\n    Cartesian3.fromElements(\n      verticalCenter.y,\n      verticalCenter.z,\n      verticalCenter.x,\n      verticalCenter\n    );\n    cart = projection.unproject(verticalCenter, rotateCVCart);\n    ellipsoid.cartographicToCartesian(cart, verticalCenter);\n\n    verticalTransform = Transforms.eastNorthUpToFixedFrame(\n      verticalCenter,\n      ellipsoid,\n      rotateCVVerticalTransform\n    );\n  } else {\n    verticalTransform = transform;\n  }\n\n  var oldGlobe = controller._globe;\n  var oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n\n  var constrainedAxis = Cartesian3.UNIT_Z;\n\n  var oldTransform = Matrix4.clone(camera.transform, rotateCVOldTransform);\n  camera._setTransform(transform);\n\n  var tangent = Cartesian3.cross(\n    Cartesian3.UNIT_Z,\n    Cartesian3.normalize(camera.position, rotateCVCartesian3),\n    rotateCVCartesian3\n  );\n  var dot = Cartesian3.dot(camera.right, tangent);\n\n  rotate3D(controller, startPosition, movement, constrainedAxis, false, true);\n\n  camera._setTransform(verticalTransform);\n  if (dot < 0.0) {\n    var movementDelta = movement.startPosition.y - movement.endPosition.y;\n    if (\n      (cameraUnderground && movementDelta < 0.0) ||\n      (!cameraUnderground && movementDelta > 0.0)\n    ) {\n      // Prevent camera from flipping past the up axis\n      constrainedAxis = undefined;\n    }\n\n    var oldConstrainedAxis = camera.constrainedAxis;\n    camera.constrainedAxis = undefined;\n\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n\n    camera.constrainedAxis = oldConstrainedAxis;\n  } else {\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n  }\n\n  if (defined(camera.constrainedAxis)) {\n    var right = Cartesian3.cross(\n      camera.direction,\n      camera.constrainedAxis,\n      tilt3DCartesian3\n    );\n    if (\n      !Cartesian3.equalsEpsilon(right, Cartesian3.ZERO, CesiumMath.EPSILON6)\n    ) {\n      if (Cartesian3.dot(right, camera.right) < 0.0) {\n        Cartesian3.negate(right, right);\n      }\n\n      Cartesian3.cross(right, camera.direction, camera.up);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n\n      Cartesian3.normalize(camera.up, camera.up);\n      Cartesian3.normalize(camera.right, camera.right);\n    }\n  }\n\n  camera._setTransform(oldTransform);\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n\n  var radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n\n  var originalPosition = Cartesian3.clone(\n    camera.positionWC,\n    rotateCVCartesian3\n  );\n\n  if (controller.enableCollisionDetection) {\n    adjustHeightForTerrain(controller);\n  }\n\n  if (!Cartesian3.equals(camera.positionWC, originalPosition)) {\n    camera._setTransform(verticalTransform);\n    camera.worldToCameraCoordinatesPoint(originalPosition, originalPosition);\n\n    var magSqrd = Cartesian3.magnitudeSquared(originalPosition);\n    if (Cartesian3.magnitudeSquared(camera.position) > magSqrd) {\n      Cartesian3.normalize(camera.position, camera.position);\n      Cartesian3.multiplyByScalar(\n        camera.position,\n        Math.sqrt(magSqrd),\n        camera.position\n      );\n    }\n\n    var angle = Cartesian3.angleBetween(originalPosition, camera.position);\n    var axis = Cartesian3.cross(\n      originalPosition,\n      camera.position,\n      originalPosition\n    );\n    Cartesian3.normalize(axis, axis);\n\n    var quaternion = Quaternion.fromAxisAngle(axis, angle, rotateCVQuaternion);\n    var rotation = Matrix3.fromQuaternion(quaternion, rotateCVMatrix);\n    Matrix3.multiplyByVector(rotation, camera.direction, camera.direction);\n    Matrix3.multiplyByVector(rotation, camera.up, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n    Cartesian3.cross(camera.right, camera.direction, camera.up);\n\n    camera._setTransform(oldTransform);\n  }\n}\n\nvar zoomCVWindowPos = new Cartesian2();\nvar zoomCVWindowRay = new Ray();\nvar zoomCVIntersection = new Cartesian3();\n\nfunction zoomCV(controller, startPosition, movement) {\n  if (defined(movement.distance)) {\n    movement = movement.distance;\n  }\n\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var canvas = scene.canvas;\n\n  var cameraUnderground = controller._cameraUnderground;\n\n  var windowPosition;\n\n  if (cameraUnderground) {\n    windowPosition = startPosition;\n  } else {\n    windowPosition = zoomCVWindowPos;\n    windowPosition.x = canvas.clientWidth / 2;\n    windowPosition.y = canvas.clientHeight / 2;\n  }\n\n  var ray = camera.getPickRay(windowPosition, zoomCVWindowRay);\n  var position = ray.origin;\n  var direction = ray.direction;\n  var height = camera.position.z;\n\n  var intersection;\n  if (height < controller._minimumPickingTerrainHeight) {\n    intersection = pickGlobe(controller, windowPosition, zoomCVIntersection);\n  }\n\n  var distance;\n  if (defined(intersection)) {\n    distance = Cartesian3.distance(position, intersection);\n  }\n\n  if (cameraUnderground) {\n    var distanceUnderground = getZoomDistanceUnderground(\n      controller,\n      ray,\n      height\n    );\n    if (defined(distance)) {\n      distance = Math.min(distance, distanceUnderground);\n    } else {\n      distance = distanceUnderground;\n    }\n  }\n\n  if (!defined(distance)) {\n    var normal = Cartesian3.UNIT_X;\n    distance =\n      -Cartesian3.dot(normal, position) / Cartesian3.dot(normal, direction);\n  }\n\n  handleZoom(\n    controller,\n    startPosition,\n    movement,\n    controller._zoomFactor,\n    distance\n  );\n}\n\nfunction updateCV(controller) {\n  var scene = controller._scene;\n  var camera = scene.camera;\n\n  if (!Matrix4.equals(Matrix4.IDENTITY, camera.transform)) {\n    reactToInput(\n      controller,\n      controller.enableRotate,\n      controller.rotateEventTypes,\n      rotate3D,\n      controller.inertiaSpin,\n      \"_lastInertiaSpinMovement\"\n    );\n    reactToInput(\n      controller,\n      controller.enableZoom,\n      controller.zoomEventTypes,\n      zoom3D,\n      controller.inertiaZoom,\n      \"_lastInertiaZoomMovement\"\n    );\n  } else {\n    var tweens = controller._tweens;\n\n    if (controller._aggregator.anyButtonDown) {\n      tweens.removeAll();\n    }\n\n    reactToInput(\n      controller,\n      controller.enableTilt,\n      controller.tiltEventTypes,\n      rotateCV,\n      controller.inertiaSpin,\n      \"_lastInertiaTiltMovement\"\n    );\n    reactToInput(\n      controller,\n      controller.enableTranslate,\n      controller.translateEventTypes,\n      translateCV,\n      controller.inertiaTranslate,\n      \"_lastInertiaTranslateMovement\"\n    );\n    reactToInput(\n      controller,\n      controller.enableZoom,\n      controller.zoomEventTypes,\n      zoomCV,\n      controller.inertiaZoom,\n      \"_lastInertiaZoomMovement\"\n    );\n    reactToInput(\n      controller,\n      controller.enableLook,\n      controller.lookEventTypes,\n      look3D\n    );\n\n    if (\n      !controller._aggregator.anyButtonDown &&\n      !tweens.contains(controller._tween)\n    ) {\n      var tween = camera.createCorrectPositionTween(\n        controller.bounceAnimationTime\n      );\n      if (defined(tween)) {\n        controller._tween = tweens.add(tween);\n      }\n    }\n\n    tweens.update();\n  }\n}\n\nvar scratchStrafeRay = new Ray();\nvar scratchStrafePlane = new Plane(Cartesian3.UNIT_X, 0.0);\nvar scratchStrafeIntersection = new Cartesian3();\nvar scratchStrafeDirection = new Cartesian3();\nvar scratchMousePos = new Cartesian3();\n\nfunction strafe(controller, movement, strafeStartPosition) {\n  var scene = controller._scene;\n  var camera = scene.camera;\n\n  var ray = camera.getPickRay(movement.endPosition, scratchStrafeRay);\n\n  var direction = Cartesian3.clone(camera.direction, scratchStrafeDirection);\n  if (scene.mode === SceneMode.COLUMBUS_VIEW) {\n    Cartesian3.fromElements(direction.z, direction.x, direction.y, direction);\n  }\n\n  var plane = Plane.fromPointNormal(\n    strafeStartPosition,\n    direction,\n    scratchStrafePlane\n  );\n  var intersection = IntersectionTests.rayPlane(\n    ray,\n    plane,\n    scratchStrafeIntersection\n  );\n  if (!defined(intersection)) {\n    return;\n  }\n\n  direction = Cartesian3.subtract(strafeStartPosition, intersection, direction);\n  if (scene.mode === SceneMode.COLUMBUS_VIEW) {\n    Cartesian3.fromElements(direction.y, direction.z, direction.x, direction);\n  }\n\n  Cartesian3.add(camera.position, direction, camera.position);\n}\n\nvar spin3DPick = new Cartesian3();\nvar scratchCartographic = new Cartographic();\nvar scratchRadii = new Cartesian3();\nvar scratchEllipsoid = new Ellipsoid();\nvar scratchLookUp = new Cartesian3();\nvar scratchNormal = new Cartesian3();\n\nfunction spin3D(controller, startPosition, movement) {\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var cameraUnderground = controller._cameraUnderground;\n  var ellipsoid = controller._ellipsoid;\n\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    rotate3D(controller, startPosition, movement);\n    return;\n  }\n\n  var magnitude;\n  var radii;\n\n  var up = ellipsoid.geodeticSurfaceNormal(camera.position, scratchLookUp);\n\n  if (Cartesian2.equals(startPosition, controller._rotateMousePosition)) {\n    if (controller._looking) {\n      look3D(controller, startPosition, movement, up);\n    } else if (controller._rotating) {\n      rotate3D(controller, startPosition, movement);\n    } else if (controller._strafing) {\n      continueStrafing(controller, movement);\n    } else {\n      if (\n        Cartesian3.magnitude(camera.position) <\n        Cartesian3.magnitude(controller._rotateStartPosition)\n      ) {\n        // Pan action is no longer valid if camera moves below the pan ellipsoid\n        return;\n      }\n      magnitude = Cartesian3.magnitude(controller._rotateStartPosition);\n      radii = scratchRadii;\n      radii.x = radii.y = radii.z = magnitude;\n      ellipsoid = Ellipsoid.fromCartesian3(radii, scratchEllipsoid);\n      pan3D(controller, startPosition, movement, ellipsoid);\n    }\n    return;\n  }\n  controller._looking = false;\n  controller._rotating = false;\n  controller._strafing = false;\n\n  var height = ellipsoid.cartesianToCartographic(\n    camera.positionWC,\n    scratchCartographic\n  ).height;\n  var globe = controller._globe;\n\n  if (defined(globe) && height < controller._minimumPickingTerrainHeight) {\n    var mousePos = pickGlobe(\n      controller,\n      movement.startPosition,\n      scratchMousePos\n    );\n    if (defined(mousePos)) {\n      var strafing = false;\n      var ray = camera.getPickRay(movement.startPosition, pickGlobeScratchRay);\n\n      if (cameraUnderground) {\n        strafing = true;\n        getStrafeStartPositionUnderground(controller, ray, mousePos, mousePos);\n      } else {\n        var normal = ellipsoid.geodeticSurfaceNormal(mousePos, scratchNormal);\n        var tangentPick =\n          Math.abs(Cartesian3.dot(ray.direction, normal)) < 0.05;\n\n        if (tangentPick) {\n          strafing = true;\n        } else {\n          strafing =\n            Cartesian3.magnitude(camera.position) <\n            Cartesian3.magnitude(mousePos);\n        }\n      }\n\n      if (strafing) {\n        Cartesian2.clone(startPosition, controller._strafeEndMousePosition);\n        Cartesian3.clone(mousePos, controller._strafeStartPosition);\n        controller._strafing = true;\n        strafe(controller, movement, controller._strafeStartPosition);\n      } else {\n        magnitude = Cartesian3.magnitude(mousePos);\n        radii = scratchRadii;\n        radii.x = radii.y = radii.z = magnitude;\n        ellipsoid = Ellipsoid.fromCartesian3(radii, scratchEllipsoid);\n        pan3D(controller, startPosition, movement, ellipsoid);\n\n        Cartesian3.clone(mousePos, controller._rotateStartPosition);\n      }\n    } else {\n      controller._looking = true;\n      look3D(controller, startPosition, movement, up);\n    }\n  } else if (\n    defined(\n      camera.pickEllipsoid(\n        movement.startPosition,\n        controller._ellipsoid,\n        spin3DPick\n      )\n    )\n  ) {\n    pan3D(controller, startPosition, movement, controller._ellipsoid);\n    Cartesian3.clone(spin3DPick, controller._rotateStartPosition);\n  } else if (height > controller._minimumTrackBallHeight) {\n    controller._rotating = true;\n    rotate3D(controller, startPosition, movement);\n  } else {\n    controller._looking = true;\n    look3D(controller, startPosition, movement, up);\n  }\n\n  Cartesian2.clone(startPosition, controller._rotateMousePosition);\n}\n\nfunction rotate3D(\n  controller,\n  startPosition,\n  movement,\n  constrainedAxis,\n  rotateOnlyVertical,\n  rotateOnlyHorizontal\n) {\n  rotateOnlyVertical = defaultValue(rotateOnlyVertical, false);\n  rotateOnlyHorizontal = defaultValue(rotateOnlyHorizontal, false);\n\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var canvas = scene.canvas;\n\n  var oldAxis = camera.constrainedAxis;\n  if (defined(constrainedAxis)) {\n    camera.constrainedAxis = constrainedAxis;\n  }\n\n  var rho = Cartesian3.magnitude(camera.position);\n  var rotateRate =\n    controller._rotateFactor * (rho - controller._rotateRateRangeAdjustment);\n\n  if (rotateRate > controller._maximumRotateRate) {\n    rotateRate = controller._maximumRotateRate;\n  }\n\n  if (rotateRate < controller._minimumRotateRate) {\n    rotateRate = controller._minimumRotateRate;\n  }\n\n  var phiWindowRatio =\n    (movement.startPosition.x - movement.endPosition.x) / canvas.clientWidth;\n  var thetaWindowRatio =\n    (movement.startPosition.y - movement.endPosition.y) / canvas.clientHeight;\n  phiWindowRatio = Math.min(phiWindowRatio, controller.maximumMovementRatio);\n  thetaWindowRatio = Math.min(\n    thetaWindowRatio,\n    controller.maximumMovementRatio\n  );\n\n  var deltaPhi = rotateRate * phiWindowRatio * Math.PI * 2.0;\n  var deltaTheta = rotateRate * thetaWindowRatio * Math.PI;\n\n  if (!rotateOnlyVertical) {\n    camera.rotateRight(deltaPhi);\n  }\n\n  if (!rotateOnlyHorizontal) {\n    camera.rotateUp(deltaTheta);\n  }\n\n  camera.constrainedAxis = oldAxis;\n}\n\nvar pan3DP0 = Cartesian4.clone(Cartesian4.UNIT_W);\nvar pan3DP1 = Cartesian4.clone(Cartesian4.UNIT_W);\nvar pan3DTemp0 = new Cartesian3();\nvar pan3DTemp1 = new Cartesian3();\nvar pan3DTemp2 = new Cartesian3();\nvar pan3DTemp3 = new Cartesian3();\nvar pan3DStartMousePosition = new Cartesian2();\nvar pan3DEndMousePosition = new Cartesian2();\n\nfunction pan3D(controller, startPosition, movement, ellipsoid) {\n  var scene = controller._scene;\n  var camera = scene.camera;\n\n  var startMousePosition = Cartesian2.clone(\n    movement.startPosition,\n    pan3DStartMousePosition\n  );\n  var endMousePosition = Cartesian2.clone(\n    movement.endPosition,\n    pan3DEndMousePosition\n  );\n\n  var p0 = camera.pickEllipsoid(startMousePosition, ellipsoid, pan3DP0);\n  var p1 = camera.pickEllipsoid(endMousePosition, ellipsoid, pan3DP1);\n\n  if (!defined(p0) || !defined(p1)) {\n    controller._rotating = true;\n    rotate3D(controller, startPosition, movement);\n    return;\n  }\n\n  p0 = camera.worldToCameraCoordinates(p0, p0);\n  p1 = camera.worldToCameraCoordinates(p1, p1);\n\n  if (!defined(camera.constrainedAxis)) {\n    Cartesian3.normalize(p0, p0);\n    Cartesian3.normalize(p1, p1);\n    var dot = Cartesian3.dot(p0, p1);\n    var axis = Cartesian3.cross(p0, p1, pan3DTemp0);\n\n    if (\n      dot < 1.0 &&\n      !Cartesian3.equalsEpsilon(axis, Cartesian3.ZERO, CesiumMath.EPSILON14)\n    ) {\n      // dot is in [0, 1]\n      var angle = Math.acos(dot);\n      camera.rotate(axis, angle);\n    }\n  } else {\n    var basis0 = camera.constrainedAxis;\n    var basis1 = Cartesian3.mostOrthogonalAxis(basis0, pan3DTemp0);\n    Cartesian3.cross(basis1, basis0, basis1);\n    Cartesian3.normalize(basis1, basis1);\n    var basis2 = Cartesian3.cross(basis0, basis1, pan3DTemp1);\n\n    var startRho = Cartesian3.magnitude(p0);\n    var startDot = Cartesian3.dot(basis0, p0);\n    var startTheta = Math.acos(startDot / startRho);\n    var startRej = Cartesian3.multiplyByScalar(basis0, startDot, pan3DTemp2);\n    Cartesian3.subtract(p0, startRej, startRej);\n    Cartesian3.normalize(startRej, startRej);\n\n    var endRho = Cartesian3.magnitude(p1);\n    var endDot = Cartesian3.dot(basis0, p1);\n    var endTheta = Math.acos(endDot / endRho);\n    var endRej = Cartesian3.multiplyByScalar(basis0, endDot, pan3DTemp3);\n    Cartesian3.subtract(p1, endRej, endRej);\n    Cartesian3.normalize(endRej, endRej);\n\n    var startPhi = Math.acos(Cartesian3.dot(startRej, basis1));\n    if (Cartesian3.dot(startRej, basis2) < 0) {\n      startPhi = CesiumMath.TWO_PI - startPhi;\n    }\n\n    var endPhi = Math.acos(Cartesian3.dot(endRej, basis1));\n    if (Cartesian3.dot(endRej, basis2) < 0) {\n      endPhi = CesiumMath.TWO_PI - endPhi;\n    }\n\n    var deltaPhi = startPhi - endPhi;\n\n    var east;\n    if (\n      Cartesian3.equalsEpsilon(basis0, camera.position, CesiumMath.EPSILON2)\n    ) {\n      east = camera.right;\n    } else {\n      east = Cartesian3.cross(basis0, camera.position, pan3DTemp0);\n    }\n\n    var planeNormal = Cartesian3.cross(basis0, east, pan3DTemp0);\n    var side0 = Cartesian3.dot(\n      planeNormal,\n      Cartesian3.subtract(p0, basis0, pan3DTemp1)\n    );\n    var side1 = Cartesian3.dot(\n      planeNormal,\n      Cartesian3.subtract(p1, basis0, pan3DTemp1)\n    );\n\n    var deltaTheta;\n    if (side0 > 0 && side1 > 0) {\n      deltaTheta = endTheta - startTheta;\n    } else if (side0 > 0 && side1 <= 0) {\n      if (Cartesian3.dot(camera.position, basis0) > 0) {\n        deltaTheta = -startTheta - endTheta;\n      } else {\n        deltaTheta = startTheta + endTheta;\n      }\n    } else {\n      deltaTheta = startTheta - endTheta;\n    }\n\n    camera.rotateRight(deltaPhi);\n    camera.rotateUp(deltaTheta);\n  }\n}\n\nvar zoom3DUnitPosition = new Cartesian3();\nvar zoom3DCartographic = new Cartographic();\n\nfunction zoom3D(controller, startPosition, movement) {\n  if (defined(movement.distance)) {\n    movement = movement.distance;\n  }\n\n  var ellipsoid = controller._ellipsoid;\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var canvas = scene.canvas;\n\n  var cameraUnderground = controller._cameraUnderground;\n\n  var windowPosition;\n\n  if (cameraUnderground) {\n    windowPosition = startPosition;\n  } else {\n    windowPosition = zoomCVWindowPos;\n    windowPosition.x = canvas.clientWidth / 2;\n    windowPosition.y = canvas.clientHeight / 2;\n  }\n\n  var ray = camera.getPickRay(windowPosition, zoomCVWindowRay);\n\n  var intersection;\n  var height = ellipsoid.cartesianToCartographic(\n    camera.position,\n    zoom3DCartographic\n  ).height;\n  if (height < controller._minimumPickingTerrainHeight) {\n    intersection = pickGlobe(controller, windowPosition, zoomCVIntersection);\n  }\n\n  var distance;\n  if (defined(intersection)) {\n    distance = Cartesian3.distance(ray.origin, intersection);\n  }\n\n  if (cameraUnderground) {\n    var distanceUnderground = getZoomDistanceUnderground(\n      controller,\n      ray,\n      height\n    );\n    if (defined(distance)) {\n      distance = Math.min(distance, distanceUnderground);\n    } else {\n      distance = distanceUnderground;\n    }\n  }\n\n  if (!defined(distance)) {\n    distance = height;\n  }\n\n  var unitPosition = Cartesian3.normalize(camera.position, zoom3DUnitPosition);\n  handleZoom(\n    controller,\n    startPosition,\n    movement,\n    controller._zoomFactor,\n    distance,\n    Cartesian3.dot(unitPosition, camera.direction)\n  );\n}\n\nvar tilt3DWindowPos = new Cartesian2();\nvar tilt3DRay = new Ray();\nvar tilt3DCenter = new Cartesian3();\nvar tilt3DVerticalCenter = new Cartesian3();\nvar tilt3DTransform = new Matrix4();\nvar tilt3DVerticalTransform = new Matrix4();\nvar tilt3DOldTransform = new Matrix4();\nvar tilt3DQuaternion = new Quaternion();\nvar tilt3DMatrix = new Matrix3();\nvar tilt3DCart = new Cartographic();\nvar tilt3DLookUp = new Cartesian3();\n\nfunction tilt3D(controller, startPosition, movement) {\n  var scene = controller._scene;\n  var camera = scene.camera;\n\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    return;\n  }\n\n  if (defined(movement.angleAndHeight)) {\n    movement = movement.angleAndHeight;\n  }\n\n  if (!Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    controller._tiltOnEllipsoid = false;\n    controller._looking = false;\n  }\n\n  if (controller._looking) {\n    var up = controller._ellipsoid.geodeticSurfaceNormal(\n      camera.position,\n      tilt3DLookUp\n    );\n    look3D(controller, startPosition, movement, up);\n    return;\n  }\n\n  var ellipsoid = controller._ellipsoid;\n  var cartographic = ellipsoid.cartesianToCartographic(\n    camera.position,\n    tilt3DCart\n  );\n\n  if (\n    controller._tiltOnEllipsoid ||\n    cartographic.height > controller._minimumCollisionTerrainHeight\n  ) {\n    controller._tiltOnEllipsoid = true;\n    tilt3DOnEllipsoid(controller, startPosition, movement);\n  } else {\n    tilt3DOnTerrain(controller, startPosition, movement);\n  }\n}\n\nvar tilt3DOnEllipsoidCartographic = new Cartographic();\n\nfunction tilt3DOnEllipsoid(controller, startPosition, movement) {\n  var ellipsoid = controller._ellipsoid;\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var minHeight = controller.minimumZoomDistance * 0.25;\n  var height = ellipsoid.cartesianToCartographic(\n    camera.positionWC,\n    tilt3DOnEllipsoidCartographic\n  ).height;\n  if (\n    height - minHeight - 1.0 < CesiumMath.EPSILON3 &&\n    movement.endPosition.y - movement.startPosition.y < 0\n  ) {\n    return;\n  }\n\n  var canvas = scene.canvas;\n\n  var windowPosition = tilt3DWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = canvas.clientHeight / 2;\n  var ray = camera.getPickRay(windowPosition, tilt3DRay);\n\n  var center;\n  var intersection = IntersectionTests.rayEllipsoid(ray, ellipsoid);\n  if (defined(intersection)) {\n    center = Ray.getPoint(ray, intersection.start, tilt3DCenter);\n  } else if (height > controller._minimumTrackBallHeight) {\n    var grazingAltitudeLocation = IntersectionTests.grazingAltitudeLocation(\n      ray,\n      ellipsoid\n    );\n    if (!defined(grazingAltitudeLocation)) {\n      return;\n    }\n    var grazingAltitudeCart = ellipsoid.cartesianToCartographic(\n      grazingAltitudeLocation,\n      tilt3DCart\n    );\n    grazingAltitudeCart.height = 0.0;\n    center = ellipsoid.cartographicToCartesian(\n      grazingAltitudeCart,\n      tilt3DCenter\n    );\n  } else {\n    controller._looking = true;\n    var up = controller._ellipsoid.geodeticSurfaceNormal(\n      camera.position,\n      tilt3DLookUp\n    );\n    look3D(controller, startPosition, movement, up);\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    return;\n  }\n\n  var transform = Transforms.eastNorthUpToFixedFrame(\n    center,\n    ellipsoid,\n    tilt3DTransform\n  );\n\n  var oldGlobe = controller._globe;\n  var oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n\n  var oldTransform = Matrix4.clone(camera.transform, tilt3DOldTransform);\n  camera._setTransform(transform);\n\n  rotate3D(controller, startPosition, movement, Cartesian3.UNIT_Z);\n\n  camera._setTransform(oldTransform);\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n\n  var radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n}\n\nfunction tilt3DOnTerrain(controller, startPosition, movement) {\n  var ellipsoid = controller._ellipsoid;\n  var scene = controller._scene;\n  var camera = scene.camera;\n  var cameraUnderground = controller._cameraUnderground;\n\n  var center;\n  var ray;\n  var intersection;\n\n  if (Cartesian2.equals(startPosition, controller._tiltCenterMousePosition)) {\n    center = Cartesian3.clone(controller._tiltCenter, tilt3DCenter);\n  } else {\n    center = pickGlobe(controller, startPosition, tilt3DCenter);\n\n    if (!defined(center)) {\n      ray = camera.getPickRay(startPosition, tilt3DRay);\n      intersection = IntersectionTests.rayEllipsoid(ray, ellipsoid);\n      if (!defined(intersection)) {\n        var cartographic = ellipsoid.cartesianToCartographic(\n          camera.position,\n          tilt3DCart\n        );\n        if (cartographic.height <= controller._minimumTrackBallHeight) {\n          controller._looking = true;\n          var up = controller._ellipsoid.geodeticSurfaceNormal(\n            camera.position,\n            tilt3DLookUp\n          );\n          look3D(controller, startPosition, movement, up);\n          Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n        }\n        return;\n      }\n      center = Ray.getPoint(ray, intersection.start, tilt3DCenter);\n    }\n\n    if (cameraUnderground) {\n      if (!defined(ray)) {\n        ray = camera.getPickRay(startPosition, tilt3DRay);\n      }\n      getTiltCenterUnderground(controller, ray, center, center);\n    }\n\n    Cartesian2.clone(startPosition, controller._tiltCenterMousePosition);\n    Cartesian3.clone(center, controller._tiltCenter);\n  }\n\n  var canvas = scene.canvas;\n\n  var windowPosition = tilt3DWindowPos;\n  windowPosition.x = canvas.clientWidth / 2;\n  windowPosition.y = controller._tiltCenterMousePosition.y;\n  ray = camera.getPickRay(windowPosition, tilt3DRay);\n\n  var mag = Cartesian3.magnitude(center);\n  var radii = Cartesian3.fromElements(mag, mag, mag, scratchRadii);\n  var newEllipsoid = Ellipsoid.fromCartesian3(radii, scratchEllipsoid);\n\n  intersection = IntersectionTests.rayEllipsoid(ray, newEllipsoid);\n  if (!defined(intersection)) {\n    return;\n  }\n\n  var t =\n    Cartesian3.magnitude(ray.origin) > mag\n      ? intersection.start\n      : intersection.stop;\n  var verticalCenter = Ray.getPoint(ray, t, tilt3DVerticalCenter);\n\n  var transform = Transforms.eastNorthUpToFixedFrame(\n    center,\n    ellipsoid,\n    tilt3DTransform\n  );\n  var verticalTransform = Transforms.eastNorthUpToFixedFrame(\n    verticalCenter,\n    newEllipsoid,\n    tilt3DVerticalTransform\n  );\n\n  var oldGlobe = controller._globe;\n  var oldEllipsoid = controller._ellipsoid;\n  controller._globe = undefined;\n  controller._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  controller._rotateFactor = 1.0;\n  controller._rotateRateRangeAdjustment = 1.0;\n\n  var constrainedAxis = Cartesian3.UNIT_Z;\n\n  var oldTransform = Matrix4.clone(camera.transform, tilt3DOldTransform);\n  camera._setTransform(transform);\n\n  var tangent = Cartesian3.cross(\n    verticalCenter,\n    camera.positionWC,\n    tilt3DCartesian3\n  );\n  var dot = Cartesian3.dot(camera.rightWC, tangent);\n\n  rotate3D(controller, startPosition, movement, constrainedAxis, false, true);\n\n  camera._setTransform(verticalTransform);\n\n  if (dot < 0.0) {\n    var movementDelta = movement.startPosition.y - movement.endPosition.y;\n    if (\n      (cameraUnderground && movementDelta < 0.0) ||\n      (!cameraUnderground && movementDelta > 0.0)\n    ) {\n      // Prevent camera from flipping past the up axis\n      constrainedAxis = undefined;\n    }\n\n    var oldConstrainedAxis = camera.constrainedAxis;\n    camera.constrainedAxis = undefined;\n\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n\n    camera.constrainedAxis = oldConstrainedAxis;\n  } else {\n    rotate3D(controller, startPosition, movement, constrainedAxis, true, false);\n  }\n\n  if (defined(camera.constrainedAxis)) {\n    var right = Cartesian3.cross(\n      camera.direction,\n      camera.constrainedAxis,\n      tilt3DCartesian3\n    );\n    if (\n      !Cartesian3.equalsEpsilon(right, Cartesian3.ZERO, CesiumMath.EPSILON6)\n    ) {\n      if (Cartesian3.dot(right, camera.right) < 0.0) {\n        Cartesian3.negate(right, right);\n      }\n\n      Cartesian3.cross(right, camera.direction, camera.up);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n\n      Cartesian3.normalize(camera.up, camera.up);\n      Cartesian3.normalize(camera.right, camera.right);\n    }\n  }\n\n  camera._setTransform(oldTransform);\n  controller._globe = oldGlobe;\n  controller._ellipsoid = oldEllipsoid;\n\n  var radius = oldEllipsoid.maximumRadius;\n  controller._rotateFactor = 1.0 / radius;\n  controller._rotateRateRangeAdjustment = radius;\n\n  var originalPosition = Cartesian3.clone(camera.positionWC, tilt3DCartesian3);\n\n  if (controller.enableCollisionDetection) {\n    adjustHeightForTerrain(controller);\n  }\n\n  if (!Cartesian3.equals(camera.positionWC, originalPosition)) {\n    camera._setTransform(verticalTransform);\n    camera.worldToCameraCoordinatesPoint(originalPosition, originalPosition);\n\n    var magSqrd = Cartesian3.magnitudeSquared(originalPosition);\n    if (Cartesian3.magnitudeSquared(camera.position) > magSqrd) {\n      Cartesian3.normalize(camera.position, camera.position);\n      Cartesian3.multiplyByScalar(\n        camera.position,\n        Math.sqrt(magSqrd),\n        camera.position\n      );\n    }\n\n    var angle = Cartesian3.angleBetween(originalPosition, camera.position);\n    var axis = Cartesian3.cross(\n      originalPosition,\n      camera.position,\n      originalPosition\n    );\n    Cartesian3.normalize(axis, axis);\n\n    var quaternion = Quaternion.fromAxisAngle(axis, angle, tilt3DQuaternion);\n    var rotation = Matrix3.fromQuaternion(quaternion, tilt3DMatrix);\n    Matrix3.multiplyByVector(rotation, camera.direction, camera.direction);\n    Matrix3.multiplyByVector(rotation, camera.up, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n    Cartesian3.cross(camera.right, camera.direction, camera.up);\n\n    camera._setTransform(oldTransform);\n  }\n}\n\nvar look3DStartPos = new Cartesian2();\nvar look3DEndPos = new Cartesian2();\nvar look3DStartRay = new Ray();\nvar look3DEndRay = new Ray();\nvar look3DNegativeRot = new Cartesian3();\nvar look3DTan = new Cartesian3();\n\nfunction look3D(controller, startPosition, movement, rotationAxis) {\n  var scene = controller._scene;\n  var camera = scene.camera;\n\n  var startPos = look3DStartPos;\n  startPos.x = movement.startPosition.x;\n  startPos.y = 0.0;\n  var endPos = look3DEndPos;\n  endPos.x = movement.endPosition.x;\n  endPos.y = 0.0;\n\n  var startRay = camera.getPickRay(startPos, look3DStartRay);\n  var endRay = camera.getPickRay(endPos, look3DEndRay);\n  var angle = 0.0;\n  var start;\n  var end;\n\n  if (camera.frustum instanceof OrthographicFrustum) {\n    start = startRay.origin;\n    end = endRay.origin;\n\n    Cartesian3.add(camera.direction, start, start);\n    Cartesian3.add(camera.direction, end, end);\n\n    Cartesian3.subtract(start, camera.position, start);\n    Cartesian3.subtract(end, camera.position, end);\n\n    Cartesian3.normalize(start, start);\n    Cartesian3.normalize(end, end);\n  } else {\n    start = startRay.direction;\n    end = endRay.direction;\n  }\n\n  var dot = Cartesian3.dot(start, end);\n  if (dot < 1.0) {\n    // dot is in [0, 1]\n    angle = Math.acos(dot);\n  }\n\n  angle = movement.startPosition.x > movement.endPosition.x ? -angle : angle;\n\n  var horizontalRotationAxis = controller._horizontalRotationAxis;\n  if (defined(rotationAxis)) {\n    camera.look(rotationAxis, -angle);\n  } else if (defined(horizontalRotationAxis)) {\n    camera.look(horizontalRotationAxis, -angle);\n  } else {\n    camera.lookLeft(angle);\n  }\n\n  startPos.x = 0.0;\n  startPos.y = movement.startPosition.y;\n  endPos.x = 0.0;\n  endPos.y = movement.endPosition.y;\n\n  startRay = camera.getPickRay(startPos, look3DStartRay);\n  endRay = camera.getPickRay(endPos, look3DEndRay);\n  angle = 0.0;\n\n  if (camera.frustum instanceof OrthographicFrustum) {\n    start = startRay.origin;\n    end = endRay.origin;\n\n    Cartesian3.add(camera.direction, start, start);\n    Cartesian3.add(camera.direction, end, end);\n\n    Cartesian3.subtract(start, camera.position, start);\n    Cartesian3.subtract(end, camera.position, end);\n\n    Cartesian3.normalize(start, start);\n    Cartesian3.normalize(end, end);\n  } else {\n    start = startRay.direction;\n    end = endRay.direction;\n  }\n\n  dot = Cartesian3.dot(start, end);\n  if (dot < 1.0) {\n    // dot is in [0, 1]\n    angle = Math.acos(dot);\n  }\n  angle = movement.startPosition.y > movement.endPosition.y ? -angle : angle;\n\n  rotationAxis = defaultValue(rotationAxis, horizontalRotationAxis);\n  if (defined(rotationAxis)) {\n    var direction = camera.direction;\n    var negativeRotationAxis = Cartesian3.negate(\n      rotationAxis,\n      look3DNegativeRot\n    );\n    var northParallel = Cartesian3.equalsEpsilon(\n      direction,\n      rotationAxis,\n      CesiumMath.EPSILON2\n    );\n    var southParallel = Cartesian3.equalsEpsilon(\n      direction,\n      negativeRotationAxis,\n      CesiumMath.EPSILON2\n    );\n    if (!northParallel && !southParallel) {\n      dot = Cartesian3.dot(direction, rotationAxis);\n      var angleToAxis = CesiumMath.acosClamped(dot);\n      if (angle > 0 && angle > angleToAxis) {\n        angle = angleToAxis - CesiumMath.EPSILON4;\n      }\n\n      dot = Cartesian3.dot(direction, negativeRotationAxis);\n      angleToAxis = CesiumMath.acosClamped(dot);\n      if (angle < 0 && -angle > angleToAxis) {\n        angle = -angleToAxis + CesiumMath.EPSILON4;\n      }\n\n      var tangent = Cartesian3.cross(rotationAxis, direction, look3DTan);\n      camera.look(tangent, angle);\n    } else if ((northParallel && angle < 0) || (southParallel && angle > 0)) {\n      camera.look(camera.right, -angle);\n    }\n  } else {\n    camera.lookUp(angle);\n  }\n}\n\nfunction update3D(controller) {\n  reactToInput(\n    controller,\n    controller.enableRotate,\n    controller.rotateEventTypes,\n    spin3D,\n    controller.inertiaSpin,\n    \"_lastInertiaSpinMovement\"\n  );\n  reactToInput(\n    controller,\n    controller.enableZoom,\n    controller.zoomEventTypes,\n    zoom3D,\n    controller.inertiaZoom,\n    \"_lastInertiaZoomMovement\"\n  );\n  reactToInput(\n    controller,\n    controller.enableTilt,\n    controller.tiltEventTypes,\n    tilt3D,\n    controller.inertiaSpin,\n    \"_lastInertiaTiltMovement\"\n  );\n  reactToInput(\n    controller,\n    controller.enableLook,\n    controller.lookEventTypes,\n    look3D\n  );\n}\n\nvar scratchAdjustHeightTransform = new Matrix4();\nvar scratchAdjustHeightCartographic = new Cartographic();\n\nfunction adjustHeightForTerrain(controller) {\n  controller._adjustedHeightForTerrain = true;\n\n  var scene = controller._scene;\n  var mode = scene.mode;\n  var globe = scene.globe;\n\n  if (\n    !defined(globe) ||\n    mode === SceneMode.SCENE2D ||\n    mode === SceneMode.MORPHING\n  ) {\n    return;\n  }\n\n  var camera = scene.camera;\n  var ellipsoid = globe.ellipsoid;\n  var projection = scene.mapProjection;\n\n  var transform;\n  var mag;\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    transform = Matrix4.clone(camera.transform, scratchAdjustHeightTransform);\n    mag = Cartesian3.magnitude(camera.position);\n    camera._setTransform(Matrix4.IDENTITY);\n  }\n\n  var cartographic = scratchAdjustHeightCartographic;\n  if (mode === SceneMode.SCENE3D) {\n    ellipsoid.cartesianToCartographic(camera.position, cartographic);\n  } else {\n    projection.unproject(camera.position, cartographic);\n  }\n\n  var heightUpdated = false;\n  if (cartographic.height < controller._minimumCollisionTerrainHeight) {\n    var globeHeight = controller._scene.globeHeight;\n    if (defined(globeHeight)) {\n      var height = globeHeight + controller.minimumZoomDistance;\n      if (cartographic.height < height) {\n        cartographic.height = height;\n        if (mode === SceneMode.SCENE3D) {\n          ellipsoid.cartographicToCartesian(cartographic, camera.position);\n        } else {\n          projection.project(cartographic, camera.position);\n        }\n        heightUpdated = true;\n      }\n    }\n  }\n\n  if (defined(transform)) {\n    camera._setTransform(transform);\n    if (heightUpdated) {\n      Cartesian3.normalize(camera.position, camera.position);\n      Cartesian3.negate(camera.position, camera.direction);\n      Cartesian3.multiplyByScalar(\n        camera.position,\n        Math.max(mag, controller.minimumZoomDistance),\n        camera.position\n      );\n      Cartesian3.normalize(camera.direction, camera.direction);\n      Cartesian3.cross(camera.direction, camera.up, camera.right);\n      Cartesian3.cross(camera.right, camera.direction, camera.up);\n    }\n  }\n}\n\n/**\n * @private\n */\nScreenSpaceCameraController.prototype.onMap = function () {\n  var scene = this._scene;\n  var mode = scene.mode;\n  var camera = scene.camera;\n\n  if (mode === SceneMode.COLUMBUS_VIEW) {\n    return (\n      Math.abs(camera.position.x) - this._maxCoord.x < 0 &&\n      Math.abs(camera.position.y) - this._maxCoord.y < 0\n    );\n  }\n\n  return true;\n};\n\nvar scratchPreviousPosition = new Cartesian3();\nvar scratchPreviousDirection = new Cartesian3();\n\n/**\n * @private\n */\nScreenSpaceCameraController.prototype.update = function () {\n  var scene = this._scene;\n  var camera = scene.camera;\n  var globe = scene.globe;\n  var mode = scene.mode;\n\n  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {\n    this._globe = undefined;\n    this._ellipsoid = Ellipsoid.UNIT_SPHERE;\n  } else {\n    this._globe = globe;\n    this._ellipsoid = defined(this._globe)\n      ? this._globe.ellipsoid\n      : scene.mapProjection.ellipsoid;\n  }\n\n  this._cameraUnderground = scene.cameraUnderground && defined(this._globe);\n\n  this._minimumCollisionTerrainHeight =\n    this.minimumCollisionTerrainHeight * scene.terrainExaggeration;\n  this._minimumPickingTerrainHeight =\n    this.minimumPickingTerrainHeight * scene.terrainExaggeration;\n  this._minimumTrackBallHeight =\n    this.minimumTrackBallHeight * scene.terrainExaggeration;\n\n  var radius = this._ellipsoid.maximumRadius;\n  this._rotateFactor = 1.0 / radius;\n  this._rotateRateRangeAdjustment = radius;\n\n  this._adjustedHeightForTerrain = false;\n  var previousPosition = Cartesian3.clone(\n    camera.positionWC,\n    scratchPreviousPosition\n  );\n  var previousDirection = Cartesian3.clone(\n    camera.directionWC,\n    scratchPreviousDirection\n  );\n\n  if (mode === SceneMode.SCENE2D) {\n    update2D(this);\n  } else if (mode === SceneMode.COLUMBUS_VIEW) {\n    this._horizontalRotationAxis = Cartesian3.UNIT_Z;\n    updateCV(this);\n  } else if (mode === SceneMode.SCENE3D) {\n    this._horizontalRotationAxis = undefined;\n    update3D(this);\n  }\n\n  if (this.enableCollisionDetection && !this._adjustedHeightForTerrain) {\n    // Adjust the camera height if the camera moved at all (user input or inertia) and an action didn't already adjust the camera height\n    var cameraChanged =\n      !Cartesian3.equals(previousPosition, camera.positionWC) ||\n      !Cartesian3.equals(previousDirection, camera.directionWC);\n    if (cameraChanged) {\n      adjustHeightForTerrain(this);\n    }\n  }\n\n  this._aggregator.reset();\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see ScreenSpaceCameraController#destroy\n */\nScreenSpaceCameraController.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Removes mouse listeners held by this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * controller = controller && controller.destroy();\n *\n * @see ScreenSpaceCameraController#isDestroyed\n */\nScreenSpaceCameraController.prototype.destroy = function () {\n  this._tweens.removeAll();\n  this._aggregator = this._aggregator && this._aggregator.destroy();\n  return destroyObject(this);\n};\nexport default ScreenSpaceCameraController;\n"]},"metadata":{},"sourceType":"module"}