{"ast":null,"code":"import defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport TerrainQuantization from \"../Core/TerrainQuantization.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport getClippingFunction from \"./getClippingFunction.js\";\nimport SceneMode from \"./SceneMode.js\";\n\nfunction GlobeSurfaceShader(numberOfDayTextures, flags, material, shaderProgram, clippingShaderState) {\n  this.numberOfDayTextures = numberOfDayTextures;\n  this.flags = flags;\n  this.material = material;\n  this.shaderProgram = shaderProgram;\n  this.clippingShaderState = clippingShaderState;\n}\n/**\n * Manages the shaders used to shade the surface of a {@link Globe}.\n *\n * @alias GlobeSurfaceShaderSet\n * @private\n */\n\n\nfunction GlobeSurfaceShaderSet() {\n  this.baseVertexShaderSource = undefined;\n  this.baseFragmentShaderSource = undefined;\n  this._shadersByTexturesFlags = [];\n  this.material = undefined;\n}\n\nfunction getPositionMode(sceneMode) {\n  var getPosition3DMode = \"vec4 getPosition(vec3 position, float height, vec2 textureCoordinates) { return getPosition3DMode(position, height, textureCoordinates); }\";\n  var getPositionColumbusViewAnd2DMode = \"vec4 getPosition(vec3 position, float height, vec2 textureCoordinates) { return getPositionColumbusViewMode(position, height, textureCoordinates); }\";\n  var getPositionMorphingMode = \"vec4 getPosition(vec3 position, float height, vec2 textureCoordinates) { return getPositionMorphingMode(position, height, textureCoordinates); }\";\n  var positionMode;\n\n  switch (sceneMode) {\n    case SceneMode.SCENE3D:\n      positionMode = getPosition3DMode;\n      break;\n\n    case SceneMode.SCENE2D:\n    case SceneMode.COLUMBUS_VIEW:\n      positionMode = getPositionColumbusViewAnd2DMode;\n      break;\n\n    case SceneMode.MORPHING:\n      positionMode = getPositionMorphingMode;\n      break;\n  }\n\n  return positionMode;\n}\n\nfunction get2DYPositionFraction(useWebMercatorProjection) {\n  var get2DYPositionFractionGeographicProjection = \"float get2DYPositionFraction(vec2 textureCoordinates) { return get2DGeographicYPositionFraction(textureCoordinates); }\";\n  var get2DYPositionFractionMercatorProjection = \"float get2DYPositionFraction(vec2 textureCoordinates) { return get2DMercatorYPositionFraction(textureCoordinates); }\";\n  return useWebMercatorProjection ? get2DYPositionFractionMercatorProjection : get2DYPositionFractionGeographicProjection;\n}\n\nGlobeSurfaceShaderSet.prototype.getShaderProgram = function (options) {\n  var frameState = options.frameState;\n  var surfaceTile = options.surfaceTile;\n  var numberOfDayTextures = options.numberOfDayTextures;\n  var applyBrightness = options.applyBrightness;\n  var applyContrast = options.applyContrast;\n  var applyHue = options.applyHue;\n  var applySaturation = options.applySaturation;\n  var applyGamma = options.applyGamma;\n  var applyAlpha = options.applyAlpha;\n  var applyDayNightAlpha = options.applyDayNightAlpha;\n  var applySplit = options.applySplit;\n  var showReflectiveOcean = options.showReflectiveOcean;\n  var showOceanWaves = options.showOceanWaves;\n  var enableLighting = options.enableLighting;\n  var dynamicAtmosphereLighting = options.dynamicAtmosphereLighting;\n  var dynamicAtmosphereLightingFromSun = options.dynamicAtmosphereLightingFromSun;\n  var showGroundAtmosphere = options.showGroundAtmosphere;\n  var perFragmentGroundAtmosphere = options.perFragmentGroundAtmosphere;\n  var hasVertexNormals = options.hasVertexNormals;\n  var useWebMercatorProjection = options.useWebMercatorProjection;\n  var enableFog = options.enableFog;\n  var enableClippingPlanes = options.enableClippingPlanes;\n  var clippingPlanes = options.clippingPlanes;\n  var clippedByBoundaries = options.clippedByBoundaries;\n  var hasImageryLayerCutout = options.hasImageryLayerCutout;\n  var colorCorrect = options.colorCorrect;\n  var highlightFillTile = options.highlightFillTile;\n  var colorToAlpha = options.colorToAlpha;\n  var showUndergroundColor = options.showUndergroundColor;\n  var translucent = options.translucent;\n  var quantization = 0;\n  var quantizationDefine = \"\";\n  var mesh = surfaceTile.renderedMesh;\n  var terrainEncoding = mesh.encoding;\n  var quantizationMode = terrainEncoding.quantization;\n\n  if (quantizationMode === TerrainQuantization.BITS12) {\n    quantization = 1;\n    quantizationDefine = \"QUANTIZATION_BITS12\";\n  }\n\n  var cartographicLimitRectangleFlag = 0;\n  var cartographicLimitRectangleDefine = \"\";\n\n  if (clippedByBoundaries) {\n    cartographicLimitRectangleFlag = 1;\n    cartographicLimitRectangleDefine = \"TILE_LIMIT_RECTANGLE\";\n  }\n\n  var imageryCutoutFlag = 0;\n  var imageryCutoutDefine = \"\";\n\n  if (hasImageryLayerCutout) {\n    imageryCutoutFlag = 1;\n    imageryCutoutDefine = \"APPLY_IMAGERY_CUTOUT\";\n  }\n\n  var sceneMode = frameState.mode;\n  var flags = sceneMode | applyBrightness << 2 | applyContrast << 3 | applyHue << 4 | applySaturation << 5 | applyGamma << 6 | applyAlpha << 7 | showReflectiveOcean << 8 | showOceanWaves << 9 | enableLighting << 10 | dynamicAtmosphereLighting << 11 | dynamicAtmosphereLightingFromSun << 12 | showGroundAtmosphere << 13 | perFragmentGroundAtmosphere << 14 | hasVertexNormals << 15 | useWebMercatorProjection << 16 | enableFog << 17 | quantization << 18 | applySplit << 19 | enableClippingPlanes << 20 | cartographicLimitRectangleFlag << 21 | imageryCutoutFlag << 22 | colorCorrect << 23 | highlightFillTile << 24 | colorToAlpha << 25 | showUndergroundColor << 26 | translucent << 27 | applyDayNightAlpha << 28;\n  var currentClippingShaderState = 0;\n\n  if (defined(clippingPlanes) && clippingPlanes.length > 0) {\n    currentClippingShaderState = enableClippingPlanes ? clippingPlanes.clippingPlanesState : 0;\n  }\n\n  var surfaceShader = surfaceTile.surfaceShader;\n\n  if (defined(surfaceShader) && surfaceShader.numberOfDayTextures === numberOfDayTextures && surfaceShader.flags === flags && surfaceShader.material === this.material && surfaceShader.clippingShaderState === currentClippingShaderState) {\n    return surfaceShader.shaderProgram;\n  } // New tile, or tile changed number of textures, flags, or clipping planes\n\n\n  var shadersByFlags = this._shadersByTexturesFlags[numberOfDayTextures];\n\n  if (!defined(shadersByFlags)) {\n    shadersByFlags = this._shadersByTexturesFlags[numberOfDayTextures] = [];\n  }\n\n  surfaceShader = shadersByFlags[flags];\n\n  if (!defined(surfaceShader) || surfaceShader.material !== this.material || surfaceShader.clippingShaderState !== currentClippingShaderState) {\n    // Cache miss - we've never seen this combination of numberOfDayTextures and flags before.\n    var vs = this.baseVertexShaderSource.clone();\n    var fs = this.baseFragmentShaderSource.clone();\n\n    if (currentClippingShaderState !== 0) {\n      fs.sources.unshift(getClippingFunction(clippingPlanes, frameState.context)); // Need to go before GlobeFS\n    }\n\n    vs.defines.push(quantizationDefine);\n    fs.defines.push(\"TEXTURE_UNITS \" + numberOfDayTextures, cartographicLimitRectangleDefine, imageryCutoutDefine);\n\n    if (applyBrightness) {\n      fs.defines.push(\"APPLY_BRIGHTNESS\");\n    }\n\n    if (applyContrast) {\n      fs.defines.push(\"APPLY_CONTRAST\");\n    }\n\n    if (applyHue) {\n      fs.defines.push(\"APPLY_HUE\");\n    }\n\n    if (applySaturation) {\n      fs.defines.push(\"APPLY_SATURATION\");\n    }\n\n    if (applyGamma) {\n      fs.defines.push(\"APPLY_GAMMA\");\n    }\n\n    if (applyAlpha) {\n      fs.defines.push(\"APPLY_ALPHA\");\n    }\n\n    if (applyDayNightAlpha) {\n      fs.defines.push(\"APPLY_DAY_NIGHT_ALPHA\");\n    }\n\n    if (showReflectiveOcean) {\n      fs.defines.push(\"SHOW_REFLECTIVE_OCEAN\");\n      vs.defines.push(\"SHOW_REFLECTIVE_OCEAN\");\n    }\n\n    if (showOceanWaves) {\n      fs.defines.push(\"SHOW_OCEAN_WAVES\");\n    }\n\n    if (colorToAlpha) {\n      fs.defines.push(\"APPLY_COLOR_TO_ALPHA\");\n    }\n\n    if (showUndergroundColor) {\n      vs.defines.push(\"UNDERGROUND_COLOR\");\n      fs.defines.push(\"UNDERGROUND_COLOR\");\n    }\n\n    if (translucent) {\n      vs.defines.push(\"TRANSLUCENT\");\n      fs.defines.push(\"TRANSLUCENT\");\n    }\n\n    if (enableLighting) {\n      if (hasVertexNormals) {\n        vs.defines.push(\"ENABLE_VERTEX_LIGHTING\");\n        fs.defines.push(\"ENABLE_VERTEX_LIGHTING\");\n      } else {\n        vs.defines.push(\"ENABLE_DAYNIGHT_SHADING\");\n        fs.defines.push(\"ENABLE_DAYNIGHT_SHADING\");\n      }\n    }\n\n    if (dynamicAtmosphereLighting) {\n      fs.defines.push(\"DYNAMIC_ATMOSPHERE_LIGHTING\");\n\n      if (dynamicAtmosphereLightingFromSun) {\n        fs.defines.push(\"DYNAMIC_ATMOSPHERE_LIGHTING_FROM_SUN\");\n      }\n    }\n\n    if (showGroundAtmosphere) {\n      vs.defines.push(\"GROUND_ATMOSPHERE\");\n      fs.defines.push(\"GROUND_ATMOSPHERE\");\n\n      if (perFragmentGroundAtmosphere) {\n        fs.defines.push(\"PER_FRAGMENT_GROUND_ATMOSPHERE\");\n      }\n    }\n\n    vs.defines.push(\"INCLUDE_WEB_MERCATOR_Y\");\n    fs.defines.push(\"INCLUDE_WEB_MERCATOR_Y\");\n\n    if (enableFog) {\n      vs.defines.push(\"FOG\");\n      fs.defines.push(\"FOG\");\n    }\n\n    if (applySplit) {\n      fs.defines.push(\"APPLY_SPLIT\");\n    }\n\n    if (enableClippingPlanes) {\n      fs.defines.push(\"ENABLE_CLIPPING_PLANES\");\n    }\n\n    if (colorCorrect) {\n      fs.defines.push(\"COLOR_CORRECT\");\n    }\n\n    if (highlightFillTile) {\n      fs.defines.push(\"HIGHLIGHT_FILL_TILE\");\n    }\n\n    var computeDayColor = \"\\\n    vec4 computeDayColor(vec4 initialColor, vec3 textureCoordinates, float nightBlend)\\n\\\n    {\\n\\\n        vec4 color = initialColor;\\n\";\n\n    if (hasImageryLayerCutout) {\n      computeDayColor += \"\\\n        vec4 cutoutAndColorResult;\\n\\\n        bool texelUnclipped;\\n\";\n    }\n\n    for (var i = 0; i < numberOfDayTextures; ++i) {\n      if (hasImageryLayerCutout) {\n        computeDayColor += \"\\\n        cutoutAndColorResult = u_dayTextureCutoutRectangles[\" + i + \"];\\n\\\n        texelUnclipped = v_textureCoordinates.x < cutoutAndColorResult.x || cutoutAndColorResult.z < v_textureCoordinates.x || v_textureCoordinates.y < cutoutAndColorResult.y || cutoutAndColorResult.w < v_textureCoordinates.y;\\n\\\n        cutoutAndColorResult = sampleAndBlend(\\n\";\n      } else {\n        computeDayColor += \"\\\n        color = sampleAndBlend(\\n\";\n      }\n\n      computeDayColor += \"\\\n            color,\\n\\\n            u_dayTextures[\" + i + \"],\\n\\\n            u_dayTextureUseWebMercatorT[\" + i + \"] ? textureCoordinates.xz : textureCoordinates.xy,\\n\\\n            u_dayTextureTexCoordsRectangle[\" + i + \"],\\n\\\n            u_dayTextureTranslationAndScale[\" + i + \"],\\n\\\n            \" + (applyAlpha ? \"u_dayTextureAlpha[\" + i + \"]\" : \"1.0\") + \",\\n\\\n            \" + (applyDayNightAlpha ? \"u_dayTextureNightAlpha[\" + i + \"]\" : \"1.0\") + \",\\n\" + (applyDayNightAlpha ? \"u_dayTextureDayAlpha[\" + i + \"]\" : \"1.0\") + \",\\n\" + (applyBrightness ? \"u_dayTextureBrightness[\" + i + \"]\" : \"0.0\") + \",\\n\\\n            \" + (applyContrast ? \"u_dayTextureContrast[\" + i + \"]\" : \"0.0\") + \",\\n\\\n            \" + (applyHue ? \"u_dayTextureHue[\" + i + \"]\" : \"0.0\") + \",\\n\\\n            \" + (applySaturation ? \"u_dayTextureSaturation[\" + i + \"]\" : \"0.0\") + \",\\n\\\n            \" + (applyGamma ? \"u_dayTextureOneOverGamma[\" + i + \"]\" : \"0.0\") + \",\\n\\\n            \" + (applySplit ? \"u_dayTextureSplit[\" + i + \"]\" : \"0.0\") + \",\\n\\\n            \" + (colorToAlpha ? \"u_colorsToAlpha[\" + i + \"]\" : \"vec4(0.0)\") + \",\\n\\\n        nightBlend\\\n        );\\n\";\n\n      if (hasImageryLayerCutout) {\n        computeDayColor += \"\\\n        color = czm_branchFreeTernary(texelUnclipped, cutoutAndColorResult, color);\\n\";\n      }\n    }\n\n    computeDayColor += \"\\\n        return color;\\n\\\n    }\";\n    fs.sources.push(computeDayColor);\n    vs.sources.push(getPositionMode(sceneMode));\n    vs.sources.push(get2DYPositionFraction(useWebMercatorProjection));\n    var shader = ShaderProgram.fromCache({\n      context: frameState.context,\n      vertexShaderSource: vs,\n      fragmentShaderSource: fs,\n      attributeLocations: terrainEncoding.getAttributeLocations()\n    });\n    surfaceShader = shadersByFlags[flags] = new GlobeSurfaceShader(numberOfDayTextures, flags, this.material, shader, currentClippingShaderState);\n  }\n\n  surfaceTile.surfaceShader = surfaceShader;\n  return surfaceShader.shaderProgram;\n};\n\nGlobeSurfaceShaderSet.prototype.destroy = function () {\n  var flags;\n  var shader;\n  var shadersByTexturesFlags = this._shadersByTexturesFlags;\n\n  for (var textureCount in shadersByTexturesFlags) {\n    if (shadersByTexturesFlags.hasOwnProperty(textureCount)) {\n      var shadersByFlags = shadersByTexturesFlags[textureCount];\n\n      if (!defined(shadersByFlags)) {\n        continue;\n      }\n\n      for (flags in shadersByFlags) {\n        if (shadersByFlags.hasOwnProperty(flags)) {\n          shader = shadersByFlags[flags];\n\n          if (defined(shader)) {\n            shader.shaderProgram.destroy();\n          }\n        }\n      }\n    }\n  }\n\n  return destroyObject(this);\n};\n\nexport default GlobeSurfaceShaderSet;","map":{"version":3,"sources":["/home/usuario/davi/thalamus/wms/3dmaptestes/leaflet_cesium/client/node_modules/cesium/Source/Scene/GlobeSurfaceShaderSet.js"],"names":["defined","destroyObject","TerrainQuantization","ShaderProgram","getClippingFunction","SceneMode","GlobeSurfaceShader","numberOfDayTextures","flags","material","shaderProgram","clippingShaderState","GlobeSurfaceShaderSet","baseVertexShaderSource","undefined","baseFragmentShaderSource","_shadersByTexturesFlags","getPositionMode","sceneMode","getPosition3DMode","getPositionColumbusViewAnd2DMode","getPositionMorphingMode","positionMode","SCENE3D","SCENE2D","COLUMBUS_VIEW","MORPHING","get2DYPositionFraction","useWebMercatorProjection","get2DYPositionFractionGeographicProjection","get2DYPositionFractionMercatorProjection","prototype","getShaderProgram","options","frameState","surfaceTile","applyBrightness","applyContrast","applyHue","applySaturation","applyGamma","applyAlpha","applyDayNightAlpha","applySplit","showReflectiveOcean","showOceanWaves","enableLighting","dynamicAtmosphereLighting","dynamicAtmosphereLightingFromSun","showGroundAtmosphere","perFragmentGroundAtmosphere","hasVertexNormals","enableFog","enableClippingPlanes","clippingPlanes","clippedByBoundaries","hasImageryLayerCutout","colorCorrect","highlightFillTile","colorToAlpha","showUndergroundColor","translucent","quantization","quantizationDefine","mesh","renderedMesh","terrainEncoding","encoding","quantizationMode","BITS12","cartographicLimitRectangleFlag","cartographicLimitRectangleDefine","imageryCutoutFlag","imageryCutoutDefine","mode","currentClippingShaderState","length","clippingPlanesState","surfaceShader","shadersByFlags","vs","clone","fs","sources","unshift","context","defines","push","computeDayColor","i","shader","fromCache","vertexShaderSource","fragmentShaderSource","attributeLocations","getAttributeLocations","destroy","shadersByTexturesFlags","textureCount","hasOwnProperty"],"mappings":"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","sourcesContent":["import defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport TerrainQuantization from \"../Core/TerrainQuantization.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport getClippingFunction from \"./getClippingFunction.js\";\nimport SceneMode from \"./SceneMode.js\";\n\nfunction GlobeSurfaceShader(\n  numberOfDayTextures,\n  flags,\n  material,\n  shaderProgram,\n  clippingShaderState\n) {\n  this.numberOfDayTextures = numberOfDayTextures;\n  this.flags = flags;\n  this.material = material;\n  this.shaderProgram = shaderProgram;\n  this.clippingShaderState = clippingShaderState;\n}\n\n/**\n * Manages the shaders used to shade the surface of a {@link Globe}.\n *\n * @alias GlobeSurfaceShaderSet\n * @private\n */\nfunction GlobeSurfaceShaderSet() {\n  this.baseVertexShaderSource = undefined;\n  this.baseFragmentShaderSource = undefined;\n\n  this._shadersByTexturesFlags = [];\n\n  this.material = undefined;\n}\n\nfunction getPositionMode(sceneMode) {\n  var getPosition3DMode =\n    \"vec4 getPosition(vec3 position, float height, vec2 textureCoordinates) { return getPosition3DMode(position, height, textureCoordinates); }\";\n  var getPositionColumbusViewAnd2DMode =\n    \"vec4 getPosition(vec3 position, float height, vec2 textureCoordinates) { return getPositionColumbusViewMode(position, height, textureCoordinates); }\";\n  var getPositionMorphingMode =\n    \"vec4 getPosition(vec3 position, float height, vec2 textureCoordinates) { return getPositionMorphingMode(position, height, textureCoordinates); }\";\n\n  var positionMode;\n\n  switch (sceneMode) {\n    case SceneMode.SCENE3D:\n      positionMode = getPosition3DMode;\n      break;\n    case SceneMode.SCENE2D:\n    case SceneMode.COLUMBUS_VIEW:\n      positionMode = getPositionColumbusViewAnd2DMode;\n      break;\n    case SceneMode.MORPHING:\n      positionMode = getPositionMorphingMode;\n      break;\n  }\n\n  return positionMode;\n}\n\nfunction get2DYPositionFraction(useWebMercatorProjection) {\n  var get2DYPositionFractionGeographicProjection =\n    \"float get2DYPositionFraction(vec2 textureCoordinates) { return get2DGeographicYPositionFraction(textureCoordinates); }\";\n  var get2DYPositionFractionMercatorProjection =\n    \"float get2DYPositionFraction(vec2 textureCoordinates) { return get2DMercatorYPositionFraction(textureCoordinates); }\";\n  return useWebMercatorProjection\n    ? get2DYPositionFractionMercatorProjection\n    : get2DYPositionFractionGeographicProjection;\n}\n\nGlobeSurfaceShaderSet.prototype.getShaderProgram = function (options) {\n  var frameState = options.frameState;\n  var surfaceTile = options.surfaceTile;\n  var numberOfDayTextures = options.numberOfDayTextures;\n  var applyBrightness = options.applyBrightness;\n  var applyContrast = options.applyContrast;\n  var applyHue = options.applyHue;\n  var applySaturation = options.applySaturation;\n  var applyGamma = options.applyGamma;\n  var applyAlpha = options.applyAlpha;\n  var applyDayNightAlpha = options.applyDayNightAlpha;\n  var applySplit = options.applySplit;\n  var showReflectiveOcean = options.showReflectiveOcean;\n  var showOceanWaves = options.showOceanWaves;\n  var enableLighting = options.enableLighting;\n  var dynamicAtmosphereLighting = options.dynamicAtmosphereLighting;\n  var dynamicAtmosphereLightingFromSun =\n    options.dynamicAtmosphereLightingFromSun;\n  var showGroundAtmosphere = options.showGroundAtmosphere;\n  var perFragmentGroundAtmosphere = options.perFragmentGroundAtmosphere;\n  var hasVertexNormals = options.hasVertexNormals;\n  var useWebMercatorProjection = options.useWebMercatorProjection;\n  var enableFog = options.enableFog;\n  var enableClippingPlanes = options.enableClippingPlanes;\n  var clippingPlanes = options.clippingPlanes;\n  var clippedByBoundaries = options.clippedByBoundaries;\n  var hasImageryLayerCutout = options.hasImageryLayerCutout;\n  var colorCorrect = options.colorCorrect;\n  var highlightFillTile = options.highlightFillTile;\n  var colorToAlpha = options.colorToAlpha;\n  var showUndergroundColor = options.showUndergroundColor;\n  var translucent = options.translucent;\n\n  var quantization = 0;\n  var quantizationDefine = \"\";\n\n  var mesh = surfaceTile.renderedMesh;\n  var terrainEncoding = mesh.encoding;\n  var quantizationMode = terrainEncoding.quantization;\n  if (quantizationMode === TerrainQuantization.BITS12) {\n    quantization = 1;\n    quantizationDefine = \"QUANTIZATION_BITS12\";\n  }\n\n  var cartographicLimitRectangleFlag = 0;\n  var cartographicLimitRectangleDefine = \"\";\n  if (clippedByBoundaries) {\n    cartographicLimitRectangleFlag = 1;\n    cartographicLimitRectangleDefine = \"TILE_LIMIT_RECTANGLE\";\n  }\n\n  var imageryCutoutFlag = 0;\n  var imageryCutoutDefine = \"\";\n  if (hasImageryLayerCutout) {\n    imageryCutoutFlag = 1;\n    imageryCutoutDefine = \"APPLY_IMAGERY_CUTOUT\";\n  }\n\n  var sceneMode = frameState.mode;\n  var flags =\n    sceneMode |\n    (applyBrightness << 2) |\n    (applyContrast << 3) |\n    (applyHue << 4) |\n    (applySaturation << 5) |\n    (applyGamma << 6) |\n    (applyAlpha << 7) |\n    (showReflectiveOcean << 8) |\n    (showOceanWaves << 9) |\n    (enableLighting << 10) |\n    (dynamicAtmosphereLighting << 11) |\n    (dynamicAtmosphereLightingFromSun << 12) |\n    (showGroundAtmosphere << 13) |\n    (perFragmentGroundAtmosphere << 14) |\n    (hasVertexNormals << 15) |\n    (useWebMercatorProjection << 16) |\n    (enableFog << 17) |\n    (quantization << 18) |\n    (applySplit << 19) |\n    (enableClippingPlanes << 20) |\n    (cartographicLimitRectangleFlag << 21) |\n    (imageryCutoutFlag << 22) |\n    (colorCorrect << 23) |\n    (highlightFillTile << 24) |\n    (colorToAlpha << 25) |\n    (showUndergroundColor << 26) |\n    (translucent << 27) |\n    (applyDayNightAlpha << 28);\n\n  var currentClippingShaderState = 0;\n  if (defined(clippingPlanes) && clippingPlanes.length > 0) {\n    currentClippingShaderState = enableClippingPlanes\n      ? clippingPlanes.clippingPlanesState\n      : 0;\n  }\n  var surfaceShader = surfaceTile.surfaceShader;\n  if (\n    defined(surfaceShader) &&\n    surfaceShader.numberOfDayTextures === numberOfDayTextures &&\n    surfaceShader.flags === flags &&\n    surfaceShader.material === this.material &&\n    surfaceShader.clippingShaderState === currentClippingShaderState\n  ) {\n    return surfaceShader.shaderProgram;\n  }\n\n  // New tile, or tile changed number of textures, flags, or clipping planes\n  var shadersByFlags = this._shadersByTexturesFlags[numberOfDayTextures];\n  if (!defined(shadersByFlags)) {\n    shadersByFlags = this._shadersByTexturesFlags[numberOfDayTextures] = [];\n  }\n\n  surfaceShader = shadersByFlags[flags];\n  if (\n    !defined(surfaceShader) ||\n    surfaceShader.material !== this.material ||\n    surfaceShader.clippingShaderState !== currentClippingShaderState\n  ) {\n    // Cache miss - we've never seen this combination of numberOfDayTextures and flags before.\n    var vs = this.baseVertexShaderSource.clone();\n    var fs = this.baseFragmentShaderSource.clone();\n\n    if (currentClippingShaderState !== 0) {\n      fs.sources.unshift(\n        getClippingFunction(clippingPlanes, frameState.context)\n      ); // Need to go before GlobeFS\n    }\n\n    vs.defines.push(quantizationDefine);\n    fs.defines.push(\n      \"TEXTURE_UNITS \" + numberOfDayTextures,\n      cartographicLimitRectangleDefine,\n      imageryCutoutDefine\n    );\n\n    if (applyBrightness) {\n      fs.defines.push(\"APPLY_BRIGHTNESS\");\n    }\n    if (applyContrast) {\n      fs.defines.push(\"APPLY_CONTRAST\");\n    }\n    if (applyHue) {\n      fs.defines.push(\"APPLY_HUE\");\n    }\n    if (applySaturation) {\n      fs.defines.push(\"APPLY_SATURATION\");\n    }\n    if (applyGamma) {\n      fs.defines.push(\"APPLY_GAMMA\");\n    }\n    if (applyAlpha) {\n      fs.defines.push(\"APPLY_ALPHA\");\n    }\n    if (applyDayNightAlpha) {\n      fs.defines.push(\"APPLY_DAY_NIGHT_ALPHA\");\n    }\n    if (showReflectiveOcean) {\n      fs.defines.push(\"SHOW_REFLECTIVE_OCEAN\");\n      vs.defines.push(\"SHOW_REFLECTIVE_OCEAN\");\n    }\n    if (showOceanWaves) {\n      fs.defines.push(\"SHOW_OCEAN_WAVES\");\n    }\n    if (colorToAlpha) {\n      fs.defines.push(\"APPLY_COLOR_TO_ALPHA\");\n    }\n    if (showUndergroundColor) {\n      vs.defines.push(\"UNDERGROUND_COLOR\");\n      fs.defines.push(\"UNDERGROUND_COLOR\");\n    }\n    if (translucent) {\n      vs.defines.push(\"TRANSLUCENT\");\n      fs.defines.push(\"TRANSLUCENT\");\n    }\n    if (enableLighting) {\n      if (hasVertexNormals) {\n        vs.defines.push(\"ENABLE_VERTEX_LIGHTING\");\n        fs.defines.push(\"ENABLE_VERTEX_LIGHTING\");\n      } else {\n        vs.defines.push(\"ENABLE_DAYNIGHT_SHADING\");\n        fs.defines.push(\"ENABLE_DAYNIGHT_SHADING\");\n      }\n    }\n\n    if (dynamicAtmosphereLighting) {\n      fs.defines.push(\"DYNAMIC_ATMOSPHERE_LIGHTING\");\n      if (dynamicAtmosphereLightingFromSun) {\n        fs.defines.push(\"DYNAMIC_ATMOSPHERE_LIGHTING_FROM_SUN\");\n      }\n    }\n\n    if (showGroundAtmosphere) {\n      vs.defines.push(\"GROUND_ATMOSPHERE\");\n      fs.defines.push(\"GROUND_ATMOSPHERE\");\n      if (perFragmentGroundAtmosphere) {\n        fs.defines.push(\"PER_FRAGMENT_GROUND_ATMOSPHERE\");\n      }\n    }\n\n    vs.defines.push(\"INCLUDE_WEB_MERCATOR_Y\");\n    fs.defines.push(\"INCLUDE_WEB_MERCATOR_Y\");\n\n    if (enableFog) {\n      vs.defines.push(\"FOG\");\n      fs.defines.push(\"FOG\");\n    }\n\n    if (applySplit) {\n      fs.defines.push(\"APPLY_SPLIT\");\n    }\n\n    if (enableClippingPlanes) {\n      fs.defines.push(\"ENABLE_CLIPPING_PLANES\");\n    }\n\n    if (colorCorrect) {\n      fs.defines.push(\"COLOR_CORRECT\");\n    }\n\n    if (highlightFillTile) {\n      fs.defines.push(\"HIGHLIGHT_FILL_TILE\");\n    }\n\n    var computeDayColor =\n      \"\\\n    vec4 computeDayColor(vec4 initialColor, vec3 textureCoordinates, float nightBlend)\\n\\\n    {\\n\\\n        vec4 color = initialColor;\\n\";\n\n    if (hasImageryLayerCutout) {\n      computeDayColor +=\n        \"\\\n        vec4 cutoutAndColorResult;\\n\\\n        bool texelUnclipped;\\n\";\n    }\n\n    for (var i = 0; i < numberOfDayTextures; ++i) {\n      if (hasImageryLayerCutout) {\n        computeDayColor +=\n          \"\\\n        cutoutAndColorResult = u_dayTextureCutoutRectangles[\" +\n          i +\n          \"];\\n\\\n        texelUnclipped = v_textureCoordinates.x < cutoutAndColorResult.x || cutoutAndColorResult.z < v_textureCoordinates.x || v_textureCoordinates.y < cutoutAndColorResult.y || cutoutAndColorResult.w < v_textureCoordinates.y;\\n\\\n        cutoutAndColorResult = sampleAndBlend(\\n\";\n      } else {\n        computeDayColor += \"\\\n        color = sampleAndBlend(\\n\";\n      }\n      computeDayColor +=\n        \"\\\n            color,\\n\\\n            u_dayTextures[\" +\n        i +\n        \"],\\n\\\n            u_dayTextureUseWebMercatorT[\" +\n        i +\n        \"] ? textureCoordinates.xz : textureCoordinates.xy,\\n\\\n            u_dayTextureTexCoordsRectangle[\" +\n        i +\n        \"],\\n\\\n            u_dayTextureTranslationAndScale[\" +\n        i +\n        \"],\\n\\\n            \" +\n        (applyAlpha ? \"u_dayTextureAlpha[\" + i + \"]\" : \"1.0\") +\n        \",\\n\\\n            \" +\n        (applyDayNightAlpha ? \"u_dayTextureNightAlpha[\" + i + \"]\" : \"1.0\") +\n        \",\\n\" +\n        (applyDayNightAlpha ? \"u_dayTextureDayAlpha[\" + i + \"]\" : \"1.0\") +\n        \",\\n\" +\n        (applyBrightness ? \"u_dayTextureBrightness[\" + i + \"]\" : \"0.0\") +\n        \",\\n\\\n            \" +\n        (applyContrast ? \"u_dayTextureContrast[\" + i + \"]\" : \"0.0\") +\n        \",\\n\\\n            \" +\n        (applyHue ? \"u_dayTextureHue[\" + i + \"]\" : \"0.0\") +\n        \",\\n\\\n            \" +\n        (applySaturation ? \"u_dayTextureSaturation[\" + i + \"]\" : \"0.0\") +\n        \",\\n\\\n            \" +\n        (applyGamma ? \"u_dayTextureOneOverGamma[\" + i + \"]\" : \"0.0\") +\n        \",\\n\\\n            \" +\n        (applySplit ? \"u_dayTextureSplit[\" + i + \"]\" : \"0.0\") +\n        \",\\n\\\n            \" +\n        (colorToAlpha ? \"u_colorsToAlpha[\" + i + \"]\" : \"vec4(0.0)\") +\n        \",\\n\\\n        nightBlend\\\n        );\\n\";\n      if (hasImageryLayerCutout) {\n        computeDayColor +=\n          \"\\\n        color = czm_branchFreeTernary(texelUnclipped, cutoutAndColorResult, color);\\n\";\n      }\n    }\n\n    computeDayColor += \"\\\n        return color;\\n\\\n    }\";\n\n    fs.sources.push(computeDayColor);\n\n    vs.sources.push(getPositionMode(sceneMode));\n    vs.sources.push(get2DYPositionFraction(useWebMercatorProjection));\n\n    var shader = ShaderProgram.fromCache({\n      context: frameState.context,\n      vertexShaderSource: vs,\n      fragmentShaderSource: fs,\n      attributeLocations: terrainEncoding.getAttributeLocations(),\n    });\n\n    surfaceShader = shadersByFlags[flags] = new GlobeSurfaceShader(\n      numberOfDayTextures,\n      flags,\n      this.material,\n      shader,\n      currentClippingShaderState\n    );\n  }\n\n  surfaceTile.surfaceShader = surfaceShader;\n  return surfaceShader.shaderProgram;\n};\n\nGlobeSurfaceShaderSet.prototype.destroy = function () {\n  var flags;\n  var shader;\n\n  var shadersByTexturesFlags = this._shadersByTexturesFlags;\n  for (var textureCount in shadersByTexturesFlags) {\n    if (shadersByTexturesFlags.hasOwnProperty(textureCount)) {\n      var shadersByFlags = shadersByTexturesFlags[textureCount];\n      if (!defined(shadersByFlags)) {\n        continue;\n      }\n\n      for (flags in shadersByFlags) {\n        if (shadersByFlags.hasOwnProperty(flags)) {\n          shader = shadersByFlags[flags];\n          if (defined(shader)) {\n            shader.shaderProgram.destroy();\n          }\n        }\n      }\n    }\n  }\n\n  return destroyObject(this);\n};\nexport default GlobeSurfaceShaderSet;\n"]},"metadata":{},"sourceType":"module"}