{"ast":null,"code":"import Cartesian3 from \"../Core/Cartesian3.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport EllipsoidGeometry from \"../Core/EllipsoidGeometry.js\";\nimport GeometryPipeline from \"../Core/GeometryPipeline.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport VertexFormat from \"../Core/VertexFormat.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport SkyAtmosphereCommon from \"../Shaders/SkyAtmosphereCommon.js\";\nimport SkyAtmosphereFS from \"../Shaders/SkyAtmosphereFS.js\";\nimport SkyAtmosphereVS from \"../Shaders/SkyAtmosphereVS.js\";\nimport Axis from \"./Axis.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport CullFace from \"./CullFace.js\";\nimport SceneMode from \"./SceneMode.js\";\n/**\n * An atmosphere drawn around the limb of the provided ellipsoid.  Based on\n * {@link https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter16.html|Accurate Atmospheric Scattering}\n * in GPU Gems 2.\n * <p>\n * This is only supported in 3D. Atmosphere is faded out when morphing to 2D or Columbus view.\n * </p>\n *\n * @alias SkyAtmosphere\n * @constructor\n *\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid that the atmosphere is drawn around.\n *\n * @example\n * scene.skyAtmosphere = new Cesium.SkyAtmosphere();\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Sky%20Atmosphere.html|Sky atmosphere demo in Sandcastle}\n *\n * @see Scene.skyAtmosphere\n */\n\nfunction SkyAtmosphere(ellipsoid) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  /**\n   * Determines if the atmosphere is shown.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.show = true;\n  /**\n   * Compute atmosphere per-fragment instead of per-vertex.\n   * This produces better looking atmosphere with a slight performance penalty.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n\n  this.perFragmentAtmosphere = false;\n  this._ellipsoid = ellipsoid;\n  var outerEllipsoidScale = 1.025;\n  var scaleVector = Cartesian3.multiplyByScalar(ellipsoid.radii, outerEllipsoidScale, new Cartesian3());\n  this._scaleMatrix = Matrix4.fromScale(scaleVector);\n  this._modelMatrix = new Matrix4();\n  this._command = new DrawCommand({\n    owner: this,\n    modelMatrix: this._modelMatrix\n  });\n  this._spSkyFromSpace = undefined;\n  this._spSkyFromAtmosphere = undefined;\n  this._flags = undefined;\n  /**\n   * The hue shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A hue shift of 1.0 indicates a complete rotation of the hues available.\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.hueShift = 0.0;\n  /**\n   * The saturation shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A saturation shift of -1.0 is monochrome.\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.saturationShift = 0.0;\n  /**\n   * The brightness shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A brightness shift of -1.0 is complete darkness, which will let space show through.\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.brightnessShift = 0.0;\n  this._hueSaturationBrightness = new Cartesian3(); // outer radius, inner radius, dynamic atmosphere color flag\n\n  var radiiAndDynamicAtmosphereColor = new Cartesian3();\n  radiiAndDynamicAtmosphereColor.x = ellipsoid.maximumRadius * outerEllipsoidScale;\n  radiiAndDynamicAtmosphereColor.y = ellipsoid.maximumRadius; // Toggles whether the sun position is used. 0 treats the sun as always directly overhead.\n\n  radiiAndDynamicAtmosphereColor.z = 0;\n  this._radiiAndDynamicAtmosphereColor = radiiAndDynamicAtmosphereColor;\n  var that = this;\n  this._command.uniformMap = {\n    u_radiiAndDynamicAtmosphereColor: function () {\n      return that._radiiAndDynamicAtmosphereColor;\n    },\n    u_hsbShift: function () {\n      that._hueSaturationBrightness.x = that.hueShift;\n      that._hueSaturationBrightness.y = that.saturationShift;\n      that._hueSaturationBrightness.z = that.brightnessShift;\n      return that._hueSaturationBrightness;\n    }\n  };\n}\n\nObject.defineProperties(SkyAtmosphere.prototype, {\n  /**\n   * Gets the ellipsoid the atmosphere is drawn around.\n   * @memberof SkyAtmosphere.prototype\n   *\n   * @type {Ellipsoid}\n   * @readonly\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    }\n  }\n});\n/**\n * @private\n */\n\nSkyAtmosphere.prototype.setDynamicAtmosphereColor = function (enableLighting, useSunDirection) {\n  var lightEnum = enableLighting ? useSunDirection ? 2.0 : 1.0 : 0.0;\n  this._radiiAndDynamicAtmosphereColor.z = lightEnum;\n};\n\nvar scratchModelMatrix = new Matrix4();\n/**\n * @private\n */\n\nSkyAtmosphere.prototype.update = function (frameState, globe) {\n  if (!this.show) {\n    return undefined;\n  }\n\n  var mode = frameState.mode;\n\n  if (mode !== SceneMode.SCENE3D && mode !== SceneMode.MORPHING) {\n    return undefined;\n  } // The atmosphere is only rendered during the render pass; it is not pickable, it doesn't cast shadows, etc.\n\n\n  if (!frameState.passes.render) {\n    return undefined;\n  } // Align the ellipsoid geometry so it always faces the same direction as the\n  // camera to reduce artifacts when rendering atmosphere per-vertex\n\n\n  var rotationMatrix = Matrix4.fromRotationTranslation(frameState.context.uniformState.inverseViewRotation, Cartesian3.ZERO, scratchModelMatrix);\n  var rotationOffsetMatrix = Matrix4.multiplyTransformation(rotationMatrix, Axis.Y_UP_TO_Z_UP, scratchModelMatrix);\n  var modelMatrix = Matrix4.multiply(this._scaleMatrix, rotationOffsetMatrix, scratchModelMatrix);\n  Matrix4.clone(modelMatrix, this._modelMatrix);\n  var context = frameState.context;\n  var colorCorrect = hasColorCorrection(this);\n  var translucent = frameState.globeTranslucencyState.translucent;\n  var perFragmentAtmosphere = this.perFragmentAtmosphere || translucent || !defined(globe) || !globe.show;\n  var command = this._command;\n\n  if (!defined(command.vertexArray)) {\n    var geometry = EllipsoidGeometry.createGeometry(new EllipsoidGeometry({\n      radii: new Cartesian3(1.0, 1.0, 1.0),\n      slicePartitions: 256,\n      stackPartitions: 256,\n      vertexFormat: VertexFormat.POSITION_ONLY\n    }));\n    command.vertexArray = VertexArray.fromGeometry({\n      context: context,\n      geometry: geometry,\n      attributeLocations: GeometryPipeline.createAttributeLocations(geometry),\n      bufferUsage: BufferUsage.STATIC_DRAW\n    });\n    command.renderState = RenderState.fromCache({\n      cull: {\n        enabled: true,\n        face: CullFace.FRONT\n      },\n      blending: BlendingState.ALPHA_BLEND,\n      depthMask: false\n    });\n  }\n\n  var flags = colorCorrect | perFragmentAtmosphere << 2 | translucent << 3;\n\n  if (flags !== this._flags) {\n    this._flags = flags;\n    var defines = [];\n\n    if (colorCorrect) {\n      defines.push(\"COLOR_CORRECT\");\n    }\n\n    if (perFragmentAtmosphere) {\n      defines.push(\"PER_FRAGMENT_ATMOSPHERE\");\n    }\n\n    if (translucent) {\n      defines.push(\"GLOBE_TRANSLUCENT\");\n    }\n\n    var vs = new ShaderSource({\n      defines: defines.concat(\"SKY_FROM_SPACE\"),\n      sources: [SkyAtmosphereCommon, SkyAtmosphereVS]\n    });\n    var fs = new ShaderSource({\n      defines: defines.concat(\"SKY_FROM_SPACE\"),\n      sources: [SkyAtmosphereCommon, SkyAtmosphereFS]\n    });\n    this._spSkyFromSpace = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: vs,\n      fragmentShaderSource: fs\n    });\n    vs = new ShaderSource({\n      defines: defines.concat(\"SKY_FROM_ATMOSPHERE\"),\n      sources: [SkyAtmosphereCommon, SkyAtmosphereVS]\n    });\n    fs = new ShaderSource({\n      defines: defines.concat(\"SKY_FROM_ATMOSPHERE\"),\n      sources: [SkyAtmosphereCommon, SkyAtmosphereFS]\n    });\n    this._spSkyFromAtmosphere = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: vs,\n      fragmentShaderSource: fs\n    });\n  }\n\n  var cameraPosition = frameState.camera.positionWC;\n  var cameraHeight = Cartesian3.magnitude(cameraPosition);\n\n  if (cameraHeight > this._radiiAndDynamicAtmosphereColor.x) {\n    // Camera in space\n    command.shaderProgram = this._spSkyFromSpace;\n  } else {\n    // Camera in atmosphere\n    command.shaderProgram = this._spSkyFromAtmosphere;\n  }\n\n  return command;\n};\n\nfunction hasColorCorrection(skyAtmosphere) {\n  return !(CesiumMath.equalsEpsilon(skyAtmosphere.hueShift, 0.0, CesiumMath.EPSILON7) && CesiumMath.equalsEpsilon(skyAtmosphere.saturationShift, 0.0, CesiumMath.EPSILON7) && CesiumMath.equalsEpsilon(skyAtmosphere.brightnessShift, 0.0, CesiumMath.EPSILON7));\n}\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see SkyAtmosphere#destroy\n */\n\n\nSkyAtmosphere.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * skyAtmosphere = skyAtmosphere && skyAtmosphere.destroy();\n *\n * @see SkyAtmosphere#isDestroyed\n */\n\n\nSkyAtmosphere.prototype.destroy = function () {\n  var command = this._command;\n  command.vertexArray = command.vertexArray && command.vertexArray.destroy();\n  this._spSkyFromSpace = this._spSkyFromSpace && this._spSkyFromSpace.destroy();\n  this._spSkyFromAtmosphere = this._spSkyFromAtmosphere && this._spSkyFromAtmosphere.destroy();\n  return destroyObject(this);\n};\n\nexport default SkyAtmosphere;","map":{"version":3,"sources":["/home/usuario/davi/thalamus/wms/3dmaptestes/leaflet_cesium/client/node_modules/cesium/Source/Scene/SkyAtmosphere.js"],"names":["Cartesian3","defaultValue","defined","destroyObject","Ellipsoid","EllipsoidGeometry","GeometryPipeline","CesiumMath","Matrix4","VertexFormat","BufferUsage","DrawCommand","RenderState","ShaderProgram","ShaderSource","VertexArray","SkyAtmosphereCommon","SkyAtmosphereFS","SkyAtmosphereVS","Axis","BlendingState","CullFace","SceneMode","SkyAtmosphere","ellipsoid","WGS84","show","perFragmentAtmosphere","_ellipsoid","outerEllipsoidScale","scaleVector","multiplyByScalar","radii","_scaleMatrix","fromScale","_modelMatrix","_command","owner","modelMatrix","_spSkyFromSpace","undefined","_spSkyFromAtmosphere","_flags","hueShift","saturationShift","brightnessShift","_hueSaturationBrightness","radiiAndDynamicAtmosphereColor","x","maximumRadius","y","z","_radiiAndDynamicAtmosphereColor","that","uniformMap","u_radiiAndDynamicAtmosphereColor","u_hsbShift","Object","defineProperties","prototype","get","setDynamicAtmosphereColor","enableLighting","useSunDirection","lightEnum","scratchModelMatrix","update","frameState","globe","mode","SCENE3D","MORPHING","passes","render","rotationMatrix","fromRotationTranslation","context","uniformState","inverseViewRotation","ZERO","rotationOffsetMatrix","multiplyTransformation","Y_UP_TO_Z_UP","multiply","clone","colorCorrect","hasColorCorrection","translucent","globeTranslucencyState","command","vertexArray","geometry","createGeometry","slicePartitions","stackPartitions","vertexFormat","POSITION_ONLY","fromGeometry","attributeLocations","createAttributeLocations","bufferUsage","STATIC_DRAW","renderState","fromCache","cull","enabled","face","FRONT","blending","ALPHA_BLEND","depthMask","flags","defines","push","vs","concat","sources","fs","vertexShaderSource","fragmentShaderSource","cameraPosition","camera","positionWC","cameraHeight","magnitude","shaderProgram","skyAtmosphere","equalsEpsilon","EPSILON7","isDestroyed","destroy"],"mappings":"AAAA,OAAOA,UAAP,MAAuB,uBAAvB;AACA,OAAOC,YAAP,MAAyB,yBAAzB;AACA,OAAOC,OAAP,MAAoB,oBAApB;AACA,OAAOC,aAAP,MAA0B,0BAA1B;AACA,OAAOC,SAAP,MAAsB,sBAAtB;AACA,OAAOC,iBAAP,MAA8B,8BAA9B;AACA,OAAOC,gBAAP,MAA6B,6BAA7B;AACA,OAAOC,UAAP,MAAuB,iBAAvB;AACA,OAAOC,OAAP,MAAoB,oBAApB;AACA,OAAOC,YAAP,MAAyB,yBAAzB;AACA,OAAOC,WAAP,MAAwB,4BAAxB;AACA,OAAOC,WAAP,MAAwB,4BAAxB;AACA,OAAOC,WAAP,MAAwB,4BAAxB;AACA,OAAOC,aAAP,MAA0B,8BAA1B;AACA,OAAOC,YAAP,MAAyB,6BAAzB;AACA,OAAOC,WAAP,MAAwB,4BAAxB;AACA,OAAOC,mBAAP,MAAgC,mCAAhC;AACA,OAAOC,eAAP,MAA4B,+BAA5B;AACA,OAAOC,eAAP,MAA4B,+BAA5B;AACA,OAAOC,IAAP,MAAiB,WAAjB;AACA,OAAOC,aAAP,MAA0B,oBAA1B;AACA,OAAOC,QAAP,MAAqB,eAArB;AACA,OAAOC,SAAP,MAAsB,gBAAtB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,aAAT,CAAuBC,SAAvB,EAAkC;AAChCA,EAAAA,SAAS,GAAGvB,YAAY,CAACuB,SAAD,EAAYpB,SAAS,CAACqB,KAAtB,CAAxB;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,IAAL,GAAY,IAAZ;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,qBAAL,GAA6B,KAA7B;AAEA,OAAKC,UAAL,GAAkBJ,SAAlB;AAEA,MAAIK,mBAAmB,GAAG,KAA1B;AACA,MAAIC,WAAW,GAAG9B,UAAU,CAAC+B,gBAAX,CAChBP,SAAS,CAACQ,KADM,EAEhBH,mBAFgB,EAGhB,IAAI7B,UAAJ,EAHgB,CAAlB;AAKA,OAAKiC,YAAL,GAAoBzB,OAAO,CAAC0B,SAAR,CAAkBJ,WAAlB,CAApB;AACA,OAAKK,YAAL,GAAoB,IAAI3B,OAAJ,EAApB;AAEA,OAAK4B,QAAL,GAAgB,IAAIzB,WAAJ,CAAgB;AAC9B0B,IAAAA,KAAK,EAAE,IADuB;AAE9BC,IAAAA,WAAW,EAAE,KAAKH;AAFY,GAAhB,CAAhB;AAIA,OAAKI,eAAL,GAAuBC,SAAvB;AACA,OAAKC,oBAAL,GAA4BD,SAA5B;AAEA,OAAKE,MAAL,GAAcF,SAAd;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKG,QAAL,GAAgB,GAAhB;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,eAAL,GAAuB,GAAvB;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,eAAL,GAAuB,GAAvB;AAEA,OAAKC,wBAAL,GAAgC,IAAI9C,UAAJ,EAAhC,CAhEgC,CAkEhC;;AACA,MAAI+C,8BAA8B,GAAG,IAAI/C,UAAJ,EAArC;AAEA+C,EAAAA,8BAA8B,CAACC,CAA/B,GACExB,SAAS,CAACyB,aAAV,GAA0BpB,mBAD5B;AAEAkB,EAAAA,8BAA8B,CAACG,CAA/B,GAAmC1B,SAAS,CAACyB,aAA7C,CAvEgC,CAyEhC;;AACAF,EAAAA,8BAA8B,CAACI,CAA/B,GAAmC,CAAnC;AAEA,OAAKC,+BAAL,GAAuCL,8BAAvC;AAEA,MAAIM,IAAI,GAAG,IAAX;AAEA,OAAKjB,QAAL,CAAckB,UAAd,GAA2B;AACzBC,IAAAA,gCAAgC,EAAE,YAAY;AAC5C,aAAOF,IAAI,CAACD,+BAAZ;AACD,KAHwB;AAIzBI,IAAAA,UAAU,EAAE,YAAY;AACtBH,MAAAA,IAAI,CAACP,wBAAL,CAA8BE,CAA9B,GAAkCK,IAAI,CAACV,QAAvC;AACAU,MAAAA,IAAI,CAACP,wBAAL,CAA8BI,CAA9B,GAAkCG,IAAI,CAACT,eAAvC;AACAS,MAAAA,IAAI,CAACP,wBAAL,CAA8BK,CAA9B,GAAkCE,IAAI,CAACR,eAAvC;AACA,aAAOQ,IAAI,CAACP,wBAAZ;AACD;AATwB,GAA3B;AAWD;;AAEDW,MAAM,CAACC,gBAAP,CAAwBnC,aAAa,CAACoC,SAAtC,EAAiD;AAC/C;AACF;AACA;AACA;AACA;AACA;AACA;AACEnC,EAAAA,SAAS,EAAE;AACToC,IAAAA,GAAG,EAAE,YAAY;AACf,aAAO,KAAKhC,UAAZ;AACD;AAHQ;AARoC,CAAjD;AAeA;AACA;AACA;;AACAL,aAAa,CAACoC,SAAd,CAAwBE,yBAAxB,GAAoD,UAClDC,cADkD,EAElDC,eAFkD,EAGlD;AACA,MAAIC,SAAS,GAAGF,cAAc,GAAIC,eAAe,GAAG,GAAH,GAAS,GAA5B,GAAmC,GAAjE;AACA,OAAKX,+BAAL,CAAqCD,CAArC,GAAyCa,SAAzC;AACD,CAND;;AAQA,IAAIC,kBAAkB,GAAG,IAAIzD,OAAJ,EAAzB;AAEA;AACA;AACA;;AACAe,aAAa,CAACoC,SAAd,CAAwBO,MAAxB,GAAiC,UAAUC,UAAV,EAAsBC,KAAtB,EAA6B;AAC5D,MAAI,CAAC,KAAK1C,IAAV,EAAgB;AACd,WAAOc,SAAP;AACD;;AAED,MAAI6B,IAAI,GAAGF,UAAU,CAACE,IAAtB;;AACA,MAAIA,IAAI,KAAK/C,SAAS,CAACgD,OAAnB,IAA8BD,IAAI,KAAK/C,SAAS,CAACiD,QAArD,EAA+D;AAC7D,WAAO/B,SAAP;AACD,GAR2D,CAU5D;;;AACA,MAAI,CAAC2B,UAAU,CAACK,MAAX,CAAkBC,MAAvB,EAA+B;AAC7B,WAAOjC,SAAP;AACD,GAb2D,CAe5D;AACA;;;AACA,MAAIkC,cAAc,GAAGlE,OAAO,CAACmE,uBAAR,CACnBR,UAAU,CAACS,OAAX,CAAmBC,YAAnB,CAAgCC,mBADb,EAEnB9E,UAAU,CAAC+E,IAFQ,EAGnBd,kBAHmB,CAArB;AAKA,MAAIe,oBAAoB,GAAGxE,OAAO,CAACyE,sBAAR,CACzBP,cADyB,EAEzBvD,IAAI,CAAC+D,YAFoB,EAGzBjB,kBAHyB,CAA3B;AAKA,MAAI3B,WAAW,GAAG9B,OAAO,CAAC2E,QAAR,CAChB,KAAKlD,YADW,EAEhB+C,oBAFgB,EAGhBf,kBAHgB,CAAlB;AAKAzD,EAAAA,OAAO,CAAC4E,KAAR,CAAc9C,WAAd,EAA2B,KAAKH,YAAhC;AAEA,MAAIyC,OAAO,GAAGT,UAAU,CAACS,OAAzB;AAEA,MAAIS,YAAY,GAAGC,kBAAkB,CAAC,IAAD,CAArC;AACA,MAAIC,WAAW,GAAGpB,UAAU,CAACqB,sBAAX,CAAkCD,WAApD;AACA,MAAI5D,qBAAqB,GACvB,KAAKA,qBAAL,IAA8B4D,WAA9B,IAA6C,CAACrF,OAAO,CAACkE,KAAD,CAArD,IAAgE,CAACA,KAAK,CAAC1C,IADzE;AAGA,MAAI+D,OAAO,GAAG,KAAKrD,QAAnB;;AAEA,MAAI,CAAClC,OAAO,CAACuF,OAAO,CAACC,WAAT,CAAZ,EAAmC;AACjC,QAAIC,QAAQ,GAAGtF,iBAAiB,CAACuF,cAAlB,CACb,IAAIvF,iBAAJ,CAAsB;AACpB2B,MAAAA,KAAK,EAAE,IAAIhC,UAAJ,CAAe,GAAf,EAAoB,GAApB,EAAyB,GAAzB,CADa;AAEpB6F,MAAAA,eAAe,EAAE,GAFG;AAGpBC,MAAAA,eAAe,EAAE,GAHG;AAIpBC,MAAAA,YAAY,EAAEtF,YAAY,CAACuF;AAJP,KAAtB,CADa,CAAf;AAQAP,IAAAA,OAAO,CAACC,WAAR,GAAsB3E,WAAW,CAACkF,YAAZ,CAAyB;AAC7CrB,MAAAA,OAAO,EAAEA,OADoC;AAE7Ce,MAAAA,QAAQ,EAAEA,QAFmC;AAG7CO,MAAAA,kBAAkB,EAAE5F,gBAAgB,CAAC6F,wBAAjB,CAA0CR,QAA1C,CAHyB;AAI7CS,MAAAA,WAAW,EAAE1F,WAAW,CAAC2F;AAJoB,KAAzB,CAAtB;AAMAZ,IAAAA,OAAO,CAACa,WAAR,GAAsB1F,WAAW,CAAC2F,SAAZ,CAAsB;AAC1CC,MAAAA,IAAI,EAAE;AACJC,QAAAA,OAAO,EAAE,IADL;AAEJC,QAAAA,IAAI,EAAErF,QAAQ,CAACsF;AAFX,OADoC;AAK1CC,MAAAA,QAAQ,EAAExF,aAAa,CAACyF,WALkB;AAM1CC,MAAAA,SAAS,EAAE;AAN+B,KAAtB,CAAtB;AAQD;;AAED,MAAIC,KAAK,GAAG1B,YAAY,GAAI1D,qBAAqB,IAAI,CAAzC,GAA+C4D,WAAW,IAAI,CAA1E;;AAEA,MAAIwB,KAAK,KAAK,KAAKrE,MAAnB,EAA2B;AACzB,SAAKA,MAAL,GAAcqE,KAAd;AAEA,QAAIC,OAAO,GAAG,EAAd;;AAEA,QAAI3B,YAAJ,EAAkB;AAChB2B,MAAAA,OAAO,CAACC,IAAR,CAAa,eAAb;AACD;;AAED,QAAItF,qBAAJ,EAA2B;AACzBqF,MAAAA,OAAO,CAACC,IAAR,CAAa,yBAAb;AACD;;AAED,QAAI1B,WAAJ,EAAiB;AACfyB,MAAAA,OAAO,CAACC,IAAR,CAAa,mBAAb;AACD;;AAED,QAAIC,EAAE,GAAG,IAAIpG,YAAJ,CAAiB;AACxBkG,MAAAA,OAAO,EAAEA,OAAO,CAACG,MAAR,CAAe,gBAAf,CADe;AAExBC,MAAAA,OAAO,EAAE,CAACpG,mBAAD,EAAsBE,eAAtB;AAFe,KAAjB,CAAT;AAKA,QAAImG,EAAE,GAAG,IAAIvG,YAAJ,CAAiB;AACxBkG,MAAAA,OAAO,EAAEA,OAAO,CAACG,MAAR,CAAe,gBAAf,CADe;AAExBC,MAAAA,OAAO,EAAE,CAACpG,mBAAD,EAAsBC,eAAtB;AAFe,KAAjB,CAAT;AAKA,SAAKsB,eAAL,GAAuB1B,aAAa,CAAC0F,SAAd,CAAwB;AAC7C3B,MAAAA,OAAO,EAAEA,OADoC;AAE7C0C,MAAAA,kBAAkB,EAAEJ,EAFyB;AAG7CK,MAAAA,oBAAoB,EAAEF;AAHuB,KAAxB,CAAvB;AAMAH,IAAAA,EAAE,GAAG,IAAIpG,YAAJ,CAAiB;AACpBkG,MAAAA,OAAO,EAAEA,OAAO,CAACG,MAAR,CAAe,qBAAf,CADW;AAEpBC,MAAAA,OAAO,EAAE,CAACpG,mBAAD,EAAsBE,eAAtB;AAFW,KAAjB,CAAL;AAKAmG,IAAAA,EAAE,GAAG,IAAIvG,YAAJ,CAAiB;AACpBkG,MAAAA,OAAO,EAAEA,OAAO,CAACG,MAAR,CAAe,qBAAf,CADW;AAEpBC,MAAAA,OAAO,EAAE,CAACpG,mBAAD,EAAsBC,eAAtB;AAFW,KAAjB,CAAL;AAKA,SAAKwB,oBAAL,GAA4B5B,aAAa,CAAC0F,SAAd,CAAwB;AAClD3B,MAAAA,OAAO,EAAEA,OADyC;AAElD0C,MAAAA,kBAAkB,EAAEJ,EAF8B;AAGlDK,MAAAA,oBAAoB,EAAEF;AAH4B,KAAxB,CAA5B;AAKD;;AAED,MAAIG,cAAc,GAAGrD,UAAU,CAACsD,MAAX,CAAkBC,UAAvC;AACA,MAAIC,YAAY,GAAG3H,UAAU,CAAC4H,SAAX,CAAqBJ,cAArB,CAAnB;;AAEA,MAAIG,YAAY,GAAG,KAAKvE,+BAAL,CAAqCJ,CAAxD,EAA2D;AACzD;AACAyC,IAAAA,OAAO,CAACoC,aAAR,GAAwB,KAAKtF,eAA7B;AACD,GAHD,MAGO;AACL;AACAkD,IAAAA,OAAO,CAACoC,aAAR,GAAwB,KAAKpF,oBAA7B;AACD;;AAED,SAAOgD,OAAP;AACD,CApID;;AAsIA,SAASH,kBAAT,CAA4BwC,aAA5B,EAA2C;AACzC,SAAO,EACLvH,UAAU,CAACwH,aAAX,CACED,aAAa,CAACnF,QADhB,EAEE,GAFF,EAGEpC,UAAU,CAACyH,QAHb,KAKAzH,UAAU,CAACwH,aAAX,CACED,aAAa,CAAClF,eADhB,EAEE,GAFF,EAGErC,UAAU,CAACyH,QAHb,CALA,IAUAzH,UAAU,CAACwH,aAAX,CACED,aAAa,CAACjF,eADhB,EAEE,GAFF,EAGEtC,UAAU,CAACyH,QAHb,CAXK,CAAP;AAiBD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAzG,aAAa,CAACoC,SAAd,CAAwBsE,WAAxB,GAAsC,YAAY;AAChD,SAAO,KAAP;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA1G,aAAa,CAACoC,SAAd,CAAwBuE,OAAxB,GAAkC,YAAY;AAC5C,MAAIzC,OAAO,GAAG,KAAKrD,QAAnB;AACAqD,EAAAA,OAAO,CAACC,WAAR,GAAsBD,OAAO,CAACC,WAAR,IAAuBD,OAAO,CAACC,WAAR,CAAoBwC,OAApB,EAA7C;AACA,OAAK3F,eAAL,GAAuB,KAAKA,eAAL,IAAwB,KAAKA,eAAL,CAAqB2F,OAArB,EAA/C;AACA,OAAKzF,oBAAL,GACE,KAAKA,oBAAL,IAA6B,KAAKA,oBAAL,CAA0ByF,OAA1B,EAD/B;AAEA,SAAO/H,aAAa,CAAC,IAAD,CAApB;AACD,CAPD;;AAQA,eAAeoB,aAAf","sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport EllipsoidGeometry from \"../Core/EllipsoidGeometry.js\";\nimport GeometryPipeline from \"../Core/GeometryPipeline.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport VertexFormat from \"../Core/VertexFormat.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport SkyAtmosphereCommon from \"../Shaders/SkyAtmosphereCommon.js\";\nimport SkyAtmosphereFS from \"../Shaders/SkyAtmosphereFS.js\";\nimport SkyAtmosphereVS from \"../Shaders/SkyAtmosphereVS.js\";\nimport Axis from \"./Axis.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport CullFace from \"./CullFace.js\";\nimport SceneMode from \"./SceneMode.js\";\n\n/**\n * An atmosphere drawn around the limb of the provided ellipsoid.  Based on\n * {@link https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter16.html|Accurate Atmospheric Scattering}\n * in GPU Gems 2.\n * <p>\n * This is only supported in 3D. Atmosphere is faded out when morphing to 2D or Columbus view.\n * </p>\n *\n * @alias SkyAtmosphere\n * @constructor\n *\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid that the atmosphere is drawn around.\n *\n * @example\n * scene.skyAtmosphere = new Cesium.SkyAtmosphere();\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Sky%20Atmosphere.html|Sky atmosphere demo in Sandcastle}\n *\n * @see Scene.skyAtmosphere\n */\nfunction SkyAtmosphere(ellipsoid) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n\n  /**\n   * Determines if the atmosphere is shown.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.show = true;\n\n  /**\n   * Compute atmosphere per-fragment instead of per-vertex.\n   * This produces better looking atmosphere with a slight performance penalty.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  this.perFragmentAtmosphere = false;\n\n  this._ellipsoid = ellipsoid;\n\n  var outerEllipsoidScale = 1.025;\n  var scaleVector = Cartesian3.multiplyByScalar(\n    ellipsoid.radii,\n    outerEllipsoidScale,\n    new Cartesian3()\n  );\n  this._scaleMatrix = Matrix4.fromScale(scaleVector);\n  this._modelMatrix = new Matrix4();\n\n  this._command = new DrawCommand({\n    owner: this,\n    modelMatrix: this._modelMatrix,\n  });\n  this._spSkyFromSpace = undefined;\n  this._spSkyFromAtmosphere = undefined;\n\n  this._flags = undefined;\n\n  /**\n   * The hue shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A hue shift of 1.0 indicates a complete rotation of the hues available.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.hueShift = 0.0;\n\n  /**\n   * The saturation shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A saturation shift of -1.0 is monochrome.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.saturationShift = 0.0;\n\n  /**\n   * The brightness shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A brightness shift of -1.0 is complete darkness, which will let space show through.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.brightnessShift = 0.0;\n\n  this._hueSaturationBrightness = new Cartesian3();\n\n  // outer radius, inner radius, dynamic atmosphere color flag\n  var radiiAndDynamicAtmosphereColor = new Cartesian3();\n\n  radiiAndDynamicAtmosphereColor.x =\n    ellipsoid.maximumRadius * outerEllipsoidScale;\n  radiiAndDynamicAtmosphereColor.y = ellipsoid.maximumRadius;\n\n  // Toggles whether the sun position is used. 0 treats the sun as always directly overhead.\n  radiiAndDynamicAtmosphereColor.z = 0;\n\n  this._radiiAndDynamicAtmosphereColor = radiiAndDynamicAtmosphereColor;\n\n  var that = this;\n\n  this._command.uniformMap = {\n    u_radiiAndDynamicAtmosphereColor: function () {\n      return that._radiiAndDynamicAtmosphereColor;\n    },\n    u_hsbShift: function () {\n      that._hueSaturationBrightness.x = that.hueShift;\n      that._hueSaturationBrightness.y = that.saturationShift;\n      that._hueSaturationBrightness.z = that.brightnessShift;\n      return that._hueSaturationBrightness;\n    },\n  };\n}\n\nObject.defineProperties(SkyAtmosphere.prototype, {\n  /**\n   * Gets the ellipsoid the atmosphere is drawn around.\n   * @memberof SkyAtmosphere.prototype\n   *\n   * @type {Ellipsoid}\n   * @readonly\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n});\n\n/**\n * @private\n */\nSkyAtmosphere.prototype.setDynamicAtmosphereColor = function (\n  enableLighting,\n  useSunDirection\n) {\n  var lightEnum = enableLighting ? (useSunDirection ? 2.0 : 1.0) : 0.0;\n  this._radiiAndDynamicAtmosphereColor.z = lightEnum;\n};\n\nvar scratchModelMatrix = new Matrix4();\n\n/**\n * @private\n */\nSkyAtmosphere.prototype.update = function (frameState, globe) {\n  if (!this.show) {\n    return undefined;\n  }\n\n  var mode = frameState.mode;\n  if (mode !== SceneMode.SCENE3D && mode !== SceneMode.MORPHING) {\n    return undefined;\n  }\n\n  // The atmosphere is only rendered during the render pass; it is not pickable, it doesn't cast shadows, etc.\n  if (!frameState.passes.render) {\n    return undefined;\n  }\n\n  // Align the ellipsoid geometry so it always faces the same direction as the\n  // camera to reduce artifacts when rendering atmosphere per-vertex\n  var rotationMatrix = Matrix4.fromRotationTranslation(\n    frameState.context.uniformState.inverseViewRotation,\n    Cartesian3.ZERO,\n    scratchModelMatrix\n  );\n  var rotationOffsetMatrix = Matrix4.multiplyTransformation(\n    rotationMatrix,\n    Axis.Y_UP_TO_Z_UP,\n    scratchModelMatrix\n  );\n  var modelMatrix = Matrix4.multiply(\n    this._scaleMatrix,\n    rotationOffsetMatrix,\n    scratchModelMatrix\n  );\n  Matrix4.clone(modelMatrix, this._modelMatrix);\n\n  var context = frameState.context;\n\n  var colorCorrect = hasColorCorrection(this);\n  var translucent = frameState.globeTranslucencyState.translucent;\n  var perFragmentAtmosphere =\n    this.perFragmentAtmosphere || translucent || !defined(globe) || !globe.show;\n\n  var command = this._command;\n\n  if (!defined(command.vertexArray)) {\n    var geometry = EllipsoidGeometry.createGeometry(\n      new EllipsoidGeometry({\n        radii: new Cartesian3(1.0, 1.0, 1.0),\n        slicePartitions: 256,\n        stackPartitions: 256,\n        vertexFormat: VertexFormat.POSITION_ONLY,\n      })\n    );\n    command.vertexArray = VertexArray.fromGeometry({\n      context: context,\n      geometry: geometry,\n      attributeLocations: GeometryPipeline.createAttributeLocations(geometry),\n      bufferUsage: BufferUsage.STATIC_DRAW,\n    });\n    command.renderState = RenderState.fromCache({\n      cull: {\n        enabled: true,\n        face: CullFace.FRONT,\n      },\n      blending: BlendingState.ALPHA_BLEND,\n      depthMask: false,\n    });\n  }\n\n  var flags = colorCorrect | (perFragmentAtmosphere << 2) | (translucent << 3);\n\n  if (flags !== this._flags) {\n    this._flags = flags;\n\n    var defines = [];\n\n    if (colorCorrect) {\n      defines.push(\"COLOR_CORRECT\");\n    }\n\n    if (perFragmentAtmosphere) {\n      defines.push(\"PER_FRAGMENT_ATMOSPHERE\");\n    }\n\n    if (translucent) {\n      defines.push(\"GLOBE_TRANSLUCENT\");\n    }\n\n    var vs = new ShaderSource({\n      defines: defines.concat(\"SKY_FROM_SPACE\"),\n      sources: [SkyAtmosphereCommon, SkyAtmosphereVS],\n    });\n\n    var fs = new ShaderSource({\n      defines: defines.concat(\"SKY_FROM_SPACE\"),\n      sources: [SkyAtmosphereCommon, SkyAtmosphereFS],\n    });\n\n    this._spSkyFromSpace = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: vs,\n      fragmentShaderSource: fs,\n    });\n\n    vs = new ShaderSource({\n      defines: defines.concat(\"SKY_FROM_ATMOSPHERE\"),\n      sources: [SkyAtmosphereCommon, SkyAtmosphereVS],\n    });\n\n    fs = new ShaderSource({\n      defines: defines.concat(\"SKY_FROM_ATMOSPHERE\"),\n      sources: [SkyAtmosphereCommon, SkyAtmosphereFS],\n    });\n\n    this._spSkyFromAtmosphere = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: vs,\n      fragmentShaderSource: fs,\n    });\n  }\n\n  var cameraPosition = frameState.camera.positionWC;\n  var cameraHeight = Cartesian3.magnitude(cameraPosition);\n\n  if (cameraHeight > this._radiiAndDynamicAtmosphereColor.x) {\n    // Camera in space\n    command.shaderProgram = this._spSkyFromSpace;\n  } else {\n    // Camera in atmosphere\n    command.shaderProgram = this._spSkyFromAtmosphere;\n  }\n\n  return command;\n};\n\nfunction hasColorCorrection(skyAtmosphere) {\n  return !(\n    CesiumMath.equalsEpsilon(\n      skyAtmosphere.hueShift,\n      0.0,\n      CesiumMath.EPSILON7\n    ) &&\n    CesiumMath.equalsEpsilon(\n      skyAtmosphere.saturationShift,\n      0.0,\n      CesiumMath.EPSILON7\n    ) &&\n    CesiumMath.equalsEpsilon(\n      skyAtmosphere.brightnessShift,\n      0.0,\n      CesiumMath.EPSILON7\n    )\n  );\n}\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see SkyAtmosphere#destroy\n */\nSkyAtmosphere.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * skyAtmosphere = skyAtmosphere && skyAtmosphere.destroy();\n *\n * @see SkyAtmosphere#isDestroyed\n */\nSkyAtmosphere.prototype.destroy = function () {\n  var command = this._command;\n  command.vertexArray = command.vertexArray && command.vertexArray.destroy();\n  this._spSkyFromSpace = this._spSkyFromSpace && this._spSkyFromSpace.destroy();\n  this._spSkyFromAtmosphere =\n    this._spSkyFromAtmosphere && this._spSkyFromAtmosphere.destroy();\n  return destroyObject(this);\n};\nexport default SkyAtmosphere;\n"]},"metadata":{},"sourceType":"module"}