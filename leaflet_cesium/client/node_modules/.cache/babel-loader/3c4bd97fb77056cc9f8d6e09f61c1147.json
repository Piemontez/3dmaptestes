{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport buildModuleUrl from \"../Core/buildModuleUrl.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport EllipsoidTerrainProvider from \"../Core/EllipsoidTerrainProvider.js\";\nimport Event from \"../Core/Event.js\";\nimport IntersectionTests from \"../Core/IntersectionTests.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport Ray from \"../Core/Ray.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Resource from \"../Core/Resource.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport GlobeFS from \"../Shaders/GlobeFS.js\";\nimport GlobeVS from \"../Shaders/GlobeVS.js\";\nimport GroundAtmosphere from \"../Shaders/GroundAtmosphere.js\";\nimport when from \"../ThirdParty/when.js\";\nimport GlobeSurfaceShaderSet from \"./GlobeSurfaceShaderSet.js\";\nimport GlobeSurfaceTileProvider from \"./GlobeSurfaceTileProvider.js\";\nimport GlobeTranslucency from \"./GlobeTranslucency.js\";\nimport ImageryLayerCollection from \"./ImageryLayerCollection.js\";\nimport QuadtreePrimitive from \"./QuadtreePrimitive.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\n/**\n * The globe rendered in the scene, including its terrain ({@link Globe#terrainProvider})\n * and imagery layers ({@link Globe#imageryLayers}).  Access the globe using {@link Scene#globe}.\n *\n * @alias Globe\n * @constructor\n *\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] Determines the size and shape of the\n * globe.\n */\n\nfunction Globe(ellipsoid) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  var terrainProvider = new EllipsoidTerrainProvider({\n    ellipsoid: ellipsoid\n  });\n  var imageryLayerCollection = new ImageryLayerCollection();\n  this._ellipsoid = ellipsoid;\n  this._imageryLayerCollection = imageryLayerCollection;\n  this._surfaceShaderSet = new GlobeSurfaceShaderSet();\n  this._material = undefined;\n  this._surface = new QuadtreePrimitive({\n    tileProvider: new GlobeSurfaceTileProvider({\n      terrainProvider: terrainProvider,\n      imageryLayers: imageryLayerCollection,\n      surfaceShaderSet: this._surfaceShaderSet\n    })\n  });\n  this._terrainProvider = terrainProvider;\n  this._terrainProviderChanged = new Event();\n  this._undergroundColor = Color.clone(Color.BLACK);\n  this._undergroundColorAlphaByDistance = new NearFarScalar(ellipsoid.maximumRadius / 1000.0, 0.0, ellipsoid.maximumRadius / 5.0, 1.0);\n  this._translucency = new GlobeTranslucency();\n  makeShadersDirty(this);\n  /**\n   * Determines if the globe will be shown.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.show = true;\n  this._oceanNormalMapResourceDirty = true;\n  this._oceanNormalMapResource = new Resource({\n    url: buildModuleUrl(\"Assets/Textures/waterNormalsSmall.jpg\")\n  });\n  /**\n   * The maximum screen-space error used to drive level-of-detail refinement.  Higher\n   * values will provide better performance but lower visual quality.\n   *\n   * @type {Number}\n   * @default 2\n   */\n\n  this.maximumScreenSpaceError = 2;\n  /**\n   * The size of the terrain tile cache, expressed as a number of tiles.  Any additional\n   * tiles beyond this number will be freed, as long as they aren't needed for rendering\n   * this frame.  A larger number will consume more memory but will show detail faster\n   * when, for example, zooming out and then back in.\n   *\n   * @type {Number}\n   * @default 100\n   */\n\n  this.tileCacheSize = 100;\n  /**\n   * Gets or sets the number of loading descendant tiles that is considered \"too many\".\n   * If a tile has too many loading descendants, that tile will be loaded and rendered before any of\n   * its descendants are loaded and rendered. This means more feedback for the user that something\n   * is happening at the cost of a longer overall load time. Setting this to 0 will cause each\n   * tile level to be loaded successively, significantly increasing load time. Setting it to a large\n   * number (e.g. 1000) will minimize the number of tiles that are loaded but tend to make\n   * detail appear all at once after a long wait.\n   * @type {Number}\n   * @default 20\n   */\n\n  this.loadingDescendantLimit = 20;\n  /**\n   * Gets or sets a value indicating whether the ancestors of rendered tiles should be preloaded.\n   * Setting this to true optimizes the zoom-out experience and provides more detail in\n   * newly-exposed areas when panning. The down side is that it requires loading more tiles.\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.preloadAncestors = true;\n  /**\n   * Gets or sets a value indicating whether the siblings of rendered tiles should be preloaded.\n   * Setting this to true causes tiles with the same parent as a rendered tile to be loaded, even\n   * if they are culled. Setting this to true may provide a better panning experience at the\n   * cost of loading more tiles.\n   * @type {Boolean}\n   * @default false\n   */\n\n  this.preloadSiblings = false;\n  /**\n   * The color to use to highlight terrain fill tiles. If undefined, fill tiles are not\n   * highlighted at all. The alpha value is used to alpha blend with the tile's\n   * actual color. Because terrain fill tiles do not represent the actual terrain surface,\n   * it may be useful in some applications to indicate visually that they are not to be trusted.\n   * @type {Color}\n   * @default undefined\n   */\n\n  this.fillHighlightColor = undefined;\n  /**\n   * Enable lighting the globe with the scene's light source.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n\n  this.enableLighting = false;\n  /**\n   * Enable dynamic lighting effects on atmosphere and fog. This only takes effect\n   * when <code>enableLighting</code> is <code>true</code>.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.dynamicAtmosphereLighting = true;\n  /**\n   * Whether dynamic atmosphere lighting uses the sun direction instead of the scene's\n   * light direction. This only takes effect when <code>enableLighting</code> and\n   * <code>dynamicAtmosphereLighting</code> are <code>true</code>.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n\n  this.dynamicAtmosphereLightingFromSun = false;\n  /**\n   * Enable the ground atmosphere, which is drawn over the globe when viewed from a distance between <code>lightingFadeInDistance</code> and <code>lightingFadeOutDistance</code>.\n   *\n   * @demo {@link https://sandcastle.cesium.com/index.html?src=Ground%20Atmosphere.html|Ground atmosphere demo in Sandcastle}\n   *\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.showGroundAtmosphere = true;\n  /**\n   * The distance where everything becomes lit. This only takes effect\n   * when <code>enableLighting</code> or <code>showGroundAtmosphere</code> is <code>true</code>.\n   *\n   * @type {Number}\n   * @default 10000000.0\n   */\n\n  this.lightingFadeOutDistance = 1.0e7;\n  /**\n   * The distance where lighting resumes. This only takes effect\n   * when <code>enableLighting</code> or <code>showGroundAtmosphere</code> is <code>true</code>.\n   *\n   * @type {Number}\n   * @default 20000000.0\n   */\n\n  this.lightingFadeInDistance = 2.0e7;\n  /**\n   * The distance where the darkness of night from the ground atmosphere fades out to a lit ground atmosphere.\n   * This only takes effect when <code>showGroundAtmosphere</code>, <code>enableLighting</code>, and\n   * <code>dynamicAtmosphereLighting</code> are <code>true</code>.\n   *\n   * @type {Number}\n   * @default 10000000.0\n   */\n\n  this.nightFadeOutDistance = 1.0e7;\n  /**\n   * The distance where the darkness of night from the ground atmosphere fades in to an unlit ground atmosphere.\n   * This only takes effect when <code>showGroundAtmosphere</code>, <code>enableLighting</code>, and\n   * <code>dynamicAtmosphereLighting</code> are <code>true</code>.\n   *\n   * @type {Number}\n   * @default 50000000.0\n   */\n\n  this.nightFadeInDistance = 5.0e7;\n  /**\n   * True if an animated wave effect should be shown in areas of the globe\n   * covered by water; otherwise, false.  This property is ignored if the\n   * <code>terrainProvider</code> does not provide a water mask.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.showWaterEffect = true;\n  /**\n   * True if primitives such as billboards, polylines, labels, etc. should be depth-tested\n   * against the terrain surface, or false if such primitives should always be drawn on top\n   * of terrain unless they're on the opposite side of the globe.  The disadvantage of depth\n   * testing primitives against terrain is that slight numerical noise or terrain level-of-detail\n   * switched can sometimes make a primitive that should be on the surface disappear underneath it.\n   *\n   * @type {Boolean}\n   * @default false\n   *\n   */\n\n  this.depthTestAgainstTerrain = false;\n  /**\n   * Determines whether the globe casts or receives shadows from light sources. Setting the globe\n   * to cast shadows may impact performance since the terrain is rendered again from the light's perspective.\n   * Currently only terrain that is in view casts shadows. By default the globe does not cast shadows.\n   *\n   * @type {ShadowMode}\n   * @default ShadowMode.RECEIVE_ONLY\n   */\n\n  this.shadows = ShadowMode.RECEIVE_ONLY;\n  /**\n   * The hue shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A hue shift of 1.0 indicates a complete rotation of the hues available.\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.atmosphereHueShift = 0.0;\n  /**\n   * The saturation shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A saturation shift of -1.0 is monochrome.\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.atmosphereSaturationShift = 0.0;\n  /**\n   * The brightness shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A brightness shift of -1.0 is complete darkness, which will let space show through.\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.atmosphereBrightnessShift = 0.0;\n  /**\n   * Whether to show terrain skirts. Terrain skirts are geometry extending downwards from a tile's edges used to hide seams between neighboring tiles.\n   * Skirts are always hidden when the camera is underground or translucency is enabled.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.showSkirts = true;\n  /**\n   * Whether to cull back-facing terrain. Back faces are not culled when the camera is underground or translucency is enabled.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n\n  this.backFaceCulling = true;\n  this._oceanNormalMap = undefined;\n  this._zoomedOutOceanSpecularIntensity = undefined;\n}\n\nObject.defineProperties(Globe.prototype, {\n  /**\n   * Gets an ellipsoid describing the shape of this globe.\n   * @memberof Globe.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    }\n  },\n\n  /**\n   * Gets the collection of image layers that will be rendered on this globe.\n   * @memberof Globe.prototype\n   * @type {ImageryLayerCollection}\n   */\n  imageryLayers: {\n    get: function () {\n      return this._imageryLayerCollection;\n    }\n  },\n\n  /**\n   * Gets an event that's raised when an imagery layer is added, shown, hidden, moved, or removed.\n   *\n   * @memberof Globe.prototype\n   * @type {Event}\n   * @readonly\n   */\n  imageryLayersUpdatedEvent: {\n    get: function () {\n      return this._surface.tileProvider.imageryLayersUpdatedEvent;\n    }\n  },\n\n  /**\n   * Returns <code>true</code> when the tile load queue is empty, <code>false</code> otherwise.  When the load queue is empty,\n   * all terrain and imagery for the current view have been loaded.\n   * @memberof Globe.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  tilesLoaded: {\n    get: function () {\n      if (!defined(this._surface)) {\n        return true;\n      }\n\n      return this._surface.tileProvider.ready && this._surface._tileLoadQueueHigh.length === 0 && this._surface._tileLoadQueueMedium.length === 0 && this._surface._tileLoadQueueLow.length === 0;\n    }\n  },\n\n  /**\n   * Gets or sets the color of the globe when no imagery is available.\n   * @memberof Globe.prototype\n   * @type {Color}\n   */\n  baseColor: {\n    get: function () {\n      return this._surface.tileProvider.baseColor;\n    },\n    set: function (value) {\n      this._surface.tileProvider.baseColor = value;\n    }\n  },\n\n  /**\n   * A property specifying a {@link ClippingPlaneCollection} used to selectively disable rendering on the outside of each plane.\n   *\n   * @memberof Globe.prototype\n   * @type {ClippingPlaneCollection}\n   */\n  clippingPlanes: {\n    get: function () {\n      return this._surface.tileProvider.clippingPlanes;\n    },\n    set: function (value) {\n      this._surface.tileProvider.clippingPlanes = value;\n    }\n  },\n\n  /**\n   * A property specifying a {@link Rectangle} used to limit globe rendering to a cartographic area.\n   * Defaults to the maximum extent of cartographic coordinates.\n   *\n   * @memberof Globe.prototype\n   * @type {Rectangle}\n   * @default {@link Rectangle.MAX_VALUE}\n   */\n  cartographicLimitRectangle: {\n    get: function () {\n      return this._surface.tileProvider.cartographicLimitRectangle;\n    },\n    set: function (value) {\n      if (!defined(value)) {\n        value = Rectangle.clone(Rectangle.MAX_VALUE);\n      }\n\n      this._surface.tileProvider.cartographicLimitRectangle = value;\n    }\n  },\n\n  /**\n   * The normal map to use for rendering waves in the ocean.  Setting this property will\n   * only have an effect if the configured terrain provider includes a water mask.\n   * @memberof Globe.prototype\n   * @type {String}\n   * @default buildModuleUrl('Assets/Textures/waterNormalsSmall.jpg')\n   */\n  oceanNormalMapUrl: {\n    get: function () {\n      return this._oceanNormalMapResource.url;\n    },\n    set: function (value) {\n      this._oceanNormalMapResource.url = value;\n      this._oceanNormalMapResourceDirty = true;\n    }\n  },\n\n  /**\n   * The terrain provider providing surface geometry for this globe.\n   * @type {TerrainProvider}\n   *\n   * @memberof Globe.prototype\n   * @type {TerrainProvider}\n   *\n   */\n  terrainProvider: {\n    get: function () {\n      return this._terrainProvider;\n    },\n    set: function (value) {\n      if (value !== this._terrainProvider) {\n        this._terrainProvider = value;\n\n        this._terrainProviderChanged.raiseEvent(value);\n\n        if (defined(this._material)) {\n          makeShadersDirty(this);\n        }\n      }\n    }\n  },\n\n  /**\n   * Gets an event that's raised when the terrain provider is changed\n   *\n   * @memberof Globe.prototype\n   * @type {Event}\n   * @readonly\n   */\n  terrainProviderChanged: {\n    get: function () {\n      return this._terrainProviderChanged;\n    }\n  },\n\n  /**\n   * Gets an event that's raised when the length of the tile load queue has changed since the last render frame.  When the load queue is empty,\n   * all terrain and imagery for the current view have been loaded.  The event passes the new length of the tile load queue.\n   *\n   * @memberof Globe.prototype\n   * @type {Event}\n   */\n  tileLoadProgressEvent: {\n    get: function () {\n      return this._surface.tileLoadProgressEvent;\n    }\n  },\n\n  /**\n   * Gets or sets the material appearance of the Globe.  This can be one of several built-in {@link Material} objects or a custom material, scripted with\n   * {@link https://github.com/CesiumGS/cesium/wiki/Fabric|Fabric}.\n   * @memberof Globe.prototype\n   * @type {Material}\n   */\n  material: {\n    get: function () {\n      return this._material;\n    },\n    set: function (material) {\n      if (this._material !== material) {\n        this._material = material;\n        makeShadersDirty(this);\n      }\n    }\n  },\n\n  /**\n   * The color to render the back side of the globe when the camera is underground or the globe is translucent,\n   * blended with the globe color based on the camera's distance.\n   * <br /><br />\n   * To disable underground coloring, set <code>undergroundColor</code> to <code>undefined</code>.\n   *\n   * @memberof Globe.prototype\n   * @type {Color}\n   * @default {@link Color.BLACK}\n   *\n   * @see Globe#undergroundColorAlphaByDistance\n   */\n  undergroundColor: {\n    get: function () {\n      return this._undergroundColor;\n    },\n    set: function (value) {\n      this._undergroundColor = Color.clone(value, this._undergroundColor);\n    }\n  },\n\n  /**\n   * Gets or sets the near and far distance for blending {@link Globe#undergroundColor} with the globe color.\n   * The alpha will interpolate between the {@link NearFarScalar#nearValue} and\n   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds\n   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.\n   * Outside of these ranges the alpha remains clamped to the nearest bound. If undefined,\n   * the underground color will not be blended with the globe color.\n   * <br /> <br />\n   * When the camera is above the ellipsoid the distance is computed from the nearest\n   * point on the ellipsoid instead of the camera's position.\n   *\n   * @memberof Globe.prototype\n   * @type {NearFarScalar}\n   *\n   * @see Globe#undergroundColor\n   *\n   */\n  undergroundColorAlphaByDistance: {\n    get: function () {\n      return this._undergroundColorAlphaByDistance;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value.far < value.near) {\n        throw new DeveloperError(\"far distance must be greater than near distance.\");\n      } //>>includeEnd('debug');\n\n\n      this._undergroundColorAlphaByDistance = NearFarScalar.clone(value, this._undergroundColorAlphaByDistance);\n    }\n  },\n\n  /**\n   * Properties for controlling globe translucency.\n   *\n   * @memberof Globe.prototype\n   * @type {GlobeTranslucency}\n   */\n  translucency: {\n    get: function () {\n      return this._translucency;\n    }\n  }\n});\n\nfunction makeShadersDirty(globe) {\n  var defines = [];\n\n  var requireNormals = defined(globe._material) && (globe._material.shaderSource.match(/slope/) || globe._material.shaderSource.match(\"normalEC\"));\n\n  var fragmentSources = [GroundAtmosphere];\n\n  if (defined(globe._material) && (!requireNormals || globe._terrainProvider.requestVertexNormals)) {\n    fragmentSources.push(globe._material.shaderSource);\n    defines.push(\"APPLY_MATERIAL\");\n    globe._surface._tileProvider.materialUniformMap = globe._material._uniforms;\n  } else {\n    globe._surface._tileProvider.materialUniformMap = undefined;\n  }\n\n  fragmentSources.push(GlobeFS);\n  globe._surfaceShaderSet.baseVertexShaderSource = new ShaderSource({\n    sources: [GroundAtmosphere, GlobeVS],\n    defines: defines\n  });\n  globe._surfaceShaderSet.baseFragmentShaderSource = new ShaderSource({\n    sources: fragmentSources,\n    defines: defines\n  });\n  globe._surfaceShaderSet.material = globe._material;\n}\n\nfunction createComparePickTileFunction(rayOrigin) {\n  return function (a, b) {\n    var aDist = BoundingSphere.distanceSquaredTo(a.pickBoundingSphere, rayOrigin);\n    var bDist = BoundingSphere.distanceSquaredTo(b.pickBoundingSphere, rayOrigin);\n    return aDist - bDist;\n  };\n}\n\nvar scratchArray = [];\nvar scratchSphereIntersectionResult = {\n  start: 0.0,\n  stop: 0.0\n};\n/**\n * Find an intersection between a ray and the globe surface that was rendered. The ray must be given in world coordinates.\n *\n * @param {Ray} ray The ray to test for intersection.\n * @param {Scene} scene The scene.\n * @param {Boolean} [cullBackFaces=true] Set to true to not pick back faces.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3|undefined} The intersection or <code>undefined</code> if none was found.  The returned position is in projected coordinates for 2D and Columbus View.\n *\n * @private\n */\n\nGlobe.prototype.pickWorldCoordinates = function (ray, scene, cullBackFaces, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required\");\n  }\n\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required\");\n  } //>>includeEnd('debug');\n\n\n  cullBackFaces = defaultValue(cullBackFaces, true);\n  var mode = scene.mode;\n  var projection = scene.mapProjection;\n  var sphereIntersections = scratchArray;\n  sphereIntersections.length = 0;\n  var tilesToRender = this._surface._tilesToRender;\n  var length = tilesToRender.length;\n  var tile;\n  var i;\n\n  for (i = 0; i < length; ++i) {\n    tile = tilesToRender[i];\n    var surfaceTile = tile.data;\n\n    if (!defined(surfaceTile)) {\n      continue;\n    }\n\n    var boundingVolume = surfaceTile.pickBoundingSphere;\n\n    if (mode !== SceneMode.SCENE3D) {\n      surfaceTile.pickBoundingSphere = boundingVolume = BoundingSphere.fromRectangleWithHeights2D(tile.rectangle, projection, surfaceTile.tileBoundingRegion.minimumHeight, surfaceTile.tileBoundingRegion.maximumHeight, boundingVolume);\n      Cartesian3.fromElements(boundingVolume.center.z, boundingVolume.center.x, boundingVolume.center.y, boundingVolume.center);\n    } else if (defined(surfaceTile.renderedMesh)) {\n      BoundingSphere.clone(surfaceTile.renderedMesh.boundingSphere3D, boundingVolume);\n    } else {\n      // So wait how did we render this thing then? It shouldn't be possible to get here.\n      continue;\n    }\n\n    var boundingSphereIntersection = IntersectionTests.raySphere(ray, boundingVolume, scratchSphereIntersectionResult);\n\n    if (defined(boundingSphereIntersection)) {\n      sphereIntersections.push(surfaceTile);\n    }\n  }\n\n  sphereIntersections.sort(createComparePickTileFunction(ray.origin));\n  var intersection;\n  length = sphereIntersections.length;\n\n  for (i = 0; i < length; ++i) {\n    intersection = sphereIntersections[i].pick(ray, scene.mode, scene.mapProjection, cullBackFaces, result);\n\n    if (defined(intersection)) {\n      break;\n    }\n  }\n\n  return intersection;\n};\n\nvar cartoScratch = new Cartographic();\n/**\n * Find an intersection between a ray and the globe surface that was rendered. The ray must be given in world coordinates.\n *\n * @param {Ray} ray The ray to test for intersection.\n * @param {Scene} scene The scene.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3|undefined} The intersection or <code>undefined</code> if none was found.\n *\n * @example\n * // find intersection of ray through a pixel and the globe\n * var ray = viewer.camera.getPickRay(windowCoordinates);\n * var intersection = globe.pick(ray, scene);\n */\n\nGlobe.prototype.pick = function (ray, scene, result) {\n  result = this.pickWorldCoordinates(ray, scene, true, result);\n\n  if (defined(result) && scene.mode !== SceneMode.SCENE3D) {\n    result = Cartesian3.fromElements(result.y, result.z, result.x, result);\n    var carto = scene.mapProjection.unproject(result, cartoScratch);\n    result = scene.globe.ellipsoid.cartographicToCartesian(carto, result);\n  }\n\n  return result;\n};\n\nvar scratchGetHeightCartesian = new Cartesian3();\nvar scratchGetHeightIntersection = new Cartesian3();\nvar scratchGetHeightCartographic = new Cartographic();\nvar scratchGetHeightRay = new Ray();\n\nfunction tileIfContainsCartographic(tile, cartographic) {\n  return defined(tile) && Rectangle.contains(tile.rectangle, cartographic) ? tile : undefined;\n}\n/**\n * Get the height of the surface at a given cartographic.\n *\n * @param {Cartographic} cartographic The cartographic for which to find the height.\n * @returns {Number|undefined} The height of the cartographic or undefined if it could not be found.\n */\n\n\nGlobe.prototype.getHeight = function (cartographic) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartographic)) {\n    throw new DeveloperError(\"cartographic is required\");\n  } //>>includeEnd('debug');\n\n\n  var levelZeroTiles = this._surface._levelZeroTiles;\n\n  if (!defined(levelZeroTiles)) {\n    return;\n  }\n\n  var tile;\n  var i;\n  var length = levelZeroTiles.length;\n\n  for (i = 0; i < length; ++i) {\n    tile = levelZeroTiles[i];\n\n    if (Rectangle.contains(tile.rectangle, cartographic)) {\n      break;\n    }\n  }\n\n  if (i >= length) {\n    return undefined;\n  }\n\n  var tileWithMesh = tile;\n\n  while (defined(tile)) {\n    tile = tileIfContainsCartographic(tile._southwestChild, cartographic) || tileIfContainsCartographic(tile._southeastChild, cartographic) || tileIfContainsCartographic(tile._northwestChild, cartographic) || tile._northeastChild;\n\n    if (defined(tile) && defined(tile.data) && defined(tile.data.renderedMesh)) {\n      tileWithMesh = tile;\n    }\n  }\n\n  tile = tileWithMesh; // This tile was either rendered or culled.\n  // It is sometimes useful to get a height from a culled tile,\n  // e.g. when we're getting a height in order to place a billboard\n  // on terrain, and the camera is looking at that same billboard.\n  // The culled tile must have a valid mesh, though.\n\n  if (!defined(tile) || !defined(tile.data) || !defined(tile.data.renderedMesh)) {\n    // Tile was not rendered (culled).\n    return undefined;\n  }\n\n  var ellipsoid = this._surface._tileProvider.tilingScheme.ellipsoid; //cartesian has to be on the ellipsoid surface for `ellipsoid.geodeticSurfaceNormal`\n\n  var cartesian = Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, 0.0, ellipsoid, scratchGetHeightCartesian);\n  var ray = scratchGetHeightRay;\n  var surfaceNormal = ellipsoid.geodeticSurfaceNormal(cartesian, ray.direction); // Try to find the intersection point between the surface normal and z-axis.\n  // minimum height (-11500.0) for the terrain set, need to get this information from the terrain provider\n\n  var rayOrigin = ellipsoid.getSurfaceNormalIntersectionWithZAxis(cartesian, 11500.0, ray.origin); // Theoretically, not with Earth datums, the intersection point can be outside the ellipsoid\n\n  if (!defined(rayOrigin)) {\n    // intersection point is outside the ellipsoid, try other value\n    // minimum height (-11500.0) for the terrain set, need to get this information from the terrain provider\n    var minimumHeight;\n\n    if (defined(tile.data.tileBoundingRegion)) {\n      minimumHeight = tile.data.tileBoundingRegion.minimumHeight;\n    }\n\n    var magnitude = Math.min(defaultValue(minimumHeight, 0.0), -11500.0); // multiply by the *positive* value of the magnitude\n\n    var vectorToMinimumPoint = Cartesian3.multiplyByScalar(surfaceNormal, Math.abs(magnitude) + 1, scratchGetHeightIntersection);\n    Cartesian3.subtract(cartesian, vectorToMinimumPoint, ray.origin);\n  }\n\n  var intersection = tile.data.pick(ray, undefined, undefined, false, scratchGetHeightIntersection);\n\n  if (!defined(intersection)) {\n    return undefined;\n  }\n\n  return ellipsoid.cartesianToCartographic(intersection, scratchGetHeightCartographic).height;\n};\n/**\n * @private\n */\n\n\nGlobe.prototype.update = function (frameState) {\n  if (!this.show) {\n    return;\n  }\n\n  if (frameState.passes.render) {\n    this._surface.update(frameState);\n  }\n};\n/**\n * @private\n */\n\n\nGlobe.prototype.beginFrame = function (frameState) {\n  var surface = this._surface;\n  var tileProvider = surface.tileProvider;\n  var terrainProvider = this.terrainProvider;\n  var hasWaterMask = this.showWaterEffect && terrainProvider.ready && terrainProvider.hasWaterMask;\n\n  if (hasWaterMask && this._oceanNormalMapResourceDirty) {\n    // url changed, load new normal map asynchronously\n    this._oceanNormalMapResourceDirty = false;\n    var oceanNormalMapResource = this._oceanNormalMapResource;\n    var oceanNormalMapUrl = oceanNormalMapResource.url;\n\n    if (defined(oceanNormalMapUrl)) {\n      var that = this;\n      when(oceanNormalMapResource.fetchImage(), function (image) {\n        if (oceanNormalMapUrl !== that._oceanNormalMapResource.url) {\n          // url changed while we were loading\n          return;\n        }\n\n        that._oceanNormalMap = that._oceanNormalMap && that._oceanNormalMap.destroy();\n        that._oceanNormalMap = new Texture({\n          context: frameState.context,\n          source: image\n        });\n      });\n    } else {\n      this._oceanNormalMap = this._oceanNormalMap && this._oceanNormalMap.destroy();\n    }\n  }\n\n  var pass = frameState.passes;\n  var mode = frameState.mode;\n\n  if (pass.render) {\n    if (this.showGroundAtmosphere) {\n      this._zoomedOutOceanSpecularIntensity = 0.4;\n    } else {\n      this._zoomedOutOceanSpecularIntensity = 0.5;\n    }\n\n    surface.maximumScreenSpaceError = this.maximumScreenSpaceError;\n    surface.tileCacheSize = this.tileCacheSize;\n    surface.loadingDescendantLimit = this.loadingDescendantLimit;\n    surface.preloadAncestors = this.preloadAncestors;\n    surface.preloadSiblings = this.preloadSiblings;\n    tileProvider.terrainProvider = this.terrainProvider;\n    tileProvider.lightingFadeOutDistance = this.lightingFadeOutDistance;\n    tileProvider.lightingFadeInDistance = this.lightingFadeInDistance;\n    tileProvider.nightFadeOutDistance = this.nightFadeOutDistance;\n    tileProvider.nightFadeInDistance = this.nightFadeInDistance;\n    tileProvider.zoomedOutOceanSpecularIntensity = mode === SceneMode.SCENE3D ? this._zoomedOutOceanSpecularIntensity : 0.0;\n    tileProvider.hasWaterMask = hasWaterMask;\n    tileProvider.oceanNormalMap = this._oceanNormalMap;\n    tileProvider.enableLighting = this.enableLighting;\n    tileProvider.dynamicAtmosphereLighting = this.dynamicAtmosphereLighting;\n    tileProvider.dynamicAtmosphereLightingFromSun = this.dynamicAtmosphereLightingFromSun;\n    tileProvider.showGroundAtmosphere = this.showGroundAtmosphere;\n    tileProvider.shadows = this.shadows;\n    tileProvider.hueShift = this.atmosphereHueShift;\n    tileProvider.saturationShift = this.atmosphereSaturationShift;\n    tileProvider.brightnessShift = this.atmosphereBrightnessShift;\n    tileProvider.fillHighlightColor = this.fillHighlightColor;\n    tileProvider.showSkirts = this.showSkirts;\n    tileProvider.backFaceCulling = this.backFaceCulling;\n    tileProvider.undergroundColor = this._undergroundColor;\n    tileProvider.undergroundColorAlphaByDistance = this._undergroundColorAlphaByDistance;\n    surface.beginFrame(frameState);\n  }\n};\n/**\n * @private\n */\n\n\nGlobe.prototype.render = function (frameState) {\n  if (!this.show) {\n    return;\n  }\n\n  if (defined(this._material)) {\n    this._material.update(frameState.context);\n  }\n\n  this._surface.render(frameState);\n};\n/**\n * @private\n */\n\n\nGlobe.prototype.endFrame = function (frameState) {\n  if (!this.show) {\n    return;\n  }\n\n  if (frameState.passes.render) {\n    this._surface.endFrame(frameState);\n  }\n};\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n *\n * @see Globe#destroy\n */\n\n\nGlobe.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * globe = globe && globe.destroy();\n *\n * @see Globe#isDestroyed\n */\n\n\nGlobe.prototype.destroy = function () {\n  this._surfaceShaderSet = this._surfaceShaderSet && this._surfaceShaderSet.destroy();\n  this._surface = this._surface && this._surface.destroy();\n  this._oceanNormalMap = this._oceanNormalMap && this._oceanNormalMap.destroy();\n  return destroyObject(this);\n};\n\nexport default Globe;","map":{"version":3,"sources":["/home/usuario/davi/thalamus/wms/3dmaptestes/leaflet_cesium/client/node_modules/cesium/Source/Scene/Globe.js"],"names":["BoundingSphere","buildModuleUrl","Cartesian3","Cartographic","Color","defaultValue","defined","destroyObject","DeveloperError","Ellipsoid","EllipsoidTerrainProvider","Event","IntersectionTests","NearFarScalar","Ray","Rectangle","Resource","ShaderSource","Texture","GlobeFS","GlobeVS","GroundAtmosphere","when","GlobeSurfaceShaderSet","GlobeSurfaceTileProvider","GlobeTranslucency","ImageryLayerCollection","QuadtreePrimitive","SceneMode","ShadowMode","Globe","ellipsoid","WGS84","terrainProvider","imageryLayerCollection","_ellipsoid","_imageryLayerCollection","_surfaceShaderSet","_material","undefined","_surface","tileProvider","imageryLayers","surfaceShaderSet","_terrainProvider","_terrainProviderChanged","_undergroundColor","clone","BLACK","_undergroundColorAlphaByDistance","maximumRadius","_translucency","makeShadersDirty","show","_oceanNormalMapResourceDirty","_oceanNormalMapResource","url","maximumScreenSpaceError","tileCacheSize","loadingDescendantLimit","preloadAncestors","preloadSiblings","fillHighlightColor","enableLighting","dynamicAtmosphereLighting","dynamicAtmosphereLightingFromSun","showGroundAtmosphere","lightingFadeOutDistance","lightingFadeInDistance","nightFadeOutDistance","nightFadeInDistance","showWaterEffect","depthTestAgainstTerrain","shadows","RECEIVE_ONLY","atmosphereHueShift","atmosphereSaturationShift","atmosphereBrightnessShift","showSkirts","backFaceCulling","_oceanNormalMap","_zoomedOutOceanSpecularIntensity","Object","defineProperties","prototype","get","imageryLayersUpdatedEvent","tilesLoaded","ready","_tileLoadQueueHigh","length","_tileLoadQueueMedium","_tileLoadQueueLow","baseColor","set","value","clippingPlanes","cartographicLimitRectangle","MAX_VALUE","oceanNormalMapUrl","raiseEvent","terrainProviderChanged","tileLoadProgressEvent","material","undergroundColor","undergroundColorAlphaByDistance","far","near","translucency","globe","defines","requireNormals","shaderSource","match","fragmentSources","requestVertexNormals","push","_tileProvider","materialUniformMap","_uniforms","baseVertexShaderSource","sources","baseFragmentShaderSource","createComparePickTileFunction","rayOrigin","a","b","aDist","distanceSquaredTo","pickBoundingSphere","bDist","scratchArray","scratchSphereIntersectionResult","start","stop","pickWorldCoordinates","ray","scene","cullBackFaces","result","mode","projection","mapProjection","sphereIntersections","tilesToRender","_tilesToRender","tile","i","surfaceTile","data","boundingVolume","SCENE3D","fromRectangleWithHeights2D","rectangle","tileBoundingRegion","minimumHeight","maximumHeight","fromElements","center","z","x","y","renderedMesh","boundingSphere3D","boundingSphereIntersection","raySphere","sort","origin","intersection","pick","cartoScratch","carto","unproject","cartographicToCartesian","scratchGetHeightCartesian","scratchGetHeightIntersection","scratchGetHeightCartographic","scratchGetHeightRay","tileIfContainsCartographic","cartographic","contains","getHeight","levelZeroTiles","_levelZeroTiles","tileWithMesh","_southwestChild","_southeastChild","_northwestChild","_northeastChild","tilingScheme","cartesian","fromRadians","longitude","latitude","surfaceNormal","geodeticSurfaceNormal","direction","getSurfaceNormalIntersectionWithZAxis","magnitude","Math","min","vectorToMinimumPoint","multiplyByScalar","abs","subtract","cartesianToCartographic","height","update","frameState","passes","render","beginFrame","surface","hasWaterMask","oceanNormalMapResource","that","fetchImage","image","destroy","context","source","pass","zoomedOutOceanSpecularIntensity","oceanNormalMap","hueShift","saturationShift","brightnessShift","endFrame","isDestroyed"],"mappings":"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;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,kBAAL,GAA0BvB,SAA1B;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKwB,cAAL,GAAsB,KAAtB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,yBAAL,GAAiC,IAAjC;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,gCAAL,GAAwC,KAAxC;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,oBAAL,GAA4B,IAA5B;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,uBAAL,GAA+B,KAA/B;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,sBAAL,GAA8B,KAA9B;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,oBAAL,GAA4B,KAA5B;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,mBAAL,GAA2B,KAA3B;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,eAAL,GAAuB,IAAvB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,uBAAL,GAA+B,KAA/B;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,OAAL,GAAe5C,UAAU,CAAC6C,YAA1B;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,kBAAL,GAA0B,GAA1B;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,yBAAL,GAAiC,GAAjC;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,yBAAL,GAAiC,GAAjC;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,UAAL,GAAkB,IAAlB;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,OAAKC,eAAL,GAAuB,IAAvB;AAEA,OAAKC,eAAL,GAAuBzC,SAAvB;AACA,OAAK0C,gCAAL,GAAwC1C,SA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","sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport buildModuleUrl from \"../Core/buildModuleUrl.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport EllipsoidTerrainProvider from \"../Core/EllipsoidTerrainProvider.js\";\nimport Event from \"../Core/Event.js\";\nimport IntersectionTests from \"../Core/IntersectionTests.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport Ray from \"../Core/Ray.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Resource from \"../Core/Resource.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport Texture from \"../Renderer/Texture.js\";\nimport GlobeFS from \"../Shaders/GlobeFS.js\";\nimport GlobeVS from \"../Shaders/GlobeVS.js\";\nimport GroundAtmosphere from \"../Shaders/GroundAtmosphere.js\";\nimport when from \"../ThirdParty/when.js\";\nimport GlobeSurfaceShaderSet from \"./GlobeSurfaceShaderSet.js\";\nimport GlobeSurfaceTileProvider from \"./GlobeSurfaceTileProvider.js\";\nimport GlobeTranslucency from \"./GlobeTranslucency.js\";\nimport ImageryLayerCollection from \"./ImageryLayerCollection.js\";\nimport QuadtreePrimitive from \"./QuadtreePrimitive.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\n\n/**\n * The globe rendered in the scene, including its terrain ({@link Globe#terrainProvider})\n * and imagery layers ({@link Globe#imageryLayers}).  Access the globe using {@link Scene#globe}.\n *\n * @alias Globe\n * @constructor\n *\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] Determines the size and shape of the\n * globe.\n */\nfunction Globe(ellipsoid) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  var terrainProvider = new EllipsoidTerrainProvider({\n    ellipsoid: ellipsoid,\n  });\n  var imageryLayerCollection = new ImageryLayerCollection();\n\n  this._ellipsoid = ellipsoid;\n  this._imageryLayerCollection = imageryLayerCollection;\n\n  this._surfaceShaderSet = new GlobeSurfaceShaderSet();\n  this._material = undefined;\n\n  this._surface = new QuadtreePrimitive({\n    tileProvider: new GlobeSurfaceTileProvider({\n      terrainProvider: terrainProvider,\n      imageryLayers: imageryLayerCollection,\n      surfaceShaderSet: this._surfaceShaderSet,\n    }),\n  });\n\n  this._terrainProvider = terrainProvider;\n  this._terrainProviderChanged = new Event();\n\n  this._undergroundColor = Color.clone(Color.BLACK);\n  this._undergroundColorAlphaByDistance = new NearFarScalar(\n    ellipsoid.maximumRadius / 1000.0,\n    0.0,\n    ellipsoid.maximumRadius / 5.0,\n    1.0\n  );\n\n  this._translucency = new GlobeTranslucency();\n\n  makeShadersDirty(this);\n\n  /**\n   * Determines if the globe will be shown.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.show = true;\n\n  this._oceanNormalMapResourceDirty = true;\n  this._oceanNormalMapResource = new Resource({\n    url: buildModuleUrl(\"Assets/Textures/waterNormalsSmall.jpg\"),\n  });\n\n  /**\n   * The maximum screen-space error used to drive level-of-detail refinement.  Higher\n   * values will provide better performance but lower visual quality.\n   *\n   * @type {Number}\n   * @default 2\n   */\n  this.maximumScreenSpaceError = 2;\n\n  /**\n   * The size of the terrain tile cache, expressed as a number of tiles.  Any additional\n   * tiles beyond this number will be freed, as long as they aren't needed for rendering\n   * this frame.  A larger number will consume more memory but will show detail faster\n   * when, for example, zooming out and then back in.\n   *\n   * @type {Number}\n   * @default 100\n   */\n  this.tileCacheSize = 100;\n\n  /**\n   * Gets or sets the number of loading descendant tiles that is considered \"too many\".\n   * If a tile has too many loading descendants, that tile will be loaded and rendered before any of\n   * its descendants are loaded and rendered. This means more feedback for the user that something\n   * is happening at the cost of a longer overall load time. Setting this to 0 will cause each\n   * tile level to be loaded successively, significantly increasing load time. Setting it to a large\n   * number (e.g. 1000) will minimize the number of tiles that are loaded but tend to make\n   * detail appear all at once after a long wait.\n   * @type {Number}\n   * @default 20\n   */\n  this.loadingDescendantLimit = 20;\n\n  /**\n   * Gets or sets a value indicating whether the ancestors of rendered tiles should be preloaded.\n   * Setting this to true optimizes the zoom-out experience and provides more detail in\n   * newly-exposed areas when panning. The down side is that it requires loading more tiles.\n   * @type {Boolean}\n   * @default true\n   */\n  this.preloadAncestors = true;\n\n  /**\n   * Gets or sets a value indicating whether the siblings of rendered tiles should be preloaded.\n   * Setting this to true causes tiles with the same parent as a rendered tile to be loaded, even\n   * if they are culled. Setting this to true may provide a better panning experience at the\n   * cost of loading more tiles.\n   * @type {Boolean}\n   * @default false\n   */\n  this.preloadSiblings = false;\n\n  /**\n   * The color to use to highlight terrain fill tiles. If undefined, fill tiles are not\n   * highlighted at all. The alpha value is used to alpha blend with the tile's\n   * actual color. Because terrain fill tiles do not represent the actual terrain surface,\n   * it may be useful in some applications to indicate visually that they are not to be trusted.\n   * @type {Color}\n   * @default undefined\n   */\n  this.fillHighlightColor = undefined;\n\n  /**\n   * Enable lighting the globe with the scene's light source.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  this.enableLighting = false;\n\n  /**\n   * Enable dynamic lighting effects on atmosphere and fog. This only takes effect\n   * when <code>enableLighting</code> is <code>true</code>.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.dynamicAtmosphereLighting = true;\n\n  /**\n   * Whether dynamic atmosphere lighting uses the sun direction instead of the scene's\n   * light direction. This only takes effect when <code>enableLighting</code> and\n   * <code>dynamicAtmosphereLighting</code> are <code>true</code>.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  this.dynamicAtmosphereLightingFromSun = false;\n\n  /**\n   * Enable the ground atmosphere, which is drawn over the globe when viewed from a distance between <code>lightingFadeInDistance</code> and <code>lightingFadeOutDistance</code>.\n   *\n   * @demo {@link https://sandcastle.cesium.com/index.html?src=Ground%20Atmosphere.html|Ground atmosphere demo in Sandcastle}\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.showGroundAtmosphere = true;\n\n  /**\n   * The distance where everything becomes lit. This only takes effect\n   * when <code>enableLighting</code> or <code>showGroundAtmosphere</code> is <code>true</code>.\n   *\n   * @type {Number}\n   * @default 10000000.0\n   */\n  this.lightingFadeOutDistance = 1.0e7;\n\n  /**\n   * The distance where lighting resumes. This only takes effect\n   * when <code>enableLighting</code> or <code>showGroundAtmosphere</code> is <code>true</code>.\n   *\n   * @type {Number}\n   * @default 20000000.0\n   */\n  this.lightingFadeInDistance = 2.0e7;\n\n  /**\n   * The distance where the darkness of night from the ground atmosphere fades out to a lit ground atmosphere.\n   * This only takes effect when <code>showGroundAtmosphere</code>, <code>enableLighting</code>, and\n   * <code>dynamicAtmosphereLighting</code> are <code>true</code>.\n   *\n   * @type {Number}\n   * @default 10000000.0\n   */\n  this.nightFadeOutDistance = 1.0e7;\n\n  /**\n   * The distance where the darkness of night from the ground atmosphere fades in to an unlit ground atmosphere.\n   * This only takes effect when <code>showGroundAtmosphere</code>, <code>enableLighting</code>, and\n   * <code>dynamicAtmosphereLighting</code> are <code>true</code>.\n   *\n   * @type {Number}\n   * @default 50000000.0\n   */\n  this.nightFadeInDistance = 5.0e7;\n\n  /**\n   * True if an animated wave effect should be shown in areas of the globe\n   * covered by water; otherwise, false.  This property is ignored if the\n   * <code>terrainProvider</code> does not provide a water mask.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.showWaterEffect = true;\n\n  /**\n   * True if primitives such as billboards, polylines, labels, etc. should be depth-tested\n   * against the terrain surface, or false if such primitives should always be drawn on top\n   * of terrain unless they're on the opposite side of the globe.  The disadvantage of depth\n   * testing primitives against terrain is that slight numerical noise or terrain level-of-detail\n   * switched can sometimes make a primitive that should be on the surface disappear underneath it.\n   *\n   * @type {Boolean}\n   * @default false\n   *\n   */\n  this.depthTestAgainstTerrain = false;\n\n  /**\n   * Determines whether the globe casts or receives shadows from light sources. Setting the globe\n   * to cast shadows may impact performance since the terrain is rendered again from the light's perspective.\n   * Currently only terrain that is in view casts shadows. By default the globe does not cast shadows.\n   *\n   * @type {ShadowMode}\n   * @default ShadowMode.RECEIVE_ONLY\n   */\n  this.shadows = ShadowMode.RECEIVE_ONLY;\n\n  /**\n   * The hue shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A hue shift of 1.0 indicates a complete rotation of the hues available.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.atmosphereHueShift = 0.0;\n\n  /**\n   * The saturation shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A saturation shift of -1.0 is monochrome.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.atmosphereSaturationShift = 0.0;\n\n  /**\n   * The brightness shift to apply to the atmosphere. Defaults to 0.0 (no shift).\n   * A brightness shift of -1.0 is complete darkness, which will let space show through.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.atmosphereBrightnessShift = 0.0;\n\n  /**\n   * Whether to show terrain skirts. Terrain skirts are geometry extending downwards from a tile's edges used to hide seams between neighboring tiles.\n   * Skirts are always hidden when the camera is underground or translucency is enabled.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.showSkirts = true;\n\n  /**\n   * Whether to cull back-facing terrain. Back faces are not culled when the camera is underground or translucency is enabled.\n   *\n   * @type {Boolean}\n   * @default true\n   */\n  this.backFaceCulling = true;\n\n  this._oceanNormalMap = undefined;\n  this._zoomedOutOceanSpecularIntensity = undefined;\n}\n\nObject.defineProperties(Globe.prototype, {\n  /**\n   * Gets an ellipsoid describing the shape of this globe.\n   * @memberof Globe.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return this._ellipsoid;\n    },\n  },\n  /**\n   * Gets the collection of image layers that will be rendered on this globe.\n   * @memberof Globe.prototype\n   * @type {ImageryLayerCollection}\n   */\n  imageryLayers: {\n    get: function () {\n      return this._imageryLayerCollection;\n    },\n  },\n  /**\n   * Gets an event that's raised when an imagery layer is added, shown, hidden, moved, or removed.\n   *\n   * @memberof Globe.prototype\n   * @type {Event}\n   * @readonly\n   */\n  imageryLayersUpdatedEvent: {\n    get: function () {\n      return this._surface.tileProvider.imageryLayersUpdatedEvent;\n    },\n  },\n  /**\n   * Returns <code>true</code> when the tile load queue is empty, <code>false</code> otherwise.  When the load queue is empty,\n   * all terrain and imagery for the current view have been loaded.\n   * @memberof Globe.prototype\n   * @type {Boolean}\n   * @readonly\n   */\n  tilesLoaded: {\n    get: function () {\n      if (!defined(this._surface)) {\n        return true;\n      }\n      return (\n        this._surface.tileProvider.ready &&\n        this._surface._tileLoadQueueHigh.length === 0 &&\n        this._surface._tileLoadQueueMedium.length === 0 &&\n        this._surface._tileLoadQueueLow.length === 0\n      );\n    },\n  },\n  /**\n   * Gets or sets the color of the globe when no imagery is available.\n   * @memberof Globe.prototype\n   * @type {Color}\n   */\n  baseColor: {\n    get: function () {\n      return this._surface.tileProvider.baseColor;\n    },\n    set: function (value) {\n      this._surface.tileProvider.baseColor = value;\n    },\n  },\n  /**\n   * A property specifying a {@link ClippingPlaneCollection} used to selectively disable rendering on the outside of each plane.\n   *\n   * @memberof Globe.prototype\n   * @type {ClippingPlaneCollection}\n   */\n  clippingPlanes: {\n    get: function () {\n      return this._surface.tileProvider.clippingPlanes;\n    },\n    set: function (value) {\n      this._surface.tileProvider.clippingPlanes = value;\n    },\n  },\n  /**\n   * A property specifying a {@link Rectangle} used to limit globe rendering to a cartographic area.\n   * Defaults to the maximum extent of cartographic coordinates.\n   *\n   * @memberof Globe.prototype\n   * @type {Rectangle}\n   * @default {@link Rectangle.MAX_VALUE}\n   */\n  cartographicLimitRectangle: {\n    get: function () {\n      return this._surface.tileProvider.cartographicLimitRectangle;\n    },\n    set: function (value) {\n      if (!defined(value)) {\n        value = Rectangle.clone(Rectangle.MAX_VALUE);\n      }\n      this._surface.tileProvider.cartographicLimitRectangle = value;\n    },\n  },\n  /**\n   * The normal map to use for rendering waves in the ocean.  Setting this property will\n   * only have an effect if the configured terrain provider includes a water mask.\n   * @memberof Globe.prototype\n   * @type {String}\n   * @default buildModuleUrl('Assets/Textures/waterNormalsSmall.jpg')\n   */\n  oceanNormalMapUrl: {\n    get: function () {\n      return this._oceanNormalMapResource.url;\n    },\n    set: function (value) {\n      this._oceanNormalMapResource.url = value;\n      this._oceanNormalMapResourceDirty = true;\n    },\n  },\n  /**\n   * The terrain provider providing surface geometry for this globe.\n   * @type {TerrainProvider}\n   *\n   * @memberof Globe.prototype\n   * @type {TerrainProvider}\n   *\n   */\n  terrainProvider: {\n    get: function () {\n      return this._terrainProvider;\n    },\n    set: function (value) {\n      if (value !== this._terrainProvider) {\n        this._terrainProvider = value;\n        this._terrainProviderChanged.raiseEvent(value);\n        if (defined(this._material)) {\n          makeShadersDirty(this);\n        }\n      }\n    },\n  },\n  /**\n   * Gets an event that's raised when the terrain provider is changed\n   *\n   * @memberof Globe.prototype\n   * @type {Event}\n   * @readonly\n   */\n  terrainProviderChanged: {\n    get: function () {\n      return this._terrainProviderChanged;\n    },\n  },\n  /**\n   * Gets an event that's raised when the length of the tile load queue has changed since the last render frame.  When the load queue is empty,\n   * all terrain and imagery for the current view have been loaded.  The event passes the new length of the tile load queue.\n   *\n   * @memberof Globe.prototype\n   * @type {Event}\n   */\n  tileLoadProgressEvent: {\n    get: function () {\n      return this._surface.tileLoadProgressEvent;\n    },\n  },\n\n  /**\n   * Gets or sets the material appearance of the Globe.  This can be one of several built-in {@link Material} objects or a custom material, scripted with\n   * {@link https://github.com/CesiumGS/cesium/wiki/Fabric|Fabric}.\n   * @memberof Globe.prototype\n   * @type {Material}\n   */\n  material: {\n    get: function () {\n      return this._material;\n    },\n    set: function (material) {\n      if (this._material !== material) {\n        this._material = material;\n        makeShadersDirty(this);\n      }\n    },\n  },\n\n  /**\n   * The color to render the back side of the globe when the camera is underground or the globe is translucent,\n   * blended with the globe color based on the camera's distance.\n   * <br /><br />\n   * To disable underground coloring, set <code>undergroundColor</code> to <code>undefined</code>.\n   *\n   * @memberof Globe.prototype\n   * @type {Color}\n   * @default {@link Color.BLACK}\n   *\n   * @see Globe#undergroundColorAlphaByDistance\n   */\n  undergroundColor: {\n    get: function () {\n      return this._undergroundColor;\n    },\n    set: function (value) {\n      this._undergroundColor = Color.clone(value, this._undergroundColor);\n    },\n  },\n\n  /**\n   * Gets or sets the near and far distance for blending {@link Globe#undergroundColor} with the globe color.\n   * The alpha will interpolate between the {@link NearFarScalar#nearValue} and\n   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds\n   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.\n   * Outside of these ranges the alpha remains clamped to the nearest bound. If undefined,\n   * the underground color will not be blended with the globe color.\n   * <br /> <br />\n   * When the camera is above the ellipsoid the distance is computed from the nearest\n   * point on the ellipsoid instead of the camera's position.\n   *\n   * @memberof Globe.prototype\n   * @type {NearFarScalar}\n   *\n   * @see Globe#undergroundColor\n   *\n   */\n  undergroundColorAlphaByDistance: {\n    get: function () {\n      return this._undergroundColorAlphaByDistance;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (defined(value) && value.far < value.near) {\n        throw new DeveloperError(\n          \"far distance must be greater than near distance.\"\n        );\n      }\n      //>>includeEnd('debug');\n      this._undergroundColorAlphaByDistance = NearFarScalar.clone(\n        value,\n        this._undergroundColorAlphaByDistance\n      );\n    },\n  },\n\n  /**\n   * Properties for controlling globe translucency.\n   *\n   * @memberof Globe.prototype\n   * @type {GlobeTranslucency}\n   */\n  translucency: {\n    get: function () {\n      return this._translucency;\n    },\n  },\n});\n\nfunction makeShadersDirty(globe) {\n  var defines = [];\n\n  var requireNormals =\n    defined(globe._material) &&\n    (globe._material.shaderSource.match(/slope/) ||\n      globe._material.shaderSource.match(\"normalEC\"));\n\n  var fragmentSources = [GroundAtmosphere];\n  if (\n    defined(globe._material) &&\n    (!requireNormals || globe._terrainProvider.requestVertexNormals)\n  ) {\n    fragmentSources.push(globe._material.shaderSource);\n    defines.push(\"APPLY_MATERIAL\");\n    globe._surface._tileProvider.materialUniformMap = globe._material._uniforms;\n  } else {\n    globe._surface._tileProvider.materialUniformMap = undefined;\n  }\n  fragmentSources.push(GlobeFS);\n\n  globe._surfaceShaderSet.baseVertexShaderSource = new ShaderSource({\n    sources: [GroundAtmosphere, GlobeVS],\n    defines: defines,\n  });\n\n  globe._surfaceShaderSet.baseFragmentShaderSource = new ShaderSource({\n    sources: fragmentSources,\n    defines: defines,\n  });\n  globe._surfaceShaderSet.material = globe._material;\n}\n\nfunction createComparePickTileFunction(rayOrigin) {\n  return function (a, b) {\n    var aDist = BoundingSphere.distanceSquaredTo(\n      a.pickBoundingSphere,\n      rayOrigin\n    );\n    var bDist = BoundingSphere.distanceSquaredTo(\n      b.pickBoundingSphere,\n      rayOrigin\n    );\n\n    return aDist - bDist;\n  };\n}\n\nvar scratchArray = [];\nvar scratchSphereIntersectionResult = {\n  start: 0.0,\n  stop: 0.0,\n};\n\n/**\n * Find an intersection between a ray and the globe surface that was rendered. The ray must be given in world coordinates.\n *\n * @param {Ray} ray The ray to test for intersection.\n * @param {Scene} scene The scene.\n * @param {Boolean} [cullBackFaces=true] Set to true to not pick back faces.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3|undefined} The intersection or <code>undefined</code> if none was found.  The returned position is in projected coordinates for 2D and Columbus View.\n *\n * @private\n */\nGlobe.prototype.pickWorldCoordinates = function (\n  ray,\n  scene,\n  cullBackFaces,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(ray)) {\n    throw new DeveloperError(\"ray is required\");\n  }\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required\");\n  }\n  //>>includeEnd('debug');\n\n  cullBackFaces = defaultValue(cullBackFaces, true);\n\n  var mode = scene.mode;\n  var projection = scene.mapProjection;\n\n  var sphereIntersections = scratchArray;\n  sphereIntersections.length = 0;\n\n  var tilesToRender = this._surface._tilesToRender;\n  var length = tilesToRender.length;\n\n  var tile;\n  var i;\n\n  for (i = 0; i < length; ++i) {\n    tile = tilesToRender[i];\n    var surfaceTile = tile.data;\n\n    if (!defined(surfaceTile)) {\n      continue;\n    }\n\n    var boundingVolume = surfaceTile.pickBoundingSphere;\n    if (mode !== SceneMode.SCENE3D) {\n      surfaceTile.pickBoundingSphere = boundingVolume = BoundingSphere.fromRectangleWithHeights2D(\n        tile.rectangle,\n        projection,\n        surfaceTile.tileBoundingRegion.minimumHeight,\n        surfaceTile.tileBoundingRegion.maximumHeight,\n        boundingVolume\n      );\n      Cartesian3.fromElements(\n        boundingVolume.center.z,\n        boundingVolume.center.x,\n        boundingVolume.center.y,\n        boundingVolume.center\n      );\n    } else if (defined(surfaceTile.renderedMesh)) {\n      BoundingSphere.clone(\n        surfaceTile.renderedMesh.boundingSphere3D,\n        boundingVolume\n      );\n    } else {\n      // So wait how did we render this thing then? It shouldn't be possible to get here.\n      continue;\n    }\n\n    var boundingSphereIntersection = IntersectionTests.raySphere(\n      ray,\n      boundingVolume,\n      scratchSphereIntersectionResult\n    );\n    if (defined(boundingSphereIntersection)) {\n      sphereIntersections.push(surfaceTile);\n    }\n  }\n\n  sphereIntersections.sort(createComparePickTileFunction(ray.origin));\n\n  var intersection;\n  length = sphereIntersections.length;\n  for (i = 0; i < length; ++i) {\n    intersection = sphereIntersections[i].pick(\n      ray,\n      scene.mode,\n      scene.mapProjection,\n      cullBackFaces,\n      result\n    );\n    if (defined(intersection)) {\n      break;\n    }\n  }\n\n  return intersection;\n};\n\nvar cartoScratch = new Cartographic();\n/**\n * Find an intersection between a ray and the globe surface that was rendered. The ray must be given in world coordinates.\n *\n * @param {Ray} ray The ray to test for intersection.\n * @param {Scene} scene The scene.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3|undefined} The intersection or <code>undefined</code> if none was found.\n *\n * @example\n * // find intersection of ray through a pixel and the globe\n * var ray = viewer.camera.getPickRay(windowCoordinates);\n * var intersection = globe.pick(ray, scene);\n */\nGlobe.prototype.pick = function (ray, scene, result) {\n  result = this.pickWorldCoordinates(ray, scene, true, result);\n  if (defined(result) && scene.mode !== SceneMode.SCENE3D) {\n    result = Cartesian3.fromElements(result.y, result.z, result.x, result);\n    var carto = scene.mapProjection.unproject(result, cartoScratch);\n    result = scene.globe.ellipsoid.cartographicToCartesian(carto, result);\n  }\n\n  return result;\n};\n\nvar scratchGetHeightCartesian = new Cartesian3();\nvar scratchGetHeightIntersection = new Cartesian3();\nvar scratchGetHeightCartographic = new Cartographic();\nvar scratchGetHeightRay = new Ray();\n\nfunction tileIfContainsCartographic(tile, cartographic) {\n  return defined(tile) && Rectangle.contains(tile.rectangle, cartographic)\n    ? tile\n    : undefined;\n}\n\n/**\n * Get the height of the surface at a given cartographic.\n *\n * @param {Cartographic} cartographic The cartographic for which to find the height.\n * @returns {Number|undefined} The height of the cartographic or undefined if it could not be found.\n */\nGlobe.prototype.getHeight = function (cartographic) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartographic)) {\n    throw new DeveloperError(\"cartographic is required\");\n  }\n  //>>includeEnd('debug');\n\n  var levelZeroTiles = this._surface._levelZeroTiles;\n  if (!defined(levelZeroTiles)) {\n    return;\n  }\n\n  var tile;\n  var i;\n\n  var length = levelZeroTiles.length;\n  for (i = 0; i < length; ++i) {\n    tile = levelZeroTiles[i];\n    if (Rectangle.contains(tile.rectangle, cartographic)) {\n      break;\n    }\n  }\n\n  if (i >= length) {\n    return undefined;\n  }\n\n  var tileWithMesh = tile;\n\n  while (defined(tile)) {\n    tile =\n      tileIfContainsCartographic(tile._southwestChild, cartographic) ||\n      tileIfContainsCartographic(tile._southeastChild, cartographic) ||\n      tileIfContainsCartographic(tile._northwestChild, cartographic) ||\n      tile._northeastChild;\n\n    if (\n      defined(tile) &&\n      defined(tile.data) &&\n      defined(tile.data.renderedMesh)\n    ) {\n      tileWithMesh = tile;\n    }\n  }\n\n  tile = tileWithMesh;\n\n  // This tile was either rendered or culled.\n  // It is sometimes useful to get a height from a culled tile,\n  // e.g. when we're getting a height in order to place a billboard\n  // on terrain, and the camera is looking at that same billboard.\n  // The culled tile must have a valid mesh, though.\n  if (\n    !defined(tile) ||\n    !defined(tile.data) ||\n    !defined(tile.data.renderedMesh)\n  ) {\n    // Tile was not rendered (culled).\n    return undefined;\n  }\n\n  var ellipsoid = this._surface._tileProvider.tilingScheme.ellipsoid;\n\n  //cartesian has to be on the ellipsoid surface for `ellipsoid.geodeticSurfaceNormal`\n  var cartesian = Cartesian3.fromRadians(\n    cartographic.longitude,\n    cartographic.latitude,\n    0.0,\n    ellipsoid,\n    scratchGetHeightCartesian\n  );\n\n  var ray = scratchGetHeightRay;\n  var surfaceNormal = ellipsoid.geodeticSurfaceNormal(cartesian, ray.direction);\n\n  // Try to find the intersection point between the surface normal and z-axis.\n  // minimum height (-11500.0) for the terrain set, need to get this information from the terrain provider\n  var rayOrigin = ellipsoid.getSurfaceNormalIntersectionWithZAxis(\n    cartesian,\n    11500.0,\n    ray.origin\n  );\n\n  // Theoretically, not with Earth datums, the intersection point can be outside the ellipsoid\n  if (!defined(rayOrigin)) {\n    // intersection point is outside the ellipsoid, try other value\n    // minimum height (-11500.0) for the terrain set, need to get this information from the terrain provider\n    var minimumHeight;\n    if (defined(tile.data.tileBoundingRegion)) {\n      minimumHeight = tile.data.tileBoundingRegion.minimumHeight;\n    }\n    var magnitude = Math.min(defaultValue(minimumHeight, 0.0), -11500.0);\n\n    // multiply by the *positive* value of the magnitude\n    var vectorToMinimumPoint = Cartesian3.multiplyByScalar(\n      surfaceNormal,\n      Math.abs(magnitude) + 1,\n      scratchGetHeightIntersection\n    );\n    Cartesian3.subtract(cartesian, vectorToMinimumPoint, ray.origin);\n  }\n\n  var intersection = tile.data.pick(\n    ray,\n    undefined,\n    undefined,\n    false,\n    scratchGetHeightIntersection\n  );\n  if (!defined(intersection)) {\n    return undefined;\n  }\n\n  return ellipsoid.cartesianToCartographic(\n    intersection,\n    scratchGetHeightCartographic\n  ).height;\n};\n\n/**\n * @private\n */\nGlobe.prototype.update = function (frameState) {\n  if (!this.show) {\n    return;\n  }\n\n  if (frameState.passes.render) {\n    this._surface.update(frameState);\n  }\n};\n\n/**\n * @private\n */\nGlobe.prototype.beginFrame = function (frameState) {\n  var surface = this._surface;\n  var tileProvider = surface.tileProvider;\n  var terrainProvider = this.terrainProvider;\n  var hasWaterMask =\n    this.showWaterEffect &&\n    terrainProvider.ready &&\n    terrainProvider.hasWaterMask;\n\n  if (hasWaterMask && this._oceanNormalMapResourceDirty) {\n    // url changed, load new normal map asynchronously\n    this._oceanNormalMapResourceDirty = false;\n    var oceanNormalMapResource = this._oceanNormalMapResource;\n    var oceanNormalMapUrl = oceanNormalMapResource.url;\n    if (defined(oceanNormalMapUrl)) {\n      var that = this;\n      when(oceanNormalMapResource.fetchImage(), function (image) {\n        if (oceanNormalMapUrl !== that._oceanNormalMapResource.url) {\n          // url changed while we were loading\n          return;\n        }\n\n        that._oceanNormalMap =\n          that._oceanNormalMap && that._oceanNormalMap.destroy();\n        that._oceanNormalMap = new Texture({\n          context: frameState.context,\n          source: image,\n        });\n      });\n    } else {\n      this._oceanNormalMap =\n        this._oceanNormalMap && this._oceanNormalMap.destroy();\n    }\n  }\n\n  var pass = frameState.passes;\n  var mode = frameState.mode;\n\n  if (pass.render) {\n    if (this.showGroundAtmosphere) {\n      this._zoomedOutOceanSpecularIntensity = 0.4;\n    } else {\n      this._zoomedOutOceanSpecularIntensity = 0.5;\n    }\n\n    surface.maximumScreenSpaceError = this.maximumScreenSpaceError;\n    surface.tileCacheSize = this.tileCacheSize;\n    surface.loadingDescendantLimit = this.loadingDescendantLimit;\n    surface.preloadAncestors = this.preloadAncestors;\n    surface.preloadSiblings = this.preloadSiblings;\n\n    tileProvider.terrainProvider = this.terrainProvider;\n    tileProvider.lightingFadeOutDistance = this.lightingFadeOutDistance;\n    tileProvider.lightingFadeInDistance = this.lightingFadeInDistance;\n    tileProvider.nightFadeOutDistance = this.nightFadeOutDistance;\n    tileProvider.nightFadeInDistance = this.nightFadeInDistance;\n    tileProvider.zoomedOutOceanSpecularIntensity =\n      mode === SceneMode.SCENE3D ? this._zoomedOutOceanSpecularIntensity : 0.0;\n    tileProvider.hasWaterMask = hasWaterMask;\n    tileProvider.oceanNormalMap = this._oceanNormalMap;\n    tileProvider.enableLighting = this.enableLighting;\n    tileProvider.dynamicAtmosphereLighting = this.dynamicAtmosphereLighting;\n    tileProvider.dynamicAtmosphereLightingFromSun = this.dynamicAtmosphereLightingFromSun;\n    tileProvider.showGroundAtmosphere = this.showGroundAtmosphere;\n    tileProvider.shadows = this.shadows;\n    tileProvider.hueShift = this.atmosphereHueShift;\n    tileProvider.saturationShift = this.atmosphereSaturationShift;\n    tileProvider.brightnessShift = this.atmosphereBrightnessShift;\n    tileProvider.fillHighlightColor = this.fillHighlightColor;\n    tileProvider.showSkirts = this.showSkirts;\n    tileProvider.backFaceCulling = this.backFaceCulling;\n    tileProvider.undergroundColor = this._undergroundColor;\n    tileProvider.undergroundColorAlphaByDistance = this._undergroundColorAlphaByDistance;\n    surface.beginFrame(frameState);\n  }\n};\n\n/**\n * @private\n */\nGlobe.prototype.render = function (frameState) {\n  if (!this.show) {\n    return;\n  }\n\n  if (defined(this._material)) {\n    this._material.update(frameState.context);\n  }\n\n  this._surface.render(frameState);\n};\n\n/**\n * @private\n */\nGlobe.prototype.endFrame = function (frameState) {\n  if (!this.show) {\n    return;\n  }\n\n  if (frameState.passes.render) {\n    this._surface.endFrame(frameState);\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n *\n * @see Globe#destroy\n */\nGlobe.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * globe = globe && globe.destroy();\n *\n * @see Globe#isDestroyed\n */\nGlobe.prototype.destroy = function () {\n  this._surfaceShaderSet =\n    this._surfaceShaderSet && this._surfaceShaderSet.destroy();\n  this._surface = this._surface && this._surface.destroy();\n  this._oceanNormalMap = this._oceanNormalMap && this._oceanNormalMap.destroy();\n  return destroyObject(this);\n};\nexport default Globe;\n"]},"metadata":{},"sourceType":"module"}