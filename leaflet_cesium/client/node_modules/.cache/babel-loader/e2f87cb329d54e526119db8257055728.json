{"ast":null,"code":"import Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n/**\n * A 4D Cartesian point.\n * @alias Cartesian4\n * @constructor\n *\n * @param {Number} [x=0.0] The X component.\n * @param {Number} [y=0.0] The Y component.\n * @param {Number} [z=0.0] The Z component.\n * @param {Number} [w=0.0] The W component.\n *\n * @see Cartesian2\n * @see Cartesian3\n * @see Packable\n */\n\nfunction Cartesian4(x, y, z, w) {\n  /**\n   * The X component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.x = defaultValue(x, 0.0);\n  /**\n   * The Y component.\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.y = defaultValue(y, 0.0);\n  /**\n   * The Z component.\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.z = defaultValue(z, 0.0);\n  /**\n   * The W component.\n   * @type {Number}\n   * @default 0.0\n   */\n\n  this.w = defaultValue(w, 0.0);\n}\n/**\n * Creates a Cartesian4 instance from x, y, z and w coordinates.\n *\n * @param {Number} x The x coordinate.\n * @param {Number} y The y coordinate.\n * @param {Number} z The z coordinate.\n * @param {Number} w The w coordinate.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\n\n\nCartesian4.fromElements = function (x, y, z, w, result) {\n  if (!defined(result)) {\n    return new Cartesian4(x, y, z, w);\n  }\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n/**\n * Creates a Cartesian4 instance from a {@link Color}. <code>red</code>, <code>green</code>, <code>blue</code>,\n * and <code>alpha</code> map to <code>x</code>, <code>y</code>, <code>z</code>, and <code>w</code>, respectively.\n *\n * @param {Color} color The source color.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\n\n\nCartesian4.fromColor = function (color, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"color\", color); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    return new Cartesian4(color.red, color.green, color.blue, color.alpha);\n  }\n\n  result.x = color.red;\n  result.y = color.green;\n  result.z = color.blue;\n  result.w = color.alpha;\n  return result;\n};\n/**\n * Duplicates a Cartesian4 instance.\n *\n * @param {Cartesian4} cartesian The Cartesian to duplicate.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided. (Returns undefined if cartesian is undefined)\n */\n\n\nCartesian4.clone = function (cartesian, result) {\n  if (!defined(cartesian)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new Cartesian4(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\n  }\n\n  result.x = cartesian.x;\n  result.y = cartesian.y;\n  result.z = cartesian.z;\n  result.w = cartesian.w;\n  return result;\n};\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\n\n\nCartesian4.packedLength = 4;\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Cartesian4} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\n\nCartesian4.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  array[startingIndex++] = value.x;\n  array[startingIndex++] = value.y;\n  array[startingIndex++] = value.z;\n  array[startingIndex] = value.w;\n  return array;\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Cartesian4} [result] The object into which to store the result.\n * @returns {Cartesian4}  The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\n\n\nCartesian4.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Cartesian4();\n  }\n\n  result.x = array[startingIndex++];\n  result.y = array[startingIndex++];\n  result.z = array[startingIndex++];\n  result.w = array[startingIndex];\n  return result;\n};\n/**\n     * Flattens an array of Cartesian4s into and array of components.\n     *\n     * @param {Cartesian4[]} array The array of cartesians to pack.\n     * @param {Number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 4 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 4) elements.\n\n     * @returns {Number[]} The packed array.\n     */\n\n\nCartesian4.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  var length = array.length;\n  var resultLength = length * 4;\n\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    throw new DeveloperError(\"If result is a typed array, it must have exactly array.length * 4 elements\");\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n\n  for (var i = 0; i < length; ++i) {\n    Cartesian4.pack(array[i], result, i * 4);\n  }\n\n  return result;\n};\n/**\n * Unpacks an array of cartesian components into and array of Cartesian4s.\n *\n * @param {Number[]} array The array of components to unpack.\n * @param {Cartesian4[]} [result] The array onto which to store the result.\n * @returns {Cartesian4[]} The unpacked array.\n */\n\n\nCartesian4.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 4);\n\n  if (array.length % 4 !== 0) {\n    throw new DeveloperError(\"array length must be a multiple of 4.\");\n  } //>>includeEnd('debug');\n\n\n  var length = array.length;\n\n  if (!defined(result)) {\n    result = new Array(length / 4);\n  } else {\n    result.length = length / 4;\n  }\n\n  for (var i = 0; i < length; i += 4) {\n    var index = i / 4;\n    result[index] = Cartesian4.unpack(array, i, result[index]);\n  }\n\n  return result;\n};\n/**\n * Creates a Cartesian4 from four consecutive elements in an array.\n * @function\n *\n * @param {Number[]} array The array whose four consecutive elements correspond to the x, y, z, and w components, respectively.\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4}  The modified result parameter or a new Cartesian4 instance if one was not provided.\n *\n * @example\n * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0)\n * var v = [1.0, 2.0, 3.0, 4.0];\n * var p = Cesium.Cartesian4.fromArray(v);\n *\n * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0) using an offset into an array\n * var v2 = [0.0, 0.0, 1.0, 2.0, 3.0, 4.0];\n * var p2 = Cesium.Cartesian4.fromArray(v2, 2);\n */\n\n\nCartesian4.fromArray = Cartesian4.unpack;\n/**\n * Computes the value of the maximum component for the supplied Cartesian.\n *\n * @param {Cartesian4} cartesian The cartesian to use.\n * @returns {Number} The value of the maximum component.\n */\n\nCartesian4.maximumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian); //>>includeEnd('debug');\n\n  return Math.max(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\n};\n/**\n * Computes the value of the minimum component for the supplied Cartesian.\n *\n * @param {Cartesian4} cartesian The cartesian to use.\n * @returns {Number} The value of the minimum component.\n */\n\n\nCartesian4.minimumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian); //>>includeEnd('debug');\n\n  return Math.min(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\n};\n/**\n * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\n *\n * @param {Cartesian4} first A cartesian to compare.\n * @param {Cartesian4} second A cartesian to compare.\n * @param {Cartesian4} result The object into which to store the result.\n * @returns {Cartesian4} A cartesian with the minimum components.\n */\n\n\nCartesian4.minimumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = Math.min(first.x, second.x);\n  result.y = Math.min(first.y, second.y);\n  result.z = Math.min(first.z, second.z);\n  result.w = Math.min(first.w, second.w);\n  return result;\n};\n/**\n * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\n *\n * @param {Cartesian4} first A cartesian to compare.\n * @param {Cartesian4} second A cartesian to compare.\n * @param {Cartesian4} result The object into which to store the result.\n * @returns {Cartesian4} A cartesian with the maximum components.\n */\n\n\nCartesian4.maximumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = Math.max(first.x, second.x);\n  result.y = Math.max(first.y, second.y);\n  result.z = Math.max(first.z, second.z);\n  result.w = Math.max(first.w, second.w);\n  return result;\n};\n/**\n * Computes the provided Cartesian's squared magnitude.\n *\n * @param {Cartesian4} cartesian The Cartesian instance whose squared magnitude is to be computed.\n * @returns {Number} The squared magnitude.\n */\n\n\nCartesian4.magnitudeSquared = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian); //>>includeEnd('debug');\n\n  return cartesian.x * cartesian.x + cartesian.y * cartesian.y + cartesian.z * cartesian.z + cartesian.w * cartesian.w;\n};\n/**\n * Computes the Cartesian's magnitude (length).\n *\n * @param {Cartesian4} cartesian The Cartesian instance whose magnitude is to be computed.\n * @returns {Number} The magnitude.\n */\n\n\nCartesian4.magnitude = function (cartesian) {\n  return Math.sqrt(Cartesian4.magnitudeSquared(cartesian));\n};\n\nvar distanceScratch = new Cartesian4();\n/**\n * Computes the 4-space distance between two points.\n *\n * @param {Cartesian4} left The first point to compute the distance from.\n * @param {Cartesian4} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 1.0\n * var d = Cesium.Cartesian4.distance(\n *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),\n *   new Cesium.Cartesian4(2.0, 0.0, 0.0, 0.0));\n */\n\nCartesian4.distance = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right); //>>includeEnd('debug');\n\n  Cartesian4.subtract(left, right, distanceScratch);\n  return Cartesian4.magnitude(distanceScratch);\n};\n/**\n * Computes the squared distance between two points.  Comparing squared distances\n * using this function is more efficient than comparing distances using {@link Cartesian4#distance}.\n *\n * @param {Cartesian4} left The first point to compute the distance from.\n * @param {Cartesian4} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 4.0, not 2.0\n * var d = Cesium.Cartesian4.distance(\n *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),\n *   new Cesium.Cartesian4(3.0, 0.0, 0.0, 0.0));\n */\n\n\nCartesian4.distanceSquared = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right); //>>includeEnd('debug');\n\n  Cartesian4.subtract(left, right, distanceScratch);\n  return Cartesian4.magnitudeSquared(distanceScratch);\n};\n/**\n * Computes the normalized form of the supplied Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian to be normalized.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\n\n\nCartesian4.normalize = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  var magnitude = Cartesian4.magnitude(cartesian);\n  result.x = cartesian.x / magnitude;\n  result.y = cartesian.y / magnitude;\n  result.z = cartesian.z / magnitude;\n  result.w = cartesian.w / magnitude; //>>includeStart('debug', pragmas.debug);\n\n  if (isNaN(result.x) || isNaN(result.y) || isNaN(result.z) || isNaN(result.w)) {\n    throw new DeveloperError(\"normalized result is not a number\");\n  } //>>includeEnd('debug');\n\n\n  return result;\n};\n/**\n * Computes the dot (scalar) product of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @returns {Number} The dot product.\n */\n\n\nCartesian4.dot = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right); //>>includeEnd('debug');\n\n  return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;\n};\n/**\n * Computes the componentwise product of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\n\n\nCartesian4.multiplyComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = left.x * right.x;\n  result.y = left.y * right.y;\n  result.z = left.z * right.z;\n  result.w = left.w * right.w;\n  return result;\n};\n/**\n * Computes the componentwise quotient of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\n\n\nCartesian4.divideComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = left.x / right.x;\n  result.y = left.y / right.y;\n  result.z = left.z / right.z;\n  result.w = left.w / right.w;\n  return result;\n};\n/**\n * Computes the componentwise sum of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\n\n\nCartesian4.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  result.z = left.z + right.z;\n  result.w = left.w + right.w;\n  return result;\n};\n/**\n * Computes the componentwise difference of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\n\n\nCartesian4.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  result.z = left.z - right.z;\n  result.w = left.w - right.w;\n  return result;\n};\n/**\n * Multiplies the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian4} cartesian The Cartesian to be scaled.\n * @param {Number} scalar The scalar to multiply with.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\n\n\nCartesian4.multiplyByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = cartesian.x * scalar;\n  result.y = cartesian.y * scalar;\n  result.z = cartesian.z * scalar;\n  result.w = cartesian.w * scalar;\n  return result;\n};\n/**\n * Divides the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian4} cartesian The Cartesian to be divided.\n * @param {Number} scalar The scalar to divide by.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\n\n\nCartesian4.divideByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = cartesian.x / scalar;\n  result.y = cartesian.y / scalar;\n  result.z = cartesian.z / scalar;\n  result.w = cartesian.w / scalar;\n  return result;\n};\n/**\n * Negates the provided Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian to be negated.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\n\n\nCartesian4.negate = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = -cartesian.x;\n  result.y = -cartesian.y;\n  result.z = -cartesian.z;\n  result.w = -cartesian.w;\n  return result;\n};\n/**\n * Computes the absolute value of the provided Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian whose absolute value is to be computed.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\n\n\nCartesian4.abs = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  result.x = Math.abs(cartesian.x);\n  result.y = Math.abs(cartesian.y);\n  result.z = Math.abs(cartesian.z);\n  result.w = Math.abs(cartesian.w);\n  return result;\n};\n\nvar lerpScratch = new Cartesian4();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided cartesians.\n *\n * @param {Cartesian4} start The value corresponding to t at 0.0.\n * @param {Cartesian4}end The value corresponding to t at 1.0.\n * @param {Number} t The point along t at which to interpolate.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\n\nCartesian4.lerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  Cartesian4.multiplyByScalar(end, t, lerpScratch);\n  result = Cartesian4.multiplyByScalar(start, 1.0 - t, result);\n  return Cartesian4.add(lerpScratch, result, result);\n};\n\nvar mostOrthogonalAxisScratch = new Cartesian4();\n/**\n * Returns the axis that is most orthogonal to the provided Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian on which to find the most orthogonal axis.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The most orthogonal axis.\n */\n\nCartesian4.mostOrthogonalAxis = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result); //>>includeEnd('debug');\n\n  var f = Cartesian4.normalize(cartesian, mostOrthogonalAxisScratch);\n  Cartesian4.abs(f, f);\n\n  if (f.x <= f.y) {\n    if (f.x <= f.z) {\n      if (f.x <= f.w) {\n        result = Cartesian4.clone(Cartesian4.UNIT_X, result);\n      } else {\n        result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n      }\n    } else if (f.z <= f.w) {\n      result = Cartesian4.clone(Cartesian4.UNIT_Z, result);\n    } else {\n      result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n    }\n  } else if (f.y <= f.z) {\n    if (f.y <= f.w) {\n      result = Cartesian4.clone(Cartesian4.UNIT_Y, result);\n    } else {\n      result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n    }\n  } else if (f.z <= f.w) {\n    result = Cartesian4.clone(Cartesian4.UNIT_Z, result);\n  } else {\n    result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n  }\n\n  return result;\n};\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian4} [left] The first Cartesian.\n * @param {Cartesian4} [right] The second Cartesian.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\n\n\nCartesian4.equals = function (left, right) {\n  return left === right || defined(left) && defined(right) && left.x === right.x && left.y === right.y && left.z === right.z && left.w === right.w;\n};\n/**\n * @private\n */\n\n\nCartesian4.equalsArray = function (cartesian, array, offset) {\n  return cartesian.x === array[offset] && cartesian.y === array[offset + 1] && cartesian.z === array[offset + 2] && cartesian.w === array[offset + 3];\n};\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian4} [left] The first Cartesian.\n * @param {Cartesian4} [right] The second Cartesian.\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\n\n\nCartesian4.equalsEpsilon = function (left, right, relativeEpsilon, absoluteEpsilon) {\n  return left === right || defined(left) && defined(right) && CesiumMath.equalsEpsilon(left.x, right.x, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.y, right.y, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.z, right.z, relativeEpsilon, absoluteEpsilon) && CesiumMath.equalsEpsilon(left.w, right.w, relativeEpsilon, absoluteEpsilon);\n};\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\n\n\nCartesian4.ZERO = Object.freeze(new Cartesian4(0.0, 0.0, 0.0, 0.0));\n/**\n * An immutable Cartesian4 instance initialized to (1.0, 0.0, 0.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\n\nCartesian4.UNIT_X = Object.freeze(new Cartesian4(1.0, 0.0, 0.0, 0.0));\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 1.0, 0.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\n\nCartesian4.UNIT_Y = Object.freeze(new Cartesian4(0.0, 1.0, 0.0, 0.0));\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 0.0, 1.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\n\nCartesian4.UNIT_Z = Object.freeze(new Cartesian4(0.0, 0.0, 1.0, 0.0));\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 1.0).\n *\n * @type {Cartesian4}\n * @constant\n */\n\nCartesian4.UNIT_W = Object.freeze(new Cartesian4(0.0, 0.0, 0.0, 1.0));\n/**\n * Duplicates this Cartesian4 instance.\n *\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\n\nCartesian4.prototype.clone = function (result) {\n  return Cartesian4.clone(this, result);\n};\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian4} [right] The right hand side Cartesian.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\n\n\nCartesian4.prototype.equals = function (right) {\n  return Cartesian4.equals(this, right);\n};\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian4} [right] The right hand side Cartesian.\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\n\n\nCartesian4.prototype.equalsEpsilon = function (right, relativeEpsilon, absoluteEpsilon) {\n  return Cartesian4.equalsEpsilon(this, right, relativeEpsilon, absoluteEpsilon);\n};\n/**\n * Creates a string representing this Cartesian in the format '(x, y, z, w)'.\n *\n * @returns {String} A string representing the provided Cartesian in the format '(x, y, z, w)'.\n */\n\n\nCartesian4.prototype.toString = function () {\n  return \"(\" + this.x + \", \" + this.y + \", \" + this.z + \", \" + this.w + \")\";\n}; // scratchU8Array and scratchF32Array are views into the same buffer\n\n\nvar scratchF32Array = new Float32Array(1);\nvar scratchU8Array = new Uint8Array(scratchF32Array.buffer);\nvar testU32 = new Uint32Array([0x11223344]);\nvar testU8 = new Uint8Array(testU32.buffer);\nvar littleEndian = testU8[0] === 0x44;\n/**\n * Packs an arbitrary floating point value to 4 values representable using uint8.\n *\n * @param {Number} value A floating point number.\n * @param {Cartesian4} [result] The Cartesian4 that will contain the packed float.\n * @returns {Cartesian4} A Cartesian4 representing the float packed to values in x, y, z, and w.\n */\n\nCartesian4.packFloat = function (value, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"value\", value); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian4();\n  } // scratchU8Array and scratchF32Array are views into the same buffer\n\n\n  scratchF32Array[0] = value;\n\n  if (littleEndian) {\n    result.x = scratchU8Array[0];\n    result.y = scratchU8Array[1];\n    result.z = scratchU8Array[2];\n    result.w = scratchU8Array[3];\n  } else {\n    // convert from big-endian to little-endian\n    result.x = scratchU8Array[3];\n    result.y = scratchU8Array[2];\n    result.z = scratchU8Array[1];\n    result.w = scratchU8Array[0];\n  }\n\n  return result;\n};\n/**\n * Unpacks a float packed using Cartesian4.packFloat.\n *\n * @param {Cartesian4} packedFloat A Cartesian4 containing a float packed to 4 values representable using uint8.\n * @returns {Number} The unpacked float.\n * @private\n */\n\n\nCartesian4.unpackFloat = function (packedFloat) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"packedFloat\", packedFloat); //>>includeEnd('debug');\n  // scratchU8Array and scratchF32Array are views into the same buffer\n\n  if (littleEndian) {\n    scratchU8Array[0] = packedFloat.x;\n    scratchU8Array[1] = packedFloat.y;\n    scratchU8Array[2] = packedFloat.z;\n    scratchU8Array[3] = packedFloat.w;\n  } else {\n    // convert from little-endian to big-endian\n    scratchU8Array[0] = packedFloat.w;\n    scratchU8Array[1] = packedFloat.z;\n    scratchU8Array[2] = packedFloat.y;\n    scratchU8Array[3] = packedFloat.x;\n  }\n\n  return scratchF32Array[0];\n};\n\nexport default Cartesian4;","map":{"version":3,"sources":["/home/usuario/davi/thalamus/wms/3dmaptestes/leaflet_cesium/client/node_modules/cesium/Source/Core/Cartesian4.js"],"names":["Check","defaultValue","defined","DeveloperError","CesiumMath","Cartesian4","x","y","z","w","fromElements","result","fromColor","color","typeOf","object","red","green","blue","alpha","clone","cartesian","undefined","packedLength","pack","value","array","startingIndex","unpack","packArray","length","resultLength","Array","isArray","i","unpackArray","number","greaterThanOrEquals","index","fromArray","maximumComponent","Math","max","minimumComponent","min","minimumByComponent","first","second","maximumByComponent","magnitudeSquared","magnitude","sqrt","distanceScratch","distance","left","right","subtract","distanceSquared","normalize","isNaN","dot","multiplyComponents","divideComponents","add","multiplyByScalar","scalar","divideByScalar","negate","abs","lerpScratch","lerp","start","end","t","mostOrthogonalAxisScratch","mostOrthogonalAxis","f","UNIT_X","UNIT_W","UNIT_Z","UNIT_Y","equals","equalsArray","offset","equalsEpsilon","relativeEpsilon","absoluteEpsilon","ZERO","Object","freeze","prototype","toString","scratchF32Array","Float32Array","scratchU8Array","Uint8Array","buffer","testU32","Uint32Array","testU8","littleEndian","packFloat","unpackFloat","packedFloat"],"mappings":"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","sourcesContent":["import Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\n\n/**\n * A 4D Cartesian point.\n * @alias Cartesian4\n * @constructor\n *\n * @param {Number} [x=0.0] The X component.\n * @param {Number} [y=0.0] The Y component.\n * @param {Number} [z=0.0] The Z component.\n * @param {Number} [w=0.0] The W component.\n *\n * @see Cartesian2\n * @see Cartesian3\n * @see Packable\n */\nfunction Cartesian4(x, y, z, w) {\n  /**\n   * The X component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.x = defaultValue(x, 0.0);\n\n  /**\n   * The Y component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.y = defaultValue(y, 0.0);\n\n  /**\n   * The Z component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.z = defaultValue(z, 0.0);\n\n  /**\n   * The W component.\n   * @type {Number}\n   * @default 0.0\n   */\n  this.w = defaultValue(w, 0.0);\n}\n\n/**\n * Creates a Cartesian4 instance from x, y, z and w coordinates.\n *\n * @param {Number} x The x coordinate.\n * @param {Number} y The y coordinate.\n * @param {Number} z The z coordinate.\n * @param {Number} w The w coordinate.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\nCartesian4.fromElements = function (x, y, z, w, result) {\n  if (!defined(result)) {\n    return new Cartesian4(x, y, z, w);\n  }\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  result.w = w;\n  return result;\n};\n\n/**\n * Creates a Cartesian4 instance from a {@link Color}. <code>red</code>, <code>green</code>, <code>blue</code>,\n * and <code>alpha</code> map to <code>x</code>, <code>y</code>, <code>z</code>, and <code>w</code>, respectively.\n *\n * @param {Color} color The source color.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\nCartesian4.fromColor = function (color, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"color\", color);\n  //>>includeEnd('debug');\n  if (!defined(result)) {\n    return new Cartesian4(color.red, color.green, color.blue, color.alpha);\n  }\n\n  result.x = color.red;\n  result.y = color.green;\n  result.z = color.blue;\n  result.w = color.alpha;\n  return result;\n};\n\n/**\n * Duplicates a Cartesian4 instance.\n *\n * @param {Cartesian4} cartesian The Cartesian to duplicate.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided. (Returns undefined if cartesian is undefined)\n */\nCartesian4.clone = function (cartesian, result) {\n  if (!defined(cartesian)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    return new Cartesian4(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\n  }\n\n  result.x = cartesian.x;\n  result.y = cartesian.y;\n  result.z = cartesian.z;\n  result.w = cartesian.w;\n  return result;\n};\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nCartesian4.packedLength = 4;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Cartesian4} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nCartesian4.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  array[startingIndex++] = value.x;\n  array[startingIndex++] = value.y;\n  array[startingIndex++] = value.z;\n  array[startingIndex] = value.w;\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Cartesian4} [result] The object into which to store the result.\n * @returns {Cartesian4}  The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\nCartesian4.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  if (!defined(result)) {\n    result = new Cartesian4();\n  }\n  result.x = array[startingIndex++];\n  result.y = array[startingIndex++];\n  result.z = array[startingIndex++];\n  result.w = array[startingIndex];\n  return result;\n};\n\n/**\n     * Flattens an array of Cartesian4s into and array of components.\n     *\n     * @param {Cartesian4[]} array The array of cartesians to pack.\n     * @param {Number[]} [result] The array onto which to store the result. If this is a typed array, it must have array.length * 4 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 4) elements.\n\n     * @returns {Number[]} The packed array.\n     */\nCartesian4.packArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  var length = array.length;\n  var resultLength = length * 4;\n  if (!defined(result)) {\n    result = new Array(resultLength);\n  } else if (!Array.isArray(result) && result.length !== resultLength) {\n    throw new DeveloperError(\n      \"If result is a typed array, it must have exactly array.length * 4 elements\"\n    );\n  } else if (result.length !== resultLength) {\n    result.length = resultLength;\n  }\n\n  for (var i = 0; i < length; ++i) {\n    Cartesian4.pack(array[i], result, i * 4);\n  }\n  return result;\n};\n\n/**\n * Unpacks an array of cartesian components into and array of Cartesian4s.\n *\n * @param {Number[]} array The array of components to unpack.\n * @param {Cartesian4[]} [result] The array onto which to store the result.\n * @returns {Cartesian4[]} The unpacked array.\n */\nCartesian4.unpackArray = function (array, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  Check.typeOf.number.greaterThanOrEquals(\"array.length\", array.length, 4);\n  if (array.length % 4 !== 0) {\n    throw new DeveloperError(\"array length must be a multiple of 4.\");\n  }\n  //>>includeEnd('debug');\n\n  var length = array.length;\n  if (!defined(result)) {\n    result = new Array(length / 4);\n  } else {\n    result.length = length / 4;\n  }\n\n  for (var i = 0; i < length; i += 4) {\n    var index = i / 4;\n    result[index] = Cartesian4.unpack(array, i, result[index]);\n  }\n  return result;\n};\n\n/**\n * Creates a Cartesian4 from four consecutive elements in an array.\n * @function\n *\n * @param {Number[]} array The array whose four consecutive elements correspond to the x, y, z, and w components, respectively.\n * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4}  The modified result parameter or a new Cartesian4 instance if one was not provided.\n *\n * @example\n * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0)\n * var v = [1.0, 2.0, 3.0, 4.0];\n * var p = Cesium.Cartesian4.fromArray(v);\n *\n * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0) using an offset into an array\n * var v2 = [0.0, 0.0, 1.0, 2.0, 3.0, 4.0];\n * var p2 = Cesium.Cartesian4.fromArray(v2, 2);\n */\nCartesian4.fromArray = Cartesian4.unpack;\n\n/**\n * Computes the value of the maximum component for the supplied Cartesian.\n *\n * @param {Cartesian4} cartesian The cartesian to use.\n * @returns {Number} The value of the maximum component.\n */\nCartesian4.maximumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.max(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\n};\n\n/**\n * Computes the value of the minimum component for the supplied Cartesian.\n *\n * @param {Cartesian4} cartesian The cartesian to use.\n * @returns {Number} The value of the minimum component.\n */\nCartesian4.minimumComponent = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return Math.min(cartesian.x, cartesian.y, cartesian.z, cartesian.w);\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.\n *\n * @param {Cartesian4} first A cartesian to compare.\n * @param {Cartesian4} second A cartesian to compare.\n * @param {Cartesian4} result The object into which to store the result.\n * @returns {Cartesian4} A cartesian with the minimum components.\n */\nCartesian4.minimumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.min(first.x, second.x);\n  result.y = Math.min(first.y, second.y);\n  result.z = Math.min(first.z, second.z);\n  result.w = Math.min(first.w, second.w);\n\n  return result;\n};\n\n/**\n * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.\n *\n * @param {Cartesian4} first A cartesian to compare.\n * @param {Cartesian4} second A cartesian to compare.\n * @param {Cartesian4} result The object into which to store the result.\n * @returns {Cartesian4} A cartesian with the maximum components.\n */\nCartesian4.maximumByComponent = function (first, second, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"first\", first);\n  Check.typeOf.object(\"second\", second);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.max(first.x, second.x);\n  result.y = Math.max(first.y, second.y);\n  result.z = Math.max(first.z, second.z);\n  result.w = Math.max(first.w, second.w);\n\n  return result;\n};\n\n/**\n * Computes the provided Cartesian's squared magnitude.\n *\n * @param {Cartesian4} cartesian The Cartesian instance whose squared magnitude is to be computed.\n * @returns {Number} The squared magnitude.\n */\nCartesian4.magnitudeSquared = function (cartesian) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  return (\n    cartesian.x * cartesian.x +\n    cartesian.y * cartesian.y +\n    cartesian.z * cartesian.z +\n    cartesian.w * cartesian.w\n  );\n};\n\n/**\n * Computes the Cartesian's magnitude (length).\n *\n * @param {Cartesian4} cartesian The Cartesian instance whose magnitude is to be computed.\n * @returns {Number} The magnitude.\n */\nCartesian4.magnitude = function (cartesian) {\n  return Math.sqrt(Cartesian4.magnitudeSquared(cartesian));\n};\n\nvar distanceScratch = new Cartesian4();\n\n/**\n * Computes the 4-space distance between two points.\n *\n * @param {Cartesian4} left The first point to compute the distance from.\n * @param {Cartesian4} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 1.0\n * var d = Cesium.Cartesian4.distance(\n *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),\n *   new Cesium.Cartesian4(2.0, 0.0, 0.0, 0.0));\n */\nCartesian4.distance = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian4.subtract(left, right, distanceScratch);\n  return Cartesian4.magnitude(distanceScratch);\n};\n\n/**\n * Computes the squared distance between two points.  Comparing squared distances\n * using this function is more efficient than comparing distances using {@link Cartesian4#distance}.\n *\n * @param {Cartesian4} left The first point to compute the distance from.\n * @param {Cartesian4} right The second point to compute the distance to.\n * @returns {Number} The distance between two points.\n *\n * @example\n * // Returns 4.0, not 2.0\n * var d = Cesium.Cartesian4.distance(\n *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),\n *   new Cesium.Cartesian4(3.0, 0.0, 0.0, 0.0));\n */\nCartesian4.distanceSquared = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  Cartesian4.subtract(left, right, distanceScratch);\n  return Cartesian4.magnitudeSquared(distanceScratch);\n};\n\n/**\n * Computes the normalized form of the supplied Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian to be normalized.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.normalize = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var magnitude = Cartesian4.magnitude(cartesian);\n\n  result.x = cartesian.x / magnitude;\n  result.y = cartesian.y / magnitude;\n  result.z = cartesian.z / magnitude;\n  result.w = cartesian.w / magnitude;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    isNaN(result.x) ||\n    isNaN(result.y) ||\n    isNaN(result.z) ||\n    isNaN(result.w)\n  ) {\n    throw new DeveloperError(\"normalized result is not a number\");\n  }\n  //>>includeEnd('debug');\n\n  return result;\n};\n\n/**\n * Computes the dot (scalar) product of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @returns {Number} The dot product.\n */\nCartesian4.dot = function (left, right) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  //>>includeEnd('debug');\n\n  return (\n    left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w\n  );\n};\n\n/**\n * Computes the componentwise product of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.multiplyComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x * right.x;\n  result.y = left.y * right.y;\n  result.z = left.z * right.z;\n  result.w = left.w * right.w;\n  return result;\n};\n\n/**\n * Computes the componentwise quotient of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.divideComponents = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x / right.x;\n  result.y = left.y / right.y;\n  result.z = left.z / right.z;\n  result.w = left.w / right.w;\n  return result;\n};\n\n/**\n * Computes the componentwise sum of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.add = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x + right.x;\n  result.y = left.y + right.y;\n  result.z = left.z + right.z;\n  result.w = left.w + right.w;\n  return result;\n};\n\n/**\n * Computes the componentwise difference of two Cartesians.\n *\n * @param {Cartesian4} left The first Cartesian.\n * @param {Cartesian4} right The second Cartesian.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.subtract = function (left, right, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"left\", left);\n  Check.typeOf.object(\"right\", right);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = left.x - right.x;\n  result.y = left.y - right.y;\n  result.z = left.z - right.z;\n  result.w = left.w - right.w;\n  return result;\n};\n\n/**\n * Multiplies the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian4} cartesian The Cartesian to be scaled.\n * @param {Number} scalar The scalar to multiply with.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.multiplyByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x * scalar;\n  result.y = cartesian.y * scalar;\n  result.z = cartesian.z * scalar;\n  result.w = cartesian.w * scalar;\n  return result;\n};\n\n/**\n * Divides the provided Cartesian componentwise by the provided scalar.\n *\n * @param {Cartesian4} cartesian The Cartesian to be divided.\n * @param {Number} scalar The scalar to divide by.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.divideByScalar = function (cartesian, scalar, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.number(\"scalar\", scalar);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = cartesian.x / scalar;\n  result.y = cartesian.y / scalar;\n  result.z = cartesian.z / scalar;\n  result.w = cartesian.w / scalar;\n  return result;\n};\n\n/**\n * Negates the provided Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian to be negated.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.negate = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = -cartesian.x;\n  result.y = -cartesian.y;\n  result.z = -cartesian.z;\n  result.w = -cartesian.w;\n  return result;\n};\n\n/**\n * Computes the absolute value of the provided Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian whose absolute value is to be computed.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.abs = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  result.x = Math.abs(cartesian.x);\n  result.y = Math.abs(cartesian.y);\n  result.z = Math.abs(cartesian.z);\n  result.w = Math.abs(cartesian.w);\n  return result;\n};\n\nvar lerpScratch = new Cartesian4();\n/**\n * Computes the linear interpolation or extrapolation at t using the provided cartesians.\n *\n * @param {Cartesian4} start The value corresponding to t at 0.0.\n * @param {Cartesian4}end The value corresponding to t at 1.0.\n * @param {Number} t The point along t at which to interpolate.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter.\n */\nCartesian4.lerp = function (start, end, t, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"start\", start);\n  Check.typeOf.object(\"end\", end);\n  Check.typeOf.number(\"t\", t);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  Cartesian4.multiplyByScalar(end, t, lerpScratch);\n  result = Cartesian4.multiplyByScalar(start, 1.0 - t, result);\n  return Cartesian4.add(lerpScratch, result, result);\n};\n\nvar mostOrthogonalAxisScratch = new Cartesian4();\n/**\n * Returns the axis that is most orthogonal to the provided Cartesian.\n *\n * @param {Cartesian4} cartesian The Cartesian on which to find the most orthogonal axis.\n * @param {Cartesian4} result The object onto which to store the result.\n * @returns {Cartesian4} The most orthogonal axis.\n */\nCartesian4.mostOrthogonalAxis = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  Check.typeOf.object(\"result\", result);\n  //>>includeEnd('debug');\n\n  var f = Cartesian4.normalize(cartesian, mostOrthogonalAxisScratch);\n  Cartesian4.abs(f, f);\n\n  if (f.x <= f.y) {\n    if (f.x <= f.z) {\n      if (f.x <= f.w) {\n        result = Cartesian4.clone(Cartesian4.UNIT_X, result);\n      } else {\n        result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n      }\n    } else if (f.z <= f.w) {\n      result = Cartesian4.clone(Cartesian4.UNIT_Z, result);\n    } else {\n      result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n    }\n  } else if (f.y <= f.z) {\n    if (f.y <= f.w) {\n      result = Cartesian4.clone(Cartesian4.UNIT_Y, result);\n    } else {\n      result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n    }\n  } else if (f.z <= f.w) {\n    result = Cartesian4.clone(Cartesian4.UNIT_Z, result);\n  } else {\n    result = Cartesian4.clone(Cartesian4.UNIT_W, result);\n  }\n\n  return result;\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian4} [left] The first Cartesian.\n * @param {Cartesian4} [right] The second Cartesian.\n * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n */\nCartesian4.equals = function (left, right) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      left.x === right.x &&\n      left.y === right.y &&\n      left.z === right.z &&\n      left.w === right.w)\n  );\n};\n\n/**\n * @private\n */\nCartesian4.equalsArray = function (cartesian, array, offset) {\n  return (\n    cartesian.x === array[offset] &&\n    cartesian.y === array[offset + 1] &&\n    cartesian.z === array[offset + 2] &&\n    cartesian.w === array[offset + 3]\n  );\n};\n\n/**\n * Compares the provided Cartesians componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian4} [left] The first Cartesian.\n * @param {Cartesian4} [right] The second Cartesian.\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian4.equalsEpsilon = function (\n  left,\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return (\n    left === right ||\n    (defined(left) &&\n      defined(right) &&\n      CesiumMath.equalsEpsilon(\n        left.x,\n        right.x,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.y,\n        right.y,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.z,\n        right.z,\n        relativeEpsilon,\n        absoluteEpsilon\n      ) &&\n      CesiumMath.equalsEpsilon(\n        left.w,\n        right.w,\n        relativeEpsilon,\n        absoluteEpsilon\n      ))\n  );\n};\n\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.ZERO = Object.freeze(new Cartesian4(0.0, 0.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (1.0, 0.0, 0.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.UNIT_X = Object.freeze(new Cartesian4(1.0, 0.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 1.0, 0.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.UNIT_Y = Object.freeze(new Cartesian4(0.0, 1.0, 0.0, 0.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 0.0, 1.0, 0.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.UNIT_Z = Object.freeze(new Cartesian4(0.0, 0.0, 1.0, 0.0));\n\n/**\n * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 1.0).\n *\n * @type {Cartesian4}\n * @constant\n */\nCartesian4.UNIT_W = Object.freeze(new Cartesian4(0.0, 0.0, 0.0, 1.0));\n\n/**\n * Duplicates this Cartesian4 instance.\n *\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.\n */\nCartesian4.prototype.clone = function (result) {\n  return Cartesian4.clone(this, result);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Cartesian4} [right] The right hand side Cartesian.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nCartesian4.prototype.equals = function (right) {\n  return Cartesian4.equals(this, right);\n};\n\n/**\n * Compares this Cartesian against the provided Cartesian componentwise and returns\n * <code>true</code> if they pass an absolute or relative tolerance test,\n * <code>false</code> otherwise.\n *\n * @param {Cartesian4} [right] The right hand side Cartesian.\n * @param {Number} [relativeEpsilon=0] The relative epsilon tolerance to use for equality testing.\n * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.\n * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.\n */\nCartesian4.prototype.equalsEpsilon = function (\n  right,\n  relativeEpsilon,\n  absoluteEpsilon\n) {\n  return Cartesian4.equalsEpsilon(\n    this,\n    right,\n    relativeEpsilon,\n    absoluteEpsilon\n  );\n};\n\n/**\n * Creates a string representing this Cartesian in the format '(x, y, z, w)'.\n *\n * @returns {String} A string representing the provided Cartesian in the format '(x, y, z, w)'.\n */\nCartesian4.prototype.toString = function () {\n  return \"(\" + this.x + \", \" + this.y + \", \" + this.z + \", \" + this.w + \")\";\n};\n\n// scratchU8Array and scratchF32Array are views into the same buffer\nvar scratchF32Array = new Float32Array(1);\nvar scratchU8Array = new Uint8Array(scratchF32Array.buffer);\n\nvar testU32 = new Uint32Array([0x11223344]);\nvar testU8 = new Uint8Array(testU32.buffer);\nvar littleEndian = testU8[0] === 0x44;\n\n/**\n * Packs an arbitrary floating point value to 4 values representable using uint8.\n *\n * @param {Number} value A floating point number.\n * @param {Cartesian4} [result] The Cartesian4 that will contain the packed float.\n * @returns {Cartesian4} A Cartesian4 representing the float packed to values in x, y, z, and w.\n */\nCartesian4.packFloat = function (value, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"value\", value);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian4();\n  }\n\n  // scratchU8Array and scratchF32Array are views into the same buffer\n  scratchF32Array[0] = value;\n\n  if (littleEndian) {\n    result.x = scratchU8Array[0];\n    result.y = scratchU8Array[1];\n    result.z = scratchU8Array[2];\n    result.w = scratchU8Array[3];\n  } else {\n    // convert from big-endian to little-endian\n    result.x = scratchU8Array[3];\n    result.y = scratchU8Array[2];\n    result.z = scratchU8Array[1];\n    result.w = scratchU8Array[0];\n  }\n  return result;\n};\n\n/**\n * Unpacks a float packed using Cartesian4.packFloat.\n *\n * @param {Cartesian4} packedFloat A Cartesian4 containing a float packed to 4 values representable using uint8.\n * @returns {Number} The unpacked float.\n * @private\n */\nCartesian4.unpackFloat = function (packedFloat) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"packedFloat\", packedFloat);\n  //>>includeEnd('debug');\n\n  // scratchU8Array and scratchF32Array are views into the same buffer\n  if (littleEndian) {\n    scratchU8Array[0] = packedFloat.x;\n    scratchU8Array[1] = packedFloat.y;\n    scratchU8Array[2] = packedFloat.z;\n    scratchU8Array[3] = packedFloat.w;\n  } else {\n    // convert from little-endian to big-endian\n    scratchU8Array[0] = packedFloat.w;\n    scratchU8Array[1] = packedFloat.z;\n    scratchU8Array[2] = packedFloat.y;\n    scratchU8Array[3] = packedFloat.x;\n  }\n  return scratchF32Array[0];\n};\nexport default Cartesian4;\n"]},"metadata":{},"sourceType":"module"}