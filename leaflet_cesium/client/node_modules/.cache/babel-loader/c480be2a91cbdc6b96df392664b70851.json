{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidGeodesic from \"./EllipsoidGeodesic.js\";\nimport EllipsoidRhumbLine from \"./EllipsoidRhumbLine.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Plane from \"./Plane.js\";\n/**\n * @private\n */\n\nvar PolylinePipeline = {};\n\nPolylinePipeline.numberOfPoints = function (p0, p1, minDistance) {\n  var distance = Cartesian3.distance(p0, p1);\n  return Math.ceil(distance / minDistance);\n};\n\nPolylinePipeline.numberOfPointsRhumbLine = function (p0, p1, granularity) {\n  var radiansDistanceSquared = Math.pow(p0.longitude - p1.longitude, 2) + Math.pow(p0.latitude - p1.latitude, 2);\n  return Math.max(1, Math.ceil(Math.sqrt(radiansDistanceSquared / (granularity * granularity))));\n};\n\nvar cartoScratch = new Cartographic();\n\nPolylinePipeline.extractHeights = function (positions, ellipsoid) {\n  var length = positions.length;\n  var heights = new Array(length);\n\n  for (var i = 0; i < length; i++) {\n    var p = positions[i];\n    heights[i] = ellipsoid.cartesianToCartographic(p, cartoScratch).height;\n  }\n\n  return heights;\n};\n\nvar wrapLongitudeInversMatrix = new Matrix4();\nvar wrapLongitudeOrigin = new Cartesian3();\nvar wrapLongitudeXZNormal = new Cartesian3();\nvar wrapLongitudeXZPlane = new Plane(Cartesian3.UNIT_X, 0.0);\nvar wrapLongitudeYZNormal = new Cartesian3();\nvar wrapLongitudeYZPlane = new Plane(Cartesian3.UNIT_X, 0.0);\nvar wrapLongitudeIntersection = new Cartesian3();\nvar wrapLongitudeOffset = new Cartesian3();\nvar subdivideHeightsScratchArray = [];\n\nfunction subdivideHeights(numPoints, h0, h1) {\n  var heights = subdivideHeightsScratchArray;\n  heights.length = numPoints;\n  var i;\n\n  if (h0 === h1) {\n    for (i = 0; i < numPoints; i++) {\n      heights[i] = h0;\n    }\n\n    return heights;\n  }\n\n  var dHeight = h1 - h0;\n  var heightPerVertex = dHeight / numPoints;\n\n  for (i = 0; i < numPoints; i++) {\n    var h = h0 + i * heightPerVertex;\n    heights[i] = h;\n  }\n\n  return heights;\n}\n\nvar carto1 = new Cartographic();\nvar carto2 = new Cartographic();\nvar cartesian = new Cartesian3();\nvar scaleFirst = new Cartesian3();\nvar scaleLast = new Cartesian3();\nvar ellipsoidGeodesic = new EllipsoidGeodesic();\nvar ellipsoidRhumb = new EllipsoidRhumbLine(); //Returns subdivided line scaled to ellipsoid surface starting at p1 and ending at p2.\n//Result includes p1, but not include p2.  This function is called for a sequence of line segments,\n//and this prevents duplication of end point.\n\nfunction generateCartesianArc(p0, p1, minDistance, ellipsoid, h0, h1, array, offset) {\n  var first = ellipsoid.scaleToGeodeticSurface(p0, scaleFirst);\n  var last = ellipsoid.scaleToGeodeticSurface(p1, scaleLast);\n  var numPoints = PolylinePipeline.numberOfPoints(p0, p1, minDistance);\n  var start = ellipsoid.cartesianToCartographic(first, carto1);\n  var end = ellipsoid.cartesianToCartographic(last, carto2);\n  var heights = subdivideHeights(numPoints, h0, h1);\n  ellipsoidGeodesic.setEndPoints(start, end);\n  var surfaceDistanceBetweenPoints = ellipsoidGeodesic.surfaceDistance / numPoints;\n  var index = offset;\n  start.height = h0;\n  var cart = ellipsoid.cartographicToCartesian(start, cartesian);\n  Cartesian3.pack(cart, array, index);\n  index += 3;\n\n  for (var i = 1; i < numPoints; i++) {\n    var carto = ellipsoidGeodesic.interpolateUsingSurfaceDistance(i * surfaceDistanceBetweenPoints, carto2);\n    carto.height = heights[i];\n    cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n    Cartesian3.pack(cart, array, index);\n    index += 3;\n  }\n\n  return index;\n} //Returns subdivided line scaled to ellipsoid surface starting at p1 and ending at p2.\n//Result includes p1, but not include p2.  This function is called for a sequence of line segments,\n//and this prevents duplication of end point.\n\n\nfunction generateCartesianRhumbArc(p0, p1, granularity, ellipsoid, h0, h1, array, offset) {\n  var start = ellipsoid.cartesianToCartographic(p0, carto1);\n  var end = ellipsoid.cartesianToCartographic(p1, carto2);\n  var numPoints = PolylinePipeline.numberOfPointsRhumbLine(start, end, granularity);\n  start.height = 0.0;\n  end.height = 0.0;\n  var heights = subdivideHeights(numPoints, h0, h1);\n\n  if (!ellipsoidRhumb.ellipsoid.equals(ellipsoid)) {\n    ellipsoidRhumb = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n  }\n\n  ellipsoidRhumb.setEndPoints(start, end);\n  var surfaceDistanceBetweenPoints = ellipsoidRhumb.surfaceDistance / numPoints;\n  var index = offset;\n  start.height = h0;\n  var cart = ellipsoid.cartographicToCartesian(start, cartesian);\n  Cartesian3.pack(cart, array, index);\n  index += 3;\n\n  for (var i = 1; i < numPoints; i++) {\n    var carto = ellipsoidRhumb.interpolateUsingSurfaceDistance(i * surfaceDistanceBetweenPoints, carto2);\n    carto.height = heights[i];\n    cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n    Cartesian3.pack(cart, array, index);\n    index += 3;\n  }\n\n  return index;\n}\n/**\n * Breaks a {@link Polyline} into segments such that it does not cross the &plusmn;180 degree meridian of an ellipsoid.\n *\n * @param {Cartesian3[]} positions The polyline's Cartesian positions.\n * @param {Matrix4} [modelMatrix=Matrix4.IDENTITY] The polyline's model matrix. Assumed to be an affine\n * transformation matrix, where the upper left 3x3 elements are a rotation matrix, and\n * the upper three elements in the fourth column are the translation.  The bottom row is assumed to be [0, 0, 0, 1].\n * The matrix is not verified to be in the proper form.\n * @returns {Object} An object with a <code>positions</code> property that is an array of positions and a\n * <code>segments</code> property.\n *\n *\n * @example\n * var polylines = new Cesium.PolylineCollection();\n * var polyline = polylines.add(...);\n * var positions = polyline.positions;\n * var modelMatrix = polylines.modelMatrix;\n * var segments = Cesium.PolylinePipeline.wrapLongitude(positions, modelMatrix);\n *\n * @see PolygonPipeline.wrapLongitude\n * @see Polyline\n * @see PolylineCollection\n */\n\n\nPolylinePipeline.wrapLongitude = function (positions, modelMatrix) {\n  var cartesians = [];\n  var segments = [];\n\n  if (defined(positions) && positions.length > 0) {\n    modelMatrix = defaultValue(modelMatrix, Matrix4.IDENTITY);\n    var inverseModelMatrix = Matrix4.inverseTransformation(modelMatrix, wrapLongitudeInversMatrix);\n    var origin = Matrix4.multiplyByPoint(inverseModelMatrix, Cartesian3.ZERO, wrapLongitudeOrigin);\n    var xzNormal = Cartesian3.normalize(Matrix4.multiplyByPointAsVector(inverseModelMatrix, Cartesian3.UNIT_Y, wrapLongitudeXZNormal), wrapLongitudeXZNormal);\n    var xzPlane = Plane.fromPointNormal(origin, xzNormal, wrapLongitudeXZPlane);\n    var yzNormal = Cartesian3.normalize(Matrix4.multiplyByPointAsVector(inverseModelMatrix, Cartesian3.UNIT_X, wrapLongitudeYZNormal), wrapLongitudeYZNormal);\n    var yzPlane = Plane.fromPointNormal(origin, yzNormal, wrapLongitudeYZPlane);\n    var count = 1;\n    cartesians.push(Cartesian3.clone(positions[0]));\n    var prev = cartesians[0];\n    var length = positions.length;\n\n    for (var i = 1; i < length; ++i) {\n      var cur = positions[i]; // intersects the IDL if either endpoint is on the negative side of the yz-plane\n\n      if (Plane.getPointDistance(yzPlane, prev) < 0.0 || Plane.getPointDistance(yzPlane, cur) < 0.0) {\n        // and intersects the xz-plane\n        var intersection = IntersectionTests.lineSegmentPlane(prev, cur, xzPlane, wrapLongitudeIntersection);\n\n        if (defined(intersection)) {\n          // move point on the xz-plane slightly away from the plane\n          var offset = Cartesian3.multiplyByScalar(xzNormal, 5.0e-9, wrapLongitudeOffset);\n\n          if (Plane.getPointDistance(xzPlane, prev) < 0.0) {\n            Cartesian3.negate(offset, offset);\n          }\n\n          cartesians.push(Cartesian3.add(intersection, offset, new Cartesian3()));\n          segments.push(count + 1);\n          Cartesian3.negate(offset, offset);\n          cartesians.push(Cartesian3.add(intersection, offset, new Cartesian3()));\n          count = 1;\n        }\n      }\n\n      cartesians.push(Cartesian3.clone(positions[i]));\n      count++;\n      prev = cur;\n    }\n\n    segments.push(count);\n  }\n\n  return {\n    positions: cartesians,\n    lengths: segments\n  };\n};\n/**\n * Subdivides polyline and raises all points to the specified height.  Returns an array of numbers to represent the positions.\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\n * @returns {Number[]} A new array of positions of type {Number} that have been subdivided and raised to the surface of the ellipsoid.\n *\n * @example\n * var positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * var surfacePositions = Cesium.PolylinePipeline.generateArc({\n *   positons: positions\n * });\n */\n\n\nPolylinePipeline.generateArc = function (options) {\n  if (!defined(options)) {\n    options = {};\n  }\n\n  var positions = options.positions; //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(positions)) {\n    throw new DeveloperError(\"options.positions is required.\");\n  } //>>includeEnd('debug');\n\n\n  var length = positions.length;\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  var height = defaultValue(options.height, 0);\n  var hasHeightArray = Array.isArray(height);\n\n  if (length < 1) {\n    return [];\n  } else if (length === 1) {\n    var p = ellipsoid.scaleToGeodeticSurface(positions[0], scaleFirst);\n    height = hasHeightArray ? height[0] : height;\n\n    if (height !== 0) {\n      var n = ellipsoid.geodeticSurfaceNormal(p, cartesian);\n      Cartesian3.multiplyByScalar(n, height, n);\n      Cartesian3.add(p, n, p);\n    }\n\n    return [p.x, p.y, p.z];\n  }\n\n  var minDistance = options.minDistance;\n\n  if (!defined(minDistance)) {\n    var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n    minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n  }\n\n  var numPoints = 0;\n  var i;\n\n  for (i = 0; i < length - 1; i++) {\n    numPoints += PolylinePipeline.numberOfPoints(positions[i], positions[i + 1], minDistance);\n  }\n\n  var arrayLength = (numPoints + 1) * 3;\n  var newPositions = new Array(arrayLength);\n  var offset = 0;\n\n  for (i = 0; i < length - 1; i++) {\n    var p0 = positions[i];\n    var p1 = positions[i + 1];\n    var h0 = hasHeightArray ? height[i] : height;\n    var h1 = hasHeightArray ? height[i + 1] : height;\n    offset = generateCartesianArc(p0, p1, minDistance, ellipsoid, h0, h1, newPositions, offset);\n  }\n\n  subdivideHeightsScratchArray.length = 0;\n  var lastPoint = positions[length - 1];\n  var carto = ellipsoid.cartesianToCartographic(lastPoint, carto1);\n  carto.height = hasHeightArray ? height[length - 1] : height;\n  var cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n  Cartesian3.pack(cart, newPositions, arrayLength - 3);\n  return newPositions;\n};\n\nvar scratchCartographic0 = new Cartographic();\nvar scratchCartographic1 = new Cartographic();\n/**\n * Subdivides polyline and raises all points to the specified height using Rhumb lines.  Returns an array of numbers to represent the positions.\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\n * @returns {Number[]} A new array of positions of type {Number} that have been subdivided and raised to the surface of the ellipsoid.\n *\n * @example\n * var positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * var surfacePositions = Cesium.PolylinePipeline.generateRhumbArc({\n *   positons: positions\n * });\n */\n\nPolylinePipeline.generateRhumbArc = function (options) {\n  if (!defined(options)) {\n    options = {};\n  }\n\n  var positions = options.positions; //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(positions)) {\n    throw new DeveloperError(\"options.positions is required.\");\n  } //>>includeEnd('debug');\n\n\n  var length = positions.length;\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  var height = defaultValue(options.height, 0);\n  var hasHeightArray = Array.isArray(height);\n\n  if (length < 1) {\n    return [];\n  } else if (length === 1) {\n    var p = ellipsoid.scaleToGeodeticSurface(positions[0], scaleFirst);\n    height = hasHeightArray ? height[0] : height;\n\n    if (height !== 0) {\n      var n = ellipsoid.geodeticSurfaceNormal(p, cartesian);\n      Cartesian3.multiplyByScalar(n, height, n);\n      Cartesian3.add(p, n, p);\n    }\n\n    return [p.x, p.y, p.z];\n  }\n\n  var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n  var numPoints = 0;\n  var i;\n  var c0 = ellipsoid.cartesianToCartographic(positions[0], scratchCartographic0);\n  var c1;\n\n  for (i = 0; i < length - 1; i++) {\n    c1 = ellipsoid.cartesianToCartographic(positions[i + 1], scratchCartographic1);\n    numPoints += PolylinePipeline.numberOfPointsRhumbLine(c0, c1, granularity);\n    c0 = Cartographic.clone(c1, scratchCartographic0);\n  }\n\n  var arrayLength = (numPoints + 1) * 3;\n  var newPositions = new Array(arrayLength);\n  var offset = 0;\n\n  for (i = 0; i < length - 1; i++) {\n    var p0 = positions[i];\n    var p1 = positions[i + 1];\n    var h0 = hasHeightArray ? height[i] : height;\n    var h1 = hasHeightArray ? height[i + 1] : height;\n    offset = generateCartesianRhumbArc(p0, p1, granularity, ellipsoid, h0, h1, newPositions, offset);\n  }\n\n  subdivideHeightsScratchArray.length = 0;\n  var lastPoint = positions[length - 1];\n  var carto = ellipsoid.cartesianToCartographic(lastPoint, carto1);\n  carto.height = hasHeightArray ? height[length - 1] : height;\n  var cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n  Cartesian3.pack(cart, newPositions, arrayLength - 3);\n  return newPositions;\n};\n/**\n * Subdivides polyline and raises all points to the specified height. Returns an array of new {Cartesian3} positions.\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\n * @returns {Cartesian3[]} A new array of cartesian3 positions that have been subdivided and raised to the surface of the ellipsoid.\n *\n * @example\n * var positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * var surfacePositions = Cesium.PolylinePipeline.generateCartesianArc({\n *   positons: positions\n * });\n */\n\n\nPolylinePipeline.generateCartesianArc = function (options) {\n  var numberArray = PolylinePipeline.generateArc(options);\n  var size = numberArray.length / 3;\n  var newPositions = new Array(size);\n\n  for (var i = 0; i < size; i++) {\n    newPositions[i] = Cartesian3.unpack(numberArray, i * 3);\n  }\n\n  return newPositions;\n};\n/**\n * Subdivides polyline and raises all points to the specified height using Rhumb Lines. Returns an array of new {Cartesian3} positions.\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\n * @returns {Cartesian3[]} A new array of cartesian3 positions that have been subdivided and raised to the surface of the ellipsoid.\n *\n * @example\n * var positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * var surfacePositions = Cesium.PolylinePipeline.generateCartesianRhumbArc({\n *   positons: positions\n * });\n */\n\n\nPolylinePipeline.generateCartesianRhumbArc = function (options) {\n  var numberArray = PolylinePipeline.generateRhumbArc(options);\n  var size = numberArray.length / 3;\n  var newPositions = new Array(size);\n\n  for (var i = 0; i < size; i++) {\n    newPositions[i] = Cartesian3.unpack(numberArray, i * 3);\n  }\n\n  return newPositions;\n};\n\nexport default PolylinePipeline;","map":{"version":3,"sources":["/home/usuario/davi/thalamus/wms/3dmaptestes/leaflet_cesium/client/node_modules/cesium/Source/Core/PolylinePipeline.js"],"names":["Cartesian3","Cartographic","defaultValue","defined","DeveloperError","Ellipsoid","EllipsoidGeodesic","EllipsoidRhumbLine","IntersectionTests","CesiumMath","Matrix4","Plane","PolylinePipeline","numberOfPoints","p0","p1","minDistance","distance","Math","ceil","numberOfPointsRhumbLine","granularity","radiansDistanceSquared","pow","longitude","latitude","max","sqrt","cartoScratch","extractHeights","positions","ellipsoid","length","heights","Array","i","p","cartesianToCartographic","height","wrapLongitudeInversMatrix","wrapLongitudeOrigin","wrapLongitudeXZNormal","wrapLongitudeXZPlane","UNIT_X","wrapLongitudeYZNormal","wrapLongitudeYZPlane","wrapLongitudeIntersection","wrapLongitudeOffset","subdivideHeightsScratchArray","subdivideHeights","numPoints","h0","h1","dHeight","heightPerVertex","h","carto1","carto2","cartesian","scaleFirst","scaleLast","ellipsoidGeodesic","ellipsoidRhumb","generateCartesianArc","array","offset","first","scaleToGeodeticSurface","last","start","end","setEndPoints","surfaceDistanceBetweenPoints","surfaceDistance","index","cart","cartographicToCartesian","pack","carto","interpolateUsingSurfaceDistance","generateCartesianRhumbArc","equals","undefined","wrapLongitude","modelMatrix","cartesians","segments","IDENTITY","inverseModelMatrix","inverseTransformation","origin","multiplyByPoint","ZERO","xzNormal","normalize","multiplyByPointAsVector","UNIT_Y","xzPlane","fromPointNormal","yzNormal","yzPlane","count","push","clone","prev","cur","getPointDistance","intersection","lineSegmentPlane","multiplyByScalar","negate","add","lengths","generateArc","options","WGS84","hasHeightArray","isArray","n","geodeticSurfaceNormal","x","y","z","RADIANS_PER_DEGREE","chordLength","maximumRadius","arrayLength","newPositions","lastPoint","scratchCartographic0","scratchCartographic1","generateRhumbArc","c0","c1","numberArray","size","unpack"],"mappings":"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","sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidGeodesic from \"./EllipsoidGeodesic.js\";\nimport EllipsoidRhumbLine from \"./EllipsoidRhumbLine.js\";\nimport IntersectionTests from \"./IntersectionTests.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix4 from \"./Matrix4.js\";\nimport Plane from \"./Plane.js\";\n\n/**\n * @private\n */\nvar PolylinePipeline = {};\n\nPolylinePipeline.numberOfPoints = function (p0, p1, minDistance) {\n  var distance = Cartesian3.distance(p0, p1);\n  return Math.ceil(distance / minDistance);\n};\n\nPolylinePipeline.numberOfPointsRhumbLine = function (p0, p1, granularity) {\n  var radiansDistanceSquared =\n    Math.pow(p0.longitude - p1.longitude, 2) +\n    Math.pow(p0.latitude - p1.latitude, 2);\n\n  return Math.max(\n    1,\n    Math.ceil(Math.sqrt(radiansDistanceSquared / (granularity * granularity)))\n  );\n};\n\nvar cartoScratch = new Cartographic();\nPolylinePipeline.extractHeights = function (positions, ellipsoid) {\n  var length = positions.length;\n  var heights = new Array(length);\n  for (var i = 0; i < length; i++) {\n    var p = positions[i];\n    heights[i] = ellipsoid.cartesianToCartographic(p, cartoScratch).height;\n  }\n  return heights;\n};\n\nvar wrapLongitudeInversMatrix = new Matrix4();\nvar wrapLongitudeOrigin = new Cartesian3();\nvar wrapLongitudeXZNormal = new Cartesian3();\nvar wrapLongitudeXZPlane = new Plane(Cartesian3.UNIT_X, 0.0);\nvar wrapLongitudeYZNormal = new Cartesian3();\nvar wrapLongitudeYZPlane = new Plane(Cartesian3.UNIT_X, 0.0);\nvar wrapLongitudeIntersection = new Cartesian3();\nvar wrapLongitudeOffset = new Cartesian3();\n\nvar subdivideHeightsScratchArray = [];\n\nfunction subdivideHeights(numPoints, h0, h1) {\n  var heights = subdivideHeightsScratchArray;\n  heights.length = numPoints;\n\n  var i;\n  if (h0 === h1) {\n    for (i = 0; i < numPoints; i++) {\n      heights[i] = h0;\n    }\n    return heights;\n  }\n\n  var dHeight = h1 - h0;\n  var heightPerVertex = dHeight / numPoints;\n\n  for (i = 0; i < numPoints; i++) {\n    var h = h0 + i * heightPerVertex;\n    heights[i] = h;\n  }\n\n  return heights;\n}\n\nvar carto1 = new Cartographic();\nvar carto2 = new Cartographic();\nvar cartesian = new Cartesian3();\nvar scaleFirst = new Cartesian3();\nvar scaleLast = new Cartesian3();\nvar ellipsoidGeodesic = new EllipsoidGeodesic();\nvar ellipsoidRhumb = new EllipsoidRhumbLine();\n\n//Returns subdivided line scaled to ellipsoid surface starting at p1 and ending at p2.\n//Result includes p1, but not include p2.  This function is called for a sequence of line segments,\n//and this prevents duplication of end point.\nfunction generateCartesianArc(\n  p0,\n  p1,\n  minDistance,\n  ellipsoid,\n  h0,\n  h1,\n  array,\n  offset\n) {\n  var first = ellipsoid.scaleToGeodeticSurface(p0, scaleFirst);\n  var last = ellipsoid.scaleToGeodeticSurface(p1, scaleLast);\n  var numPoints = PolylinePipeline.numberOfPoints(p0, p1, minDistance);\n  var start = ellipsoid.cartesianToCartographic(first, carto1);\n  var end = ellipsoid.cartesianToCartographic(last, carto2);\n  var heights = subdivideHeights(numPoints, h0, h1);\n\n  ellipsoidGeodesic.setEndPoints(start, end);\n  var surfaceDistanceBetweenPoints =\n    ellipsoidGeodesic.surfaceDistance / numPoints;\n\n  var index = offset;\n  start.height = h0;\n  var cart = ellipsoid.cartographicToCartesian(start, cartesian);\n  Cartesian3.pack(cart, array, index);\n  index += 3;\n\n  for (var i = 1; i < numPoints; i++) {\n    var carto = ellipsoidGeodesic.interpolateUsingSurfaceDistance(\n      i * surfaceDistanceBetweenPoints,\n      carto2\n    );\n    carto.height = heights[i];\n    cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n    Cartesian3.pack(cart, array, index);\n    index += 3;\n  }\n\n  return index;\n}\n\n//Returns subdivided line scaled to ellipsoid surface starting at p1 and ending at p2.\n//Result includes p1, but not include p2.  This function is called for a sequence of line segments,\n//and this prevents duplication of end point.\nfunction generateCartesianRhumbArc(\n  p0,\n  p1,\n  granularity,\n  ellipsoid,\n  h0,\n  h1,\n  array,\n  offset\n) {\n  var start = ellipsoid.cartesianToCartographic(p0, carto1);\n  var end = ellipsoid.cartesianToCartographic(p1, carto2);\n  var numPoints = PolylinePipeline.numberOfPointsRhumbLine(\n    start,\n    end,\n    granularity\n  );\n  start.height = 0.0;\n  end.height = 0.0;\n  var heights = subdivideHeights(numPoints, h0, h1);\n\n  if (!ellipsoidRhumb.ellipsoid.equals(ellipsoid)) {\n    ellipsoidRhumb = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\n  }\n  ellipsoidRhumb.setEndPoints(start, end);\n  var surfaceDistanceBetweenPoints = ellipsoidRhumb.surfaceDistance / numPoints;\n\n  var index = offset;\n  start.height = h0;\n  var cart = ellipsoid.cartographicToCartesian(start, cartesian);\n  Cartesian3.pack(cart, array, index);\n  index += 3;\n\n  for (var i = 1; i < numPoints; i++) {\n    var carto = ellipsoidRhumb.interpolateUsingSurfaceDistance(\n      i * surfaceDistanceBetweenPoints,\n      carto2\n    );\n    carto.height = heights[i];\n    cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n    Cartesian3.pack(cart, array, index);\n    index += 3;\n  }\n\n  return index;\n}\n\n/**\n * Breaks a {@link Polyline} into segments such that it does not cross the &plusmn;180 degree meridian of an ellipsoid.\n *\n * @param {Cartesian3[]} positions The polyline's Cartesian positions.\n * @param {Matrix4} [modelMatrix=Matrix4.IDENTITY] The polyline's model matrix. Assumed to be an affine\n * transformation matrix, where the upper left 3x3 elements are a rotation matrix, and\n * the upper three elements in the fourth column are the translation.  The bottom row is assumed to be [0, 0, 0, 1].\n * The matrix is not verified to be in the proper form.\n * @returns {Object} An object with a <code>positions</code> property that is an array of positions and a\n * <code>segments</code> property.\n *\n *\n * @example\n * var polylines = new Cesium.PolylineCollection();\n * var polyline = polylines.add(...);\n * var positions = polyline.positions;\n * var modelMatrix = polylines.modelMatrix;\n * var segments = Cesium.PolylinePipeline.wrapLongitude(positions, modelMatrix);\n *\n * @see PolygonPipeline.wrapLongitude\n * @see Polyline\n * @see PolylineCollection\n */\nPolylinePipeline.wrapLongitude = function (positions, modelMatrix) {\n  var cartesians = [];\n  var segments = [];\n\n  if (defined(positions) && positions.length > 0) {\n    modelMatrix = defaultValue(modelMatrix, Matrix4.IDENTITY);\n    var inverseModelMatrix = Matrix4.inverseTransformation(\n      modelMatrix,\n      wrapLongitudeInversMatrix\n    );\n\n    var origin = Matrix4.multiplyByPoint(\n      inverseModelMatrix,\n      Cartesian3.ZERO,\n      wrapLongitudeOrigin\n    );\n    var xzNormal = Cartesian3.normalize(\n      Matrix4.multiplyByPointAsVector(\n        inverseModelMatrix,\n        Cartesian3.UNIT_Y,\n        wrapLongitudeXZNormal\n      ),\n      wrapLongitudeXZNormal\n    );\n    var xzPlane = Plane.fromPointNormal(origin, xzNormal, wrapLongitudeXZPlane);\n    var yzNormal = Cartesian3.normalize(\n      Matrix4.multiplyByPointAsVector(\n        inverseModelMatrix,\n        Cartesian3.UNIT_X,\n        wrapLongitudeYZNormal\n      ),\n      wrapLongitudeYZNormal\n    );\n    var yzPlane = Plane.fromPointNormal(origin, yzNormal, wrapLongitudeYZPlane);\n\n    var count = 1;\n    cartesians.push(Cartesian3.clone(positions[0]));\n    var prev = cartesians[0];\n\n    var length = positions.length;\n    for (var i = 1; i < length; ++i) {\n      var cur = positions[i];\n\n      // intersects the IDL if either endpoint is on the negative side of the yz-plane\n      if (\n        Plane.getPointDistance(yzPlane, prev) < 0.0 ||\n        Plane.getPointDistance(yzPlane, cur) < 0.0\n      ) {\n        // and intersects the xz-plane\n        var intersection = IntersectionTests.lineSegmentPlane(\n          prev,\n          cur,\n          xzPlane,\n          wrapLongitudeIntersection\n        );\n        if (defined(intersection)) {\n          // move point on the xz-plane slightly away from the plane\n          var offset = Cartesian3.multiplyByScalar(\n            xzNormal,\n            5.0e-9,\n            wrapLongitudeOffset\n          );\n          if (Plane.getPointDistance(xzPlane, prev) < 0.0) {\n            Cartesian3.negate(offset, offset);\n          }\n\n          cartesians.push(\n            Cartesian3.add(intersection, offset, new Cartesian3())\n          );\n          segments.push(count + 1);\n\n          Cartesian3.negate(offset, offset);\n          cartesians.push(\n            Cartesian3.add(intersection, offset, new Cartesian3())\n          );\n          count = 1;\n        }\n      }\n\n      cartesians.push(Cartesian3.clone(positions[i]));\n      count++;\n\n      prev = cur;\n    }\n\n    segments.push(count);\n  }\n\n  return {\n    positions: cartesians,\n    lengths: segments,\n  };\n};\n\n/**\n * Subdivides polyline and raises all points to the specified height.  Returns an array of numbers to represent the positions.\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\n * @returns {Number[]} A new array of positions of type {Number} that have been subdivided and raised to the surface of the ellipsoid.\n *\n * @example\n * var positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * var surfacePositions = Cesium.PolylinePipeline.generateArc({\n *   positons: positions\n * });\n */\nPolylinePipeline.generateArc = function (options) {\n  if (!defined(options)) {\n    options = {};\n  }\n  var positions = options.positions;\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions)) {\n    throw new DeveloperError(\"options.positions is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var length = positions.length;\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  var height = defaultValue(options.height, 0);\n  var hasHeightArray = Array.isArray(height);\n\n  if (length < 1) {\n    return [];\n  } else if (length === 1) {\n    var p = ellipsoid.scaleToGeodeticSurface(positions[0], scaleFirst);\n    height = hasHeightArray ? height[0] : height;\n    if (height !== 0) {\n      var n = ellipsoid.geodeticSurfaceNormal(p, cartesian);\n      Cartesian3.multiplyByScalar(n, height, n);\n      Cartesian3.add(p, n, p);\n    }\n\n    return [p.x, p.y, p.z];\n  }\n\n  var minDistance = options.minDistance;\n  if (!defined(minDistance)) {\n    var granularity = defaultValue(\n      options.granularity,\n      CesiumMath.RADIANS_PER_DEGREE\n    );\n    minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n  }\n\n  var numPoints = 0;\n  var i;\n\n  for (i = 0; i < length - 1; i++) {\n    numPoints += PolylinePipeline.numberOfPoints(\n      positions[i],\n      positions[i + 1],\n      minDistance\n    );\n  }\n\n  var arrayLength = (numPoints + 1) * 3;\n  var newPositions = new Array(arrayLength);\n  var offset = 0;\n\n  for (i = 0; i < length - 1; i++) {\n    var p0 = positions[i];\n    var p1 = positions[i + 1];\n\n    var h0 = hasHeightArray ? height[i] : height;\n    var h1 = hasHeightArray ? height[i + 1] : height;\n\n    offset = generateCartesianArc(\n      p0,\n      p1,\n      minDistance,\n      ellipsoid,\n      h0,\n      h1,\n      newPositions,\n      offset\n    );\n  }\n\n  subdivideHeightsScratchArray.length = 0;\n\n  var lastPoint = positions[length - 1];\n  var carto = ellipsoid.cartesianToCartographic(lastPoint, carto1);\n  carto.height = hasHeightArray ? height[length - 1] : height;\n  var cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n  Cartesian3.pack(cart, newPositions, arrayLength - 3);\n\n  return newPositions;\n};\n\nvar scratchCartographic0 = new Cartographic();\nvar scratchCartographic1 = new Cartographic();\n\n/**\n * Subdivides polyline and raises all points to the specified height using Rhumb lines.  Returns an array of numbers to represent the positions.\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\n * @returns {Number[]} A new array of positions of type {Number} that have been subdivided and raised to the surface of the ellipsoid.\n *\n * @example\n * var positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * var surfacePositions = Cesium.PolylinePipeline.generateRhumbArc({\n *   positons: positions\n * });\n */\nPolylinePipeline.generateRhumbArc = function (options) {\n  if (!defined(options)) {\n    options = {};\n  }\n  var positions = options.positions;\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(positions)) {\n    throw new DeveloperError(\"options.positions is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var length = positions.length;\n  var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n  var height = defaultValue(options.height, 0);\n  var hasHeightArray = Array.isArray(height);\n\n  if (length < 1) {\n    return [];\n  } else if (length === 1) {\n    var p = ellipsoid.scaleToGeodeticSurface(positions[0], scaleFirst);\n    height = hasHeightArray ? height[0] : height;\n    if (height !== 0) {\n      var n = ellipsoid.geodeticSurfaceNormal(p, cartesian);\n      Cartesian3.multiplyByScalar(n, height, n);\n      Cartesian3.add(p, n, p);\n    }\n\n    return [p.x, p.y, p.z];\n  }\n\n  var granularity = defaultValue(\n    options.granularity,\n    CesiumMath.RADIANS_PER_DEGREE\n  );\n\n  var numPoints = 0;\n  var i;\n\n  var c0 = ellipsoid.cartesianToCartographic(\n    positions[0],\n    scratchCartographic0\n  );\n  var c1;\n  for (i = 0; i < length - 1; i++) {\n    c1 = ellipsoid.cartesianToCartographic(\n      positions[i + 1],\n      scratchCartographic1\n    );\n    numPoints += PolylinePipeline.numberOfPointsRhumbLine(c0, c1, granularity);\n    c0 = Cartographic.clone(c1, scratchCartographic0);\n  }\n\n  var arrayLength = (numPoints + 1) * 3;\n  var newPositions = new Array(arrayLength);\n  var offset = 0;\n\n  for (i = 0; i < length - 1; i++) {\n    var p0 = positions[i];\n    var p1 = positions[i + 1];\n\n    var h0 = hasHeightArray ? height[i] : height;\n    var h1 = hasHeightArray ? height[i + 1] : height;\n\n    offset = generateCartesianRhumbArc(\n      p0,\n      p1,\n      granularity,\n      ellipsoid,\n      h0,\n      h1,\n      newPositions,\n      offset\n    );\n  }\n\n  subdivideHeightsScratchArray.length = 0;\n\n  var lastPoint = positions[length - 1];\n  var carto = ellipsoid.cartesianToCartographic(lastPoint, carto1);\n  carto.height = hasHeightArray ? height[length - 1] : height;\n  var cart = ellipsoid.cartographicToCartesian(carto, cartesian);\n  Cartesian3.pack(cart, newPositions, arrayLength - 3);\n\n  return newPositions;\n};\n\n/**\n * Subdivides polyline and raises all points to the specified height. Returns an array of new {Cartesian3} positions.\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\n * @returns {Cartesian3[]} A new array of cartesian3 positions that have been subdivided and raised to the surface of the ellipsoid.\n *\n * @example\n * var positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * var surfacePositions = Cesium.PolylinePipeline.generateCartesianArc({\n *   positons: positions\n * });\n */\nPolylinePipeline.generateCartesianArc = function (options) {\n  var numberArray = PolylinePipeline.generateArc(options);\n  var size = numberArray.length / 3;\n  var newPositions = new Array(size);\n  for (var i = 0; i < size; i++) {\n    newPositions[i] = Cartesian3.unpack(numberArray, i * 3);\n  }\n  return newPositions;\n};\n\n/**\n * Subdivides polyline and raises all points to the specified height using Rhumb Lines. Returns an array of new {Cartesian3} positions.\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3[]} options.positions The array of type {Cartesian3} representing positions.\n * @param {Number|Number[]} [options.height=0.0] A number or array of numbers representing the heights of each position.\n * @param {Number} [options.granularity = CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the positions lie.\n * @returns {Cartesian3[]} A new array of cartesian3 positions that have been subdivided and raised to the surface of the ellipsoid.\n *\n * @example\n * var positions = Cesium.Cartesian3.fromDegreesArray([\n *   -105.0, 40.0,\n *   -100.0, 38.0,\n *   -105.0, 35.0,\n *   -100.0, 32.0\n * ]);\n * var surfacePositions = Cesium.PolylinePipeline.generateCartesianRhumbArc({\n *   positons: positions\n * });\n */\nPolylinePipeline.generateCartesianRhumbArc = function (options) {\n  var numberArray = PolylinePipeline.generateRhumbArc(options);\n  var size = numberArray.length / 3;\n  var newPositions = new Array(size);\n  for (var i = 0; i < size; i++) {\n    newPositions[i] = Cartesian3.unpack(numberArray, i * 3);\n  }\n  return newPositions;\n};\nexport default PolylinePipeline;\n"]},"metadata":{},"sourceType":"module"}