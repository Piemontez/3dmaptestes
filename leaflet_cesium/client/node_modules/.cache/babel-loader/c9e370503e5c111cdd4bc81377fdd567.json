{"ast":null,"code":"import when from \"../ThirdParty/when.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport HeightmapEncoding from \"./HeightmapEncoding.js\";\nimport HeightmapTessellator from \"./HeightmapTessellator.js\";\nimport CesiumMath from \"./Math.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport TaskProcessor from \"./TaskProcessor.js\";\nimport TerrainData from \"./TerrainData.js\";\nimport TerrainEncoding from \"./TerrainEncoding.js\";\nimport TerrainMesh from \"./TerrainMesh.js\";\nimport TerrainProvider from \"./TerrainProvider.js\";\n/**\n * Terrain data for a single tile where the terrain data is represented as a heightmap.  A heightmap\n * is a rectangular array of heights in row-major order from north to south and west to east.\n *\n * @alias HeightmapTerrainData\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} options.buffer The buffer containing height data.\n * @param {Number} options.width The width (longitude direction) of the heightmap, in samples.\n * @param {Number} options.height The height (latitude direction) of the heightmap, in samples.\n * @param {Number} [options.childTileMask=15] A bit mask indicating which of this tile's four children exist.\n *                 If a child's bit is set, geometry will be requested for that tile as well when it\n *                 is needed.  If the bit is cleared, the child tile is not requested and geometry is\n *                 instead upsampled from the parent.  The bit values are as follows:\n *                 <table>\n *                  <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>\n *                  <tr><td>0</td><td>1</td><td>Southwest</td></tr>\n *                  <tr><td>1</td><td>2</td><td>Southeast</td></tr>\n *                  <tr><td>2</td><td>4</td><td>Northwest</td></tr>\n *                  <tr><td>3</td><td>8</td><td>Northeast</td></tr>\n *                 </table>\n * @param {Uint8Array} [options.waterMask] The water mask included in this terrain data, if any.  A water mask is a square\n *                     Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.\n *                     Values in between 0 and 255 are allowed as well to smoothly blend between land and water.\n * @param {Object} [options.structure] An object describing the structure of the height data.\n * @param {Number} [options.structure.heightScale=1.0] The factor by which to multiply height samples in order to obtain\n *                 the height above the heightOffset, in meters.  The heightOffset is added to the resulting\n *                 height after multiplying by the scale.\n * @param {Number} [options.structure.heightOffset=0.0] The offset to add to the scaled height to obtain the final\n *                 height in meters.  The offset is added after the height sample is multiplied by the\n *                 heightScale.\n * @param {Number} [options.structure.elementsPerHeight=1] The number of elements in the buffer that make up a single height\n *                 sample.  This is usually 1, indicating that each element is a separate height sample.  If\n *                 it is greater than 1, that number of elements together form the height sample, which is\n *                 computed according to the structure.elementMultiplier and structure.isBigEndian properties.\n * @param {Number} [options.structure.stride=1] The number of elements to skip to get from the first element of\n *                 one height to the first element of the next height.\n * @param {Number} [options.structure.elementMultiplier=256.0] The multiplier used to compute the height value when the\n *                 stride property is greater than 1.  For example, if the stride is 4 and the strideMultiplier\n *                 is 256, the height is computed as follows:\n *                 `height = buffer[index] + buffer[index + 1] * 256 + buffer[index + 2] * 256 * 256 + buffer[index + 3] * 256 * 256 * 256`\n *                 This is assuming that the isBigEndian property is false.  If it is true, the order of the\n *                 elements is reversed.\n * @param {Boolean} [options.structure.isBigEndian=false] Indicates endianness of the elements in the buffer when the\n *                  stride property is greater than 1.  If this property is false, the first element is the\n *                  low-order element.  If it is true, the first element is the high-order element.\n * @param {Number} [options.structure.lowestEncodedHeight] The lowest value that can be stored in the height buffer.  Any heights that are lower\n *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height\n *                 buffer is a `Uint16Array`, this value should be 0 because a `Uint16Array` cannot store negative numbers.  If this parameter is\n *                 not specified, no minimum value is enforced.\n * @param {Number} [options.structure.highestEncodedHeight] The highest value that can be stored in the height buffer.  Any heights that are higher\n *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height\n *                 buffer is a `Uint16Array`, this value should be `256 * 256 - 1` or 65535 because a `Uint16Array` cannot store numbers larger\n *                 than 65535.  If this parameter is not specified, no maximum value is enforced.\n * @param {HeightmapEncoding} [options.encoding=HeightmapEncoding.NONE] The encoding that is used on the buffer.\n * @param {Boolean} [options.createdByUpsampling=false] True if this instance was created by upsampling another instance;\n *                  otherwise, false.\n *\n *\n * @example\n * var buffer = ...\n * var heightBuffer = new Uint16Array(buffer, 0, that._heightmapWidth * that._heightmapWidth);\n * var childTileMask = new Uint8Array(buffer, heightBuffer.byteLength, 1)[0];\n * var waterMask = new Uint8Array(buffer, heightBuffer.byteLength + 1, buffer.byteLength - heightBuffer.byteLength - 1);\n * var terrainData = new Cesium.HeightmapTerrainData({\n *   buffer : heightBuffer,\n *   width : 65,\n *   height : 65,\n *   childTileMask : childTileMask,\n *   waterMask : waterMask\n * });\n *\n * @see TerrainData\n * @see QuantizedMeshTerrainData\n * @see GoogleEarthEnterpriseTerrainData\n */\n\nfunction HeightmapTerrainData(options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options) || !defined(options.buffer)) {\n    throw new DeveloperError(\"options.buffer is required.\");\n  }\n\n  if (!defined(options.width)) {\n    throw new DeveloperError(\"options.width is required.\");\n  }\n\n  if (!defined(options.height)) {\n    throw new DeveloperError(\"options.height is required.\");\n  } //>>includeEnd('debug');\n\n\n  this._buffer = options.buffer;\n  this._width = options.width;\n  this._height = options.height;\n  this._childTileMask = defaultValue(options.childTileMask, 15);\n  this._encoding = defaultValue(options.encoding, HeightmapEncoding.NONE);\n  var defaultStructure = HeightmapTessellator.DEFAULT_STRUCTURE;\n  var structure = options.structure;\n\n  if (!defined(structure)) {\n    structure = defaultStructure;\n  } else if (structure !== defaultStructure) {\n    structure.heightScale = defaultValue(structure.heightScale, defaultStructure.heightScale);\n    structure.heightOffset = defaultValue(structure.heightOffset, defaultStructure.heightOffset);\n    structure.elementsPerHeight = defaultValue(structure.elementsPerHeight, defaultStructure.elementsPerHeight);\n    structure.stride = defaultValue(structure.stride, defaultStructure.stride);\n    structure.elementMultiplier = defaultValue(structure.elementMultiplier, defaultStructure.elementMultiplier);\n    structure.isBigEndian = defaultValue(structure.isBigEndian, defaultStructure.isBigEndian);\n  }\n\n  this._structure = structure;\n  this._createdByUpsampling = defaultValue(options.createdByUpsampling, false);\n  this._waterMask = options.waterMask;\n  this._skirtHeight = undefined;\n  this._bufferType = this._encoding === HeightmapEncoding.LERC ? Float32Array : this._buffer.constructor;\n  this._mesh = undefined;\n}\n\nObject.defineProperties(HeightmapTerrainData.prototype, {\n  /**\n   * An array of credits for this tile.\n   * @memberof HeightmapTerrainData.prototype\n   * @type {Credit[]}\n   */\n  credits: {\n    get: function () {\n      return undefined;\n    }\n  },\n\n  /**\n   * The water mask included in this terrain data, if any.  A water mask is a square\n   * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.\n   * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.\n   * @memberof HeightmapTerrainData.prototype\n   * @type {Uint8Array|HTMLImageElement|HTMLCanvasElement}\n   */\n  waterMask: {\n    get: function () {\n      return this._waterMask;\n    }\n  },\n  childTileMask: {\n    get: function () {\n      return this._childTileMask;\n    }\n  }\n});\nvar createMeshTaskName = \"createVerticesFromHeightmap\";\nvar createMeshTaskProcessorNoThrottle = new TaskProcessor(createMeshTaskName);\nvar createMeshTaskProcessorThrottle = new TaskProcessor(createMeshTaskName, TerrainData.maximumAsynchronousTasks);\n/**\n * Creates a {@link TerrainMesh} from this terrain data.\n *\n * @private\n *\n * @param {Object} options Object with the following properties:\n * @param {TilingScheme} options.tilingScheme The tiling scheme to which this tile belongs.\n * @param {Number} options.x The X coordinate of the tile for which to create the terrain data.\n * @param {Number} options.y The Y coordinate of the tile for which to create the terrain data.\n * @param {Number} options.level The level of the tile for which to create the terrain data.\n * @param {Number} [options.exaggeration=1.0] The scale used to exaggerate the terrain.\n * @param {Boolean} [options.throttle=true] If true, indicates that this operation will need to be retried if too many asynchronous mesh creations are already in progress.\n * @returns {Promise.<TerrainMesh>|undefined} A promise for the terrain mesh, or undefined if too many\n *          asynchronous mesh creations are already in progress and the operation should\n *          be retried later.\n */\n\nHeightmapTerrainData.prototype.createMesh = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT); //>>includeStart('debug', pragmas.debug);\n\n  Check.typeOf.object(\"options.tilingScheme\", options.tilingScheme);\n  Check.typeOf.number(\"options.x\", options.x);\n  Check.typeOf.number(\"options.y\", options.y);\n  Check.typeOf.number(\"options.level\", options.level); //>>includeEnd('debug');\n\n  var tilingScheme = options.tilingScheme;\n  var x = options.x;\n  var y = options.y;\n  var level = options.level;\n  var exaggeration = defaultValue(options.exaggeration, 1.0);\n  var throttle = defaultValue(options.throttle, true);\n  var ellipsoid = tilingScheme.ellipsoid;\n  var nativeRectangle = tilingScheme.tileXYToNativeRectangle(x, y, level);\n  var rectangle = tilingScheme.tileXYToRectangle(x, y, level); // Compute the center of the tile for RTC rendering.\n\n  var center = ellipsoid.cartographicToCartesian(Rectangle.center(rectangle));\n  var structure = this._structure;\n  var levelZeroMaxError = TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(ellipsoid, this._width, tilingScheme.getNumberOfXTilesAtLevel(0));\n  var thisLevelMaxError = levelZeroMaxError / (1 << level);\n  this._skirtHeight = Math.min(thisLevelMaxError * 4.0, 1000.0);\n  var createMeshTaskProcessor = throttle ? createMeshTaskProcessorThrottle : createMeshTaskProcessorNoThrottle;\n  var verticesPromise = createMeshTaskProcessor.scheduleTask({\n    heightmap: this._buffer,\n    structure: structure,\n    includeWebMercatorT: true,\n    width: this._width,\n    height: this._height,\n    nativeRectangle: nativeRectangle,\n    rectangle: rectangle,\n    relativeToCenter: center,\n    ellipsoid: ellipsoid,\n    skirtHeight: this._skirtHeight,\n    isGeographic: tilingScheme.projection instanceof GeographicProjection,\n    exaggeration: exaggeration,\n    encoding: this._encoding\n  });\n\n  if (!defined(verticesPromise)) {\n    // Postponed\n    return undefined;\n  }\n\n  var that = this;\n  return when(verticesPromise, function (result) {\n    var indicesAndEdges;\n\n    if (that._skirtHeight > 0.0) {\n      indicesAndEdges = TerrainProvider.getRegularGridAndSkirtIndicesAndEdgeIndices(result.gridWidth, result.gridHeight);\n    } else {\n      indicesAndEdges = TerrainProvider.getRegularGridIndicesAndEdgeIndices(result.gridWidth, result.gridHeight);\n    }\n\n    var vertexCountWithoutSkirts = result.gridWidth * result.gridHeight; // Clone complex result objects because the transfer from the web worker\n    // has stripped them down to JSON-style objects.\n\n    that._mesh = new TerrainMesh(center, new Float32Array(result.vertices), indicesAndEdges.indices, indicesAndEdges.indexCountWithoutSkirts, vertexCountWithoutSkirts, result.minimumHeight, result.maximumHeight, BoundingSphere.clone(result.boundingSphere3D), Cartesian3.clone(result.occludeePointInScaledSpace), result.numberOfAttributes, OrientedBoundingBox.clone(result.orientedBoundingBox), TerrainEncoding.clone(result.encoding), exaggeration, indicesAndEdges.westIndicesSouthToNorth, indicesAndEdges.southIndicesEastToWest, indicesAndEdges.eastIndicesNorthToSouth, indicesAndEdges.northIndicesWestToEast); // Free memory received from server after mesh is created.\n\n    that._buffer = undefined;\n    return that._mesh;\n  });\n};\n/**\n * @param {Object} options Object with the following properties:\n * @param {TilingScheme} options.tilingScheme The tiling scheme to which this tile belongs.\n * @param {Number} options.x The X coordinate of the tile for which to create the terrain data.\n * @param {Number} options.y The Y coordinate of the tile for which to create the terrain data.\n * @param {Number} options.level The level of the tile for which to create the terrain data.\n * @param {Number} [options.exaggeration=1.0] The scale used to exaggerate the terrain.\n *\n * @private\n */\n\n\nHeightmapTerrainData.prototype._createMeshSync = function (options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.tilingScheme\", options.tilingScheme);\n  Check.typeOf.number(\"options.x\", options.x);\n  Check.typeOf.number(\"options.y\", options.y);\n  Check.typeOf.number(\"options.level\", options.level); //>>includeEnd('debug');\n\n  var tilingScheme = options.tilingScheme;\n  var x = options.x;\n  var y = options.y;\n  var level = options.level;\n  var exaggeration = defaultValue(options.exaggeration, 1.0);\n  var ellipsoid = tilingScheme.ellipsoid;\n  var nativeRectangle = tilingScheme.tileXYToNativeRectangle(x, y, level);\n  var rectangle = tilingScheme.tileXYToRectangle(x, y, level); // Compute the center of the tile for RTC rendering.\n\n  var center = ellipsoid.cartographicToCartesian(Rectangle.center(rectangle));\n  var structure = this._structure;\n  var levelZeroMaxError = TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(ellipsoid, this._width, tilingScheme.getNumberOfXTilesAtLevel(0));\n  var thisLevelMaxError = levelZeroMaxError / (1 << level);\n  this._skirtHeight = Math.min(thisLevelMaxError * 4.0, 1000.0);\n  var result = HeightmapTessellator.computeVertices({\n    heightmap: this._buffer,\n    structure: structure,\n    includeWebMercatorT: true,\n    width: this._width,\n    height: this._height,\n    nativeRectangle: nativeRectangle,\n    rectangle: rectangle,\n    relativeToCenter: center,\n    ellipsoid: ellipsoid,\n    skirtHeight: this._skirtHeight,\n    isGeographic: tilingScheme.projection instanceof GeographicProjection,\n    exaggeration: exaggeration\n  }); // Free memory received from server after mesh is created.\n\n  this._buffer = undefined;\n  var indicesAndEdges;\n\n  if (this._skirtHeight > 0.0) {\n    indicesAndEdges = TerrainProvider.getRegularGridAndSkirtIndicesAndEdgeIndices(this._width, this._height);\n  } else {\n    indicesAndEdges = TerrainProvider.getRegularGridIndicesAndEdgeIndices(this._width, this._height);\n  }\n\n  var vertexCountWithoutSkirts = result.gridWidth * result.gridHeight; // No need to clone here (as we do in the async version) because the result\n  // is not coming from a web worker.\n\n  return new TerrainMesh(center, result.vertices, indicesAndEdges.indices, indicesAndEdges.indexCountWithoutSkirts, vertexCountWithoutSkirts, result.minimumHeight, result.maximumHeight, result.boundingSphere3D, result.occludeePointInScaledSpace, result.encoding.getStride(), result.orientedBoundingBox, result.encoding, exaggeration, indicesAndEdges.westIndicesSouthToNorth, indicesAndEdges.southIndicesEastToWest, indicesAndEdges.eastIndicesNorthToSouth, indicesAndEdges.northIndicesWestToEast);\n};\n/**\n * Computes the terrain height at a specified longitude and latitude.\n *\n * @param {Rectangle} rectangle The rectangle covered by this terrain data.\n * @param {Number} longitude The longitude in radians.\n * @param {Number} latitude The latitude in radians.\n * @returns {Number} The terrain height at the specified position.  If the position\n *          is outside the rectangle, this method will extrapolate the height, which is likely to be wildly\n *          incorrect for positions far outside the rectangle.\n */\n\n\nHeightmapTerrainData.prototype.interpolateHeight = function (rectangle, longitude, latitude) {\n  var width = this._width;\n  var height = this._height;\n  var structure = this._structure;\n  var stride = structure.stride;\n  var elementsPerHeight = structure.elementsPerHeight;\n  var elementMultiplier = structure.elementMultiplier;\n  var isBigEndian = structure.isBigEndian;\n  var heightOffset = structure.heightOffset;\n  var heightScale = structure.heightScale;\n  var isMeshCreated = defined(this._mesh);\n  var isLERCEncoding = this._encoding === HeightmapEncoding.LERC;\n  var isInterpolationImpossible = !isMeshCreated && isLERCEncoding;\n\n  if (isInterpolationImpossible) {\n    // We can't interpolate using the buffer because it's LERC encoded\n    //  so please call createMesh() first and interpolate using the mesh;\n    //  as mesh creation will decode the LERC buffer\n    return undefined;\n  }\n\n  var heightSample;\n\n  if (isMeshCreated) {\n    var buffer = this._mesh.vertices;\n    var encoding = this._mesh.encoding;\n    var exaggeration = this._mesh.exaggeration;\n    heightSample = interpolateMeshHeight(buffer, encoding, heightOffset, heightScale, rectangle, width, height, longitude, latitude, exaggeration);\n  } else {\n    heightSample = interpolateHeight(this._buffer, elementsPerHeight, elementMultiplier, stride, isBigEndian, rectangle, width, height, longitude, latitude);\n    heightSample = heightSample * heightScale + heightOffset;\n  }\n\n  return heightSample;\n};\n/**\n * Upsamples this terrain data for use by a descendant tile.  The resulting instance will contain a subset of the\n * height samples in this instance, interpolated if necessary.\n *\n * @param {TilingScheme} tilingScheme The tiling scheme of this terrain data.\n * @param {Number} thisX The X coordinate of this tile in the tiling scheme.\n * @param {Number} thisY The Y coordinate of this tile in the tiling scheme.\n * @param {Number} thisLevel The level of this tile in the tiling scheme.\n * @param {Number} descendantX The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {Number} descendantY The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {Number} descendantLevel The level within the tiling scheme of the descendant tile for which we are upsampling.\n * @returns {Promise.<HeightmapTerrainData>|undefined} A promise for upsampled heightmap terrain data for the descendant tile,\n *          or undefined if too many asynchronous upsample operations are in progress and the request has been\n *          deferred.\n */\n\n\nHeightmapTerrainData.prototype.upsample = function (tilingScheme, thisX, thisY, thisLevel, descendantX, descendantY, descendantLevel) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(tilingScheme)) {\n    throw new DeveloperError(\"tilingScheme is required.\");\n  }\n\n  if (!defined(thisX)) {\n    throw new DeveloperError(\"thisX is required.\");\n  }\n\n  if (!defined(thisY)) {\n    throw new DeveloperError(\"thisY is required.\");\n  }\n\n  if (!defined(thisLevel)) {\n    throw new DeveloperError(\"thisLevel is required.\");\n  }\n\n  if (!defined(descendantX)) {\n    throw new DeveloperError(\"descendantX is required.\");\n  }\n\n  if (!defined(descendantY)) {\n    throw new DeveloperError(\"descendantY is required.\");\n  }\n\n  if (!defined(descendantLevel)) {\n    throw new DeveloperError(\"descendantLevel is required.\");\n  }\n\n  var levelDifference = descendantLevel - thisLevel;\n\n  if (levelDifference > 1) {\n    throw new DeveloperError(\"Upsampling through more than one level at a time is not currently supported.\");\n  } //>>includeEnd('debug');\n\n\n  var meshData = this._mesh;\n\n  if (!defined(meshData)) {\n    return undefined;\n  }\n\n  var width = this._width;\n  var height = this._height;\n  var structure = this._structure;\n  var stride = structure.stride;\n  var heights = new this._bufferType(width * height * stride);\n  var buffer = meshData.vertices;\n  var encoding = meshData.encoding; // PERFORMANCE_IDEA: don't recompute these rectangles - the caller already knows them.\n\n  var sourceRectangle = tilingScheme.tileXYToRectangle(thisX, thisY, thisLevel);\n  var destinationRectangle = tilingScheme.tileXYToRectangle(descendantX, descendantY, descendantLevel);\n  var heightOffset = structure.heightOffset;\n  var heightScale = structure.heightScale;\n  var exaggeration = meshData.exaggeration;\n  var elementsPerHeight = structure.elementsPerHeight;\n  var elementMultiplier = structure.elementMultiplier;\n  var isBigEndian = structure.isBigEndian;\n  var divisor = Math.pow(elementMultiplier, elementsPerHeight - 1);\n\n  for (var j = 0; j < height; ++j) {\n    var latitude = CesiumMath.lerp(destinationRectangle.north, destinationRectangle.south, j / (height - 1));\n\n    for (var i = 0; i < width; ++i) {\n      var longitude = CesiumMath.lerp(destinationRectangle.west, destinationRectangle.east, i / (width - 1));\n      var heightSample = interpolateMeshHeight(buffer, encoding, heightOffset, heightScale, sourceRectangle, width, height, longitude, latitude, exaggeration); // Use conditionals here instead of Math.min and Math.max so that an undefined\n      // lowestEncodedHeight or highestEncodedHeight has no effect.\n\n      heightSample = heightSample < structure.lowestEncodedHeight ? structure.lowestEncodedHeight : heightSample;\n      heightSample = heightSample > structure.highestEncodedHeight ? structure.highestEncodedHeight : heightSample;\n      setHeight(heights, elementsPerHeight, elementMultiplier, divisor, stride, isBigEndian, j * width + i, heightSample);\n    }\n  }\n\n  return new HeightmapTerrainData({\n    buffer: heights,\n    width: width,\n    height: height,\n    childTileMask: 0,\n    structure: this._structure,\n    createdByUpsampling: true\n  });\n};\n/**\n * Determines if a given child tile is available, based on the\n * {@link HeightmapTerrainData.childTileMask}.  The given child tile coordinates are assumed\n * to be one of the four children of this tile.  If non-child tile coordinates are\n * given, the availability of the southeast child tile is returned.\n *\n * @param {Number} thisX The tile X coordinate of this (the parent) tile.\n * @param {Number} thisY The tile Y coordinate of this (the parent) tile.\n * @param {Number} childX The tile X coordinate of the child tile to check for availability.\n * @param {Number} childY The tile Y coordinate of the child tile to check for availability.\n * @returns {Boolean} True if the child tile is available; otherwise, false.\n */\n\n\nHeightmapTerrainData.prototype.isChildAvailable = function (thisX, thisY, childX, childY) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(thisX)) {\n    throw new DeveloperError(\"thisX is required.\");\n  }\n\n  if (!defined(thisY)) {\n    throw new DeveloperError(\"thisY is required.\");\n  }\n\n  if (!defined(childX)) {\n    throw new DeveloperError(\"childX is required.\");\n  }\n\n  if (!defined(childY)) {\n    throw new DeveloperError(\"childY is required.\");\n  } //>>includeEnd('debug');\n\n\n  var bitNumber = 2; // northwest child\n\n  if (childX !== thisX * 2) {\n    ++bitNumber; // east child\n  }\n\n  if (childY !== thisY * 2) {\n    bitNumber -= 2; // south child\n  }\n\n  return (this._childTileMask & 1 << bitNumber) !== 0;\n};\n/**\n * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution\n * terrain data.  If this value is false, the data was obtained from some other source, such\n * as by downloading it from a remote server.  This method should return true for instances\n * returned from a call to {@link HeightmapTerrainData#upsample}.\n *\n * @returns {Boolean} True if this instance was created by upsampling; otherwise, false.\n */\n\n\nHeightmapTerrainData.prototype.wasCreatedByUpsampling = function () {\n  return this._createdByUpsampling;\n};\n\nfunction interpolateHeight(sourceHeights, elementsPerHeight, elementMultiplier, stride, isBigEndian, sourceRectangle, width, height, longitude, latitude) {\n  var fromWest = (longitude - sourceRectangle.west) * (width - 1) / (sourceRectangle.east - sourceRectangle.west);\n  var fromSouth = (latitude - sourceRectangle.south) * (height - 1) / (sourceRectangle.north - sourceRectangle.south);\n  var westInteger = fromWest | 0;\n  var eastInteger = westInteger + 1;\n\n  if (eastInteger >= width) {\n    eastInteger = width - 1;\n    westInteger = width - 2;\n  }\n\n  var southInteger = fromSouth | 0;\n  var northInteger = southInteger + 1;\n\n  if (northInteger >= height) {\n    northInteger = height - 1;\n    southInteger = height - 2;\n  }\n\n  var dx = fromWest - westInteger;\n  var dy = fromSouth - southInteger;\n  southInteger = height - 1 - southInteger;\n  northInteger = height - 1 - northInteger;\n  var southwestHeight = getHeight(sourceHeights, elementsPerHeight, elementMultiplier, stride, isBigEndian, southInteger * width + westInteger);\n  var southeastHeight = getHeight(sourceHeights, elementsPerHeight, elementMultiplier, stride, isBigEndian, southInteger * width + eastInteger);\n  var northwestHeight = getHeight(sourceHeights, elementsPerHeight, elementMultiplier, stride, isBigEndian, northInteger * width + westInteger);\n  var northeastHeight = getHeight(sourceHeights, elementsPerHeight, elementMultiplier, stride, isBigEndian, northInteger * width + eastInteger);\n  return triangleInterpolateHeight(dx, dy, southwestHeight, southeastHeight, northwestHeight, northeastHeight);\n}\n\nfunction interpolateMeshHeight(buffer, encoding, heightOffset, heightScale, sourceRectangle, width, height, longitude, latitude, exaggeration) {\n  // returns a height encoded according to the structure's heightScale and heightOffset.\n  var fromWest = (longitude - sourceRectangle.west) * (width - 1) / (sourceRectangle.east - sourceRectangle.west);\n  var fromSouth = (latitude - sourceRectangle.south) * (height - 1) / (sourceRectangle.north - sourceRectangle.south);\n  var westInteger = fromWest | 0;\n  var eastInteger = westInteger + 1;\n\n  if (eastInteger >= width) {\n    eastInteger = width - 1;\n    westInteger = width - 2;\n  }\n\n  var southInteger = fromSouth | 0;\n  var northInteger = southInteger + 1;\n\n  if (northInteger >= height) {\n    northInteger = height - 1;\n    southInteger = height - 2;\n  }\n\n  var dx = fromWest - westInteger;\n  var dy = fromSouth - southInteger;\n  southInteger = height - 1 - southInteger;\n  northInteger = height - 1 - northInteger;\n  var southwestHeight = (encoding.decodeHeight(buffer, southInteger * width + westInteger) / exaggeration - heightOffset) / heightScale;\n  var southeastHeight = (encoding.decodeHeight(buffer, southInteger * width + eastInteger) / exaggeration - heightOffset) / heightScale;\n  var northwestHeight = (encoding.decodeHeight(buffer, northInteger * width + westInteger) / exaggeration - heightOffset) / heightScale;\n  var northeastHeight = (encoding.decodeHeight(buffer, northInteger * width + eastInteger) / exaggeration - heightOffset) / heightScale;\n  return triangleInterpolateHeight(dx, dy, southwestHeight, southeastHeight, northwestHeight, northeastHeight);\n}\n\nfunction triangleInterpolateHeight(dX, dY, southwestHeight, southeastHeight, northwestHeight, northeastHeight) {\n  // The HeightmapTessellator bisects the quad from southwest to northeast.\n  if (dY < dX) {\n    // Lower right triangle\n    return southwestHeight + dX * (southeastHeight - southwestHeight) + dY * (northeastHeight - southeastHeight);\n  } // Upper left triangle\n\n\n  return southwestHeight + dX * (northeastHeight - northwestHeight) + dY * (northwestHeight - southwestHeight);\n}\n\nfunction getHeight(heights, elementsPerHeight, elementMultiplier, stride, isBigEndian, index) {\n  index *= stride;\n  var height = 0;\n  var i;\n\n  if (isBigEndian) {\n    for (i = 0; i < elementsPerHeight; ++i) {\n      height = height * elementMultiplier + heights[index + i];\n    }\n  } else {\n    for (i = elementsPerHeight - 1; i >= 0; --i) {\n      height = height * elementMultiplier + heights[index + i];\n    }\n  }\n\n  return height;\n}\n\nfunction setHeight(heights, elementsPerHeight, elementMultiplier, divisor, stride, isBigEndian, index, height) {\n  index *= stride;\n  var i;\n\n  if (isBigEndian) {\n    for (i = 0; i < elementsPerHeight - 1; ++i) {\n      heights[index + i] = height / divisor | 0;\n      height -= heights[index + i] * divisor;\n      divisor /= elementMultiplier;\n    }\n  } else {\n    for (i = elementsPerHeight - 1; i > 0; --i) {\n      heights[index + i] = height / divisor | 0;\n      height -= heights[index + i] * divisor;\n      divisor /= elementMultiplier;\n    }\n  }\n\n  heights[index + i] = height;\n}\n\nexport default HeightmapTerrainData;","map":{"version":3,"sources":["/home/usuario/davi/thalamus/wms/3dmaptestes/leaflet_cesium/client/node_modules/cesium/Source/Core/HeightmapTerrainData.js"],"names":["when","BoundingSphere","Cartesian3","Check","defaultValue","defined","DeveloperError","GeographicProjection","HeightmapEncoding","HeightmapTessellator","CesiumMath","OrientedBoundingBox","Rectangle","TaskProcessor","TerrainData","TerrainEncoding","TerrainMesh","TerrainProvider","HeightmapTerrainData","options","buffer","width","height","_buffer","_width","_height","_childTileMask","childTileMask","_encoding","encoding","NONE","defaultStructure","DEFAULT_STRUCTURE","structure","heightScale","heightOffset","elementsPerHeight","stride","elementMultiplier","isBigEndian","_structure","_createdByUpsampling","createdByUpsampling","_waterMask","waterMask","_skirtHeight","undefined","_bufferType","LERC","Float32Array","constructor","_mesh","Object","defineProperties","prototype","credits","get","createMeshTaskName","createMeshTaskProcessorNoThrottle","createMeshTaskProcessorThrottle","maximumAsynchronousTasks","createMesh","EMPTY_OBJECT","typeOf","object","tilingScheme","number","x","y","level","exaggeration","throttle","ellipsoid","nativeRectangle","tileXYToNativeRectangle","rectangle","tileXYToRectangle","center","cartographicToCartesian","levelZeroMaxError","getEstimatedLevelZeroGeometricErrorForAHeightmap","getNumberOfXTilesAtLevel","thisLevelMaxError","Math","min","createMeshTaskProcessor","verticesPromise","scheduleTask","heightmap","includeWebMercatorT","relativeToCenter","skirtHeight","isGeographic","projection","that","result","indicesAndEdges","getRegularGridAndSkirtIndicesAndEdgeIndices","gridWidth","gridHeight","getRegularGridIndicesAndEdgeIndices","vertexCountWithoutSkirts","vertices","indices","indexCountWithoutSkirts","minimumHeight","maximumHeight","clone","boundingSphere3D","occludeePointInScaledSpace","numberOfAttributes","orientedBoundingBox","westIndicesSouthToNorth","southIndicesEastToWest","eastIndicesNorthToSouth","northIndicesWestToEast","_createMeshSync","computeVertices","getStride","interpolateHeight","longitude","latitude","isMeshCreated","isLERCEncoding","isInterpolationImpossible","heightSample","interpolateMeshHeight","upsample","thisX","thisY","thisLevel","descendantX","descendantY","descendantLevel","levelDifference","meshData","heights","sourceRectangle","destinationRectangle","divisor","pow","j","lerp","north","south","i","west","east","lowestEncodedHeight","highestEncodedHeight","setHeight","isChildAvailable","childX","childY","bitNumber","wasCreatedByUpsampling","sourceHeights","fromWest","fromSouth","westInteger","eastInteger","southInteger","northInteger","dx","dy","southwestHeight","getHeight","southeastHeight","northwestHeight","northeastHeight","triangleInterpolateHeight","decodeHeight","dX","dY","index"],"mappings":"AAAA,OAAOA,IAAP,MAAiB,uBAAjB;AACA,OAAOC,cAAP,MAA2B,qBAA3B;AACA,OAAOC,UAAP,MAAuB,iBAAvB;AACA,OAAOC,KAAP,MAAkB,YAAlB;AACA,OAAOC,YAAP,MAAyB,mBAAzB;AACA,OAAOC,OAAP,MAAoB,cAApB;AACA,OAAOC,cAAP,MAA2B,qBAA3B;AACA,OAAOC,oBAAP,MAAiC,2BAAjC;AACA,OAAOC,iBAAP,MAA8B,wBAA9B;AACA,OAAOC,oBAAP,MAAiC,2BAAjC;AACA,OAAOC,UAAP,MAAuB,WAAvB;AACA,OAAOC,mBAAP,MAAgC,0BAAhC;AACA,OAAOC,SAAP,MAAsB,gBAAtB;AACA,OAAOC,aAAP,MAA0B,oBAA1B;AACA,OAAOC,WAAP,MAAwB,kBAAxB;AACA,OAAOC,eAAP,MAA4B,sBAA5B;AACA,OAAOC,WAAP,MAAwB,kBAAxB;AACA,OAAOC,eAAP,MAA4B,sBAA5B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,oBAAT,CAA8BC,OAA9B,EAAuC;AACrC;AACA,MAAI,CAACd,OAAO,CAACc,OAAD,CAAR,IAAqB,CAACd,OAAO,CAACc,OAAO,CAACC,MAAT,CAAjC,EAAmD;AACjD,UAAM,IAAId,cAAJ,CAAmB,6BAAnB,CAAN;AACD;;AACD,MAAI,CAACD,OAAO,CAACc,OAAO,CAACE,KAAT,CAAZ,EAA6B;AAC3B,UAAM,IAAIf,cAAJ,CAAmB,4BAAnB,CAAN;AACD;;AACD,MAAI,CAACD,OAAO,CAACc,OAAO,CAACG,MAAT,CAAZ,EAA8B;AAC5B,UAAM,IAAIhB,cAAJ,CAAmB,6BAAnB,CAAN;AACD,GAVoC,CAWrC;;;AAEA,OAAKiB,OAAL,GAAeJ,OAAO,CAACC,MAAvB;AACA,OAAKI,MAAL,GAAcL,OAAO,CAACE,KAAtB;AACA,OAAKI,OAAL,GAAeN,OAAO,CAACG,MAAvB;AACA,OAAKI,cAAL,GAAsBtB,YAAY,CAACe,OAAO,CAACQ,aAAT,EAAwB,EAAxB,CAAlC;AACA,OAAKC,SAAL,GAAiBxB,YAAY,CAACe,OAAO,CAACU,QAAT,EAAmBrB,iBAAiB,CAACsB,IAArC,CAA7B;AAEA,MAAIC,gBAAgB,GAAGtB,oBAAoB,CAACuB,iBAA5C;AACA,MAAIC,SAAS,GAAGd,OAAO,CAACc,SAAxB;;AACA,MAAI,CAAC5B,OAAO,CAAC4B,SAAD,CAAZ,EAAyB;AACvBA,IAAAA,SAAS,GAAGF,gBAAZ;AACD,GAFD,MAEO,IAAIE,SAAS,KAAKF,gBAAlB,EAAoC;AACzCE,IAAAA,SAAS,CAACC,WAAV,GAAwB9B,YAAY,CAClC6B,SAAS,CAACC,WADwB,EAElCH,gBAAgB,CAACG,WAFiB,CAApC;AAIAD,IAAAA,SAAS,CAACE,YAAV,GAAyB/B,YAAY,CACnC6B,SAAS,CAACE,YADyB,EAEnCJ,gBAAgB,CAACI,YAFkB,CAArC;AAIAF,IAAAA,SAAS,CAACG,iBAAV,GAA8BhC,YAAY,CACxC6B,SAAS,CAACG,iBAD8B,EAExCL,gBAAgB,CAACK,iBAFuB,CAA1C;AAIAH,IAAAA,SAAS,CAACI,MAAV,GAAmBjC,YAAY,CAAC6B,SAAS,CAACI,MAAX,EAAmBN,gBAAgB,CAACM,MAApC,CAA/B;AACAJ,IAAAA,SAAS,CAACK,iBAAV,GAA8BlC,YAAY,CACxC6B,SAAS,CAACK,iBAD8B,EAExCP,gBAAgB,CAACO,iBAFuB,CAA1C;AAIAL,IAAAA,SAAS,CAACM,WAAV,GAAwBnC,YAAY,CAClC6B,SAAS,CAACM,WADwB,EAElCR,gBAAgB,CAACQ,WAFiB,CAApC;AAID;;AAED,OAAKC,UAAL,GAAkBP,SAAlB;AACA,OAAKQ,oBAAL,GAA4BrC,YAAY,CAACe,OAAO,CAACuB,mBAAT,EAA8B,KAA9B,CAAxC;AACA,OAAKC,UAAL,GAAkBxB,OAAO,CAACyB,SAA1B;AAEA,OAAKC,YAAL,GAAoBC,SAApB;AACA,OAAKC,WAAL,GACE,KAAKnB,SAAL,KAAmBpB,iBAAiB,CAACwC,IAArC,GACIC,YADJ,GAEI,KAAK1B,OAAL,CAAa2B,WAHnB;AAIA,OAAKC,KAAL,GAAaL,SAAb;AACD;;AAEDM,MAAM,CAACC,gBAAP,CAAwBnC,oBAAoB,CAACoC,SAA7C,EAAwD;AACtD;AACF;AACA;AACA;AACA;AACEC,EAAAA,OAAO,EAAE;AACPC,IAAAA,GAAG,EAAE,YAAY;AACf,aAAOV,SAAP;AACD;AAHM,GAN6C;;AAWtD;AACF;AACA;AACA;AACA;AACA;AACA;AACEF,EAAAA,SAAS,EAAE;AACTY,IAAAA,GAAG,EAAE,YAAY;AACf,aAAO,KAAKb,UAAZ;AACD;AAHQ,GAlB2C;AAwBtDhB,EAAAA,aAAa,EAAE;AACb6B,IAAAA,GAAG,EAAE,YAAY;AACf,aAAO,KAAK9B,cAAZ;AACD;AAHY;AAxBuC,CAAxD;AA+BA,IAAI+B,kBAAkB,GAAG,6BAAzB;AACA,IAAIC,iCAAiC,GAAG,IAAI7C,aAAJ,CAAkB4C,kBAAlB,CAAxC;AACA,IAAIE,+BAA+B,GAAG,IAAI9C,aAAJ,CACpC4C,kBADoC,EAEpC3C,WAAW,CAAC8C,wBAFwB,CAAtC;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA1C,oBAAoB,CAACoC,SAArB,CAA+BO,UAA/B,GAA4C,UAAU1C,OAAV,EAAmB;AAC7DA,EAAAA,OAAO,GAAGf,YAAY,CAACe,OAAD,EAAUf,YAAY,CAAC0D,YAAvB,CAAtB,CAD6D,CAG7D;;AACA3D,EAAAA,KAAK,CAAC4D,MAAN,CAAaC,MAAb,CAAoB,sBAApB,EAA4C7C,OAAO,CAAC8C,YAApD;AACA9D,EAAAA,KAAK,CAAC4D,MAAN,CAAaG,MAAb,CAAoB,WAApB,EAAiC/C,OAAO,CAACgD,CAAzC;AACAhE,EAAAA,KAAK,CAAC4D,MAAN,CAAaG,MAAb,CAAoB,WAApB,EAAiC/C,OAAO,CAACiD,CAAzC;AACAjE,EAAAA,KAAK,CAAC4D,MAAN,CAAaG,MAAb,CAAoB,eAApB,EAAqC/C,OAAO,CAACkD,KAA7C,EAP6D,CAQ7D;;AAEA,MAAIJ,YAAY,GAAG9C,OAAO,CAAC8C,YAA3B;AACA,MAAIE,CAAC,GAAGhD,OAAO,CAACgD,CAAhB;AACA,MAAIC,CAAC,GAAGjD,OAAO,CAACiD,CAAhB;AACA,MAAIC,KAAK,GAAGlD,OAAO,CAACkD,KAApB;AACA,MAAIC,YAAY,GAAGlE,YAAY,CAACe,OAAO,CAACmD,YAAT,EAAuB,GAAvB,CAA/B;AACA,MAAIC,QAAQ,GAAGnE,YAAY,CAACe,OAAO,CAACoD,QAAT,EAAmB,IAAnB,CAA3B;AAEA,MAAIC,SAAS,GAAGP,YAAY,CAACO,SAA7B;AACA,MAAIC,eAAe,GAAGR,YAAY,CAACS,uBAAb,CAAqCP,CAArC,EAAwCC,CAAxC,EAA2CC,KAA3C,CAAtB;AACA,MAAIM,SAAS,GAAGV,YAAY,CAACW,iBAAb,CAA+BT,CAA/B,EAAkCC,CAAlC,EAAqCC,KAArC,CAAhB,CAnB6D,CAqB7D;;AACA,MAAIQ,MAAM,GAAGL,SAAS,CAACM,uBAAV,CAAkClE,SAAS,CAACiE,MAAV,CAAiBF,SAAjB,CAAlC,CAAb;AAEA,MAAI1C,SAAS,GAAG,KAAKO,UAArB;AAEA,MAAIuC,iBAAiB,GAAG9D,eAAe,CAAC+D,gDAAhB,CACtBR,SADsB,EAEtB,KAAKhD,MAFiB,EAGtByC,YAAY,CAACgB,wBAAb,CAAsC,CAAtC,CAHsB,CAAxB;AAKA,MAAIC,iBAAiB,GAAGH,iBAAiB,IAAI,KAAKV,KAAT,CAAzC;AACA,OAAKxB,YAAL,GAAoBsC,IAAI,CAACC,GAAL,CAASF,iBAAiB,GAAG,GAA7B,EAAkC,MAAlC,CAApB;AAEA,MAAIG,uBAAuB,GAAGd,QAAQ,GAClCZ,+BADkC,GAElCD,iCAFJ;AAIA,MAAI4B,eAAe,GAAGD,uBAAuB,CAACE,YAAxB,CAAqC;AACzDC,IAAAA,SAAS,EAAE,KAAKjE,OADyC;AAEzDU,IAAAA,SAAS,EAAEA,SAF8C;AAGzDwD,IAAAA,mBAAmB,EAAE,IAHoC;AAIzDpE,IAAAA,KAAK,EAAE,KAAKG,MAJ6C;AAKzDF,IAAAA,MAAM,EAAE,KAAKG,OAL4C;AAMzDgD,IAAAA,eAAe,EAAEA,eANwC;AAOzDE,IAAAA,SAAS,EAAEA,SAP8C;AAQzDe,IAAAA,gBAAgB,EAAEb,MARuC;AASzDL,IAAAA,SAAS,EAAEA,SAT8C;AAUzDmB,IAAAA,WAAW,EAAE,KAAK9C,YAVuC;AAWzD+C,IAAAA,YAAY,EAAE3B,YAAY,CAAC4B,UAAb,YAAmCtF,oBAXQ;AAYzD+D,IAAAA,YAAY,EAAEA,YAZ2C;AAazDzC,IAAAA,QAAQ,EAAE,KAAKD;AAb0C,GAArC,CAAtB;;AAgBA,MAAI,CAACvB,OAAO,CAACiF,eAAD,CAAZ,EAA+B;AAC7B;AACA,WAAOxC,SAAP;AACD;;AAED,MAAIgD,IAAI,GAAG,IAAX;AACA,SAAO9F,IAAI,CAACsF,eAAD,EAAkB,UAAUS,MAAV,EAAkB;AAC7C,QAAIC,eAAJ;;AACA,QAAIF,IAAI,CAACjD,YAAL,GAAoB,GAAxB,EAA6B;AAC3BmD,MAAAA,eAAe,GAAG/E,eAAe,CAACgF,2CAAhB,CAChBF,MAAM,CAACG,SADS,EAEhBH,MAAM,CAACI,UAFS,CAAlB;AAID,KALD,MAKO;AACLH,MAAAA,eAAe,GAAG/E,eAAe,CAACmF,mCAAhB,CAChBL,MAAM,CAACG,SADS,EAEhBH,MAAM,CAACI,UAFS,CAAlB;AAID;;AAED,QAAIE,wBAAwB,GAAGN,MAAM,CAACG,SAAP,GAAmBH,MAAM,CAACI,UAAzD,CAd6C,CAgB7C;AACA;;AACAL,IAAAA,IAAI,CAAC3C,KAAL,GAAa,IAAInC,WAAJ,CACX6D,MADW,EAEX,IAAI5B,YAAJ,CAAiB8C,MAAM,CAACO,QAAxB,CAFW,EAGXN,eAAe,CAACO,OAHL,EAIXP,eAAe,CAACQ,uBAJL,EAKXH,wBALW,EAMXN,MAAM,CAACU,aANI,EAOXV,MAAM,CAACW,aAPI,EAQXzG,cAAc,CAAC0G,KAAf,CAAqBZ,MAAM,CAACa,gBAA5B,CARW,EASX1G,UAAU,CAACyG,KAAX,CAAiBZ,MAAM,CAACc,0BAAxB,CATW,EAUXd,MAAM,CAACe,kBAVI,EAWXnG,mBAAmB,CAACgG,KAApB,CAA0BZ,MAAM,CAACgB,mBAAjC,CAXW,EAYXhG,eAAe,CAAC4F,KAAhB,CAAsBZ,MAAM,CAAClE,QAA7B,CAZW,EAaXyC,YAbW,EAcX0B,eAAe,CAACgB,uBAdL,EAeXhB,eAAe,CAACiB,sBAfL,EAgBXjB,eAAe,CAACkB,uBAhBL,EAiBXlB,eAAe,CAACmB,sBAjBL,CAAb,CAlB6C,CAsC7C;;AACArB,IAAAA,IAAI,CAACvE,OAAL,GAAeuB,SAAf;AACA,WAAOgD,IAAI,CAAC3C,KAAZ;AACD,GAzCU,CAAX;AA0CD,CAtGD;AAwGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAjC,oBAAoB,CAACoC,SAArB,CAA+B8D,eAA/B,GAAiD,UAAUjG,OAAV,EAAmB;AAClE;AACAhB,EAAAA,KAAK,CAAC4D,MAAN,CAAaC,MAAb,CAAoB,sBAApB,EAA4C7C,OAAO,CAAC8C,YAApD;AACA9D,EAAAA,KAAK,CAAC4D,MAAN,CAAaG,MAAb,CAAoB,WAApB,EAAiC/C,OAAO,CAACgD,CAAzC;AACAhE,EAAAA,KAAK,CAAC4D,MAAN,CAAaG,MAAb,CAAoB,WAApB,EAAiC/C,OAAO,CAACiD,CAAzC;AACAjE,EAAAA,KAAK,CAAC4D,MAAN,CAAaG,MAAb,CAAoB,eAApB,EAAqC/C,OAAO,CAACkD,KAA7C,EALkE,CAMlE;;AAEA,MAAIJ,YAAY,GAAG9C,OAAO,CAAC8C,YAA3B;AACA,MAAIE,CAAC,GAAGhD,OAAO,CAACgD,CAAhB;AACA,MAAIC,CAAC,GAAGjD,OAAO,CAACiD,CAAhB;AACA,MAAIC,KAAK,GAAGlD,OAAO,CAACkD,KAApB;AACA,MAAIC,YAAY,GAAGlE,YAAY,CAACe,OAAO,CAACmD,YAAT,EAAuB,GAAvB,CAA/B;AAEA,MAAIE,SAAS,GAAGP,YAAY,CAACO,SAA7B;AACA,MAAIC,eAAe,GAAGR,YAAY,CAACS,uBAAb,CAAqCP,CAArC,EAAwCC,CAAxC,EAA2CC,KAA3C,CAAtB;AACA,MAAIM,SAAS,GAAGV,YAAY,CAACW,iBAAb,CAA+BT,CAA/B,EAAkCC,CAAlC,EAAqCC,KAArC,CAAhB,CAhBkE,CAkBlE;;AACA,MAAIQ,MAAM,GAAGL,SAAS,CAACM,uBAAV,CAAkClE,SAAS,CAACiE,MAAV,CAAiBF,SAAjB,CAAlC,CAAb;AAEA,MAAI1C,SAAS,GAAG,KAAKO,UAArB;AAEA,MAAIuC,iBAAiB,GAAG9D,eAAe,CAAC+D,gDAAhB,CACtBR,SADsB,EAEtB,KAAKhD,MAFiB,EAGtByC,YAAY,CAACgB,wBAAb,CAAsC,CAAtC,CAHsB,CAAxB;AAKA,MAAIC,iBAAiB,GAAGH,iBAAiB,IAAI,KAAKV,KAAT,CAAzC;AACA,OAAKxB,YAAL,GAAoBsC,IAAI,CAACC,GAAL,CAASF,iBAAiB,GAAG,GAA7B,EAAkC,MAAlC,CAApB;AAEA,MAAIa,MAAM,GAAGtF,oBAAoB,CAAC4G,eAArB,CAAqC;AAChD7B,IAAAA,SAAS,EAAE,KAAKjE,OADgC;AAEhDU,IAAAA,SAAS,EAAEA,SAFqC;AAGhDwD,IAAAA,mBAAmB,EAAE,IAH2B;AAIhDpE,IAAAA,KAAK,EAAE,KAAKG,MAJoC;AAKhDF,IAAAA,MAAM,EAAE,KAAKG,OALmC;AAMhDgD,IAAAA,eAAe,EAAEA,eAN+B;AAOhDE,IAAAA,SAAS,EAAEA,SAPqC;AAQhDe,IAAAA,gBAAgB,EAAEb,MAR8B;AAShDL,IAAAA,SAAS,EAAEA,SATqC;AAUhDmB,IAAAA,WAAW,EAAE,KAAK9C,YAV8B;AAWhD+C,IAAAA,YAAY,EAAE3B,YAAY,CAAC4B,UAAb,YAAmCtF,oBAXD;AAYhD+D,IAAAA,YAAY,EAAEA;AAZkC,GAArC,CAAb,CA/BkE,CA8ClE;;AACA,OAAK/C,OAAL,GAAeuB,SAAf;AAEA,MAAIkD,eAAJ;;AACA,MAAI,KAAKnD,YAAL,GAAoB,GAAxB,EAA6B;AAC3BmD,IAAAA,eAAe,GAAG/E,eAAe,CAACgF,2CAAhB,CAChB,KAAKzE,MADW,EAEhB,KAAKC,OAFW,CAAlB;AAID,GALD,MAKO;AACLuE,IAAAA,eAAe,GAAG/E,eAAe,CAACmF,mCAAhB,CAChB,KAAK5E,MADW,EAEhB,KAAKC,OAFW,CAAlB;AAID;;AAED,MAAI4E,wBAAwB,GAAGN,MAAM,CAACG,SAAP,GAAmBH,MAAM,CAACI,UAAzD,CA9DkE,CAgElE;AACA;;AACA,SAAO,IAAInF,WAAJ,CACL6D,MADK,EAELkB,MAAM,CAACO,QAFF,EAGLN,eAAe,CAACO,OAHX,EAILP,eAAe,CAACQ,uBAJX,EAKLH,wBALK,EAMLN,MAAM,CAACU,aANF,EAOLV,MAAM,CAACW,aAPF,EAQLX,MAAM,CAACa,gBARF,EASLb,MAAM,CAACc,0BATF,EAULd,MAAM,CAAClE,QAAP,CAAgByF,SAAhB,EAVK,EAWLvB,MAAM,CAACgB,mBAXF,EAYLhB,MAAM,CAAClE,QAZF,EAaLyC,YAbK,EAcL0B,eAAe,CAACgB,uBAdX,EAeLhB,eAAe,CAACiB,sBAfX,EAgBLjB,eAAe,CAACkB,uBAhBX,EAiBLlB,eAAe,CAACmB,sBAjBX,CAAP;AAmBD,CArFD;AAuFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAjG,oBAAoB,CAACoC,SAArB,CAA+BiE,iBAA/B,GAAmD,UACjD5C,SADiD,EAEjD6C,SAFiD,EAGjDC,QAHiD,EAIjD;AACA,MAAIpG,KAAK,GAAG,KAAKG,MAAjB;AACA,MAAIF,MAAM,GAAG,KAAKG,OAAlB;AAEA,MAAIQ,SAAS,GAAG,KAAKO,UAArB;AACA,MAAIH,MAAM,GAAGJ,SAAS,CAACI,MAAvB;AACA,MAAID,iBAAiB,GAAGH,SAAS,CAACG,iBAAlC;AACA,MAAIE,iBAAiB,GAAGL,SAAS,CAACK,iBAAlC;AACA,MAAIC,WAAW,GAAGN,SAAS,CAACM,WAA5B;AACA,MAAIJ,YAAY,GAAGF,SAAS,CAACE,YAA7B;AACA,MAAID,WAAW,GAAGD,SAAS,CAACC,WAA5B;AAEA,MAAIwF,aAAa,GAAGrH,OAAO,CAAC,KAAK8C,KAAN,CAA3B;AACA,MAAIwE,cAAc,GAAG,KAAK/F,SAAL,KAAmBpB,iBAAiB,CAACwC,IAA1D;AACA,MAAI4E,yBAAyB,GAAG,CAACF,aAAD,IAAkBC,cAAlD;;AACA,MAAIC,yBAAJ,EAA+B;AAC7B;AACA;AACA;AACA,WAAO9E,SAAP;AACD;;AAED,MAAI+E,YAAJ;;AACA,MAAIH,aAAJ,EAAmB;AACjB,QAAItG,MAAM,GAAG,KAAK+B,KAAL,CAAWmD,QAAxB;AACA,QAAIzE,QAAQ,GAAG,KAAKsB,KAAL,CAAWtB,QAA1B;AACA,QAAIyC,YAAY,GAAG,KAAKnB,KAAL,CAAWmB,YAA9B;AACAuD,IAAAA,YAAY,GAAGC,qBAAqB,CAClC1G,MADkC,EAElCS,QAFkC,EAGlCM,YAHkC,EAIlCD,WAJkC,EAKlCyC,SALkC,EAMlCtD,KANkC,EAOlCC,MAPkC,EAQlCkG,SARkC,EASlCC,QATkC,EAUlCnD,YAVkC,CAApC;AAYD,GAhBD,MAgBO;AACLuD,IAAAA,YAAY,GAAGN,iBAAiB,CAC9B,KAAKhG,OADyB,EAE9Ba,iBAF8B,EAG9BE,iBAH8B,EAI9BD,MAJ8B,EAK9BE,WAL8B,EAM9BoC,SAN8B,EAO9BtD,KAP8B,EAQ9BC,MAR8B,EAS9BkG,SAT8B,EAU9BC,QAV8B,CAAhC;AAYAI,IAAAA,YAAY,GAAGA,YAAY,GAAG3F,WAAf,GAA6BC,YAA5C;AACD;;AAED,SAAO0F,YAAP;AACD,CA5DD;AA8DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA3G,oBAAoB,CAACoC,SAArB,CAA+ByE,QAA/B,GAA0C,UACxC9D,YADwC,EAExC+D,KAFwC,EAGxCC,KAHwC,EAIxCC,SAJwC,EAKxCC,WALwC,EAMxCC,WANwC,EAOxCC,eAPwC,EAQxC;AACA;AACA,MAAI,CAAChI,OAAO,CAAC4D,YAAD,CAAZ,EAA4B;AAC1B,UAAM,IAAI3D,cAAJ,CAAmB,2BAAnB,CAAN;AACD;;AACD,MAAI,CAACD,OAAO,CAAC2H,KAAD,CAAZ,EAAqB;AACnB,UAAM,IAAI1H,cAAJ,CAAmB,oBAAnB,CAAN;AACD;;AACD,MAAI,CAACD,OAAO,CAAC4H,KAAD,CAAZ,EAAqB;AACnB,UAAM,IAAI3H,cAAJ,CAAmB,oBAAnB,CAAN;AACD;;AACD,MAAI,CAACD,OAAO,CAAC6H,SAAD,CAAZ,EAAyB;AACvB,UAAM,IAAI5H,cAAJ,CAAmB,wBAAnB,CAAN;AACD;;AACD,MAAI,CAACD,OAAO,CAAC8H,WAAD,CAAZ,EAA2B;AACzB,UAAM,IAAI7H,cAAJ,CAAmB,0BAAnB,CAAN;AACD;;AACD,MAAI,CAACD,OAAO,CAAC+H,WAAD,CAAZ,EAA2B;AACzB,UAAM,IAAI9H,cAAJ,CAAmB,0BAAnB,CAAN;AACD;;AACD,MAAI,CAACD,OAAO,CAACgI,eAAD,CAAZ,EAA+B;AAC7B,UAAM,IAAI/H,cAAJ,CAAmB,8BAAnB,CAAN;AACD;;AACD,MAAIgI,eAAe,GAAGD,eAAe,GAAGH,SAAxC;;AACA,MAAII,eAAe,GAAG,CAAtB,EAAyB;AACvB,UAAM,IAAIhI,cAAJ,CACJ,8EADI,CAAN;AAGD,GA5BD,CA6BA;;;AAEA,MAAIiI,QAAQ,GAAG,KAAKpF,KAApB;;AACA,MAAI,CAAC9C,OAAO,CAACkI,QAAD,CAAZ,EAAwB;AACtB,WAAOzF,SAAP;AACD;;AAED,MAAIzB,KAAK,GAAG,KAAKG,MAAjB;AACA,MAAIF,MAAM,GAAG,KAAKG,OAAlB;AACA,MAAIQ,SAAS,GAAG,KAAKO,UAArB;AACA,MAAIH,MAAM,GAAGJ,SAAS,CAACI,MAAvB;AAEA,MAAImG,OAAO,GAAG,IAAI,KAAKzF,WAAT,CAAqB1B,KAAK,GAAGC,MAAR,GAAiBe,MAAtC,CAAd;AAEA,MAAIjB,MAAM,GAAGmH,QAAQ,CAACjC,QAAtB;AACA,MAAIzE,QAAQ,GAAG0G,QAAQ,CAAC1G,QAAxB,CA5CA,CA8CA;;AACA,MAAI4G,eAAe,GAAGxE,YAAY,CAACW,iBAAb,CAA+BoD,KAA/B,EAAsCC,KAAtC,EAA6CC,SAA7C,CAAtB;AACA,MAAIQ,oBAAoB,GAAGzE,YAAY,CAACW,iBAAb,CACzBuD,WADyB,EAEzBC,WAFyB,EAGzBC,eAHyB,CAA3B;AAMA,MAAIlG,YAAY,GAAGF,SAAS,CAACE,YAA7B;AACA,MAAID,WAAW,GAAGD,SAAS,CAACC,WAA5B;AACA,MAAIoC,YAAY,GAAGiE,QAAQ,CAACjE,YAA5B;AAEA,MAAIlC,iBAAiB,GAAGH,SAAS,CAACG,iBAAlC;AACA,MAAIE,iBAAiB,GAAGL,SAAS,CAACK,iBAAlC;AACA,MAAIC,WAAW,GAAGN,SAAS,CAACM,WAA5B;AAEA,MAAIoG,OAAO,GAAGxD,IAAI,CAACyD,GAAL,CAAStG,iBAAT,EAA4BF,iBAAiB,GAAG,CAAhD,CAAd;;AAEA,OAAK,IAAIyG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGvH,MAApB,EAA4B,EAAEuH,CAA9B,EAAiC;AAC/B,QAAIpB,QAAQ,GAAG/G,UAAU,CAACoI,IAAX,CACbJ,oBAAoB,CAACK,KADR,EAEbL,oBAAoB,CAACM,KAFR,EAGbH,CAAC,IAAIvH,MAAM,GAAG,CAAb,CAHY,CAAf;;AAKA,SAAK,IAAI2H,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG5H,KAApB,EAA2B,EAAE4H,CAA7B,EAAgC;AAC9B,UAAIzB,SAAS,GAAG9G,UAAU,CAACoI,IAAX,CACdJ,oBAAoB,CAACQ,IADP,EAEdR,oBAAoB,CAACS,IAFP,EAGdF,CAAC,IAAI5H,KAAK,GAAG,CAAZ,CAHa,CAAhB;AAKA,UAAIwG,YAAY,GAAGC,qBAAqB,CACtC1G,MADsC,EAEtCS,QAFsC,EAGtCM,YAHsC,EAItCD,WAJsC,EAKtCuG,eALsC,EAMtCpH,KANsC,EAOtCC,MAPsC,EAQtCkG,SARsC,EAStCC,QATsC,EAUtCnD,YAVsC,CAAxC,CAN8B,CAmB9B;AACA;;AACAuD,MAAAA,YAAY,GACVA,YAAY,GAAG5F,SAAS,CAACmH,mBAAzB,GACInH,SAAS,CAACmH,mBADd,GAEIvB,YAHN;AAIAA,MAAAA,YAAY,GACVA,YAAY,GAAG5F,SAAS,CAACoH,oBAAzB,GACIpH,SAAS,CAACoH,oBADd,GAEIxB,YAHN;AAKAyB,MAAAA,SAAS,CACPd,OADO,EAEPpG,iBAFO,EAGPE,iBAHO,EAIPqG,OAJO,EAKPtG,MALO,EAMPE,WANO,EAOPsG,CAAC,GAAGxH,KAAJ,GAAY4H,CAPL,EAQPpB,YARO,CAAT;AAUD;AACF;;AAED,SAAO,IAAI3G,oBAAJ,CAAyB;AAC9BE,IAAAA,MAAM,EAAEoH,OADsB;AAE9BnH,IAAAA,KAAK,EAAEA,KAFuB;AAG9BC,IAAAA,MAAM,EAAEA,MAHsB;AAI9BK,IAAAA,aAAa,EAAE,CAJe;AAK9BM,IAAAA,SAAS,EAAE,KAAKO,UALc;AAM9BE,IAAAA,mBAAmB,EAAE;AANS,GAAzB,CAAP;AAQD,CAjID;AAmIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAxB,oBAAoB,CAACoC,SAArB,CAA+BiG,gBAA/B,GAAkD,UAChDvB,KADgD,EAEhDC,KAFgD,EAGhDuB,MAHgD,EAIhDC,MAJgD,EAKhD;AACA;AACA,MAAI,CAACpJ,OAAO,CAAC2H,KAAD,CAAZ,EAAqB;AACnB,UAAM,IAAI1H,cAAJ,CAAmB,oBAAnB,CAAN;AACD;;AACD,MAAI,CAACD,OAAO,CAAC4H,KAAD,CAAZ,EAAqB;AACnB,UAAM,IAAI3H,cAAJ,CAAmB,oBAAnB,CAAN;AACD;;AACD,MAAI,CAACD,OAAO,CAACmJ,MAAD,CAAZ,EAAsB;AACpB,UAAM,IAAIlJ,cAAJ,CAAmB,qBAAnB,CAAN;AACD;;AACD,MAAI,CAACD,OAAO,CAACoJ,MAAD,CAAZ,EAAsB;AACpB,UAAM,IAAInJ,cAAJ,CAAmB,qBAAnB,CAAN;AACD,GAbD,CAcA;;;AAEA,MAAIoJ,SAAS,GAAG,CAAhB,CAhBA,CAgBmB;;AACnB,MAAIF,MAAM,KAAKxB,KAAK,GAAG,CAAvB,EAA0B;AACxB,MAAE0B,SAAF,CADwB,CACX;AACd;;AACD,MAAID,MAAM,KAAKxB,KAAK,GAAG,CAAvB,EAA0B;AACxByB,IAAAA,SAAS,IAAI,CAAb,CADwB,CACR;AACjB;;AAED,SAAO,CAAC,KAAKhI,cAAL,GAAuB,KAAKgI,SAA7B,MAA6C,CAApD;AACD,CA9BD;AAgCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAxI,oBAAoB,CAACoC,SAArB,CAA+BqG,sBAA/B,GAAwD,YAAY;AAClE,SAAO,KAAKlH,oBAAZ;AACD,CAFD;;AAIA,SAAS8E,iBAAT,CACEqC,aADF,EAEExH,iBAFF,EAGEE,iBAHF,EAIED,MAJF,EAKEE,WALF,EAMEkG,eANF,EAOEpH,KAPF,EAQEC,MARF,EASEkG,SATF,EAUEC,QAVF,EAWE;AACA,MAAIoC,QAAQ,GACT,CAACrC,SAAS,GAAGiB,eAAe,CAACS,IAA7B,KAAsC7H,KAAK,GAAG,CAA9C,CAAD,IACCoH,eAAe,CAACU,IAAhB,GAAuBV,eAAe,CAACS,IADxC,CADF;AAGA,MAAIY,SAAS,GACV,CAACrC,QAAQ,GAAGgB,eAAe,CAACO,KAA5B,KAAsC1H,MAAM,GAAG,CAA/C,CAAD,IACCmH,eAAe,CAACM,KAAhB,GAAwBN,eAAe,CAACO,KADzC,CADF;AAIA,MAAIe,WAAW,GAAGF,QAAQ,GAAG,CAA7B;AACA,MAAIG,WAAW,GAAGD,WAAW,GAAG,CAAhC;;AACA,MAAIC,WAAW,IAAI3I,KAAnB,EAA0B;AACxB2I,IAAAA,WAAW,GAAG3I,KAAK,GAAG,CAAtB;AACA0I,IAAAA,WAAW,GAAG1I,KAAK,GAAG,CAAtB;AACD;;AAED,MAAI4I,YAAY,GAAGH,SAAS,GAAG,CAA/B;AACA,MAAII,YAAY,GAAGD,YAAY,GAAG,CAAlC;;AACA,MAAIC,YAAY,IAAI5I,MAApB,EAA4B;AAC1B4I,IAAAA,YAAY,GAAG5I,MAAM,GAAG,CAAxB;AACA2I,IAAAA,YAAY,GAAG3I,MAAM,GAAG,CAAxB;AACD;;AAED,MAAI6I,EAAE,GAAGN,QAAQ,GAAGE,WAApB;AACA,MAAIK,EAAE,GAAGN,SAAS,GAAGG,YAArB;AAEAA,EAAAA,YAAY,GAAG3I,MAAM,GAAG,CAAT,GAAa2I,YAA5B;AACAC,EAAAA,YAAY,GAAG5I,MAAM,GAAG,CAAT,GAAa4I,YAA5B;AAEA,MAAIG,eAAe,GAAGC,SAAS,CAC7BV,aAD6B,EAE7BxH,iBAF6B,EAG7BE,iBAH6B,EAI7BD,MAJ6B,EAK7BE,WAL6B,EAM7B0H,YAAY,GAAG5I,KAAf,GAAuB0I,WANM,CAA/B;AAQA,MAAIQ,eAAe,GAAGD,SAAS,CAC7BV,aAD6B,EAE7BxH,iBAF6B,EAG7BE,iBAH6B,EAI7BD,MAJ6B,EAK7BE,WAL6B,EAM7B0H,YAAY,GAAG5I,KAAf,GAAuB2I,WANM,CAA/B;AAQA,MAAIQ,eAAe,GAAGF,SAAS,CAC7BV,aAD6B,EAE7BxH,iBAF6B,EAG7BE,iBAH6B,EAI7BD,MAJ6B,EAK7BE,WAL6B,EAM7B2H,YAAY,GAAG7I,KAAf,GAAuB0I,WANM,CAA/B;AAQA,MAAIU,eAAe,GAAGH,SAAS,CAC7BV,aAD6B,EAE7BxH,iBAF6B,EAG7BE,iBAH6B,EAI7BD,MAJ6B,EAK7BE,WAL6B,EAM7B2H,YAAY,GAAG7I,KAAf,GAAuB2I,WANM,CAA/B;AASA,SAAOU,yBAAyB,CAC9BP,EAD8B,EAE9BC,EAF8B,EAG9BC,eAH8B,EAI9BE,eAJ8B,EAK9BC,eAL8B,EAM9BC,eAN8B,CAAhC;AAQD;;AAED,SAAS3C,qBAAT,CACE1G,MADF,EAEES,QAFF,EAGEM,YAHF,EAIED,WAJF,EAKEuG,eALF,EAMEpH,KANF,EAOEC,MAPF,EAQEkG,SARF,EASEC,QATF,EAUEnD,YAVF,EAWE;AACA;AACA,MAAIuF,QAAQ,GACT,CAACrC,SAAS,GAAGiB,eAAe,CAACS,IAA7B,KAAsC7H,KAAK,GAAG,CAA9C,CAAD,IACCoH,eAAe,CAACU,IAAhB,GAAuBV,eAAe,CAACS,IADxC,CADF;AAGA,MAAIY,SAAS,GACV,CAACrC,QAAQ,GAAGgB,eAAe,CAACO,KAA5B,KAAsC1H,MAAM,GAAG,CAA/C,CAAD,IACCmH,eAAe,CAACM,KAAhB,GAAwBN,eAAe,CAACO,KADzC,CADF;AAIA,MAAIe,WAAW,GAAGF,QAAQ,GAAG,CAA7B;AACA,MAAIG,WAAW,GAAGD,WAAW,GAAG,CAAhC;;AACA,MAAIC,WAAW,IAAI3I,KAAnB,EAA0B;AACxB2I,IAAAA,WAAW,GAAG3I,KAAK,GAAG,CAAtB;AACA0I,IAAAA,WAAW,GAAG1I,KAAK,GAAG,CAAtB;AACD;;AAED,MAAI4I,YAAY,GAAGH,SAAS,GAAG,CAA/B;AACA,MAAII,YAAY,GAAGD,YAAY,GAAG,CAAlC;;AACA,MAAIC,YAAY,IAAI5I,MAApB,EAA4B;AAC1B4I,IAAAA,YAAY,GAAG5I,MAAM,GAAG,CAAxB;AACA2I,IAAAA,YAAY,GAAG3I,MAAM,GAAG,CAAxB;AACD;;AAED,MAAI6I,EAAE,GAAGN,QAAQ,GAAGE,WAApB;AACA,MAAIK,EAAE,GAAGN,SAAS,GAAGG,YAArB;AAEAA,EAAAA,YAAY,GAAG3I,MAAM,GAAG,CAAT,GAAa2I,YAA5B;AACAC,EAAAA,YAAY,GAAG5I,MAAM,GAAG,CAAT,GAAa4I,YAA5B;AAEA,MAAIG,eAAe,GACjB,CAACxI,QAAQ,CAAC8I,YAAT,CAAsBvJ,MAAtB,EAA8B6I,YAAY,GAAG5I,KAAf,GAAuB0I,WAArD,IACCzF,YADD,GAECnC,YAFF,IAGAD,WAJF;AAKA,MAAIqI,eAAe,GACjB,CAAC1I,QAAQ,CAAC8I,YAAT,CAAsBvJ,MAAtB,EAA8B6I,YAAY,GAAG5I,KAAf,GAAuB2I,WAArD,IACC1F,YADD,GAECnC,YAFF,IAGAD,WAJF;AAKA,MAAIsI,eAAe,GACjB,CAAC3I,QAAQ,CAAC8I,YAAT,CAAsBvJ,MAAtB,EAA8B8I,YAAY,GAAG7I,KAAf,GAAuB0I,WAArD,IACCzF,YADD,GAECnC,YAFF,IAGAD,WAJF;AAKA,MAAIuI,eAAe,GACjB,CAAC5I,QAAQ,CAAC8I,YAAT,CAAsBvJ,MAAtB,EAA8B8I,YAAY,GAAG7I,KAAf,GAAuB2I,WAArD,IACC1F,YADD,GAECnC,YAFF,IAGAD,WAJF;AAMA,SAAOwI,yBAAyB,CAC9BP,EAD8B,EAE9BC,EAF8B,EAG9BC,eAH8B,EAI9BE,eAJ8B,EAK9BC,eAL8B,EAM9BC,eAN8B,CAAhC;AAQD;;AAED,SAASC,yBAAT,CACEE,EADF,EAEEC,EAFF,EAGER,eAHF,EAIEE,eAJF,EAKEC,eALF,EAMEC,eANF,EAOE;AACA;AACA,MAAII,EAAE,GAAGD,EAAT,EAAa;AACX;AACA,WACEP,eAAe,GACfO,EAAE,IAAIL,eAAe,GAAGF,eAAtB,CADF,GAEAQ,EAAE,IAAIJ,eAAe,GAAGF,eAAtB,CAHJ;AAKD,GATD,CAWA;;;AACA,SACEF,eAAe,GACfO,EAAE,IAAIH,eAAe,GAAGD,eAAtB,CADF,GAEAK,EAAE,IAAIL,eAAe,GAAGH,eAAtB,CAHJ;AAKD;;AAED,SAASC,SAAT,CACE9B,OADF,EAEEpG,iBAFF,EAGEE,iBAHF,EAIED,MAJF,EAKEE,WALF,EAMEuI,KANF,EAOE;AACAA,EAAAA,KAAK,IAAIzI,MAAT;AAEA,MAAIf,MAAM,GAAG,CAAb;AACA,MAAI2H,CAAJ;;AAEA,MAAI1G,WAAJ,EAAiB;AACf,SAAK0G,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG7G,iBAAhB,EAAmC,EAAE6G,CAArC,EAAwC;AACtC3H,MAAAA,MAAM,GAAGA,MAAM,GAAGgB,iBAAT,GAA6BkG,OAAO,CAACsC,KAAK,GAAG7B,CAAT,CAA7C;AACD;AACF,GAJD,MAIO;AACL,SAAKA,CAAC,GAAG7G,iBAAiB,GAAG,CAA7B,EAAgC6G,CAAC,IAAI,CAArC,EAAwC,EAAEA,CAA1C,EAA6C;AAC3C3H,MAAAA,MAAM,GAAGA,MAAM,GAAGgB,iBAAT,GAA6BkG,OAAO,CAACsC,KAAK,GAAG7B,CAAT,CAA7C;AACD;AACF;;AAED,SAAO3H,MAAP;AACD;;AAED,SAASgI,SAAT,CACEd,OADF,EAEEpG,iBAFF,EAGEE,iBAHF,EAIEqG,OAJF,EAKEtG,MALF,EAMEE,WANF,EAOEuI,KAPF,EAQExJ,MARF,EASE;AACAwJ,EAAAA,KAAK,IAAIzI,MAAT;AAEA,MAAI4G,CAAJ;;AACA,MAAI1G,WAAJ,EAAiB;AACf,SAAK0G,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG7G,iBAAiB,GAAG,CAApC,EAAuC,EAAE6G,CAAzC,EAA4C;AAC1CT,MAAAA,OAAO,CAACsC,KAAK,GAAG7B,CAAT,CAAP,GAAsB3H,MAAM,GAAGqH,OAAV,GAAqB,CAA1C;AACArH,MAAAA,MAAM,IAAIkH,OAAO,CAACsC,KAAK,GAAG7B,CAAT,CAAP,GAAqBN,OAA/B;AACAA,MAAAA,OAAO,IAAIrG,iBAAX;AACD;AACF,GAND,MAMO;AACL,SAAK2G,CAAC,GAAG7G,iBAAiB,GAAG,CAA7B,EAAgC6G,CAAC,GAAG,CAApC,EAAuC,EAAEA,CAAzC,EAA4C;AAC1CT,MAAAA,OAAO,CAACsC,KAAK,GAAG7B,CAAT,CAAP,GAAsB3H,MAAM,GAAGqH,OAAV,GAAqB,CAA1C;AACArH,MAAAA,MAAM,IAAIkH,OAAO,CAACsC,KAAK,GAAG7B,CAAT,CAAP,GAAqBN,OAA/B;AACAA,MAAAA,OAAO,IAAIrG,iBAAX;AACD;AACF;;AACDkG,EAAAA,OAAO,CAACsC,KAAK,GAAG7B,CAAT,CAAP,GAAqB3H,MAArB;AACD;;AACD,eAAeJ,oBAAf","sourcesContent":["import when from \"../ThirdParty/when.js\";\nimport BoundingSphere from \"./BoundingSphere.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport GeographicProjection from \"./GeographicProjection.js\";\nimport HeightmapEncoding from \"./HeightmapEncoding.js\";\nimport HeightmapTessellator from \"./HeightmapTessellator.js\";\nimport CesiumMath from \"./Math.js\";\nimport OrientedBoundingBox from \"./OrientedBoundingBox.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport TaskProcessor from \"./TaskProcessor.js\";\nimport TerrainData from \"./TerrainData.js\";\nimport TerrainEncoding from \"./TerrainEncoding.js\";\nimport TerrainMesh from \"./TerrainMesh.js\";\nimport TerrainProvider from \"./TerrainProvider.js\";\n\n/**\n * Terrain data for a single tile where the terrain data is represented as a heightmap.  A heightmap\n * is a rectangular array of heights in row-major order from north to south and west to east.\n *\n * @alias HeightmapTerrainData\n * @constructor\n *\n * @param {Object} options Object with the following properties:\n * @param {Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} options.buffer The buffer containing height data.\n * @param {Number} options.width The width (longitude direction) of the heightmap, in samples.\n * @param {Number} options.height The height (latitude direction) of the heightmap, in samples.\n * @param {Number} [options.childTileMask=15] A bit mask indicating which of this tile's four children exist.\n *                 If a child's bit is set, geometry will be requested for that tile as well when it\n *                 is needed.  If the bit is cleared, the child tile is not requested and geometry is\n *                 instead upsampled from the parent.  The bit values are as follows:\n *                 <table>\n *                  <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>\n *                  <tr><td>0</td><td>1</td><td>Southwest</td></tr>\n *                  <tr><td>1</td><td>2</td><td>Southeast</td></tr>\n *                  <tr><td>2</td><td>4</td><td>Northwest</td></tr>\n *                  <tr><td>3</td><td>8</td><td>Northeast</td></tr>\n *                 </table>\n * @param {Uint8Array} [options.waterMask] The water mask included in this terrain data, if any.  A water mask is a square\n *                     Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.\n *                     Values in between 0 and 255 are allowed as well to smoothly blend between land and water.\n * @param {Object} [options.structure] An object describing the structure of the height data.\n * @param {Number} [options.structure.heightScale=1.0] The factor by which to multiply height samples in order to obtain\n *                 the height above the heightOffset, in meters.  The heightOffset is added to the resulting\n *                 height after multiplying by the scale.\n * @param {Number} [options.structure.heightOffset=0.0] The offset to add to the scaled height to obtain the final\n *                 height in meters.  The offset is added after the height sample is multiplied by the\n *                 heightScale.\n * @param {Number} [options.structure.elementsPerHeight=1] The number of elements in the buffer that make up a single height\n *                 sample.  This is usually 1, indicating that each element is a separate height sample.  If\n *                 it is greater than 1, that number of elements together form the height sample, which is\n *                 computed according to the structure.elementMultiplier and structure.isBigEndian properties.\n * @param {Number} [options.structure.stride=1] The number of elements to skip to get from the first element of\n *                 one height to the first element of the next height.\n * @param {Number} [options.structure.elementMultiplier=256.0] The multiplier used to compute the height value when the\n *                 stride property is greater than 1.  For example, if the stride is 4 and the strideMultiplier\n *                 is 256, the height is computed as follows:\n *                 `height = buffer[index] + buffer[index + 1] * 256 + buffer[index + 2] * 256 * 256 + buffer[index + 3] * 256 * 256 * 256`\n *                 This is assuming that the isBigEndian property is false.  If it is true, the order of the\n *                 elements is reversed.\n * @param {Boolean} [options.structure.isBigEndian=false] Indicates endianness of the elements in the buffer when the\n *                  stride property is greater than 1.  If this property is false, the first element is the\n *                  low-order element.  If it is true, the first element is the high-order element.\n * @param {Number} [options.structure.lowestEncodedHeight] The lowest value that can be stored in the height buffer.  Any heights that are lower\n *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height\n *                 buffer is a `Uint16Array`, this value should be 0 because a `Uint16Array` cannot store negative numbers.  If this parameter is\n *                 not specified, no minimum value is enforced.\n * @param {Number} [options.structure.highestEncodedHeight] The highest value that can be stored in the height buffer.  Any heights that are higher\n *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height\n *                 buffer is a `Uint16Array`, this value should be `256 * 256 - 1` or 65535 because a `Uint16Array` cannot store numbers larger\n *                 than 65535.  If this parameter is not specified, no maximum value is enforced.\n * @param {HeightmapEncoding} [options.encoding=HeightmapEncoding.NONE] The encoding that is used on the buffer.\n * @param {Boolean} [options.createdByUpsampling=false] True if this instance was created by upsampling another instance;\n *                  otherwise, false.\n *\n *\n * @example\n * var buffer = ...\n * var heightBuffer = new Uint16Array(buffer, 0, that._heightmapWidth * that._heightmapWidth);\n * var childTileMask = new Uint8Array(buffer, heightBuffer.byteLength, 1)[0];\n * var waterMask = new Uint8Array(buffer, heightBuffer.byteLength + 1, buffer.byteLength - heightBuffer.byteLength - 1);\n * var terrainData = new Cesium.HeightmapTerrainData({\n *   buffer : heightBuffer,\n *   width : 65,\n *   height : 65,\n *   childTileMask : childTileMask,\n *   waterMask : waterMask\n * });\n *\n * @see TerrainData\n * @see QuantizedMeshTerrainData\n * @see GoogleEarthEnterpriseTerrainData\n */\nfunction HeightmapTerrainData(options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options) || !defined(options.buffer)) {\n    throw new DeveloperError(\"options.buffer is required.\");\n  }\n  if (!defined(options.width)) {\n    throw new DeveloperError(\"options.width is required.\");\n  }\n  if (!defined(options.height)) {\n    throw new DeveloperError(\"options.height is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this._buffer = options.buffer;\n  this._width = options.width;\n  this._height = options.height;\n  this._childTileMask = defaultValue(options.childTileMask, 15);\n  this._encoding = defaultValue(options.encoding, HeightmapEncoding.NONE);\n\n  var defaultStructure = HeightmapTessellator.DEFAULT_STRUCTURE;\n  var structure = options.structure;\n  if (!defined(structure)) {\n    structure = defaultStructure;\n  } else if (structure !== defaultStructure) {\n    structure.heightScale = defaultValue(\n      structure.heightScale,\n      defaultStructure.heightScale\n    );\n    structure.heightOffset = defaultValue(\n      structure.heightOffset,\n      defaultStructure.heightOffset\n    );\n    structure.elementsPerHeight = defaultValue(\n      structure.elementsPerHeight,\n      defaultStructure.elementsPerHeight\n    );\n    structure.stride = defaultValue(structure.stride, defaultStructure.stride);\n    structure.elementMultiplier = defaultValue(\n      structure.elementMultiplier,\n      defaultStructure.elementMultiplier\n    );\n    structure.isBigEndian = defaultValue(\n      structure.isBigEndian,\n      defaultStructure.isBigEndian\n    );\n  }\n\n  this._structure = structure;\n  this._createdByUpsampling = defaultValue(options.createdByUpsampling, false);\n  this._waterMask = options.waterMask;\n\n  this._skirtHeight = undefined;\n  this._bufferType =\n    this._encoding === HeightmapEncoding.LERC\n      ? Float32Array\n      : this._buffer.constructor;\n  this._mesh = undefined;\n}\n\nObject.defineProperties(HeightmapTerrainData.prototype, {\n  /**\n   * An array of credits for this tile.\n   * @memberof HeightmapTerrainData.prototype\n   * @type {Credit[]}\n   */\n  credits: {\n    get: function () {\n      return undefined;\n    },\n  },\n  /**\n   * The water mask included in this terrain data, if any.  A water mask is a square\n   * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.\n   * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.\n   * @memberof HeightmapTerrainData.prototype\n   * @type {Uint8Array|HTMLImageElement|HTMLCanvasElement}\n   */\n  waterMask: {\n    get: function () {\n      return this._waterMask;\n    },\n  },\n\n  childTileMask: {\n    get: function () {\n      return this._childTileMask;\n    },\n  },\n});\n\nvar createMeshTaskName = \"createVerticesFromHeightmap\";\nvar createMeshTaskProcessorNoThrottle = new TaskProcessor(createMeshTaskName);\nvar createMeshTaskProcessorThrottle = new TaskProcessor(\n  createMeshTaskName,\n  TerrainData.maximumAsynchronousTasks\n);\n\n/**\n * Creates a {@link TerrainMesh} from this terrain data.\n *\n * @private\n *\n * @param {Object} options Object with the following properties:\n * @param {TilingScheme} options.tilingScheme The tiling scheme to which this tile belongs.\n * @param {Number} options.x The X coordinate of the tile for which to create the terrain data.\n * @param {Number} options.y The Y coordinate of the tile for which to create the terrain data.\n * @param {Number} options.level The level of the tile for which to create the terrain data.\n * @param {Number} [options.exaggeration=1.0] The scale used to exaggerate the terrain.\n * @param {Boolean} [options.throttle=true] If true, indicates that this operation will need to be retried if too many asynchronous mesh creations are already in progress.\n * @returns {Promise.<TerrainMesh>|undefined} A promise for the terrain mesh, or undefined if too many\n *          asynchronous mesh creations are already in progress and the operation should\n *          be retried later.\n */\nHeightmapTerrainData.prototype.createMesh = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.tilingScheme\", options.tilingScheme);\n  Check.typeOf.number(\"options.x\", options.x);\n  Check.typeOf.number(\"options.y\", options.y);\n  Check.typeOf.number(\"options.level\", options.level);\n  //>>includeEnd('debug');\n\n  var tilingScheme = options.tilingScheme;\n  var x = options.x;\n  var y = options.y;\n  var level = options.level;\n  var exaggeration = defaultValue(options.exaggeration, 1.0);\n  var throttle = defaultValue(options.throttle, true);\n\n  var ellipsoid = tilingScheme.ellipsoid;\n  var nativeRectangle = tilingScheme.tileXYToNativeRectangle(x, y, level);\n  var rectangle = tilingScheme.tileXYToRectangle(x, y, level);\n\n  // Compute the center of the tile for RTC rendering.\n  var center = ellipsoid.cartographicToCartesian(Rectangle.center(rectangle));\n\n  var structure = this._structure;\n\n  var levelZeroMaxError = TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(\n    ellipsoid,\n    this._width,\n    tilingScheme.getNumberOfXTilesAtLevel(0)\n  );\n  var thisLevelMaxError = levelZeroMaxError / (1 << level);\n  this._skirtHeight = Math.min(thisLevelMaxError * 4.0, 1000.0);\n\n  var createMeshTaskProcessor = throttle\n    ? createMeshTaskProcessorThrottle\n    : createMeshTaskProcessorNoThrottle;\n\n  var verticesPromise = createMeshTaskProcessor.scheduleTask({\n    heightmap: this._buffer,\n    structure: structure,\n    includeWebMercatorT: true,\n    width: this._width,\n    height: this._height,\n    nativeRectangle: nativeRectangle,\n    rectangle: rectangle,\n    relativeToCenter: center,\n    ellipsoid: ellipsoid,\n    skirtHeight: this._skirtHeight,\n    isGeographic: tilingScheme.projection instanceof GeographicProjection,\n    exaggeration: exaggeration,\n    encoding: this._encoding,\n  });\n\n  if (!defined(verticesPromise)) {\n    // Postponed\n    return undefined;\n  }\n\n  var that = this;\n  return when(verticesPromise, function (result) {\n    var indicesAndEdges;\n    if (that._skirtHeight > 0.0) {\n      indicesAndEdges = TerrainProvider.getRegularGridAndSkirtIndicesAndEdgeIndices(\n        result.gridWidth,\n        result.gridHeight\n      );\n    } else {\n      indicesAndEdges = TerrainProvider.getRegularGridIndicesAndEdgeIndices(\n        result.gridWidth,\n        result.gridHeight\n      );\n    }\n\n    var vertexCountWithoutSkirts = result.gridWidth * result.gridHeight;\n\n    // Clone complex result objects because the transfer from the web worker\n    // has stripped them down to JSON-style objects.\n    that._mesh = new TerrainMesh(\n      center,\n      new Float32Array(result.vertices),\n      indicesAndEdges.indices,\n      indicesAndEdges.indexCountWithoutSkirts,\n      vertexCountWithoutSkirts,\n      result.minimumHeight,\n      result.maximumHeight,\n      BoundingSphere.clone(result.boundingSphere3D),\n      Cartesian3.clone(result.occludeePointInScaledSpace),\n      result.numberOfAttributes,\n      OrientedBoundingBox.clone(result.orientedBoundingBox),\n      TerrainEncoding.clone(result.encoding),\n      exaggeration,\n      indicesAndEdges.westIndicesSouthToNorth,\n      indicesAndEdges.southIndicesEastToWest,\n      indicesAndEdges.eastIndicesNorthToSouth,\n      indicesAndEdges.northIndicesWestToEast\n    );\n\n    // Free memory received from server after mesh is created.\n    that._buffer = undefined;\n    return that._mesh;\n  });\n};\n\n/**\n * @param {Object} options Object with the following properties:\n * @param {TilingScheme} options.tilingScheme The tiling scheme to which this tile belongs.\n * @param {Number} options.x The X coordinate of the tile for which to create the terrain data.\n * @param {Number} options.y The Y coordinate of the tile for which to create the terrain data.\n * @param {Number} options.level The level of the tile for which to create the terrain data.\n * @param {Number} [options.exaggeration=1.0] The scale used to exaggerate the terrain.\n *\n * @private\n */\nHeightmapTerrainData.prototype._createMeshSync = function (options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options.tilingScheme\", options.tilingScheme);\n  Check.typeOf.number(\"options.x\", options.x);\n  Check.typeOf.number(\"options.y\", options.y);\n  Check.typeOf.number(\"options.level\", options.level);\n  //>>includeEnd('debug');\n\n  var tilingScheme = options.tilingScheme;\n  var x = options.x;\n  var y = options.y;\n  var level = options.level;\n  var exaggeration = defaultValue(options.exaggeration, 1.0);\n\n  var ellipsoid = tilingScheme.ellipsoid;\n  var nativeRectangle = tilingScheme.tileXYToNativeRectangle(x, y, level);\n  var rectangle = tilingScheme.tileXYToRectangle(x, y, level);\n\n  // Compute the center of the tile for RTC rendering.\n  var center = ellipsoid.cartographicToCartesian(Rectangle.center(rectangle));\n\n  var structure = this._structure;\n\n  var levelZeroMaxError = TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(\n    ellipsoid,\n    this._width,\n    tilingScheme.getNumberOfXTilesAtLevel(0)\n  );\n  var thisLevelMaxError = levelZeroMaxError / (1 << level);\n  this._skirtHeight = Math.min(thisLevelMaxError * 4.0, 1000.0);\n\n  var result = HeightmapTessellator.computeVertices({\n    heightmap: this._buffer,\n    structure: structure,\n    includeWebMercatorT: true,\n    width: this._width,\n    height: this._height,\n    nativeRectangle: nativeRectangle,\n    rectangle: rectangle,\n    relativeToCenter: center,\n    ellipsoid: ellipsoid,\n    skirtHeight: this._skirtHeight,\n    isGeographic: tilingScheme.projection instanceof GeographicProjection,\n    exaggeration: exaggeration,\n  });\n\n  // Free memory received from server after mesh is created.\n  this._buffer = undefined;\n\n  var indicesAndEdges;\n  if (this._skirtHeight > 0.0) {\n    indicesAndEdges = TerrainProvider.getRegularGridAndSkirtIndicesAndEdgeIndices(\n      this._width,\n      this._height\n    );\n  } else {\n    indicesAndEdges = TerrainProvider.getRegularGridIndicesAndEdgeIndices(\n      this._width,\n      this._height\n    );\n  }\n\n  var vertexCountWithoutSkirts = result.gridWidth * result.gridHeight;\n\n  // No need to clone here (as we do in the async version) because the result\n  // is not coming from a web worker.\n  return new TerrainMesh(\n    center,\n    result.vertices,\n    indicesAndEdges.indices,\n    indicesAndEdges.indexCountWithoutSkirts,\n    vertexCountWithoutSkirts,\n    result.minimumHeight,\n    result.maximumHeight,\n    result.boundingSphere3D,\n    result.occludeePointInScaledSpace,\n    result.encoding.getStride(),\n    result.orientedBoundingBox,\n    result.encoding,\n    exaggeration,\n    indicesAndEdges.westIndicesSouthToNorth,\n    indicesAndEdges.southIndicesEastToWest,\n    indicesAndEdges.eastIndicesNorthToSouth,\n    indicesAndEdges.northIndicesWestToEast\n  );\n};\n\n/**\n * Computes the terrain height at a specified longitude and latitude.\n *\n * @param {Rectangle} rectangle The rectangle covered by this terrain data.\n * @param {Number} longitude The longitude in radians.\n * @param {Number} latitude The latitude in radians.\n * @returns {Number} The terrain height at the specified position.  If the position\n *          is outside the rectangle, this method will extrapolate the height, which is likely to be wildly\n *          incorrect for positions far outside the rectangle.\n */\nHeightmapTerrainData.prototype.interpolateHeight = function (\n  rectangle,\n  longitude,\n  latitude\n) {\n  var width = this._width;\n  var height = this._height;\n\n  var structure = this._structure;\n  var stride = structure.stride;\n  var elementsPerHeight = structure.elementsPerHeight;\n  var elementMultiplier = structure.elementMultiplier;\n  var isBigEndian = structure.isBigEndian;\n  var heightOffset = structure.heightOffset;\n  var heightScale = structure.heightScale;\n\n  var isMeshCreated = defined(this._mesh);\n  var isLERCEncoding = this._encoding === HeightmapEncoding.LERC;\n  var isInterpolationImpossible = !isMeshCreated && isLERCEncoding;\n  if (isInterpolationImpossible) {\n    // We can't interpolate using the buffer because it's LERC encoded\n    //  so please call createMesh() first and interpolate using the mesh;\n    //  as mesh creation will decode the LERC buffer\n    return undefined;\n  }\n\n  var heightSample;\n  if (isMeshCreated) {\n    var buffer = this._mesh.vertices;\n    var encoding = this._mesh.encoding;\n    var exaggeration = this._mesh.exaggeration;\n    heightSample = interpolateMeshHeight(\n      buffer,\n      encoding,\n      heightOffset,\n      heightScale,\n      rectangle,\n      width,\n      height,\n      longitude,\n      latitude,\n      exaggeration\n    );\n  } else {\n    heightSample = interpolateHeight(\n      this._buffer,\n      elementsPerHeight,\n      elementMultiplier,\n      stride,\n      isBigEndian,\n      rectangle,\n      width,\n      height,\n      longitude,\n      latitude\n    );\n    heightSample = heightSample * heightScale + heightOffset;\n  }\n\n  return heightSample;\n};\n\n/**\n * Upsamples this terrain data for use by a descendant tile.  The resulting instance will contain a subset of the\n * height samples in this instance, interpolated if necessary.\n *\n * @param {TilingScheme} tilingScheme The tiling scheme of this terrain data.\n * @param {Number} thisX The X coordinate of this tile in the tiling scheme.\n * @param {Number} thisY The Y coordinate of this tile in the tiling scheme.\n * @param {Number} thisLevel The level of this tile in the tiling scheme.\n * @param {Number} descendantX The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {Number} descendantY The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.\n * @param {Number} descendantLevel The level within the tiling scheme of the descendant tile for which we are upsampling.\n * @returns {Promise.<HeightmapTerrainData>|undefined} A promise for upsampled heightmap terrain data for the descendant tile,\n *          or undefined if too many asynchronous upsample operations are in progress and the request has been\n *          deferred.\n */\nHeightmapTerrainData.prototype.upsample = function (\n  tilingScheme,\n  thisX,\n  thisY,\n  thisLevel,\n  descendantX,\n  descendantY,\n  descendantLevel\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(tilingScheme)) {\n    throw new DeveloperError(\"tilingScheme is required.\");\n  }\n  if (!defined(thisX)) {\n    throw new DeveloperError(\"thisX is required.\");\n  }\n  if (!defined(thisY)) {\n    throw new DeveloperError(\"thisY is required.\");\n  }\n  if (!defined(thisLevel)) {\n    throw new DeveloperError(\"thisLevel is required.\");\n  }\n  if (!defined(descendantX)) {\n    throw new DeveloperError(\"descendantX is required.\");\n  }\n  if (!defined(descendantY)) {\n    throw new DeveloperError(\"descendantY is required.\");\n  }\n  if (!defined(descendantLevel)) {\n    throw new DeveloperError(\"descendantLevel is required.\");\n  }\n  var levelDifference = descendantLevel - thisLevel;\n  if (levelDifference > 1) {\n    throw new DeveloperError(\n      \"Upsampling through more than one level at a time is not currently supported.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var meshData = this._mesh;\n  if (!defined(meshData)) {\n    return undefined;\n  }\n\n  var width = this._width;\n  var height = this._height;\n  var structure = this._structure;\n  var stride = structure.stride;\n\n  var heights = new this._bufferType(width * height * stride);\n\n  var buffer = meshData.vertices;\n  var encoding = meshData.encoding;\n\n  // PERFORMANCE_IDEA: don't recompute these rectangles - the caller already knows them.\n  var sourceRectangle = tilingScheme.tileXYToRectangle(thisX, thisY, thisLevel);\n  var destinationRectangle = tilingScheme.tileXYToRectangle(\n    descendantX,\n    descendantY,\n    descendantLevel\n  );\n\n  var heightOffset = structure.heightOffset;\n  var heightScale = structure.heightScale;\n  var exaggeration = meshData.exaggeration;\n\n  var elementsPerHeight = structure.elementsPerHeight;\n  var elementMultiplier = structure.elementMultiplier;\n  var isBigEndian = structure.isBigEndian;\n\n  var divisor = Math.pow(elementMultiplier, elementsPerHeight - 1);\n\n  for (var j = 0; j < height; ++j) {\n    var latitude = CesiumMath.lerp(\n      destinationRectangle.north,\n      destinationRectangle.south,\n      j / (height - 1)\n    );\n    for (var i = 0; i < width; ++i) {\n      var longitude = CesiumMath.lerp(\n        destinationRectangle.west,\n        destinationRectangle.east,\n        i / (width - 1)\n      );\n      var heightSample = interpolateMeshHeight(\n        buffer,\n        encoding,\n        heightOffset,\n        heightScale,\n        sourceRectangle,\n        width,\n        height,\n        longitude,\n        latitude,\n        exaggeration\n      );\n\n      // Use conditionals here instead of Math.min and Math.max so that an undefined\n      // lowestEncodedHeight or highestEncodedHeight has no effect.\n      heightSample =\n        heightSample < structure.lowestEncodedHeight\n          ? structure.lowestEncodedHeight\n          : heightSample;\n      heightSample =\n        heightSample > structure.highestEncodedHeight\n          ? structure.highestEncodedHeight\n          : heightSample;\n\n      setHeight(\n        heights,\n        elementsPerHeight,\n        elementMultiplier,\n        divisor,\n        stride,\n        isBigEndian,\n        j * width + i,\n        heightSample\n      );\n    }\n  }\n\n  return new HeightmapTerrainData({\n    buffer: heights,\n    width: width,\n    height: height,\n    childTileMask: 0,\n    structure: this._structure,\n    createdByUpsampling: true,\n  });\n};\n\n/**\n * Determines if a given child tile is available, based on the\n * {@link HeightmapTerrainData.childTileMask}.  The given child tile coordinates are assumed\n * to be one of the four children of this tile.  If non-child tile coordinates are\n * given, the availability of the southeast child tile is returned.\n *\n * @param {Number} thisX The tile X coordinate of this (the parent) tile.\n * @param {Number} thisY The tile Y coordinate of this (the parent) tile.\n * @param {Number} childX The tile X coordinate of the child tile to check for availability.\n * @param {Number} childY The tile Y coordinate of the child tile to check for availability.\n * @returns {Boolean} True if the child tile is available; otherwise, false.\n */\nHeightmapTerrainData.prototype.isChildAvailable = function (\n  thisX,\n  thisY,\n  childX,\n  childY\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(thisX)) {\n    throw new DeveloperError(\"thisX is required.\");\n  }\n  if (!defined(thisY)) {\n    throw new DeveloperError(\"thisY is required.\");\n  }\n  if (!defined(childX)) {\n    throw new DeveloperError(\"childX is required.\");\n  }\n  if (!defined(childY)) {\n    throw new DeveloperError(\"childY is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var bitNumber = 2; // northwest child\n  if (childX !== thisX * 2) {\n    ++bitNumber; // east child\n  }\n  if (childY !== thisY * 2) {\n    bitNumber -= 2; // south child\n  }\n\n  return (this._childTileMask & (1 << bitNumber)) !== 0;\n};\n\n/**\n * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution\n * terrain data.  If this value is false, the data was obtained from some other source, such\n * as by downloading it from a remote server.  This method should return true for instances\n * returned from a call to {@link HeightmapTerrainData#upsample}.\n *\n * @returns {Boolean} True if this instance was created by upsampling; otherwise, false.\n */\nHeightmapTerrainData.prototype.wasCreatedByUpsampling = function () {\n  return this._createdByUpsampling;\n};\n\nfunction interpolateHeight(\n  sourceHeights,\n  elementsPerHeight,\n  elementMultiplier,\n  stride,\n  isBigEndian,\n  sourceRectangle,\n  width,\n  height,\n  longitude,\n  latitude\n) {\n  var fromWest =\n    ((longitude - sourceRectangle.west) * (width - 1)) /\n    (sourceRectangle.east - sourceRectangle.west);\n  var fromSouth =\n    ((latitude - sourceRectangle.south) * (height - 1)) /\n    (sourceRectangle.north - sourceRectangle.south);\n\n  var westInteger = fromWest | 0;\n  var eastInteger = westInteger + 1;\n  if (eastInteger >= width) {\n    eastInteger = width - 1;\n    westInteger = width - 2;\n  }\n\n  var southInteger = fromSouth | 0;\n  var northInteger = southInteger + 1;\n  if (northInteger >= height) {\n    northInteger = height - 1;\n    southInteger = height - 2;\n  }\n\n  var dx = fromWest - westInteger;\n  var dy = fromSouth - southInteger;\n\n  southInteger = height - 1 - southInteger;\n  northInteger = height - 1 - northInteger;\n\n  var southwestHeight = getHeight(\n    sourceHeights,\n    elementsPerHeight,\n    elementMultiplier,\n    stride,\n    isBigEndian,\n    southInteger * width + westInteger\n  );\n  var southeastHeight = getHeight(\n    sourceHeights,\n    elementsPerHeight,\n    elementMultiplier,\n    stride,\n    isBigEndian,\n    southInteger * width + eastInteger\n  );\n  var northwestHeight = getHeight(\n    sourceHeights,\n    elementsPerHeight,\n    elementMultiplier,\n    stride,\n    isBigEndian,\n    northInteger * width + westInteger\n  );\n  var northeastHeight = getHeight(\n    sourceHeights,\n    elementsPerHeight,\n    elementMultiplier,\n    stride,\n    isBigEndian,\n    northInteger * width + eastInteger\n  );\n\n  return triangleInterpolateHeight(\n    dx,\n    dy,\n    southwestHeight,\n    southeastHeight,\n    northwestHeight,\n    northeastHeight\n  );\n}\n\nfunction interpolateMeshHeight(\n  buffer,\n  encoding,\n  heightOffset,\n  heightScale,\n  sourceRectangle,\n  width,\n  height,\n  longitude,\n  latitude,\n  exaggeration\n) {\n  // returns a height encoded according to the structure's heightScale and heightOffset.\n  var fromWest =\n    ((longitude - sourceRectangle.west) * (width - 1)) /\n    (sourceRectangle.east - sourceRectangle.west);\n  var fromSouth =\n    ((latitude - sourceRectangle.south) * (height - 1)) /\n    (sourceRectangle.north - sourceRectangle.south);\n\n  var westInteger = fromWest | 0;\n  var eastInteger = westInteger + 1;\n  if (eastInteger >= width) {\n    eastInteger = width - 1;\n    westInteger = width - 2;\n  }\n\n  var southInteger = fromSouth | 0;\n  var northInteger = southInteger + 1;\n  if (northInteger >= height) {\n    northInteger = height - 1;\n    southInteger = height - 2;\n  }\n\n  var dx = fromWest - westInteger;\n  var dy = fromSouth - southInteger;\n\n  southInteger = height - 1 - southInteger;\n  northInteger = height - 1 - northInteger;\n\n  var southwestHeight =\n    (encoding.decodeHeight(buffer, southInteger * width + westInteger) /\n      exaggeration -\n      heightOffset) /\n    heightScale;\n  var southeastHeight =\n    (encoding.decodeHeight(buffer, southInteger * width + eastInteger) /\n      exaggeration -\n      heightOffset) /\n    heightScale;\n  var northwestHeight =\n    (encoding.decodeHeight(buffer, northInteger * width + westInteger) /\n      exaggeration -\n      heightOffset) /\n    heightScale;\n  var northeastHeight =\n    (encoding.decodeHeight(buffer, northInteger * width + eastInteger) /\n      exaggeration -\n      heightOffset) /\n    heightScale;\n\n  return triangleInterpolateHeight(\n    dx,\n    dy,\n    southwestHeight,\n    southeastHeight,\n    northwestHeight,\n    northeastHeight\n  );\n}\n\nfunction triangleInterpolateHeight(\n  dX,\n  dY,\n  southwestHeight,\n  southeastHeight,\n  northwestHeight,\n  northeastHeight\n) {\n  // The HeightmapTessellator bisects the quad from southwest to northeast.\n  if (dY < dX) {\n    // Lower right triangle\n    return (\n      southwestHeight +\n      dX * (southeastHeight - southwestHeight) +\n      dY * (northeastHeight - southeastHeight)\n    );\n  }\n\n  // Upper left triangle\n  return (\n    southwestHeight +\n    dX * (northeastHeight - northwestHeight) +\n    dY * (northwestHeight - southwestHeight)\n  );\n}\n\nfunction getHeight(\n  heights,\n  elementsPerHeight,\n  elementMultiplier,\n  stride,\n  isBigEndian,\n  index\n) {\n  index *= stride;\n\n  var height = 0;\n  var i;\n\n  if (isBigEndian) {\n    for (i = 0; i < elementsPerHeight; ++i) {\n      height = height * elementMultiplier + heights[index + i];\n    }\n  } else {\n    for (i = elementsPerHeight - 1; i >= 0; --i) {\n      height = height * elementMultiplier + heights[index + i];\n    }\n  }\n\n  return height;\n}\n\nfunction setHeight(\n  heights,\n  elementsPerHeight,\n  elementMultiplier,\n  divisor,\n  stride,\n  isBigEndian,\n  index,\n  height\n) {\n  index *= stride;\n\n  var i;\n  if (isBigEndian) {\n    for (i = 0; i < elementsPerHeight - 1; ++i) {\n      heights[index + i] = (height / divisor) | 0;\n      height -= heights[index + i] * divisor;\n      divisor /= elementMultiplier;\n    }\n  } else {\n    for (i = elementsPerHeight - 1; i > 0; --i) {\n      heights[index + i] = (height / divisor) | 0;\n      height -= heights[index + i] * divisor;\n      divisor /= elementMultiplier;\n    }\n  }\n  heights[index + i] = height;\n}\nexport default HeightmapTerrainData;\n"]},"metadata":{},"sourceType":"module"}