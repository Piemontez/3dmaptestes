{"ast":null,"code":"import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport ShadowVolumeFS from \"../Shaders/ShadowVolumeFS.js\";\nimport VectorTileVS from \"../Shaders/VectorTileVS.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport Cesium3DTileFeature from \"./Cesium3DTileFeature.js\";\nimport ClassificationType from \"./ClassificationType.js\";\nimport DepthFunction from \"./DepthFunction.js\";\nimport Expression from \"./Expression.js\";\nimport StencilConstants from \"./StencilConstants.js\";\nimport StencilFunction from \"./StencilFunction.js\";\nimport StencilOperation from \"./StencilOperation.js\";\nimport Vector3DTileBatch from \"./Vector3DTileBatch.js\";\n/**\n * Creates a batch of classification meshes.\n *\n * @alias Vector3DTilePrimitive\n * @constructor\n *\n * @param {Object} options An object with following properties:\n * @param {Float32Array} options.positions The positions of the meshes.\n * @param {Uint16Array|Uint32Array} options.indices The indices of the triangulated meshes. The indices must be contiguous so that\n * the indices for mesh n are in [i, i + indexCounts[n]] where i = sum{indexCounts[0], indexCounts[n - 1]}.\n * @param {Uint32Array} options.indexCounts The number of indices for each mesh.\n * @param {Uint32Array} options.indexOffsets The offset into the index buffer for each mesh.\n * @param {Vector3DTileBatch[]} options.batchedIndices The index offset and count for each batch with the same color.\n * @param {Cartesian3} [options.center=Cartesian3.ZERO] The RTC center.\n * @param {Cesium3DTileBatchTable} options.batchTable The batch table for the tile containing the batched meshes.\n * @param {Uint16Array} options.batchIds The batch ids for each mesh.\n * @param {Uint16Array} options.vertexBatchIds The batch id for each vertex.\n * @param {BoundingSphere} options.boundingVolume The bounding volume for the entire batch of meshes.\n * @param {BoundingSphere[]} options.boundingVolumes The bounding volume for each mesh.\n * @param {ClassificationType} [options.classificationType] What this tile will classify.\n *\n * @private\n */\n\nfunction Vector3DTilePrimitive(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  this._batchTable = options.batchTable;\n  this._batchIds = options.batchIds; // These arrays are released after VAO creation.\n\n  this._positions = options.positions;\n  this._vertexBatchIds = options.vertexBatchIds; // These arrays are kept for re-batching indices based on colors.\n  // If WebGL 2 is supported, indices will be released and re-batching uses buffer-to-buffer copies.\n\n  this._indices = options.indices;\n  this._indexCounts = options.indexCounts;\n  this._indexOffsets = options.indexOffsets;\n  this._batchedIndices = options.batchedIndices;\n  this._boundingVolume = options.boundingVolume;\n  this._boundingVolumes = options.boundingVolumes;\n  this._center = defaultValue(options.center, Cartesian3.ZERO);\n  this._va = undefined;\n  this._sp = undefined;\n  this._spStencil = undefined;\n  this._spPick = undefined;\n  this._uniformMap = undefined; // Only used with WebGL 2 to ping-pong ibos after copy.\n\n  this._vaSwap = undefined;\n  this._rsStencilDepthPass = undefined;\n  this._rsStencilDepthPass3DTiles = undefined;\n  this._rsColorPass = undefined;\n  this._rsPickPass = undefined;\n  this._rsWireframe = undefined;\n  this._commands = [];\n  this._commandsIgnoreShow = [];\n  this._pickCommands = [];\n  this._constantColor = Color.clone(Color.WHITE);\n  this._highlightColor = this._constantColor;\n  this._batchDirty = true;\n  this._pickCommandsDirty = true;\n  this._framesSinceLastRebatch = 0;\n  this._updatingAllCommands = false;\n  this._trianglesLength = this._indices.length / 3;\n  this._geometryByteLength = this._indices.byteLength + this._positions.byteLength + this._vertexBatchIds.byteLength;\n  /**\n   * Draw the wireframe of the classification meshes.\n   * @type {Boolean}\n   * @default false\n   */\n\n  this.debugWireframe = false;\n  this._debugWireframe = this.debugWireframe;\n  this._wireframeDirty = false;\n  /**\n   * Forces a re-batch instead of waiting after a number of frames have been rendered. For testing only.\n   * @type {Boolean}\n   * @default false\n   */\n\n  this.forceRebatch = false;\n  /**\n   * What this tile will classify.\n   * @type {ClassificationType}\n   * @default ClassificationType.BOTH\n   */\n\n  this.classificationType = defaultValue(options.classificationType, ClassificationType.BOTH); // Hidden options\n\n  this._vertexShaderSource = options._vertexShaderSource;\n  this._fragmentShaderSource = options._fragmentShaderSource;\n  this._attributeLocations = options._attributeLocations;\n  this._uniformMap = options._uniformMap;\n  this._pickId = options._pickId;\n  this._modelMatrix = options._modelMatrix;\n  this._boundingSphere = options._boundingSphere;\n  this._batchIdLookUp = {};\n  var length = this._batchIds.length;\n\n  for (var i = 0; i < length; ++i) {\n    var batchId = this._batchIds[i];\n    this._batchIdLookUp[batchId] = i;\n  }\n}\n\nObject.defineProperties(Vector3DTilePrimitive.prototype, {\n  /**\n   * Gets the number of triangles.\n   *\n   * @memberof Vector3DTilePrimitive.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  trianglesLength: {\n    get: function () {\n      return this._trianglesLength;\n    }\n  },\n\n  /**\n   * Gets the geometry memory in bytes.\n   *\n   * @memberof Vector3DTilePrimitive.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  geometryByteLength: {\n    get: function () {\n      return this._geometryByteLength;\n    }\n  }\n});\nvar defaultAttributeLocations = {\n  position: 0,\n  a_batchId: 1\n};\n\nfunction createVertexArray(primitive, context) {\n  if (defined(primitive._va)) {\n    return;\n  }\n\n  var positionBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: primitive._positions,\n    usage: BufferUsage.STATIC_DRAW\n  });\n  var idBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: primitive._vertexBatchIds,\n    usage: BufferUsage.STATIC_DRAW\n  });\n  var indexBuffer = Buffer.createIndexBuffer({\n    context: context,\n    typedArray: primitive._indices,\n    usage: BufferUsage.DYNAMIC_DRAW,\n    indexDatatype: primitive._indices.BYTES_PER_ELEMENT === 2 ? IndexDatatype.UNSIGNED_SHORT : IndexDatatype.UNSIGNED_INT\n  });\n  var vertexAttributes = [{\n    index: 0,\n    vertexBuffer: positionBuffer,\n    componentDatatype: ComponentDatatype.fromTypedArray(primitive._positions),\n    componentsPerAttribute: 3\n  }, {\n    index: 1,\n    vertexBuffer: idBuffer,\n    componentDatatype: ComponentDatatype.fromTypedArray(primitive._vertexBatchIds),\n    componentsPerAttribute: 1\n  }];\n  primitive._va = new VertexArray({\n    context: context,\n    attributes: vertexAttributes,\n    indexBuffer: indexBuffer\n  });\n\n  if (context.webgl2) {\n    primitive._vaSwap = new VertexArray({\n      context: context,\n      attributes: vertexAttributes,\n      indexBuffer: Buffer.createIndexBuffer({\n        context: context,\n        sizeInBytes: indexBuffer.sizeInBytes,\n        usage: BufferUsage.DYNAMIC_DRAW,\n        indexDatatype: indexBuffer.indexDatatype\n      })\n    });\n  }\n\n  primitive._batchedPositions = undefined;\n  primitive._transferrableBatchIds = undefined;\n  primitive._vertexBatchIds = undefined;\n  primitive._verticesPromise = undefined;\n}\n\nfunction createShaders(primitive, context) {\n  if (defined(primitive._sp)) {\n    return;\n  }\n\n  var batchTable = primitive._batchTable;\n  var attributeLocations = defaultValue(primitive._attributeLocations, defaultAttributeLocations);\n  var pickId = primitive._pickId;\n  var vertexShaderSource = primitive._vertexShaderSource;\n  var fragmentShaderSource = primitive._fragmentShaderSource;\n\n  if (defined(vertexShaderSource)) {\n    primitive._sp = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: vertexShaderSource,\n      fragmentShaderSource: fragmentShaderSource,\n      attributeLocations: attributeLocations\n    });\n    primitive._spStencil = primitive._sp;\n    fragmentShaderSource = ShaderSource.replaceMain(fragmentShaderSource, \"czm_non_pick_main\");\n    fragmentShaderSource = fragmentShaderSource + \"void main() \\n\" + \"{ \\n\" + \"    czm_non_pick_main(); \\n\" + \"    gl_FragColor = \" + pickId + \"; \\n\" + \"} \\n\";\n    primitive._spPick = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: vertexShaderSource,\n      fragmentShaderSource: fragmentShaderSource,\n      attributeLocations: attributeLocations\n    });\n    return;\n  }\n\n  var vsSource = batchTable.getVertexShaderCallback(false, \"a_batchId\", undefined)(VectorTileVS);\n  var fsSource = batchTable.getFragmentShaderCallback()(ShadowVolumeFS, false, undefined);\n  pickId = batchTable.getPickId();\n  var vs = new ShaderSource({\n    sources: [vsSource]\n  });\n  var fs = new ShaderSource({\n    defines: [\"VECTOR_TILE\"],\n    sources: [fsSource]\n  });\n  primitive._sp = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations\n  });\n  vs = new ShaderSource({\n    sources: [VectorTileVS]\n  });\n  fs = new ShaderSource({\n    defines: [\"VECTOR_TILE\"],\n    sources: [ShadowVolumeFS]\n  });\n  primitive._spStencil = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations\n  });\n  fsSource = ShaderSource.replaceMain(fsSource, \"czm_non_pick_main\");\n  fsSource = fsSource + \"\\n\" + \"void main() \\n\" + \"{ \\n\" + \"    czm_non_pick_main(); \\n\" + \"    gl_FragColor = \" + pickId + \"; \\n\" + \"} \\n\";\n  var pickVS = new ShaderSource({\n    sources: [vsSource]\n  });\n  var pickFS = new ShaderSource({\n    defines: [\"VECTOR_TILE\"],\n    sources: [fsSource]\n  });\n  primitive._spPick = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: pickVS,\n    fragmentShaderSource: pickFS,\n    attributeLocations: attributeLocations\n  });\n}\n\nfunction getStencilDepthRenderState(mask3DTiles) {\n  var stencilFunction = mask3DTiles ? StencilFunction.EQUAL : StencilFunction.ALWAYS;\n  return {\n    colorMask: {\n      red: false,\n      green: false,\n      blue: false,\n      alpha: false\n    },\n    stencilTest: {\n      enabled: true,\n      frontFunction: stencilFunction,\n      frontOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.DECREMENT_WRAP,\n        zPass: StencilOperation.KEEP\n      },\n      backFunction: stencilFunction,\n      backOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.INCREMENT_WRAP,\n        zPass: StencilOperation.KEEP\n      },\n      reference: StencilConstants.CESIUM_3D_TILE_MASK,\n      mask: StencilConstants.CESIUM_3D_TILE_MASK\n    },\n    stencilMask: StencilConstants.CLASSIFICATION_MASK,\n    depthTest: {\n      enabled: true,\n      func: DepthFunction.LESS_OR_EQUAL\n    },\n    depthMask: false\n  };\n}\n\nvar colorRenderState = {\n  stencilTest: {\n    enabled: true,\n    frontFunction: StencilFunction.NOT_EQUAL,\n    frontOperation: {\n      fail: StencilOperation.ZERO,\n      zFail: StencilOperation.ZERO,\n      zPass: StencilOperation.ZERO\n    },\n    backFunction: StencilFunction.NOT_EQUAL,\n    backOperation: {\n      fail: StencilOperation.ZERO,\n      zFail: StencilOperation.ZERO,\n      zPass: StencilOperation.ZERO\n    },\n    reference: 0,\n    mask: StencilConstants.CLASSIFICATION_MASK\n  },\n  stencilMask: StencilConstants.CLASSIFICATION_MASK,\n  depthTest: {\n    enabled: false\n  },\n  depthMask: false,\n  blending: BlendingState.ALPHA_BLEND\n};\nvar pickRenderState = {\n  stencilTest: {\n    enabled: true,\n    frontFunction: StencilFunction.NOT_EQUAL,\n    frontOperation: {\n      fail: StencilOperation.ZERO,\n      zFail: StencilOperation.ZERO,\n      zPass: StencilOperation.ZERO\n    },\n    backFunction: StencilFunction.NOT_EQUAL,\n    backOperation: {\n      fail: StencilOperation.ZERO,\n      zFail: StencilOperation.ZERO,\n      zPass: StencilOperation.ZERO\n    },\n    reference: 0,\n    mask: StencilConstants.CLASSIFICATION_MASK\n  },\n  stencilMask: StencilConstants.CLASSIFICATION_MASK,\n  depthTest: {\n    enabled: false\n  },\n  depthMask: false\n};\n\nfunction createRenderStates(primitive) {\n  if (defined(primitive._rsStencilDepthPass)) {\n    return;\n  }\n\n  primitive._rsStencilDepthPass = RenderState.fromCache(getStencilDepthRenderState(false));\n  primitive._rsStencilDepthPass3DTiles = RenderState.fromCache(getStencilDepthRenderState(true));\n  primitive._rsColorPass = RenderState.fromCache(colorRenderState);\n  primitive._rsPickPass = RenderState.fromCache(pickRenderState);\n}\n\nvar modifiedModelViewScratch = new Matrix4();\nvar rtcScratch = new Cartesian3();\n\nfunction createUniformMap(primitive, context) {\n  if (defined(primitive._uniformMap)) {\n    return;\n  }\n\n  var uniformMap = {\n    u_modifiedModelViewProjection: function () {\n      var viewMatrix = context.uniformState.view;\n      var projectionMatrix = context.uniformState.projection;\n      Matrix4.clone(viewMatrix, modifiedModelViewScratch);\n      Matrix4.multiplyByPoint(modifiedModelViewScratch, primitive._center, rtcScratch);\n      Matrix4.setTranslation(modifiedModelViewScratch, rtcScratch, modifiedModelViewScratch);\n      Matrix4.multiply(projectionMatrix, modifiedModelViewScratch, modifiedModelViewScratch);\n      return modifiedModelViewScratch;\n    },\n    u_highlightColor: function () {\n      return primitive._highlightColor;\n    }\n  };\n  primitive._uniformMap = primitive._batchTable.getUniformMapCallback()(uniformMap);\n}\n\nfunction copyIndicesCPU(indices, newIndices, currentOffset, offsets, counts, batchIds, batchIdLookUp) {\n  var sizeInBytes = indices.constructor.BYTES_PER_ELEMENT;\n  var batchedIdsLength = batchIds.length;\n\n  for (var j = 0; j < batchedIdsLength; ++j) {\n    var batchedId = batchIds[j];\n    var index = batchIdLookUp[batchedId];\n    var offset = offsets[index];\n    var count = counts[index];\n    var subarray = new indices.constructor(indices.buffer, sizeInBytes * offset, count);\n    newIndices.set(subarray, currentOffset);\n    offsets[index] = currentOffset;\n    currentOffset += count;\n  }\n\n  return currentOffset;\n}\n\nfunction rebatchCPU(primitive, batchedIndices) {\n  var indices = primitive._indices;\n  var indexOffsets = primitive._indexOffsets;\n  var indexCounts = primitive._indexCounts;\n  var batchIdLookUp = primitive._batchIdLookUp;\n  var newIndices = new indices.constructor(indices.length);\n  var current = batchedIndices.pop();\n  var newBatchedIndices = [current];\n  var currentOffset = copyIndicesCPU(indices, newIndices, 0, indexOffsets, indexCounts, current.batchIds, batchIdLookUp);\n  current.offset = 0;\n  current.count = currentOffset;\n\n  while (batchedIndices.length > 0) {\n    var next = batchedIndices.pop();\n\n    if (Color.equals(next.color, current.color)) {\n      currentOffset = copyIndicesCPU(indices, newIndices, currentOffset, indexOffsets, indexCounts, next.batchIds, batchIdLookUp);\n      current.batchIds = current.batchIds.concat(next.batchIds);\n      current.count = currentOffset - current.offset;\n    } else {\n      var offset = currentOffset;\n      currentOffset = copyIndicesCPU(indices, newIndices, currentOffset, indexOffsets, indexCounts, next.batchIds, batchIdLookUp);\n      next.offset = offset;\n      next.count = currentOffset - offset;\n      newBatchedIndices.push(next);\n      current = next;\n    }\n  }\n\n  primitive._va.indexBuffer.copyFromArrayView(newIndices);\n\n  primitive._indices = newIndices;\n  primitive._batchedIndices = newBatchedIndices;\n}\n\nfunction copyIndicesGPU(readBuffer, writeBuffer, currentOffset, offsets, counts, batchIds, batchIdLookUp) {\n  var sizeInBytes = readBuffer.bytesPerIndex;\n  var batchedIdsLength = batchIds.length;\n\n  for (var j = 0; j < batchedIdsLength; ++j) {\n    var batchedId = batchIds[j];\n    var index = batchIdLookUp[batchedId];\n    var offset = offsets[index];\n    var count = counts[index];\n    writeBuffer.copyFromBuffer(readBuffer, offset * sizeInBytes, currentOffset * sizeInBytes, count * sizeInBytes);\n    offsets[index] = currentOffset;\n    currentOffset += count;\n  }\n\n  return currentOffset;\n}\n\nfunction rebatchGPU(primitive, batchedIndices) {\n  var indexOffsets = primitive._indexOffsets;\n  var indexCounts = primitive._indexCounts;\n  var batchIdLookUp = primitive._batchIdLookUp;\n  var current = batchedIndices.pop();\n  var newBatchedIndices = [current];\n  var readBuffer = primitive._va.indexBuffer;\n  var writeBuffer = primitive._vaSwap.indexBuffer;\n  var currentOffset = copyIndicesGPU(readBuffer, writeBuffer, 0, indexOffsets, indexCounts, current.batchIds, batchIdLookUp);\n  current.offset = 0;\n  current.count = currentOffset;\n\n  while (batchedIndices.length > 0) {\n    var next = batchedIndices.pop();\n\n    if (Color.equals(next.color, current.color)) {\n      currentOffset = copyIndicesGPU(readBuffer, writeBuffer, currentOffset, indexOffsets, indexCounts, next.batchIds, batchIdLookUp);\n      current.batchIds = current.batchIds.concat(next.batchIds);\n      current.count = currentOffset - current.offset;\n    } else {\n      var offset = currentOffset;\n      currentOffset = copyIndicesGPU(readBuffer, writeBuffer, currentOffset, indexOffsets, indexCounts, next.batchIds, batchIdLookUp);\n      next.offset = offset;\n      next.count = currentOffset - offset;\n      newBatchedIndices.push(next);\n      current = next;\n    }\n  }\n\n  var temp = primitive._va;\n  primitive._va = primitive._vaSwap;\n  primitive._vaSwap = temp;\n  primitive._batchedIndices = newBatchedIndices;\n}\n\nfunction compareColors(a, b) {\n  return b.color.toRgba() - a.color.toRgba();\n} // PERFORMANCE_IDEA: For WebGL 2, we can use copyBufferSubData for buffer-to-buffer copies.\n// PERFORMANCE_IDEA: Not supported, but we could use glMultiDrawElements here.\n\n\nfunction rebatchCommands(primitive, context) {\n  if (!primitive._batchDirty) {\n    return false;\n  }\n\n  var batchedIndices = primitive._batchedIndices;\n  var length = batchedIndices.length;\n  var needToRebatch = false;\n  var colorCounts = {};\n\n  for (var i = 0; i < length; ++i) {\n    var color = batchedIndices[i].color;\n    var rgba = color.toRgba();\n\n    if (defined(colorCounts[rgba])) {\n      needToRebatch = true;\n      break;\n    } else {\n      colorCounts[rgba] = true;\n    }\n  }\n\n  if (!needToRebatch) {\n    primitive._batchDirty = false;\n    return false;\n  }\n\n  if (needToRebatch && !primitive.forceRebatch && primitive._framesSinceLastRebatch < 120) {\n    ++primitive._framesSinceLastRebatch;\n    return;\n  }\n\n  batchedIndices.sort(compareColors);\n\n  if (context.webgl2) {\n    rebatchGPU(primitive, batchedIndices);\n  } else {\n    rebatchCPU(primitive, batchedIndices);\n  }\n\n  primitive._framesSinceLastRebatch = 0;\n  primitive._batchDirty = false;\n  primitive._pickCommandsDirty = true;\n  primitive._wireframeDirty = true;\n  return true;\n}\n\nfunction createColorCommands(primitive, context) {\n  var needsRebatch = rebatchCommands(primitive, context);\n  var commands = primitive._commands;\n  var batchedIndices = primitive._batchedIndices;\n  var length = batchedIndices.length;\n  var commandsLength = length * 2;\n\n  if (defined(commands) && !needsRebatch && commands.length === commandsLength) {\n    return;\n  }\n\n  commands.length = commandsLength;\n  var vertexArray = primitive._va;\n  var sp = primitive._sp;\n  var modelMatrix = defaultValue(primitive._modelMatrix, Matrix4.IDENTITY);\n  var uniformMap = primitive._uniformMap;\n  var bv = primitive._boundingVolume;\n\n  for (var j = 0; j < length; ++j) {\n    var offset = batchedIndices[j].offset;\n    var count = batchedIndices[j].count;\n    var stencilDepthCommand = commands[j * 2];\n\n    if (!defined(stencilDepthCommand)) {\n      stencilDepthCommand = commands[j * 2] = new DrawCommand({\n        owner: primitive\n      });\n    }\n\n    stencilDepthCommand.vertexArray = vertexArray;\n    stencilDepthCommand.modelMatrix = modelMatrix;\n    stencilDepthCommand.offset = offset;\n    stencilDepthCommand.count = count;\n    stencilDepthCommand.renderState = primitive._rsStencilDepthPass;\n    stencilDepthCommand.shaderProgram = sp;\n    stencilDepthCommand.uniformMap = uniformMap;\n    stencilDepthCommand.boundingVolume = bv;\n    stencilDepthCommand.cull = false;\n    stencilDepthCommand.pass = Pass.TERRAIN_CLASSIFICATION;\n    var stencilDepthDerivedCommand = DrawCommand.shallowClone(stencilDepthCommand, stencilDepthCommand.derivedCommands.tileset);\n    stencilDepthDerivedCommand.renderState = primitive._rsStencilDepthPass3DTiles;\n    stencilDepthDerivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    stencilDepthCommand.derivedCommands.tileset = stencilDepthDerivedCommand;\n    var colorCommand = commands[j * 2 + 1];\n\n    if (!defined(colorCommand)) {\n      colorCommand = commands[j * 2 + 1] = new DrawCommand({\n        owner: primitive\n      });\n    }\n\n    colorCommand.vertexArray = vertexArray;\n    colorCommand.modelMatrix = modelMatrix;\n    colorCommand.offset = offset;\n    colorCommand.count = count;\n    colorCommand.renderState = primitive._rsColorPass;\n    colorCommand.shaderProgram = sp;\n    colorCommand.uniformMap = uniformMap;\n    colorCommand.boundingVolume = bv;\n    colorCommand.cull = false;\n    colorCommand.pass = Pass.TERRAIN_CLASSIFICATION;\n    var colorDerivedCommand = DrawCommand.shallowClone(colorCommand, colorCommand.derivedCommands.tileset);\n    colorDerivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    colorCommand.derivedCommands.tileset = colorDerivedCommand;\n  }\n\n  primitive._commandsDirty = true;\n}\n\nfunction createColorCommandsIgnoreShow(primitive, frameState) {\n  if (primitive.classificationType === ClassificationType.TERRAIN || !frameState.invertClassification || defined(primitive._commandsIgnoreShow) && !primitive._commandsDirty) {\n    return;\n  }\n\n  var commands = primitive._commands;\n  var commandsIgnoreShow = primitive._commandsIgnoreShow;\n  var spStencil = primitive._spStencil;\n  var commandsLength = commands.length;\n  var length = commandsIgnoreShow.length = commandsLength / 2;\n  var commandIndex = 0;\n\n  for (var j = 0; j < length; ++j) {\n    var commandIgnoreShow = commandsIgnoreShow[j] = DrawCommand.shallowClone(commands[commandIndex], commandsIgnoreShow[j]);\n    commandIgnoreShow.shaderProgram = spStencil;\n    commandIgnoreShow.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW;\n    commandIndex += 2;\n  }\n\n  primitive._commandsDirty = false;\n}\n\nfunction createPickCommands(primitive) {\n  if (!primitive._pickCommandsDirty) {\n    return;\n  }\n\n  var length = primitive._indexOffsets.length;\n  var pickCommands = primitive._pickCommands;\n  pickCommands.length = length * 2;\n  var vertexArray = primitive._va;\n  var spStencil = primitive._spStencil;\n  var spPick = primitive._spPick;\n  var modelMatrix = defaultValue(primitive._modelMatrix, Matrix4.IDENTITY);\n  var uniformMap = primitive._uniformMap;\n\n  for (var j = 0; j < length; ++j) {\n    var offset = primitive._indexOffsets[j];\n    var count = primitive._indexCounts[j];\n    var bv = defined(primitive._boundingVolumes) ? primitive._boundingVolumes[j] : primitive.boundingVolume;\n    var stencilDepthCommand = pickCommands[j * 2];\n\n    if (!defined(stencilDepthCommand)) {\n      stencilDepthCommand = pickCommands[j * 2] = new DrawCommand({\n        owner: primitive,\n        pickOnly: true\n      });\n    }\n\n    stencilDepthCommand.vertexArray = vertexArray;\n    stencilDepthCommand.modelMatrix = modelMatrix;\n    stencilDepthCommand.offset = offset;\n    stencilDepthCommand.count = count;\n    stencilDepthCommand.renderState = primitive._rsStencilDepthPass;\n    stencilDepthCommand.shaderProgram = spStencil;\n    stencilDepthCommand.uniformMap = uniformMap;\n    stencilDepthCommand.boundingVolume = bv;\n    stencilDepthCommand.pass = Pass.TERRAIN_CLASSIFICATION;\n    var stencilDepthDerivedCommand = DrawCommand.shallowClone(stencilDepthCommand, stencilDepthCommand.derivedCommands.tileset);\n    stencilDepthDerivedCommand.renderState = primitive._rsStencilDepthPass3DTiles;\n    stencilDepthDerivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    stencilDepthCommand.derivedCommands.tileset = stencilDepthDerivedCommand;\n    var colorCommand = pickCommands[j * 2 + 1];\n\n    if (!defined(colorCommand)) {\n      colorCommand = pickCommands[j * 2 + 1] = new DrawCommand({\n        owner: primitive,\n        pickOnly: true\n      });\n    }\n\n    colorCommand.vertexArray = vertexArray;\n    colorCommand.modelMatrix = modelMatrix;\n    colorCommand.offset = offset;\n    colorCommand.count = count;\n    colorCommand.renderState = primitive._rsPickPass;\n    colorCommand.shaderProgram = spPick;\n    colorCommand.uniformMap = uniformMap;\n    colorCommand.boundingVolume = bv;\n    colorCommand.pass = Pass.TERRAIN_CLASSIFICATION;\n    var colorDerivedCommand = DrawCommand.shallowClone(colorCommand, colorCommand.derivedCommands.tileset);\n    colorDerivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    colorCommand.derivedCommands.tileset = colorDerivedCommand;\n  }\n\n  primitive._pickCommandsDirty = false;\n}\n/**\n * Creates features for each mesh and places it at the batch id index of features.\n *\n * @param {Vector3DTileContent} content The vector tile content.\n * @param {Cesium3DTileFeature[]} features An array of features where the polygon features will be placed.\n */\n\n\nVector3DTilePrimitive.prototype.createFeatures = function (content, features) {\n  var batchIds = this._batchIds;\n  var length = batchIds.length;\n\n  for (var i = 0; i < length; ++i) {\n    var batchId = batchIds[i];\n    features[batchId] = new Cesium3DTileFeature(content, batchId);\n  }\n};\n/**\n * Colors the entire tile when enabled is true. The resulting color will be (mesh batch table color * color).\n *\n * @param {Boolean} enabled Whether to enable debug coloring.\n * @param {Color} color The debug color.\n */\n\n\nVector3DTilePrimitive.prototype.applyDebugSettings = function (enabled, color) {\n  this._highlightColor = enabled ? color : this._constantColor;\n};\n\nfunction clearStyle(polygons, features) {\n  polygons._updatingAllCommands = true;\n  var batchIds = polygons._batchIds;\n  var length = batchIds.length;\n  var i;\n\n  for (i = 0; i < length; ++i) {\n    var batchId = batchIds[i];\n    var feature = features[batchId];\n    feature.show = true;\n    feature.color = Color.WHITE;\n  }\n\n  var batchedIndices = polygons._batchedIndices;\n  length = batchedIndices.length;\n\n  for (i = 0; i < length; ++i) {\n    batchedIndices[i].color = Color.clone(Color.WHITE);\n  }\n\n  polygons._updatingAllCommands = false;\n  polygons._batchDirty = true;\n}\n\nvar scratchColor = new Color();\nvar DEFAULT_COLOR_VALUE = Color.WHITE;\nvar DEFAULT_SHOW_VALUE = true;\nvar complexExpressionReg = /\\$/;\n/**\n * Apply a style to the content.\n *\n * @param {Cesium3DTileStyle} style The style.\n * @param {Cesium3DTileFeature[]} features The array of features.\n */\n\nVector3DTilePrimitive.prototype.applyStyle = function (style, features) {\n  if (!defined(style)) {\n    clearStyle(this, features);\n    return;\n  }\n\n  var colorExpression = style.color;\n  var isSimpleStyle = colorExpression instanceof Expression && !complexExpressionReg.test(colorExpression.expression);\n  this._updatingAllCommands = isSimpleStyle;\n  var batchIds = this._batchIds;\n  var length = batchIds.length;\n  var i;\n\n  for (i = 0; i < length; ++i) {\n    var batchId = batchIds[i];\n    var feature = features[batchId];\n    feature.color = defined(style.color) ? style.color.evaluateColor(feature, scratchColor) : DEFAULT_COLOR_VALUE;\n    feature.show = defined(style.show) ? style.show.evaluate(feature) : DEFAULT_SHOW_VALUE;\n  }\n\n  if (isSimpleStyle) {\n    var batchedIndices = this._batchedIndices;\n    length = batchedIndices.length;\n\n    for (i = 0; i < length; ++i) {\n      batchedIndices[i].color = Color.clone(Color.WHITE);\n    }\n\n    this._updatingAllCommands = false;\n    this._batchDirty = true;\n  }\n};\n/**\n * Call when updating the color of a mesh with batchId changes color. The meshes will need to be re-batched\n * on the next update.\n *\n * @param {Number} batchId The batch id of the meshes whose color has changed.\n * @param {Color} color The new polygon color.\n */\n\n\nVector3DTilePrimitive.prototype.updateCommands = function (batchId, color) {\n  if (this._updatingAllCommands) {\n    return;\n  }\n\n  var batchIdLookUp = this._batchIdLookUp;\n  var index = batchIdLookUp[batchId];\n\n  if (!defined(index)) {\n    return;\n  }\n\n  var indexOffsets = this._indexOffsets;\n  var indexCounts = this._indexCounts;\n  var offset = indexOffsets[index];\n  var count = indexCounts[index];\n  var batchedIndices = this._batchedIndices;\n  var length = batchedIndices.length;\n  var i;\n\n  for (i = 0; i < length; ++i) {\n    var batchedOffset = batchedIndices[i].offset;\n    var batchedCount = batchedIndices[i].count;\n\n    if (offset >= batchedOffset && offset < batchedOffset + batchedCount) {\n      break;\n    }\n  }\n\n  batchedIndices.push(new Vector3DTileBatch({\n    color: Color.clone(color),\n    offset: offset,\n    count: count,\n    batchIds: [batchId]\n  }));\n  var startIds = [];\n  var endIds = [];\n  var batchIds = batchedIndices[i].batchIds;\n  var batchIdsLength = batchIds.length;\n\n  for (var j = 0; j < batchIdsLength; ++j) {\n    var id = batchIds[j];\n\n    if (id === batchId) {\n      continue;\n    }\n\n    var offsetIndex = batchIdLookUp[id];\n\n    if (indexOffsets[offsetIndex] < offset) {\n      startIds.push(id);\n    } else {\n      endIds.push(id);\n    }\n  }\n\n  if (endIds.length !== 0) {\n    batchedIndices.push(new Vector3DTileBatch({\n      color: Color.clone(batchedIndices[i].color),\n      offset: offset + count,\n      count: batchedIndices[i].offset + batchedIndices[i].count - (offset + count),\n      batchIds: endIds\n    }));\n  }\n\n  if (startIds.length !== 0) {\n    batchedIndices[i].count = offset - batchedIndices[i].offset;\n    batchedIndices[i].batchIds = startIds;\n  } else {\n    batchedIndices.splice(i, 1);\n  }\n\n  this._batchDirty = true;\n};\n\nfunction queueCommands(primitive, frameState, commands, commandsIgnoreShow) {\n  var classificationType = primitive.classificationType;\n  var queueTerrainCommands = classificationType !== ClassificationType.CESIUM_3D_TILE;\n  var queue3DTilesCommands = classificationType !== ClassificationType.TERRAIN;\n  var commandList = frameState.commandList;\n  var commandLength = commands.length;\n  var command;\n  var i;\n\n  for (i = 0; i < commandLength; ++i) {\n    if (queueTerrainCommands) {\n      command = commands[i];\n      command.pass = Pass.TERRAIN_CLASSIFICATION;\n      commandList.push(command);\n    }\n\n    if (queue3DTilesCommands) {\n      command = commands[i].derivedCommands.tileset;\n      command.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n      commandList.push(command);\n    }\n  }\n\n  if (!frameState.invertClassification || !defined(commandsIgnoreShow)) {\n    return;\n  }\n\n  commandLength = commandsIgnoreShow.length;\n\n  for (i = 0; i < commandLength; ++i) {\n    commandList.push(commandsIgnoreShow[i]);\n  }\n}\n\nfunction queueWireframeCommands(frameState, commands) {\n  var commandList = frameState.commandList;\n  var commandLength = commands.length;\n\n  for (var i = 0; i < commandLength; i += 2) {\n    var command = commands[i + 1];\n    command.pass = Pass.OPAQUE;\n    commandList.push(command);\n  }\n}\n\nfunction updateWireframe(primitive) {\n  var earlyExit = primitive.debugWireframe === primitive._debugWireframe;\n  earlyExit = earlyExit && !(primitive.debugWireframe && primitive._wireframeDirty);\n\n  if (earlyExit) {\n    return;\n  }\n\n  if (!defined(primitive._rsWireframe)) {\n    primitive._rsWireframe = RenderState.fromCache({});\n  }\n\n  var rs;\n  var type;\n\n  if (primitive.debugWireframe) {\n    rs = primitive._rsWireframe;\n    type = PrimitiveType.LINES;\n  } else {\n    rs = primitive._rsColorPass;\n    type = PrimitiveType.TRIANGLES;\n  }\n\n  var commands = primitive._commands;\n  var commandLength = commands.length;\n\n  for (var i = 0; i < commandLength; i += 2) {\n    var command = commands[i + 1];\n    command.renderState = rs;\n    command.primitiveType = type;\n  }\n\n  primitive._debugWireframe = primitive.debugWireframe;\n  primitive._wireframeDirty = false;\n}\n/**\n * Updates the batches and queues the commands for rendering.\n *\n * @param {FrameState} frameState The current frame state.\n */\n\n\nVector3DTilePrimitive.prototype.update = function (frameState) {\n  var context = frameState.context;\n  createVertexArray(this, context);\n  createShaders(this, context);\n  createRenderStates(this);\n  createUniformMap(this, context);\n  var passes = frameState.passes;\n\n  if (passes.render) {\n    createColorCommands(this, context);\n    createColorCommandsIgnoreShow(this, frameState);\n    updateWireframe(this);\n\n    if (this._debugWireframe) {\n      queueWireframeCommands(frameState, this._commands);\n    } else {\n      queueCommands(this, frameState, this._commands, this._commandsIgnoreShow);\n    }\n  }\n\n  if (passes.pick) {\n    createPickCommands(this);\n    queueCommands(this, frameState, this._pickCommands);\n  }\n};\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n */\n\n\nVector3DTilePrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\n\n\nVector3DTilePrimitive.prototype.destroy = function () {\n  this._va = this._va && this._va.destroy();\n  this._sp = this._sp && this._sp.destroy();\n  this._spPick = this._spPick && this._spPick.destroy();\n  this._vaSwap = this._vaSwap && this._vaSwap.destroy();\n  return destroyObject(this);\n};\n\nexport default Vector3DTilePrimitive;","map":{"version":3,"sources":["/home/usuario/davi/thalamus/wms/3dmaptestes/leaflet_cesium/client/node_modules/cesium/Source/Scene/Vector3DTilePrimitive.js"],"names":["Cartesian3","Color","ComponentDatatype","defaultValue","defined","destroyObject","IndexDatatype","Matrix4","PrimitiveType","Buffer","BufferUsage","DrawCommand","Pass","RenderState","ShaderProgram","ShaderSource","VertexArray","ShadowVolumeFS","VectorTileVS","BlendingState","Cesium3DTileFeature","ClassificationType","DepthFunction","Expression","StencilConstants","StencilFunction","StencilOperation","Vector3DTileBatch","Vector3DTilePrimitive","options","EMPTY_OBJECT","_batchTable","batchTable","_batchIds","batchIds","_positions","positions","_vertexBatchIds","vertexBatchIds","_indices","indices","_indexCounts","indexCounts","_indexOffsets","indexOffsets","_batchedIndices","batchedIndices","_boundingVolume","boundingVolume","_boundingVolumes","boundingVolumes","_center","center","ZERO","_va","undefined","_sp","_spStencil","_spPick","_uniformMap","_vaSwap","_rsStencilDepthPass","_rsStencilDepthPass3DTiles","_rsColorPass","_rsPickPass","_rsWireframe","_commands","_commandsIgnoreShow","_pickCommands","_constantColor","clone","WHITE","_highlightColor","_batchDirty","_pickCommandsDirty","_framesSinceLastRebatch","_updatingAllCommands","_trianglesLength","length","_geometryByteLength","byteLength","debugWireframe","_debugWireframe","_wireframeDirty","forceRebatch","classificationType","BOTH","_vertexShaderSource","_fragmentShaderSource","_attributeLocations","_pickId","_modelMatrix","_boundingSphere","_batchIdLookUp","i","batchId","Object","defineProperties","prototype","trianglesLength","get","geometryByteLength","defaultAttributeLocations","position","a_batchId","createVertexArray","primitive","context","positionBuffer","createVertexBuffer","typedArray","usage","STATIC_DRAW","idBuffer","indexBuffer","createIndexBuffer","DYNAMIC_DRAW","indexDatatype","BYTES_PER_ELEMENT","UNSIGNED_SHORT","UNSIGNED_INT","vertexAttributes","index","vertexBuffer","componentDatatype","fromTypedArray","componentsPerAttribute","attributes","webgl2","sizeInBytes","_batchedPositions","_transferrableBatchIds","_verticesPromise","createShaders","attributeLocations","pickId","vertexShaderSource","fragmentShaderSource","fromCache","replaceMain","vsSource","getVertexShaderCallback","fsSource","getFragmentShaderCallback","getPickId","vs","sources","fs","defines","pickVS","pickFS","getStencilDepthRenderState","mask3DTiles","stencilFunction","EQUAL","ALWAYS","colorMask","red","green","blue","alpha","stencilTest","enabled","frontFunction","frontOperation","fail","KEEP","zFail","DECREMENT_WRAP","zPass","backFunction","backOperation","INCREMENT_WRAP","reference","CESIUM_3D_TILE_MASK","mask","stencilMask","CLASSIFICATION_MASK","depthTest","func","LESS_OR_EQUAL","depthMask","colorRenderState","NOT_EQUAL","blending","ALPHA_BLEND","pickRenderState","createRenderStates","modifiedModelViewScratch","rtcScratch","createUniformMap","uniformMap","u_modifiedModelViewProjection","viewMatrix","uniformState","view","projectionMatrix","projection","multiplyByPoint","setTranslation","multiply","u_highlightColor","getUniformMapCallback","copyIndicesCPU","newIndices","currentOffset","offsets","counts","batchIdLookUp","constructor","batchedIdsLength","j","batchedId","offset","count","subarray","buffer","set","rebatchCPU","current","pop","newBatchedIndices","next","equals","color","concat","push","copyFromArrayView","copyIndicesGPU","readBuffer","writeBuffer","bytesPerIndex","copyFromBuffer","rebatchGPU","temp","compareColors","a","b","toRgba","rebatchCommands","needToRebatch","colorCounts","rgba","sort","createColorCommands","needsRebatch","commands","commandsLength","vertexArray","sp","modelMatrix","IDENTITY","bv","stencilDepthCommand","owner","renderState","shaderProgram","cull","pass","TERRAIN_CLASSIFICATION","stencilDepthDerivedCommand","shallowClone","derivedCommands","tileset","CESIUM_3D_TILE_CLASSIFICATION","colorCommand","colorDerivedCommand","_commandsDirty","createColorCommandsIgnoreShow","frameState","TERRAIN","invertClassification","commandsIgnoreShow","spStencil","commandIndex","commandIgnoreShow","CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW","createPickCommands","pickCommands","spPick","pickOnly","createFeatures","content","features","applyDebugSettings","clearStyle","polygons","feature","show","scratchColor","DEFAULT_COLOR_VALUE","DEFAULT_SHOW_VALUE","complexExpressionReg","applyStyle","style","colorExpression","isSimpleStyle","test","expression","evaluateColor","evaluate","updateCommands","batchedOffset","batchedCount","startIds","endIds","batchIdsLength","id","offsetIndex","splice","queueCommands","queueTerrainCommands","CESIUM_3D_TILE","queue3DTilesCommands","commandList","commandLength","command","queueWireframeCommands","OPAQUE","updateWireframe","earlyExit","rs","type","LINES","TRIANGLES","primitiveType","update","passes","render","pick","isDestroyed","destroy"],"mappings":"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","sourcesContent":["import Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport ShadowVolumeFS from \"../Shaders/ShadowVolumeFS.js\";\nimport VectorTileVS from \"../Shaders/VectorTileVS.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport Cesium3DTileFeature from \"./Cesium3DTileFeature.js\";\nimport ClassificationType from \"./ClassificationType.js\";\nimport DepthFunction from \"./DepthFunction.js\";\nimport Expression from \"./Expression.js\";\nimport StencilConstants from \"./StencilConstants.js\";\nimport StencilFunction from \"./StencilFunction.js\";\nimport StencilOperation from \"./StencilOperation.js\";\nimport Vector3DTileBatch from \"./Vector3DTileBatch.js\";\n\n/**\n * Creates a batch of classification meshes.\n *\n * @alias Vector3DTilePrimitive\n * @constructor\n *\n * @param {Object} options An object with following properties:\n * @param {Float32Array} options.positions The positions of the meshes.\n * @param {Uint16Array|Uint32Array} options.indices The indices of the triangulated meshes. The indices must be contiguous so that\n * the indices for mesh n are in [i, i + indexCounts[n]] where i = sum{indexCounts[0], indexCounts[n - 1]}.\n * @param {Uint32Array} options.indexCounts The number of indices for each mesh.\n * @param {Uint32Array} options.indexOffsets The offset into the index buffer for each mesh.\n * @param {Vector3DTileBatch[]} options.batchedIndices The index offset and count for each batch with the same color.\n * @param {Cartesian3} [options.center=Cartesian3.ZERO] The RTC center.\n * @param {Cesium3DTileBatchTable} options.batchTable The batch table for the tile containing the batched meshes.\n * @param {Uint16Array} options.batchIds The batch ids for each mesh.\n * @param {Uint16Array} options.vertexBatchIds The batch id for each vertex.\n * @param {BoundingSphere} options.boundingVolume The bounding volume for the entire batch of meshes.\n * @param {BoundingSphere[]} options.boundingVolumes The bounding volume for each mesh.\n * @param {ClassificationType} [options.classificationType] What this tile will classify.\n *\n * @private\n */\nfunction Vector3DTilePrimitive(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._batchTable = options.batchTable;\n  this._batchIds = options.batchIds;\n\n  // These arrays are released after VAO creation.\n  this._positions = options.positions;\n  this._vertexBatchIds = options.vertexBatchIds;\n\n  // These arrays are kept for re-batching indices based on colors.\n  // If WebGL 2 is supported, indices will be released and re-batching uses buffer-to-buffer copies.\n  this._indices = options.indices;\n  this._indexCounts = options.indexCounts;\n  this._indexOffsets = options.indexOffsets;\n  this._batchedIndices = options.batchedIndices;\n\n  this._boundingVolume = options.boundingVolume;\n  this._boundingVolumes = options.boundingVolumes;\n\n  this._center = defaultValue(options.center, Cartesian3.ZERO);\n\n  this._va = undefined;\n  this._sp = undefined;\n  this._spStencil = undefined;\n  this._spPick = undefined;\n  this._uniformMap = undefined;\n\n  // Only used with WebGL 2 to ping-pong ibos after copy.\n  this._vaSwap = undefined;\n\n  this._rsStencilDepthPass = undefined;\n  this._rsStencilDepthPass3DTiles = undefined;\n  this._rsColorPass = undefined;\n  this._rsPickPass = undefined;\n  this._rsWireframe = undefined;\n\n  this._commands = [];\n  this._commandsIgnoreShow = [];\n  this._pickCommands = [];\n\n  this._constantColor = Color.clone(Color.WHITE);\n  this._highlightColor = this._constantColor;\n\n  this._batchDirty = true;\n  this._pickCommandsDirty = true;\n  this._framesSinceLastRebatch = 0;\n\n  this._updatingAllCommands = false;\n\n  this._trianglesLength = this._indices.length / 3;\n  this._geometryByteLength =\n    this._indices.byteLength +\n    this._positions.byteLength +\n    this._vertexBatchIds.byteLength;\n\n  /**\n   * Draw the wireframe of the classification meshes.\n   * @type {Boolean}\n   * @default false\n   */\n  this.debugWireframe = false;\n  this._debugWireframe = this.debugWireframe;\n  this._wireframeDirty = false;\n\n  /**\n   * Forces a re-batch instead of waiting after a number of frames have been rendered. For testing only.\n   * @type {Boolean}\n   * @default false\n   */\n  this.forceRebatch = false;\n\n  /**\n   * What this tile will classify.\n   * @type {ClassificationType}\n   * @default ClassificationType.BOTH\n   */\n  this.classificationType = defaultValue(\n    options.classificationType,\n    ClassificationType.BOTH\n  );\n\n  // Hidden options\n  this._vertexShaderSource = options._vertexShaderSource;\n  this._fragmentShaderSource = options._fragmentShaderSource;\n  this._attributeLocations = options._attributeLocations;\n  this._uniformMap = options._uniformMap;\n  this._pickId = options._pickId;\n  this._modelMatrix = options._modelMatrix;\n  this._boundingSphere = options._boundingSphere;\n\n  this._batchIdLookUp = {};\n\n  var length = this._batchIds.length;\n  for (var i = 0; i < length; ++i) {\n    var batchId = this._batchIds[i];\n    this._batchIdLookUp[batchId] = i;\n  }\n}\n\nObject.defineProperties(Vector3DTilePrimitive.prototype, {\n  /**\n   * Gets the number of triangles.\n   *\n   * @memberof Vector3DTilePrimitive.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  trianglesLength: {\n    get: function () {\n      return this._trianglesLength;\n    },\n  },\n\n  /**\n   * Gets the geometry memory in bytes.\n   *\n   * @memberof Vector3DTilePrimitive.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  geometryByteLength: {\n    get: function () {\n      return this._geometryByteLength;\n    },\n  },\n});\n\nvar defaultAttributeLocations = {\n  position: 0,\n  a_batchId: 1,\n};\n\nfunction createVertexArray(primitive, context) {\n  if (defined(primitive._va)) {\n    return;\n  }\n\n  var positionBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: primitive._positions,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  var idBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: primitive._vertexBatchIds,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  var indexBuffer = Buffer.createIndexBuffer({\n    context: context,\n    typedArray: primitive._indices,\n    usage: BufferUsage.DYNAMIC_DRAW,\n    indexDatatype:\n      primitive._indices.BYTES_PER_ELEMENT === 2\n        ? IndexDatatype.UNSIGNED_SHORT\n        : IndexDatatype.UNSIGNED_INT,\n  });\n\n  var vertexAttributes = [\n    {\n      index: 0,\n      vertexBuffer: positionBuffer,\n      componentDatatype: ComponentDatatype.fromTypedArray(primitive._positions),\n      componentsPerAttribute: 3,\n    },\n    {\n      index: 1,\n      vertexBuffer: idBuffer,\n      componentDatatype: ComponentDatatype.fromTypedArray(\n        primitive._vertexBatchIds\n      ),\n      componentsPerAttribute: 1,\n    },\n  ];\n\n  primitive._va = new VertexArray({\n    context: context,\n    attributes: vertexAttributes,\n    indexBuffer: indexBuffer,\n  });\n\n  if (context.webgl2) {\n    primitive._vaSwap = new VertexArray({\n      context: context,\n      attributes: vertexAttributes,\n      indexBuffer: Buffer.createIndexBuffer({\n        context: context,\n        sizeInBytes: indexBuffer.sizeInBytes,\n        usage: BufferUsage.DYNAMIC_DRAW,\n        indexDatatype: indexBuffer.indexDatatype,\n      }),\n    });\n  }\n\n  primitive._batchedPositions = undefined;\n  primitive._transferrableBatchIds = undefined;\n  primitive._vertexBatchIds = undefined;\n  primitive._verticesPromise = undefined;\n}\n\nfunction createShaders(primitive, context) {\n  if (defined(primitive._sp)) {\n    return;\n  }\n\n  var batchTable = primitive._batchTable;\n  var attributeLocations = defaultValue(\n    primitive._attributeLocations,\n    defaultAttributeLocations\n  );\n\n  var pickId = primitive._pickId;\n  var vertexShaderSource = primitive._vertexShaderSource;\n  var fragmentShaderSource = primitive._fragmentShaderSource;\n  if (defined(vertexShaderSource)) {\n    primitive._sp = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: vertexShaderSource,\n      fragmentShaderSource: fragmentShaderSource,\n      attributeLocations: attributeLocations,\n    });\n    primitive._spStencil = primitive._sp;\n\n    fragmentShaderSource = ShaderSource.replaceMain(\n      fragmentShaderSource,\n      \"czm_non_pick_main\"\n    );\n    fragmentShaderSource =\n      fragmentShaderSource +\n      \"void main() \\n\" +\n      \"{ \\n\" +\n      \"    czm_non_pick_main(); \\n\" +\n      \"    gl_FragColor = \" +\n      pickId +\n      \"; \\n\" +\n      \"} \\n\";\n    primitive._spPick = ShaderProgram.fromCache({\n      context: context,\n      vertexShaderSource: vertexShaderSource,\n      fragmentShaderSource: fragmentShaderSource,\n      attributeLocations: attributeLocations,\n    });\n    return;\n  }\n\n  var vsSource = batchTable.getVertexShaderCallback(\n    false,\n    \"a_batchId\",\n    undefined\n  )(VectorTileVS);\n  var fsSource = batchTable.getFragmentShaderCallback()(\n    ShadowVolumeFS,\n    false,\n    undefined\n  );\n\n  pickId = batchTable.getPickId();\n\n  var vs = new ShaderSource({\n    sources: [vsSource],\n  });\n  var fs = new ShaderSource({\n    defines: [\"VECTOR_TILE\"],\n    sources: [fsSource],\n  });\n\n  primitive._sp = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations,\n  });\n\n  vs = new ShaderSource({\n    sources: [VectorTileVS],\n  });\n  fs = new ShaderSource({\n    defines: [\"VECTOR_TILE\"],\n    sources: [ShadowVolumeFS],\n  });\n\n  primitive._spStencil = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations,\n  });\n\n  fsSource = ShaderSource.replaceMain(fsSource, \"czm_non_pick_main\");\n  fsSource =\n    fsSource +\n    \"\\n\" +\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    czm_non_pick_main(); \\n\" +\n    \"    gl_FragColor = \" +\n    pickId +\n    \"; \\n\" +\n    \"} \\n\";\n\n  var pickVS = new ShaderSource({\n    sources: [vsSource],\n  });\n  var pickFS = new ShaderSource({\n    defines: [\"VECTOR_TILE\"],\n    sources: [fsSource],\n  });\n  primitive._spPick = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: pickVS,\n    fragmentShaderSource: pickFS,\n    attributeLocations: attributeLocations,\n  });\n}\n\nfunction getStencilDepthRenderState(mask3DTiles) {\n  var stencilFunction = mask3DTiles\n    ? StencilFunction.EQUAL\n    : StencilFunction.ALWAYS;\n  return {\n    colorMask: {\n      red: false,\n      green: false,\n      blue: false,\n      alpha: false,\n    },\n    stencilTest: {\n      enabled: true,\n      frontFunction: stencilFunction,\n      frontOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.DECREMENT_WRAP,\n        zPass: StencilOperation.KEEP,\n      },\n      backFunction: stencilFunction,\n      backOperation: {\n        fail: StencilOperation.KEEP,\n        zFail: StencilOperation.INCREMENT_WRAP,\n        zPass: StencilOperation.KEEP,\n      },\n      reference: StencilConstants.CESIUM_3D_TILE_MASK,\n      mask: StencilConstants.CESIUM_3D_TILE_MASK,\n    },\n    stencilMask: StencilConstants.CLASSIFICATION_MASK,\n    depthTest: {\n      enabled: true,\n      func: DepthFunction.LESS_OR_EQUAL,\n    },\n    depthMask: false,\n  };\n}\n\nvar colorRenderState = {\n  stencilTest: {\n    enabled: true,\n    frontFunction: StencilFunction.NOT_EQUAL,\n    frontOperation: {\n      fail: StencilOperation.ZERO,\n      zFail: StencilOperation.ZERO,\n      zPass: StencilOperation.ZERO,\n    },\n    backFunction: StencilFunction.NOT_EQUAL,\n    backOperation: {\n      fail: StencilOperation.ZERO,\n      zFail: StencilOperation.ZERO,\n      zPass: StencilOperation.ZERO,\n    },\n    reference: 0,\n    mask: StencilConstants.CLASSIFICATION_MASK,\n  },\n  stencilMask: StencilConstants.CLASSIFICATION_MASK,\n  depthTest: {\n    enabled: false,\n  },\n  depthMask: false,\n  blending: BlendingState.ALPHA_BLEND,\n};\n\nvar pickRenderState = {\n  stencilTest: {\n    enabled: true,\n    frontFunction: StencilFunction.NOT_EQUAL,\n    frontOperation: {\n      fail: StencilOperation.ZERO,\n      zFail: StencilOperation.ZERO,\n      zPass: StencilOperation.ZERO,\n    },\n    backFunction: StencilFunction.NOT_EQUAL,\n    backOperation: {\n      fail: StencilOperation.ZERO,\n      zFail: StencilOperation.ZERO,\n      zPass: StencilOperation.ZERO,\n    },\n    reference: 0,\n    mask: StencilConstants.CLASSIFICATION_MASK,\n  },\n  stencilMask: StencilConstants.CLASSIFICATION_MASK,\n  depthTest: {\n    enabled: false,\n  },\n  depthMask: false,\n};\n\nfunction createRenderStates(primitive) {\n  if (defined(primitive._rsStencilDepthPass)) {\n    return;\n  }\n\n  primitive._rsStencilDepthPass = RenderState.fromCache(\n    getStencilDepthRenderState(false)\n  );\n  primitive._rsStencilDepthPass3DTiles = RenderState.fromCache(\n    getStencilDepthRenderState(true)\n  );\n  primitive._rsColorPass = RenderState.fromCache(colorRenderState);\n  primitive._rsPickPass = RenderState.fromCache(pickRenderState);\n}\n\nvar modifiedModelViewScratch = new Matrix4();\nvar rtcScratch = new Cartesian3();\n\nfunction createUniformMap(primitive, context) {\n  if (defined(primitive._uniformMap)) {\n    return;\n  }\n\n  var uniformMap = {\n    u_modifiedModelViewProjection: function () {\n      var viewMatrix = context.uniformState.view;\n      var projectionMatrix = context.uniformState.projection;\n      Matrix4.clone(viewMatrix, modifiedModelViewScratch);\n      Matrix4.multiplyByPoint(\n        modifiedModelViewScratch,\n        primitive._center,\n        rtcScratch\n      );\n      Matrix4.setTranslation(\n        modifiedModelViewScratch,\n        rtcScratch,\n        modifiedModelViewScratch\n      );\n      Matrix4.multiply(\n        projectionMatrix,\n        modifiedModelViewScratch,\n        modifiedModelViewScratch\n      );\n      return modifiedModelViewScratch;\n    },\n    u_highlightColor: function () {\n      return primitive._highlightColor;\n    },\n  };\n\n  primitive._uniformMap = primitive._batchTable.getUniformMapCallback()(\n    uniformMap\n  );\n}\n\nfunction copyIndicesCPU(\n  indices,\n  newIndices,\n  currentOffset,\n  offsets,\n  counts,\n  batchIds,\n  batchIdLookUp\n) {\n  var sizeInBytes = indices.constructor.BYTES_PER_ELEMENT;\n\n  var batchedIdsLength = batchIds.length;\n  for (var j = 0; j < batchedIdsLength; ++j) {\n    var batchedId = batchIds[j];\n    var index = batchIdLookUp[batchedId];\n    var offset = offsets[index];\n    var count = counts[index];\n\n    var subarray = new indices.constructor(\n      indices.buffer,\n      sizeInBytes * offset,\n      count\n    );\n    newIndices.set(subarray, currentOffset);\n\n    offsets[index] = currentOffset;\n    currentOffset += count;\n  }\n\n  return currentOffset;\n}\n\nfunction rebatchCPU(primitive, batchedIndices) {\n  var indices = primitive._indices;\n  var indexOffsets = primitive._indexOffsets;\n  var indexCounts = primitive._indexCounts;\n  var batchIdLookUp = primitive._batchIdLookUp;\n\n  var newIndices = new indices.constructor(indices.length);\n\n  var current = batchedIndices.pop();\n  var newBatchedIndices = [current];\n\n  var currentOffset = copyIndicesCPU(\n    indices,\n    newIndices,\n    0,\n    indexOffsets,\n    indexCounts,\n    current.batchIds,\n    batchIdLookUp\n  );\n\n  current.offset = 0;\n  current.count = currentOffset;\n\n  while (batchedIndices.length > 0) {\n    var next = batchedIndices.pop();\n    if (Color.equals(next.color, current.color)) {\n      currentOffset = copyIndicesCPU(\n        indices,\n        newIndices,\n        currentOffset,\n        indexOffsets,\n        indexCounts,\n        next.batchIds,\n        batchIdLookUp\n      );\n      current.batchIds = current.batchIds.concat(next.batchIds);\n      current.count = currentOffset - current.offset;\n    } else {\n      var offset = currentOffset;\n      currentOffset = copyIndicesCPU(\n        indices,\n        newIndices,\n        currentOffset,\n        indexOffsets,\n        indexCounts,\n        next.batchIds,\n        batchIdLookUp\n      );\n\n      next.offset = offset;\n      next.count = currentOffset - offset;\n      newBatchedIndices.push(next);\n      current = next;\n    }\n  }\n\n  primitive._va.indexBuffer.copyFromArrayView(newIndices);\n\n  primitive._indices = newIndices;\n  primitive._batchedIndices = newBatchedIndices;\n}\n\nfunction copyIndicesGPU(\n  readBuffer,\n  writeBuffer,\n  currentOffset,\n  offsets,\n  counts,\n  batchIds,\n  batchIdLookUp\n) {\n  var sizeInBytes = readBuffer.bytesPerIndex;\n\n  var batchedIdsLength = batchIds.length;\n  for (var j = 0; j < batchedIdsLength; ++j) {\n    var batchedId = batchIds[j];\n    var index = batchIdLookUp[batchedId];\n    var offset = offsets[index];\n    var count = counts[index];\n\n    writeBuffer.copyFromBuffer(\n      readBuffer,\n      offset * sizeInBytes,\n      currentOffset * sizeInBytes,\n      count * sizeInBytes\n    );\n\n    offsets[index] = currentOffset;\n    currentOffset += count;\n  }\n\n  return currentOffset;\n}\n\nfunction rebatchGPU(primitive, batchedIndices) {\n  var indexOffsets = primitive._indexOffsets;\n  var indexCounts = primitive._indexCounts;\n  var batchIdLookUp = primitive._batchIdLookUp;\n\n  var current = batchedIndices.pop();\n  var newBatchedIndices = [current];\n\n  var readBuffer = primitive._va.indexBuffer;\n  var writeBuffer = primitive._vaSwap.indexBuffer;\n\n  var currentOffset = copyIndicesGPU(\n    readBuffer,\n    writeBuffer,\n    0,\n    indexOffsets,\n    indexCounts,\n    current.batchIds,\n    batchIdLookUp\n  );\n\n  current.offset = 0;\n  current.count = currentOffset;\n\n  while (batchedIndices.length > 0) {\n    var next = batchedIndices.pop();\n    if (Color.equals(next.color, current.color)) {\n      currentOffset = copyIndicesGPU(\n        readBuffer,\n        writeBuffer,\n        currentOffset,\n        indexOffsets,\n        indexCounts,\n        next.batchIds,\n        batchIdLookUp\n      );\n      current.batchIds = current.batchIds.concat(next.batchIds);\n      current.count = currentOffset - current.offset;\n    } else {\n      var offset = currentOffset;\n      currentOffset = copyIndicesGPU(\n        readBuffer,\n        writeBuffer,\n        currentOffset,\n        indexOffsets,\n        indexCounts,\n        next.batchIds,\n        batchIdLookUp\n      );\n      next.offset = offset;\n      next.count = currentOffset - offset;\n      newBatchedIndices.push(next);\n      current = next;\n    }\n  }\n\n  var temp = primitive._va;\n  primitive._va = primitive._vaSwap;\n  primitive._vaSwap = temp;\n\n  primitive._batchedIndices = newBatchedIndices;\n}\n\nfunction compareColors(a, b) {\n  return b.color.toRgba() - a.color.toRgba();\n}\n\n// PERFORMANCE_IDEA: For WebGL 2, we can use copyBufferSubData for buffer-to-buffer copies.\n// PERFORMANCE_IDEA: Not supported, but we could use glMultiDrawElements here.\nfunction rebatchCommands(primitive, context) {\n  if (!primitive._batchDirty) {\n    return false;\n  }\n\n  var batchedIndices = primitive._batchedIndices;\n  var length = batchedIndices.length;\n\n  var needToRebatch = false;\n  var colorCounts = {};\n\n  for (var i = 0; i < length; ++i) {\n    var color = batchedIndices[i].color;\n    var rgba = color.toRgba();\n    if (defined(colorCounts[rgba])) {\n      needToRebatch = true;\n      break;\n    } else {\n      colorCounts[rgba] = true;\n    }\n  }\n\n  if (!needToRebatch) {\n    primitive._batchDirty = false;\n    return false;\n  }\n\n  if (\n    needToRebatch &&\n    !primitive.forceRebatch &&\n    primitive._framesSinceLastRebatch < 120\n  ) {\n    ++primitive._framesSinceLastRebatch;\n    return;\n  }\n\n  batchedIndices.sort(compareColors);\n\n  if (context.webgl2) {\n    rebatchGPU(primitive, batchedIndices);\n  } else {\n    rebatchCPU(primitive, batchedIndices);\n  }\n\n  primitive._framesSinceLastRebatch = 0;\n  primitive._batchDirty = false;\n  primitive._pickCommandsDirty = true;\n  primitive._wireframeDirty = true;\n  return true;\n}\n\nfunction createColorCommands(primitive, context) {\n  var needsRebatch = rebatchCommands(primitive, context);\n\n  var commands = primitive._commands;\n  var batchedIndices = primitive._batchedIndices;\n  var length = batchedIndices.length;\n  var commandsLength = length * 2;\n\n  if (\n    defined(commands) &&\n    !needsRebatch &&\n    commands.length === commandsLength\n  ) {\n    return;\n  }\n\n  commands.length = commandsLength;\n\n  var vertexArray = primitive._va;\n  var sp = primitive._sp;\n  var modelMatrix = defaultValue(primitive._modelMatrix, Matrix4.IDENTITY);\n  var uniformMap = primitive._uniformMap;\n  var bv = primitive._boundingVolume;\n\n  for (var j = 0; j < length; ++j) {\n    var offset = batchedIndices[j].offset;\n    var count = batchedIndices[j].count;\n\n    var stencilDepthCommand = commands[j * 2];\n    if (!defined(stencilDepthCommand)) {\n      stencilDepthCommand = commands[j * 2] = new DrawCommand({\n        owner: primitive,\n      });\n    }\n\n    stencilDepthCommand.vertexArray = vertexArray;\n    stencilDepthCommand.modelMatrix = modelMatrix;\n    stencilDepthCommand.offset = offset;\n    stencilDepthCommand.count = count;\n    stencilDepthCommand.renderState = primitive._rsStencilDepthPass;\n    stencilDepthCommand.shaderProgram = sp;\n    stencilDepthCommand.uniformMap = uniformMap;\n    stencilDepthCommand.boundingVolume = bv;\n    stencilDepthCommand.cull = false;\n    stencilDepthCommand.pass = Pass.TERRAIN_CLASSIFICATION;\n\n    var stencilDepthDerivedCommand = DrawCommand.shallowClone(\n      stencilDepthCommand,\n      stencilDepthCommand.derivedCommands.tileset\n    );\n    stencilDepthDerivedCommand.renderState =\n      primitive._rsStencilDepthPass3DTiles;\n    stencilDepthDerivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    stencilDepthCommand.derivedCommands.tileset = stencilDepthDerivedCommand;\n\n    var colorCommand = commands[j * 2 + 1];\n    if (!defined(colorCommand)) {\n      colorCommand = commands[j * 2 + 1] = new DrawCommand({\n        owner: primitive,\n      });\n    }\n\n    colorCommand.vertexArray = vertexArray;\n    colorCommand.modelMatrix = modelMatrix;\n    colorCommand.offset = offset;\n    colorCommand.count = count;\n    colorCommand.renderState = primitive._rsColorPass;\n    colorCommand.shaderProgram = sp;\n    colorCommand.uniformMap = uniformMap;\n    colorCommand.boundingVolume = bv;\n    colorCommand.cull = false;\n    colorCommand.pass = Pass.TERRAIN_CLASSIFICATION;\n\n    var colorDerivedCommand = DrawCommand.shallowClone(\n      colorCommand,\n      colorCommand.derivedCommands.tileset\n    );\n    colorDerivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    colorCommand.derivedCommands.tileset = colorDerivedCommand;\n  }\n\n  primitive._commandsDirty = true;\n}\n\nfunction createColorCommandsIgnoreShow(primitive, frameState) {\n  if (\n    primitive.classificationType === ClassificationType.TERRAIN ||\n    !frameState.invertClassification ||\n    (defined(primitive._commandsIgnoreShow) && !primitive._commandsDirty)\n  ) {\n    return;\n  }\n\n  var commands = primitive._commands;\n  var commandsIgnoreShow = primitive._commandsIgnoreShow;\n  var spStencil = primitive._spStencil;\n\n  var commandsLength = commands.length;\n  var length = (commandsIgnoreShow.length = commandsLength / 2);\n\n  var commandIndex = 0;\n  for (var j = 0; j < length; ++j) {\n    var commandIgnoreShow = (commandsIgnoreShow[j] = DrawCommand.shallowClone(\n      commands[commandIndex],\n      commandsIgnoreShow[j]\n    ));\n    commandIgnoreShow.shaderProgram = spStencil;\n    commandIgnoreShow.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW;\n\n    commandIndex += 2;\n  }\n\n  primitive._commandsDirty = false;\n}\n\nfunction createPickCommands(primitive) {\n  if (!primitive._pickCommandsDirty) {\n    return;\n  }\n\n  var length = primitive._indexOffsets.length;\n  var pickCommands = primitive._pickCommands;\n  pickCommands.length = length * 2;\n\n  var vertexArray = primitive._va;\n  var spStencil = primitive._spStencil;\n  var spPick = primitive._spPick;\n  var modelMatrix = defaultValue(primitive._modelMatrix, Matrix4.IDENTITY);\n  var uniformMap = primitive._uniformMap;\n\n  for (var j = 0; j < length; ++j) {\n    var offset = primitive._indexOffsets[j];\n    var count = primitive._indexCounts[j];\n    var bv = defined(primitive._boundingVolumes)\n      ? primitive._boundingVolumes[j]\n      : primitive.boundingVolume;\n\n    var stencilDepthCommand = pickCommands[j * 2];\n    if (!defined(stencilDepthCommand)) {\n      stencilDepthCommand = pickCommands[j * 2] = new DrawCommand({\n        owner: primitive,\n        pickOnly: true,\n      });\n    }\n\n    stencilDepthCommand.vertexArray = vertexArray;\n    stencilDepthCommand.modelMatrix = modelMatrix;\n    stencilDepthCommand.offset = offset;\n    stencilDepthCommand.count = count;\n    stencilDepthCommand.renderState = primitive._rsStencilDepthPass;\n    stencilDepthCommand.shaderProgram = spStencil;\n    stencilDepthCommand.uniformMap = uniformMap;\n    stencilDepthCommand.boundingVolume = bv;\n    stencilDepthCommand.pass = Pass.TERRAIN_CLASSIFICATION;\n\n    var stencilDepthDerivedCommand = DrawCommand.shallowClone(\n      stencilDepthCommand,\n      stencilDepthCommand.derivedCommands.tileset\n    );\n    stencilDepthDerivedCommand.renderState =\n      primitive._rsStencilDepthPass3DTiles;\n    stencilDepthDerivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    stencilDepthCommand.derivedCommands.tileset = stencilDepthDerivedCommand;\n\n    var colorCommand = pickCommands[j * 2 + 1];\n    if (!defined(colorCommand)) {\n      colorCommand = pickCommands[j * 2 + 1] = new DrawCommand({\n        owner: primitive,\n        pickOnly: true,\n      });\n    }\n\n    colorCommand.vertexArray = vertexArray;\n    colorCommand.modelMatrix = modelMatrix;\n    colorCommand.offset = offset;\n    colorCommand.count = count;\n    colorCommand.renderState = primitive._rsPickPass;\n    colorCommand.shaderProgram = spPick;\n    colorCommand.uniformMap = uniformMap;\n    colorCommand.boundingVolume = bv;\n    colorCommand.pass = Pass.TERRAIN_CLASSIFICATION;\n\n    var colorDerivedCommand = DrawCommand.shallowClone(\n      colorCommand,\n      colorCommand.derivedCommands.tileset\n    );\n    colorDerivedCommand.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n    colorCommand.derivedCommands.tileset = colorDerivedCommand;\n  }\n\n  primitive._pickCommandsDirty = false;\n}\n\n/**\n * Creates features for each mesh and places it at the batch id index of features.\n *\n * @param {Vector3DTileContent} content The vector tile content.\n * @param {Cesium3DTileFeature[]} features An array of features where the polygon features will be placed.\n */\nVector3DTilePrimitive.prototype.createFeatures = function (content, features) {\n  var batchIds = this._batchIds;\n  var length = batchIds.length;\n  for (var i = 0; i < length; ++i) {\n    var batchId = batchIds[i];\n    features[batchId] = new Cesium3DTileFeature(content, batchId);\n  }\n};\n\n/**\n * Colors the entire tile when enabled is true. The resulting color will be (mesh batch table color * color).\n *\n * @param {Boolean} enabled Whether to enable debug coloring.\n * @param {Color} color The debug color.\n */\nVector3DTilePrimitive.prototype.applyDebugSettings = function (enabled, color) {\n  this._highlightColor = enabled ? color : this._constantColor;\n};\n\nfunction clearStyle(polygons, features) {\n  polygons._updatingAllCommands = true;\n\n  var batchIds = polygons._batchIds;\n  var length = batchIds.length;\n  var i;\n\n  for (i = 0; i < length; ++i) {\n    var batchId = batchIds[i];\n    var feature = features[batchId];\n\n    feature.show = true;\n    feature.color = Color.WHITE;\n  }\n\n  var batchedIndices = polygons._batchedIndices;\n  length = batchedIndices.length;\n\n  for (i = 0; i < length; ++i) {\n    batchedIndices[i].color = Color.clone(Color.WHITE);\n  }\n\n  polygons._updatingAllCommands = false;\n  polygons._batchDirty = true;\n}\n\nvar scratchColor = new Color();\n\nvar DEFAULT_COLOR_VALUE = Color.WHITE;\nvar DEFAULT_SHOW_VALUE = true;\n\nvar complexExpressionReg = /\\$/;\n\n/**\n * Apply a style to the content.\n *\n * @param {Cesium3DTileStyle} style The style.\n * @param {Cesium3DTileFeature[]} features The array of features.\n */\nVector3DTilePrimitive.prototype.applyStyle = function (style, features) {\n  if (!defined(style)) {\n    clearStyle(this, features);\n    return;\n  }\n\n  var colorExpression = style.color;\n  var isSimpleStyle =\n    colorExpression instanceof Expression &&\n    !complexExpressionReg.test(colorExpression.expression);\n  this._updatingAllCommands = isSimpleStyle;\n\n  var batchIds = this._batchIds;\n  var length = batchIds.length;\n  var i;\n\n  for (i = 0; i < length; ++i) {\n    var batchId = batchIds[i];\n    var feature = features[batchId];\n\n    feature.color = defined(style.color)\n      ? style.color.evaluateColor(feature, scratchColor)\n      : DEFAULT_COLOR_VALUE;\n    feature.show = defined(style.show)\n      ? style.show.evaluate(feature)\n      : DEFAULT_SHOW_VALUE;\n  }\n\n  if (isSimpleStyle) {\n    var batchedIndices = this._batchedIndices;\n    length = batchedIndices.length;\n\n    for (i = 0; i < length; ++i) {\n      batchedIndices[i].color = Color.clone(Color.WHITE);\n    }\n\n    this._updatingAllCommands = false;\n    this._batchDirty = true;\n  }\n};\n\n/**\n * Call when updating the color of a mesh with batchId changes color. The meshes will need to be re-batched\n * on the next update.\n *\n * @param {Number} batchId The batch id of the meshes whose color has changed.\n * @param {Color} color The new polygon color.\n */\nVector3DTilePrimitive.prototype.updateCommands = function (batchId, color) {\n  if (this._updatingAllCommands) {\n    return;\n  }\n\n  var batchIdLookUp = this._batchIdLookUp;\n  var index = batchIdLookUp[batchId];\n  if (!defined(index)) {\n    return;\n  }\n\n  var indexOffsets = this._indexOffsets;\n  var indexCounts = this._indexCounts;\n\n  var offset = indexOffsets[index];\n  var count = indexCounts[index];\n\n  var batchedIndices = this._batchedIndices;\n  var length = batchedIndices.length;\n\n  var i;\n  for (i = 0; i < length; ++i) {\n    var batchedOffset = batchedIndices[i].offset;\n    var batchedCount = batchedIndices[i].count;\n\n    if (offset >= batchedOffset && offset < batchedOffset + batchedCount) {\n      break;\n    }\n  }\n\n  batchedIndices.push(\n    new Vector3DTileBatch({\n      color: Color.clone(color),\n      offset: offset,\n      count: count,\n      batchIds: [batchId],\n    })\n  );\n\n  var startIds = [];\n  var endIds = [];\n\n  var batchIds = batchedIndices[i].batchIds;\n  var batchIdsLength = batchIds.length;\n\n  for (var j = 0; j < batchIdsLength; ++j) {\n    var id = batchIds[j];\n    if (id === batchId) {\n      continue;\n    }\n\n    var offsetIndex = batchIdLookUp[id];\n    if (indexOffsets[offsetIndex] < offset) {\n      startIds.push(id);\n    } else {\n      endIds.push(id);\n    }\n  }\n\n  if (endIds.length !== 0) {\n    batchedIndices.push(\n      new Vector3DTileBatch({\n        color: Color.clone(batchedIndices[i].color),\n        offset: offset + count,\n        count:\n          batchedIndices[i].offset + batchedIndices[i].count - (offset + count),\n        batchIds: endIds,\n      })\n    );\n  }\n\n  if (startIds.length !== 0) {\n    batchedIndices[i].count = offset - batchedIndices[i].offset;\n    batchedIndices[i].batchIds = startIds;\n  } else {\n    batchedIndices.splice(i, 1);\n  }\n\n  this._batchDirty = true;\n};\n\nfunction queueCommands(primitive, frameState, commands, commandsIgnoreShow) {\n  var classificationType = primitive.classificationType;\n  var queueTerrainCommands =\n    classificationType !== ClassificationType.CESIUM_3D_TILE;\n  var queue3DTilesCommands = classificationType !== ClassificationType.TERRAIN;\n\n  var commandList = frameState.commandList;\n  var commandLength = commands.length;\n  var command;\n  var i;\n  for (i = 0; i < commandLength; ++i) {\n    if (queueTerrainCommands) {\n      command = commands[i];\n      command.pass = Pass.TERRAIN_CLASSIFICATION;\n      commandList.push(command);\n    }\n    if (queue3DTilesCommands) {\n      command = commands[i].derivedCommands.tileset;\n      command.pass = Pass.CESIUM_3D_TILE_CLASSIFICATION;\n      commandList.push(command);\n    }\n  }\n\n  if (!frameState.invertClassification || !defined(commandsIgnoreShow)) {\n    return;\n  }\n\n  commandLength = commandsIgnoreShow.length;\n  for (i = 0; i < commandLength; ++i) {\n    commandList.push(commandsIgnoreShow[i]);\n  }\n}\n\nfunction queueWireframeCommands(frameState, commands) {\n  var commandList = frameState.commandList;\n  var commandLength = commands.length;\n  for (var i = 0; i < commandLength; i += 2) {\n    var command = commands[i + 1];\n    command.pass = Pass.OPAQUE;\n    commandList.push(command);\n  }\n}\n\nfunction updateWireframe(primitive) {\n  var earlyExit = primitive.debugWireframe === primitive._debugWireframe;\n  earlyExit =\n    earlyExit && !(primitive.debugWireframe && primitive._wireframeDirty);\n  if (earlyExit) {\n    return;\n  }\n\n  if (!defined(primitive._rsWireframe)) {\n    primitive._rsWireframe = RenderState.fromCache({});\n  }\n\n  var rs;\n  var type;\n\n  if (primitive.debugWireframe) {\n    rs = primitive._rsWireframe;\n    type = PrimitiveType.LINES;\n  } else {\n    rs = primitive._rsColorPass;\n    type = PrimitiveType.TRIANGLES;\n  }\n\n  var commands = primitive._commands;\n  var commandLength = commands.length;\n  for (var i = 0; i < commandLength; i += 2) {\n    var command = commands[i + 1];\n    command.renderState = rs;\n    command.primitiveType = type;\n  }\n\n  primitive._debugWireframe = primitive.debugWireframe;\n  primitive._wireframeDirty = false;\n}\n\n/**\n * Updates the batches and queues the commands for rendering.\n *\n * @param {FrameState} frameState The current frame state.\n */\nVector3DTilePrimitive.prototype.update = function (frameState) {\n  var context = frameState.context;\n\n  createVertexArray(this, context);\n  createShaders(this, context);\n  createRenderStates(this);\n  createUniformMap(this, context);\n\n  var passes = frameState.passes;\n  if (passes.render) {\n    createColorCommands(this, context);\n    createColorCommandsIgnoreShow(this, frameState);\n    updateWireframe(this);\n\n    if (this._debugWireframe) {\n      queueWireframeCommands(frameState, this._commands);\n    } else {\n      queueCommands(this, frameState, this._commands, this._commandsIgnoreShow);\n    }\n  }\n\n  if (passes.pick) {\n    createPickCommands(this);\n    queueCommands(this, frameState, this._pickCommands);\n  }\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n */\nVector3DTilePrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n */\nVector3DTilePrimitive.prototype.destroy = function () {\n  this._va = this._va && this._va.destroy();\n  this._sp = this._sp && this._sp.destroy();\n  this._spPick = this._spPick && this._spPick.destroy();\n  this._vaSwap = this._vaSwap && this._vaSwap.destroy();\n  return destroyObject(this);\n};\nexport default Vector3DTilePrimitive;\n"]},"metadata":{},"sourceType":"module"}