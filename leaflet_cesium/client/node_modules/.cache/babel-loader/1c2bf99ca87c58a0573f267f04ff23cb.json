{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport BoxOutlineGeometry from \"../Core/BoxOutlineGeometry.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport combine from \"../Core/combine.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport GeometryPipeline from \"../Core/GeometryPipeline.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport SphereOutlineGeometry from \"../Core/SphereOutlineGeometry.js\";\nimport TerrainQuantization from \"../Core/TerrainQuantization.js\";\nimport Visibility from \"../Core/Visibility.js\";\nimport WebMercatorProjection from \"../Core/WebMercatorProjection.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport ClippingPlaneCollection from \"./ClippingPlaneCollection.js\";\nimport DepthFunction from \"./DepthFunction.js\";\nimport GlobeSurfaceTile from \"./GlobeSurfaceTile.js\";\nimport ImageryLayer from \"./ImageryLayer.js\";\nimport ImageryState from \"./ImageryState.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Primitive from \"./Primitive.js\";\nimport QuadtreeTileLoadState from \"./QuadtreeTileLoadState.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\nimport TerrainFillMesh from \"./TerrainFillMesh.js\";\nimport TerrainState from \"./TerrainState.js\";\nimport TileBoundingRegion from \"./TileBoundingRegion.js\";\nimport TileSelectionResult from \"./TileSelectionResult.js\";\n/**\n * Provides quadtree tiles representing the surface of the globe.  This type is intended to be used\n * with {@link QuadtreePrimitive}.\n *\n * @alias GlobeSurfaceTileProvider\n * @constructor\n *\n * @param {TerrainProvider} options.terrainProvider The terrain provider that describes the surface geometry.\n * @param {ImageryLayerCollection} option.imageryLayers The collection of imagery layers describing the shading of the surface.\n * @param {GlobeSurfaceShaderSet} options.surfaceShaderSet The set of shaders used to render the surface.\n *\n * @private\n */\n\nfunction GlobeSurfaceTileProvider(options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options)) {\n    throw new DeveloperError(\"options is required.\");\n  }\n\n  if (!defined(options.terrainProvider)) {\n    throw new DeveloperError(\"options.terrainProvider is required.\");\n  } else if (!defined(options.imageryLayers)) {\n    throw new DeveloperError(\"options.imageryLayers is required.\");\n  } else if (!defined(options.surfaceShaderSet)) {\n    throw new DeveloperError(\"options.surfaceShaderSet is required.\");\n  } //>>includeEnd('debug');\n\n\n  this.lightingFadeOutDistance = 6500000.0;\n  this.lightingFadeInDistance = 9000000.0;\n  this.hasWaterMask = false;\n  this.oceanNormalMap = undefined;\n  this.zoomedOutOceanSpecularIntensity = 0.5;\n  this.enableLighting = false;\n  this.dynamicAtmosphereLighting = false;\n  this.dynamicAtmosphereLightingFromSun = false;\n  this.showGroundAtmosphere = false;\n  this.shadows = ShadowMode.RECEIVE_ONLY;\n  /**\n   * The color to use to highlight terrain fill tiles. If undefined, fill tiles are not\n   * highlighted at all. The alpha value is used to alpha blend with the tile's\n   * actual color. Because terrain fill tiles do not represent the actual terrain surface,\n   * it may be useful in some applications to indicate visually that they are not to be trusted.\n   * @type {Color}\n   * @default undefined\n   */\n\n  this.fillHighlightColor = undefined;\n  this.hueShift = 0.0;\n  this.saturationShift = 0.0;\n  this.brightnessShift = 0.0;\n  this.showSkirts = true;\n  this.backFaceCulling = true;\n  this.undergroundColor = undefined;\n  this.undergroundColorAlphaByDistance = undefined;\n  this.materialUniformMap = undefined;\n  this._materialUniformMap = undefined;\n  this._quadtree = undefined;\n  this._terrainProvider = options.terrainProvider;\n  this._imageryLayers = options.imageryLayers;\n  this._surfaceShaderSet = options.surfaceShaderSet;\n  this._renderState = undefined;\n  this._blendRenderState = undefined;\n  this._disableCullingRenderState = undefined;\n  this._disableCullingBlendRenderState = undefined;\n  this._errorEvent = new Event();\n\n  this._imageryLayers.layerAdded.addEventListener(GlobeSurfaceTileProvider.prototype._onLayerAdded, this);\n\n  this._imageryLayers.layerRemoved.addEventListener(GlobeSurfaceTileProvider.prototype._onLayerRemoved, this);\n\n  this._imageryLayers.layerMoved.addEventListener(GlobeSurfaceTileProvider.prototype._onLayerMoved, this);\n\n  this._imageryLayers.layerShownOrHidden.addEventListener(GlobeSurfaceTileProvider.prototype._onLayerShownOrHidden, this);\n\n  this._imageryLayersUpdatedEvent = new Event();\n  this._layerOrderChanged = false;\n  this._tilesToRenderByTextureCount = [];\n  this._drawCommands = [];\n  this._uniformMaps = [];\n  this._usedDrawCommands = 0;\n  this._vertexArraysToDestroy = [];\n  this._debug = {\n    wireframe: false,\n    boundingSphereTile: undefined\n  };\n  this._baseColor = undefined;\n  this._firstPassInitialColor = undefined;\n  this.baseColor = new Color(0.0, 0.0, 0.5, 1.0);\n  /**\n   * A property specifying a {@link ClippingPlaneCollection} used to selectively disable rendering on the outside of each plane.\n   * @type {ClippingPlaneCollection}\n   * @private\n   */\n\n  this._clippingPlanes = undefined;\n  /**\n   * A property specifying a {@link Rectangle} used to selectively limit terrain and imagery rendering.\n   * @type {Rectangle}\n   */\n\n  this.cartographicLimitRectangle = Rectangle.clone(Rectangle.MAX_VALUE);\n  this._hasLoadedTilesThisFrame = false;\n  this._hasFillTilesThisFrame = false;\n}\n\nObject.defineProperties(GlobeSurfaceTileProvider.prototype, {\n  /**\n   * Gets or sets the color of the globe when no imagery is available.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {Color}\n   */\n  baseColor: {\n    get: function () {\n      return this._baseColor;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      } //>>includeEnd('debug');\n\n\n      this._baseColor = value;\n      this._firstPassInitialColor = Cartesian4.fromColor(value, this._firstPassInitialColor);\n    }\n  },\n\n  /**\n   * Gets or sets the {@link QuadtreePrimitive} for which this provider is\n   * providing tiles.  This property may be undefined if the provider is not yet associated\n   * with a {@link QuadtreePrimitive}.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {QuadtreePrimitive}\n   */\n  quadtree: {\n    get: function () {\n      return this._quadtree;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      } //>>includeEnd('debug');\n\n\n      this._quadtree = value;\n    }\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {Boolean}\n   */\n  ready: {\n    get: function () {\n      return this._terrainProvider.ready && (this._imageryLayers.length === 0 || this._imageryLayers.get(0).imageryProvider.ready);\n    }\n  },\n\n  /**\n   * Gets the tiling scheme used by the provider.  This property should\n   * not be accessed before {@link GlobeSurfaceTileProvider#ready} returns true.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {TilingScheme}\n   */\n  tilingScheme: {\n    get: function () {\n      return this._terrainProvider.tilingScheme;\n    }\n  },\n\n  /**\n   * Gets an event that is raised when the geometry provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {Event}\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    }\n  },\n\n  /**\n   * Gets an event that is raised when an imagery layer is added, shown, hidden, moved, or removed.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {Event}\n   */\n  imageryLayersUpdatedEvent: {\n    get: function () {\n      return this._imageryLayersUpdatedEvent;\n    }\n  },\n\n  /**\n   * Gets or sets the terrain provider that describes the surface geometry.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {TerrainProvider}\n   */\n  terrainProvider: {\n    get: function () {\n      return this._terrainProvider;\n    },\n    set: function (terrainProvider) {\n      if (this._terrainProvider === terrainProvider) {\n        return;\n      } //>>includeStart('debug', pragmas.debug);\n\n\n      if (!defined(terrainProvider)) {\n        throw new DeveloperError(\"terrainProvider is required.\");\n      } //>>includeEnd('debug');\n\n\n      this._terrainProvider = terrainProvider;\n\n      if (defined(this._quadtree)) {\n        this._quadtree.invalidateAllTiles();\n      }\n    }\n  },\n\n  /**\n   * The {@link ClippingPlaneCollection} used to selectively disable rendering the tileset.\n   *\n   * @type {ClippingPlaneCollection}\n   *\n   * @private\n   */\n  clippingPlanes: {\n    get: function () {\n      return this._clippingPlanes;\n    },\n    set: function (value) {\n      ClippingPlaneCollection.setOwner(value, this, \"_clippingPlanes\");\n    }\n  }\n});\n\nfunction sortTileImageryByLayerIndex(a, b) {\n  var aImagery = a.loadingImagery;\n\n  if (!defined(aImagery)) {\n    aImagery = a.readyImagery;\n  }\n\n  var bImagery = b.loadingImagery;\n\n  if (!defined(bImagery)) {\n    bImagery = b.readyImagery;\n  }\n\n  return aImagery.imageryLayer._layerIndex - bImagery.imageryLayer._layerIndex;\n}\n/**\n * Make updates to the tile provider that are not involved in rendering. Called before the render update cycle.\n */\n\n\nGlobeSurfaceTileProvider.prototype.update = function (frameState) {\n  // update collection: imagery indices, base layers, raise layer show/hide event\n  this._imageryLayers._update();\n};\n\nfunction updateCredits(surface, frameState) {\n  var creditDisplay = frameState.creditDisplay;\n\n  if (surface._terrainProvider.ready && defined(surface._terrainProvider.credit)) {\n    creditDisplay.addCredit(surface._terrainProvider.credit);\n  }\n\n  var imageryLayers = surface._imageryLayers;\n\n  for (var i = 0, len = imageryLayers.length; i < len; ++i) {\n    var imageryProvider = imageryLayers.get(i).imageryProvider;\n\n    if (imageryProvider.ready && defined(imageryProvider.credit)) {\n      creditDisplay.addCredit(imageryProvider.credit);\n    }\n  }\n}\n/**\n * Called at the beginning of each render frame, before {@link QuadtreeTileProvider#showTileThisFrame}\n * @param {FrameState} frameState The frame state.\n */\n\n\nGlobeSurfaceTileProvider.prototype.initialize = function (frameState) {\n  // update each layer for texture reprojection.\n  this._imageryLayers.queueReprojectionCommands(frameState);\n\n  if (this._layerOrderChanged) {\n    this._layerOrderChanged = false; // Sort the TileImagery instances in each tile by the layer index.\n\n    this._quadtree.forEachLoadedTile(function (tile) {\n      tile.data.imagery.sort(sortTileImageryByLayerIndex);\n    });\n  } // Add credits for terrain and imagery providers.\n\n\n  updateCredits(this, frameState);\n  var vertexArraysToDestroy = this._vertexArraysToDestroy;\n  var length = vertexArraysToDestroy.length;\n\n  for (var j = 0; j < length; ++j) {\n    GlobeSurfaceTile._freeVertexArray(vertexArraysToDestroy[j]);\n  }\n\n  vertexArraysToDestroy.length = 0;\n};\n/**\n * Called at the beginning of the update cycle for each render frame, before {@link QuadtreeTileProvider#showTileThisFrame}\n * or any other functions.\n *\n * @param {FrameState} frameState The frame state.\n */\n\n\nGlobeSurfaceTileProvider.prototype.beginUpdate = function (frameState) {\n  var tilesToRenderByTextureCount = this._tilesToRenderByTextureCount;\n\n  for (var i = 0, len = tilesToRenderByTextureCount.length; i < len; ++i) {\n    var tiles = tilesToRenderByTextureCount[i];\n\n    if (defined(tiles)) {\n      tiles.length = 0;\n    }\n  } // update clipping planes\n\n\n  var clippingPlanes = this._clippingPlanes;\n\n  if (defined(clippingPlanes) && clippingPlanes.enabled) {\n    clippingPlanes.update(frameState);\n  }\n\n  this._usedDrawCommands = 0;\n  this._hasLoadedTilesThisFrame = false;\n  this._hasFillTilesThisFrame = false;\n};\n/**\n * Called at the end of the update cycle for each render frame, after {@link QuadtreeTileProvider#showTileThisFrame}\n * and any other functions.\n *\n * @param {FrameState} frameState The frame state.\n */\n\n\nGlobeSurfaceTileProvider.prototype.endUpdate = function (frameState) {\n  if (!defined(this._renderState)) {\n    this._renderState = RenderState.fromCache({\n      // Write color and depth\n      cull: {\n        enabled: true\n      },\n      depthTest: {\n        enabled: true,\n        func: DepthFunction.LESS\n      }\n    });\n    this._blendRenderState = RenderState.fromCache({\n      // Write color and depth\n      cull: {\n        enabled: true\n      },\n      depthTest: {\n        enabled: true,\n        func: DepthFunction.LESS_OR_EQUAL\n      },\n      blending: BlendingState.ALPHA_BLEND\n    });\n    var rs = clone(this._renderState, true);\n    rs.cull.enabled = false;\n    this._disableCullingRenderState = RenderState.fromCache(rs);\n    rs = clone(this._blendRenderState, true);\n    rs.cull.enabled = false;\n    this._disableCullingBlendRenderState = RenderState.fromCache(rs);\n  } // If this frame has a mix of loaded and fill tiles, we need to propagate\n  // loaded heights to the fill tiles.\n\n\n  if (this._hasFillTilesThisFrame && this._hasLoadedTilesThisFrame) {\n    TerrainFillMesh.updateFillTiles(this, this._quadtree._tilesToRender, frameState, this._vertexArraysToDestroy);\n  } // Add the tile render commands to the command list, sorted by texture count.\n\n\n  var tilesToRenderByTextureCount = this._tilesToRenderByTextureCount;\n\n  for (var textureCountIndex = 0, textureCountLength = tilesToRenderByTextureCount.length; textureCountIndex < textureCountLength; ++textureCountIndex) {\n    var tilesToRender = tilesToRenderByTextureCount[textureCountIndex];\n\n    if (!defined(tilesToRender)) {\n      continue;\n    }\n\n    for (var tileIndex = 0, tileLength = tilesToRender.length; tileIndex < tileLength; ++tileIndex) {\n      var tile = tilesToRender[tileIndex];\n      var tileBoundingRegion = tile.data.tileBoundingRegion;\n      addDrawCommandsForTile(this, tile, frameState);\n      frameState.minimumTerrainHeight = Math.min(frameState.minimumTerrainHeight, tileBoundingRegion.minimumHeight);\n    }\n  }\n};\n\nfunction pushCommand(command, frameState) {\n  var globeTranslucencyState = frameState.globeTranslucencyState;\n\n  if (globeTranslucencyState.translucent) {\n    var isBlendCommand = command.renderState.blending.enabled;\n    globeTranslucencyState.pushDerivedCommands(command, isBlendCommand, frameState);\n  } else {\n    frameState.commandList.push(command);\n  }\n}\n/**\n * Adds draw commands for tiles rendered in the previous frame for a pick pass.\n *\n * @param {FrameState} frameState The frame state.\n */\n\n\nGlobeSurfaceTileProvider.prototype.updateForPick = function (frameState) {\n  // Add the tile pick commands from the tiles drawn last frame.\n  var drawCommands = this._drawCommands;\n\n  for (var i = 0, length = this._usedDrawCommands; i < length; ++i) {\n    pushCommand(drawCommands[i], frameState);\n  }\n};\n/**\n * Cancels any imagery re-projections in the queue.\n */\n\n\nGlobeSurfaceTileProvider.prototype.cancelReprojections = function () {\n  this._imageryLayers.cancelReprojections();\n};\n/**\n * Gets the maximum geometric error allowed in a tile at a given level, in meters.  This function should not be\n * called before {@link GlobeSurfaceTileProvider#ready} returns true.\n *\n * @param {Number} level The tile level for which to get the maximum geometric error.\n * @returns {Number} The maximum geometric error in meters.\n */\n\n\nGlobeSurfaceTileProvider.prototype.getLevelMaximumGeometricError = function (level) {\n  return this._terrainProvider.getLevelMaximumGeometricError(level);\n};\n/**\n * Loads, or continues loading, a given tile.  This function will continue to be called\n * until {@link QuadtreeTile#state} is no longer {@link QuadtreeTileLoadState#LOADING}.  This function should\n * not be called before {@link GlobeSurfaceTileProvider#ready} returns true.\n *\n * @param {FrameState} frameState The frame state.\n * @param {QuadtreeTile} tile The tile to load.\n *\n * @exception {DeveloperError} <code>loadTile</code> must not be called before the tile provider is ready.\n */\n\n\nGlobeSurfaceTileProvider.prototype.loadTile = function (frameState, tile) {\n  // We don't want to load imagery until we're certain that the terrain tiles are actually visible.\n  // So if our bounding volume isn't accurate because it came from another tile, load terrain only\n  // initially. If we load some terrain and suddenly have a more accurate bounding volume and the\n  // tile is _still_ visible, give the tile a chance to load imagery immediately rather than\n  // waiting for next frame.\n  var surfaceTile = tile.data;\n  var terrainOnly = true;\n  var terrainStateBefore;\n\n  if (defined(surfaceTile)) {\n    terrainOnly = surfaceTile.boundingVolumeSourceTile !== tile || tile._lastSelectionResult === TileSelectionResult.CULLED_BUT_NEEDED;\n    terrainStateBefore = surfaceTile.terrainState;\n  }\n\n  GlobeSurfaceTile.processStateMachine(tile, frameState, this.terrainProvider, this._imageryLayers, this._vertexArraysToDestroy, terrainOnly);\n  surfaceTile = tile.data;\n\n  if (terrainOnly && terrainStateBefore !== tile.data.terrainState) {\n    // Terrain state changed. If:\n    // a) The tile is visible, and\n    // b) The bounding volume is accurate (updated as a side effect of computing visibility)\n    // Then we'll load imagery, too.\n    if (this.computeTileVisibility(tile, frameState, this.quadtree.occluders) !== Visibility.NONE && surfaceTile.boundingVolumeSourceTile === tile) {\n      terrainOnly = false;\n      GlobeSurfaceTile.processStateMachine(tile, frameState, this.terrainProvider, this._imageryLayers, this._vertexArraysToDestroy, terrainOnly);\n    }\n  }\n};\n\nvar boundingSphereScratch = new BoundingSphere();\nvar rectangleIntersectionScratch = new Rectangle();\nvar splitCartographicLimitRectangleScratch = new Rectangle();\nvar rectangleCenterScratch = new Cartographic(); // cartographicLimitRectangle may span the IDL, but tiles never will.\n\nfunction clipRectangleAntimeridian(tileRectangle, cartographicLimitRectangle) {\n  if (cartographicLimitRectangle.west < cartographicLimitRectangle.east) {\n    return cartographicLimitRectangle;\n  }\n\n  var splitRectangle = Rectangle.clone(cartographicLimitRectangle, splitCartographicLimitRectangleScratch);\n  var tileCenter = Rectangle.center(tileRectangle, rectangleCenterScratch);\n\n  if (tileCenter.longitude > 0.0) {\n    splitRectangle.east = CesiumMath.PI;\n  } else {\n    splitRectangle.west = -CesiumMath.PI;\n  }\n\n  return splitRectangle;\n}\n\nfunction isUndergroundVisible(tileProvider, frameState) {\n  if (frameState.cameraUnderground) {\n    return true;\n  }\n\n  if (frameState.globeTranslucencyState.translucent) {\n    return true;\n  }\n\n  if (tileProvider.backFaceCulling) {\n    return false;\n  }\n\n  var clippingPlanes = tileProvider._clippingPlanes;\n\n  if (defined(clippingPlanes) && clippingPlanes.enabled) {\n    return true;\n  }\n\n  if (!Rectangle.equals(tileProvider.cartographicLimitRectangle, Rectangle.MAX_VALUE)) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * Determines the visibility of a given tile.  The tile may be fully visible, partially visible, or not\n * visible at all.  Tiles that are renderable and are at least partially visible will be shown by a call\n * to {@link GlobeSurfaceTileProvider#showTileThisFrame}.\n *\n * @param {QuadtreeTile} tile The tile instance.\n * @param {FrameState} frameState The state information about the current frame.\n * @param {QuadtreeOccluders} occluders The objects that may occlude this tile.\n *\n * @returns {Visibility} Visibility.NONE if the tile is not visible,\n *                       Visibility.PARTIAL if the tile is partially visible, or\n *                       Visibility.FULL if the tile is fully visible.\n */\n\n\nGlobeSurfaceTileProvider.prototype.computeTileVisibility = function (tile, frameState, occluders) {\n  var distance = this.computeDistanceToTile(tile, frameState);\n  tile._distance = distance;\n  var undergroundVisible = isUndergroundVisible(this, frameState);\n\n  if (frameState.fog.enabled && !undergroundVisible) {\n    if (CesiumMath.fog(distance, frameState.fog.density) >= 1.0) {\n      // Tile is completely in fog so return that it is not visible.\n      return Visibility.NONE;\n    }\n  }\n\n  var surfaceTile = tile.data;\n  var tileBoundingRegion = surfaceTile.tileBoundingRegion;\n\n  if (surfaceTile.boundingVolumeSourceTile === undefined) {\n    // We have no idea where this tile is, so let's just call it partially visible.\n    return Visibility.PARTIAL;\n  }\n\n  var cullingVolume = frameState.cullingVolume;\n  var boundingVolume = surfaceTile.orientedBoundingBox;\n\n  if (!defined(boundingVolume) && defined(surfaceTile.renderedMesh)) {\n    boundingVolume = surfaceTile.renderedMesh.boundingSphere3D;\n  } // Check if the tile is outside the limit area in cartographic space\n\n\n  surfaceTile.clippedByBoundaries = false;\n  var clippedCartographicLimitRectangle = clipRectangleAntimeridian(tile.rectangle, this.cartographicLimitRectangle);\n  var areaLimitIntersection = Rectangle.simpleIntersection(clippedCartographicLimitRectangle, tile.rectangle, rectangleIntersectionScratch);\n\n  if (!defined(areaLimitIntersection)) {\n    return Visibility.NONE;\n  }\n\n  if (!Rectangle.equals(areaLimitIntersection, tile.rectangle)) {\n    surfaceTile.clippedByBoundaries = true;\n  }\n\n  if (frameState.mode !== SceneMode.SCENE3D) {\n    boundingVolume = boundingSphereScratch;\n    BoundingSphere.fromRectangleWithHeights2D(tile.rectangle, frameState.mapProjection, tileBoundingRegion.minimumHeight, tileBoundingRegion.maximumHeight, boundingVolume);\n    Cartesian3.fromElements(boundingVolume.center.z, boundingVolume.center.x, boundingVolume.center.y, boundingVolume.center);\n\n    if (frameState.mode === SceneMode.MORPHING && defined(surfaceTile.renderedMesh)) {\n      boundingVolume = BoundingSphere.union(surfaceTile.renderedMesh.boundingSphere3D, boundingVolume, boundingVolume);\n    }\n  }\n\n  if (!defined(boundingVolume)) {\n    return Visibility.PARTIAL;\n  }\n\n  var clippingPlanes = this._clippingPlanes;\n\n  if (defined(clippingPlanes) && clippingPlanes.enabled) {\n    var planeIntersection = clippingPlanes.computeIntersectionWithBoundingVolume(boundingVolume);\n    tile.isClipped = planeIntersection !== Intersect.INSIDE;\n\n    if (planeIntersection === Intersect.OUTSIDE) {\n      return Visibility.NONE;\n    }\n  }\n\n  var visibility;\n  var intersection = cullingVolume.computeVisibility(boundingVolume);\n\n  if (intersection === Intersect.OUTSIDE) {\n    visibility = Visibility.NONE;\n  } else if (intersection === Intersect.INTERSECTING) {\n    visibility = Visibility.PARTIAL;\n  } else if (intersection === Intersect.INSIDE) {\n    visibility = Visibility.FULL;\n  }\n\n  if (visibility === Visibility.NONE) {\n    return visibility;\n  }\n\n  var ortho3D = frameState.mode === SceneMode.SCENE3D && frameState.camera.frustum instanceof OrthographicFrustum;\n\n  if (frameState.mode === SceneMode.SCENE3D && !ortho3D && defined(occluders) && !undergroundVisible) {\n    var occludeePointInScaledSpace = surfaceTile.occludeePointInScaledSpace;\n\n    if (!defined(occludeePointInScaledSpace)) {\n      return visibility;\n    }\n\n    if (occluders.ellipsoid.isScaledSpacePointVisiblePossiblyUnderEllipsoid(occludeePointInScaledSpace, tileBoundingRegion.minimumHeight)) {\n      return visibility;\n    }\n\n    return Visibility.NONE;\n  }\n\n  return visibility;\n};\n/**\n * Determines if the given tile can be refined\n * @param {QuadtreeTile} tile The tile to check.\n * @returns {boolean} True if the tile can be refined, false if it cannot.\n */\n\n\nGlobeSurfaceTileProvider.prototype.canRefine = function (tile) {\n  // Only allow refinement it we know whether or not the children of this tile exist.\n  // For a tileset with `availability`, we'll always be able to refine.\n  // We can ask for availability of _any_ child tile because we only need to confirm\n  // that we get a yes or no answer, it doesn't matter what the answer is.\n  if (defined(tile.data.terrainData)) {\n    return true;\n  }\n\n  var childAvailable = this.terrainProvider.getTileDataAvailable(tile.x * 2, tile.y * 2, tile.level + 1);\n  return childAvailable !== undefined;\n};\n\nvar readyImageryScratch = [];\nvar canRenderTraversalStack = [];\n/**\n * Determines if the given not-fully-loaded tile can be rendered without losing detail that\n * was present last frame as a result of rendering descendant tiles. This method will only be\n * called if this tile's descendants were rendered last frame. If the tile is fully loaded,\n * it is assumed that this method will return true and it will not be called.\n * @param {QuadtreeTile} tile The tile to check.\n * @returns {boolean} True if the tile can be rendered without losing detail.\n */\n\nGlobeSurfaceTileProvider.prototype.canRenderWithoutLosingDetail = function (tile, frameState) {\n  var surfaceTile = tile.data;\n  var readyImagery = readyImageryScratch;\n  readyImagery.length = this._imageryLayers.length;\n  var terrainReady = false;\n  var initialImageryState = false;\n  var imagery;\n\n  if (defined(surfaceTile)) {\n    // We can render even with non-ready terrain as long as all our rendered descendants\n    // are missing terrain geometry too. i.e. if we rendered fills for more detailed tiles\n    // last frame, it's ok to render a fill for this tile this frame.\n    terrainReady = surfaceTile.terrainState === TerrainState.READY; // Initially assume all imagery layers are ready, unless imagery hasn't been initialized at all.\n\n    initialImageryState = true;\n    imagery = surfaceTile.imagery;\n  }\n\n  var i;\n  var len;\n\n  for (i = 0, len = readyImagery.length; i < len; ++i) {\n    readyImagery[i] = initialImageryState;\n  }\n\n  if (defined(imagery)) {\n    for (i = 0, len = imagery.length; i < len; ++i) {\n      var tileImagery = imagery[i];\n      var loadingImagery = tileImagery.loadingImagery;\n      var isReady = !defined(loadingImagery) || loadingImagery.state === ImageryState.FAILED || loadingImagery.state === ImageryState.INVALID;\n      var layerIndex = (tileImagery.loadingImagery || tileImagery.readyImagery).imageryLayer._layerIndex; // For a layer to be ready, all tiles belonging to that layer must be ready.\n\n      readyImagery[layerIndex] = isReady && readyImagery[layerIndex];\n    }\n  }\n\n  var lastFrame = this.quadtree._lastSelectionFrameNumber; // Traverse the descendants looking for one with terrain or imagery that is not loaded on this tile.\n\n  var stack = canRenderTraversalStack;\n  stack.length = 0;\n  stack.push(tile.southwestChild, tile.southeastChild, tile.northwestChild, tile.northeastChild);\n\n  while (stack.length > 0) {\n    var descendant = stack.pop();\n    var lastFrameSelectionResult = descendant._lastSelectionResultFrame === lastFrame ? descendant._lastSelectionResult : TileSelectionResult.NONE;\n\n    if (lastFrameSelectionResult === TileSelectionResult.RENDERED) {\n      var descendantSurface = descendant.data;\n\n      if (!defined(descendantSurface)) {\n        // Descendant has no data, so it can't block rendering.\n        continue;\n      }\n\n      if (!terrainReady && descendant.data.terrainState === TerrainState.READY) {\n        // Rendered descendant has real terrain, but we don't. Rendering is blocked.\n        return false;\n      }\n\n      var descendantImagery = descendant.data.imagery;\n\n      for (i = 0, len = descendantImagery.length; i < len; ++i) {\n        var descendantTileImagery = descendantImagery[i];\n        var descendantLoadingImagery = descendantTileImagery.loadingImagery;\n        var descendantIsReady = !defined(descendantLoadingImagery) || descendantLoadingImagery.state === ImageryState.FAILED || descendantLoadingImagery.state === ImageryState.INVALID;\n        var descendantLayerIndex = (descendantTileImagery.loadingImagery || descendantTileImagery.readyImagery).imageryLayer._layerIndex; // If this imagery tile of a descendant is ready but the layer isn't ready in this tile,\n        // then rendering is blocked.\n\n        if (descendantIsReady && !readyImagery[descendantLayerIndex]) {\n          return false;\n        }\n      }\n    } else if (lastFrameSelectionResult === TileSelectionResult.REFINED) {\n      stack.push(descendant.southwestChild, descendant.southeastChild, descendant.northwestChild, descendant.northeastChild);\n    }\n  }\n\n  return true;\n};\n\nvar tileDirectionScratch = new Cartesian3();\n/**\n * Determines the priority for loading this tile. Lower priority values load sooner.\n * @param {QuadtreeTile} tile The tile.\n * @param {FrameState} frameState The frame state.\n * @returns {Number} The load priority value.\n */\n\nGlobeSurfaceTileProvider.prototype.computeTileLoadPriority = function (tile, frameState) {\n  var surfaceTile = tile.data;\n\n  if (surfaceTile === undefined) {\n    return 0.0;\n  }\n\n  var obb = surfaceTile.orientedBoundingBox;\n\n  if (obb === undefined) {\n    return 0.0;\n  }\n\n  var cameraPosition = frameState.camera.positionWC;\n  var cameraDirection = frameState.camera.directionWC;\n  var tileDirection = Cartesian3.subtract(obb.center, cameraPosition, tileDirectionScratch);\n  var magnitude = Cartesian3.magnitude(tileDirection);\n\n  if (magnitude < CesiumMath.EPSILON5) {\n    return 0.0;\n  }\n\n  Cartesian3.divideByScalar(tileDirection, magnitude, tileDirection);\n  return (1.0 - Cartesian3.dot(tileDirection, cameraDirection)) * tile._distance;\n};\n\nvar modifiedModelViewScratch = new Matrix4();\nvar modifiedModelViewProjectionScratch = new Matrix4();\nvar tileRectangleScratch = new Cartesian4();\nvar localizedCartographicLimitRectangleScratch = new Cartesian4();\nvar localizedTranslucencyRectangleScratch = new Cartesian4();\nvar rtcScratch = new Cartesian3();\nvar centerEyeScratch = new Cartesian3();\nvar southwestScratch = new Cartesian3();\nvar northeastScratch = new Cartesian3();\n/**\n * Shows a specified tile in this frame.  The provider can cause the tile to be shown by adding\n * render commands to the commandList, or use any other method as appropriate.  The tile is not\n * expected to be visible next frame as well, unless this method is called next frame, too.\n *\n * @param {QuadtreeTile} tile The tile instance.\n * @param {FrameState} frameState The state information of the current rendering frame.\n */\n\nGlobeSurfaceTileProvider.prototype.showTileThisFrame = function (tile, frameState) {\n  var readyTextureCount = 0;\n  var tileImageryCollection = tile.data.imagery;\n\n  for (var i = 0, len = tileImageryCollection.length; i < len; ++i) {\n    var tileImagery = tileImageryCollection[i];\n\n    if (defined(tileImagery.readyImagery) && tileImagery.readyImagery.imageryLayer.alpha !== 0.0) {\n      ++readyTextureCount;\n    }\n  }\n\n  var tileSet = this._tilesToRenderByTextureCount[readyTextureCount];\n\n  if (!defined(tileSet)) {\n    tileSet = [];\n    this._tilesToRenderByTextureCount[readyTextureCount] = tileSet;\n  }\n\n  tileSet.push(tile);\n  var surfaceTile = tile.data;\n\n  if (!defined(surfaceTile.vertexArray)) {\n    this._hasFillTilesThisFrame = true;\n  } else {\n    this._hasLoadedTilesThisFrame = true;\n  }\n\n  var debug = this._debug;\n  ++debug.tilesRendered;\n  debug.texturesRendered += readyTextureCount;\n};\n\nvar cornerPositionsScratch = [new Cartesian3(), new Cartesian3(), new Cartesian3(), new Cartesian3()];\n\nfunction computeOccludeePoint(tileProvider, center, rectangle, minimumHeight, maximumHeight, result) {\n  var ellipsoidalOccluder = tileProvider.quadtree._occluders.ellipsoid;\n  var ellipsoid = ellipsoidalOccluder.ellipsoid;\n  var cornerPositions = cornerPositionsScratch;\n  Cartesian3.fromRadians(rectangle.west, rectangle.south, maximumHeight, ellipsoid, cornerPositions[0]);\n  Cartesian3.fromRadians(rectangle.east, rectangle.south, maximumHeight, ellipsoid, cornerPositions[1]);\n  Cartesian3.fromRadians(rectangle.west, rectangle.north, maximumHeight, ellipsoid, cornerPositions[2]);\n  Cartesian3.fromRadians(rectangle.east, rectangle.north, maximumHeight, ellipsoid, cornerPositions[3]);\n  return ellipsoidalOccluder.computeHorizonCullingPointPossiblyUnderEllipsoid(center, cornerPositions, minimumHeight, result);\n}\n/**\n * Gets the distance from the camera to the closest point on the tile.  This is used for level-of-detail selection.\n *\n * @param {QuadtreeTile} tile The tile instance.\n * @param {FrameState} frameState The state information of the current rendering frame.\n *\n * @returns {Number} The distance from the camera to the closest point on the tile, in meters.\n */\n\n\nGlobeSurfaceTileProvider.prototype.computeDistanceToTile = function (tile, frameState) {\n  // The distance should be:\n  // 1. the actual distance to the tight-fitting bounding volume, or\n  // 2. a distance that is equal to or greater than the actual distance to the tight-fitting bounding volume.\n  //\n  // When we don't know the min/max heights for a tile, but we do know the min/max of an ancestor tile, we can\n  // build a tight-fitting bounding volume horizontally, but not vertically. The min/max heights from the\n  // ancestor will likely form a volume that is much bigger than it needs to be. This means that the volume may\n  // be deemed to be much closer to the camera than it really is, causing us to select tiles that are too detailed.\n  // Loading too-detailed tiles is super expensive, so we don't want to do that. We don't know where the child\n  // tile really lies within the parent range of heights, but we _do_ know the child tile can't be any closer than\n  // the ancestor height surface (min or max) that is _farthest away_ from the camera. So if we compute distance\n  // based that conservative metric, we may end up loading tiles that are not detailed enough, but that's much\n  // better (faster) than loading tiles that are too detailed.\n  var heightSource = updateTileBoundingRegion(tile, this.terrainProvider, frameState);\n  var surfaceTile = tile.data;\n  var tileBoundingRegion = surfaceTile.tileBoundingRegion;\n\n  if (heightSource === undefined) {\n    // Can't find any min/max heights anywhere? Ok, let's just say the\n    // tile is really far away so we'll load and render it rather than\n    // refining.\n    return 9999999999.0;\n  } else if (surfaceTile.boundingVolumeSourceTile !== heightSource) {\n    // Heights are from a new source tile, so update the bounding volume.\n    surfaceTile.boundingVolumeSourceTile = heightSource;\n    var rectangle = tile.rectangle;\n\n    if (defined(rectangle)) {\n      surfaceTile.orientedBoundingBox = OrientedBoundingBox.fromRectangle(tile.rectangle, tileBoundingRegion.minimumHeight, tileBoundingRegion.maximumHeight, tile.tilingScheme.ellipsoid, surfaceTile.orientedBoundingBox);\n      surfaceTile.occludeePointInScaledSpace = computeOccludeePoint(this, surfaceTile.orientedBoundingBox.center, tile.rectangle, tileBoundingRegion.minimumHeight, tileBoundingRegion.maximumHeight, surfaceTile.occludeePointInScaledSpace);\n    }\n  }\n\n  var min = tileBoundingRegion.minimumHeight;\n  var max = tileBoundingRegion.maximumHeight;\n\n  if (surfaceTile.boundingVolumeSourceTile !== tile) {\n    var cameraHeight = frameState.camera.positionCartographic.height;\n    var distanceToMin = Math.abs(cameraHeight - min);\n    var distanceToMax = Math.abs(cameraHeight - max);\n\n    if (distanceToMin > distanceToMax) {\n      tileBoundingRegion.minimumHeight = min;\n      tileBoundingRegion.maximumHeight = min;\n    } else {\n      tileBoundingRegion.minimumHeight = max;\n      tileBoundingRegion.maximumHeight = max;\n    }\n  }\n\n  var result = tileBoundingRegion.distanceToCamera(frameState);\n  tileBoundingRegion.minimumHeight = min;\n  tileBoundingRegion.maximumHeight = max;\n  return result;\n};\n\nfunction updateTileBoundingRegion(tile, terrainProvider, frameState) {\n  var surfaceTile = tile.data;\n\n  if (surfaceTile === undefined) {\n    surfaceTile = tile.data = new GlobeSurfaceTile();\n  }\n\n  if (surfaceTile.tileBoundingRegion === undefined) {\n    surfaceTile.tileBoundingRegion = new TileBoundingRegion({\n      computeBoundingVolumes: false,\n      rectangle: tile.rectangle,\n      ellipsoid: tile.tilingScheme.ellipsoid,\n      minimumHeight: 0.0,\n      maximumHeight: 0.0\n    });\n  }\n\n  var terrainData = surfaceTile.terrainData;\n  var mesh = surfaceTile.mesh;\n  var tileBoundingRegion = surfaceTile.tileBoundingRegion;\n\n  if (mesh !== undefined && mesh.minimumHeight !== undefined && mesh.maximumHeight !== undefined) {\n    // We have tight-fitting min/max heights from the mesh.\n    tileBoundingRegion.minimumHeight = mesh.minimumHeight;\n    tileBoundingRegion.maximumHeight = mesh.maximumHeight;\n    return tile;\n  }\n\n  if (terrainData !== undefined && terrainData._minimumHeight !== undefined && terrainData._maximumHeight !== undefined) {\n    // We have tight-fitting min/max heights from the terrain data.\n    tileBoundingRegion.minimumHeight = terrainData._minimumHeight * frameState.terrainExaggeration;\n    tileBoundingRegion.maximumHeight = terrainData._maximumHeight * frameState.terrainExaggeration;\n    return tile;\n  } // No accurate min/max heights available, so we're stuck with min/max heights from an ancestor tile.\n\n\n  tileBoundingRegion.minimumHeight = Number.NaN;\n  tileBoundingRegion.maximumHeight = Number.NaN;\n  var ancestor = tile.parent;\n\n  while (ancestor !== undefined) {\n    var ancestorSurfaceTile = ancestor.data;\n\n    if (ancestorSurfaceTile !== undefined) {\n      var ancestorMesh = ancestorSurfaceTile.mesh;\n\n      if (ancestorMesh !== undefined && ancestorMesh.minimumHeight !== undefined && ancestorMesh.maximumHeight !== undefined) {\n        tileBoundingRegion.minimumHeight = ancestorMesh.minimumHeight;\n        tileBoundingRegion.maximumHeight = ancestorMesh.maximumHeight;\n        return ancestor;\n      }\n\n      var ancestorTerrainData = ancestorSurfaceTile.terrainData;\n\n      if (ancestorTerrainData !== undefined && ancestorTerrainData._minimumHeight !== undefined && ancestorTerrainData._maximumHeight !== undefined) {\n        tileBoundingRegion.minimumHeight = ancestorTerrainData._minimumHeight * frameState.terrainExaggeration;\n        tileBoundingRegion.maximumHeight = ancestorTerrainData._maximumHeight * frameState.terrainExaggeration;\n        return ancestor;\n      }\n    }\n\n    ancestor = ancestor.parent;\n  }\n\n  return undefined;\n}\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n *\n * @see GlobeSurfaceTileProvider#destroy\n */\n\n\nGlobeSurfaceTileProvider.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * provider = provider && provider();\n *\n * @see GlobeSurfaceTileProvider#isDestroyed\n */\n\n\nGlobeSurfaceTileProvider.prototype.destroy = function () {\n  this._tileProvider = this._tileProvider && this._tileProvider.destroy();\n  this._clippingPlanes = this._clippingPlanes && this._clippingPlanes.destroy();\n  return destroyObject(this);\n};\n\nfunction getTileReadyCallback(tileImageriesToFree, layer, terrainProvider) {\n  return function (tile) {\n    var tileImagery;\n    var imagery;\n    var startIndex = -1;\n    var tileImageryCollection = tile.data.imagery;\n    var length = tileImageryCollection.length;\n    var i;\n\n    for (i = 0; i < length; ++i) {\n      tileImagery = tileImageryCollection[i];\n      imagery = defaultValue(tileImagery.readyImagery, tileImagery.loadingImagery);\n\n      if (imagery.imageryLayer === layer) {\n        startIndex = i;\n        break;\n      }\n    }\n\n    if (startIndex !== -1) {\n      var endIndex = startIndex + tileImageriesToFree;\n      tileImagery = tileImageryCollection[endIndex];\n      imagery = defined(tileImagery) ? defaultValue(tileImagery.readyImagery, tileImagery.loadingImagery) : undefined;\n\n      if (!defined(imagery) || imagery.imageryLayer !== layer) {\n        // Return false to keep the callback if we have to wait on the skeletons\n        // Return true to remove the callback if something went wrong\n        return !layer._createTileImagerySkeletons(tile, terrainProvider, endIndex);\n      }\n\n      for (i = startIndex; i < endIndex; ++i) {\n        tileImageryCollection[i].freeResources();\n      }\n\n      tileImageryCollection.splice(startIndex, tileImageriesToFree);\n    }\n\n    return true; // Everything is done, so remove the callback\n  };\n}\n\nGlobeSurfaceTileProvider.prototype._onLayerAdded = function (layer, index) {\n  if (layer.show) {\n    var terrainProvider = this._terrainProvider;\n    var that = this;\n    var imageryProvider = layer.imageryProvider;\n    var tileImageryUpdatedEvent = this._imageryLayersUpdatedEvent;\n\n    imageryProvider._reload = function () {\n      // Clear the layer's cache\n      layer._imageryCache = {};\n\n      that._quadtree.forEachLoadedTile(function (tile) {\n        // If this layer is still waiting to for the loaded callback, just return\n        if (defined(tile._loadedCallbacks[layer._layerIndex])) {\n          return;\n        }\n\n        var i; // Figure out how many TileImageries we will need to remove and where to insert new ones\n\n        var tileImageryCollection = tile.data.imagery;\n        var length = tileImageryCollection.length;\n        var startIndex = -1;\n        var tileImageriesToFree = 0;\n\n        for (i = 0; i < length; ++i) {\n          var tileImagery = tileImageryCollection[i];\n          var imagery = defaultValue(tileImagery.readyImagery, tileImagery.loadingImagery);\n\n          if (imagery.imageryLayer === layer) {\n            if (startIndex === -1) {\n              startIndex = i;\n            }\n\n            ++tileImageriesToFree;\n          } else if (startIndex !== -1) {\n            // iterated past the section of TileImageries belonging to this layer, no need to continue.\n            break;\n          }\n        }\n\n        if (startIndex === -1) {\n          return;\n        } // Insert immediately after existing TileImageries\n\n\n        var insertionPoint = startIndex + tileImageriesToFree; // Create new TileImageries for all loaded tiles\n\n        if (layer._createTileImagerySkeletons(tile, terrainProvider, insertionPoint)) {\n          // Add callback to remove old TileImageries when the new TileImageries are ready\n          tile._loadedCallbacks[layer._layerIndex] = getTileReadyCallback(tileImageriesToFree, layer, terrainProvider);\n          tile.state = QuadtreeTileLoadState.LOADING;\n        }\n      });\n    }; // create TileImageries for this layer for all previously loaded tiles\n\n\n    this._quadtree.forEachLoadedTile(function (tile) {\n      if (layer._createTileImagerySkeletons(tile, terrainProvider)) {\n        tile.state = QuadtreeTileLoadState.LOADING; // Tiles that are not currently being rendered need to load the new layer before they're renderable.\n        // We don't mark the rendered tiles non-renderable, though, because that would make the globe disappear.\n\n        if (tile.level !== 0 && (tile._lastSelectionResultFrame !== that.quadtree._lastSelectionFrameNumber || tile._lastSelectionResult !== TileSelectionResult.RENDERED)) {\n          tile.renderable = false;\n        }\n      }\n    });\n\n    this._layerOrderChanged = true;\n    tileImageryUpdatedEvent.raiseEvent();\n  }\n};\n\nGlobeSurfaceTileProvider.prototype._onLayerRemoved = function (layer, index) {\n  // destroy TileImagerys for this layer for all previously loaded tiles\n  this._quadtree.forEachLoadedTile(function (tile) {\n    var tileImageryCollection = tile.data.imagery;\n    var startIndex = -1;\n    var numDestroyed = 0;\n\n    for (var i = 0, len = tileImageryCollection.length; i < len; ++i) {\n      var tileImagery = tileImageryCollection[i];\n      var imagery = tileImagery.loadingImagery;\n\n      if (!defined(imagery)) {\n        imagery = tileImagery.readyImagery;\n      }\n\n      if (imagery.imageryLayer === layer) {\n        if (startIndex === -1) {\n          startIndex = i;\n        }\n\n        tileImagery.freeResources();\n        ++numDestroyed;\n      } else if (startIndex !== -1) {\n        // iterated past the section of TileImagerys belonging to this layer, no need to continue.\n        break;\n      }\n    }\n\n    if (startIndex !== -1) {\n      tileImageryCollection.splice(startIndex, numDestroyed);\n    }\n  });\n\n  if (defined(layer.imageryProvider)) {\n    layer.imageryProvider._reload = undefined;\n  }\n\n  this._imageryLayersUpdatedEvent.raiseEvent();\n};\n\nGlobeSurfaceTileProvider.prototype._onLayerMoved = function (layer, newIndex, oldIndex) {\n  this._layerOrderChanged = true;\n\n  this._imageryLayersUpdatedEvent.raiseEvent();\n};\n\nGlobeSurfaceTileProvider.prototype._onLayerShownOrHidden = function (layer, index, show) {\n  if (show) {\n    this._onLayerAdded(layer, index);\n  } else {\n    this._onLayerRemoved(layer, index);\n  }\n};\n\nvar scratchClippingPlanesMatrix = new Matrix4();\nvar scratchInverseTransposeClippingPlanesMatrix = new Matrix4();\n\nfunction createTileUniformMap(frameState, globeSurfaceTileProvider) {\n  var uniformMap = {\n    u_initialColor: function () {\n      return this.properties.initialColor;\n    },\n    u_fillHighlightColor: function () {\n      return this.properties.fillHighlightColor;\n    },\n    u_zoomedOutOceanSpecularIntensity: function () {\n      return this.properties.zoomedOutOceanSpecularIntensity;\n    },\n    u_oceanNormalMap: function () {\n      return this.properties.oceanNormalMap;\n    },\n    u_lightingFadeDistance: function () {\n      return this.properties.lightingFadeDistance;\n    },\n    u_nightFadeDistance: function () {\n      return this.properties.nightFadeDistance;\n    },\n    u_center3D: function () {\n      return this.properties.center3D;\n    },\n    u_tileRectangle: function () {\n      return this.properties.tileRectangle;\n    },\n    u_modifiedModelView: function () {\n      var viewMatrix = frameState.context.uniformState.view;\n      var centerEye = Matrix4.multiplyByPoint(viewMatrix, this.properties.rtc, centerEyeScratch);\n      Matrix4.setTranslation(viewMatrix, centerEye, modifiedModelViewScratch);\n      return modifiedModelViewScratch;\n    },\n    u_modifiedModelViewProjection: function () {\n      var viewMatrix = frameState.context.uniformState.view;\n      var projectionMatrix = frameState.context.uniformState.projection;\n      var centerEye = Matrix4.multiplyByPoint(viewMatrix, this.properties.rtc, centerEyeScratch);\n      Matrix4.setTranslation(viewMatrix, centerEye, modifiedModelViewProjectionScratch);\n      Matrix4.multiply(projectionMatrix, modifiedModelViewProjectionScratch, modifiedModelViewProjectionScratch);\n      return modifiedModelViewProjectionScratch;\n    },\n    u_dayTextures: function () {\n      return this.properties.dayTextures;\n    },\n    u_dayTextureTranslationAndScale: function () {\n      return this.properties.dayTextureTranslationAndScale;\n    },\n    u_dayTextureTexCoordsRectangle: function () {\n      return this.properties.dayTextureTexCoordsRectangle;\n    },\n    u_dayTextureUseWebMercatorT: function () {\n      return this.properties.dayTextureUseWebMercatorT;\n    },\n    u_dayTextureAlpha: function () {\n      return this.properties.dayTextureAlpha;\n    },\n    u_dayTextureNightAlpha: function () {\n      return this.properties.dayTextureNightAlpha;\n    },\n    u_dayTextureDayAlpha: function () {\n      return this.properties.dayTextureDayAlpha;\n    },\n    u_dayTextureBrightness: function () {\n      return this.properties.dayTextureBrightness;\n    },\n    u_dayTextureContrast: function () {\n      return this.properties.dayTextureContrast;\n    },\n    u_dayTextureHue: function () {\n      return this.properties.dayTextureHue;\n    },\n    u_dayTextureSaturation: function () {\n      return this.properties.dayTextureSaturation;\n    },\n    u_dayTextureOneOverGamma: function () {\n      return this.properties.dayTextureOneOverGamma;\n    },\n    u_dayIntensity: function () {\n      return this.properties.dayIntensity;\n    },\n    u_southAndNorthLatitude: function () {\n      return this.properties.southAndNorthLatitude;\n    },\n    u_southMercatorYAndOneOverHeight: function () {\n      return this.properties.southMercatorYAndOneOverHeight;\n    },\n    u_waterMask: function () {\n      return this.properties.waterMask;\n    },\n    u_waterMaskTranslationAndScale: function () {\n      return this.properties.waterMaskTranslationAndScale;\n    },\n    u_minMaxHeight: function () {\n      return this.properties.minMaxHeight;\n    },\n    u_scaleAndBias: function () {\n      return this.properties.scaleAndBias;\n    },\n    u_dayTextureSplit: function () {\n      return this.properties.dayTextureSplit;\n    },\n    u_dayTextureCutoutRectangles: function () {\n      return this.properties.dayTextureCutoutRectangles;\n    },\n    u_clippingPlanes: function () {\n      var clippingPlanes = globeSurfaceTileProvider._clippingPlanes;\n\n      if (defined(clippingPlanes) && defined(clippingPlanes.texture)) {\n        // Check in case clippingPlanes hasn't been updated yet.\n        return clippingPlanes.texture;\n      }\n\n      return frameState.context.defaultTexture;\n    },\n    u_cartographicLimitRectangle: function () {\n      return this.properties.localizedCartographicLimitRectangle;\n    },\n    u_clippingPlanesMatrix: function () {\n      var clippingPlanes = globeSurfaceTileProvider._clippingPlanes;\n      var transform = defined(clippingPlanes) ? Matrix4.multiply(frameState.context.uniformState.view, clippingPlanes.modelMatrix, scratchClippingPlanesMatrix) : Matrix4.IDENTITY;\n      return Matrix4.inverseTranspose(transform, scratchInverseTransposeClippingPlanesMatrix);\n    },\n    u_clippingPlanesEdgeStyle: function () {\n      var style = this.properties.clippingPlanesEdgeColor;\n      style.alpha = this.properties.clippingPlanesEdgeWidth;\n      return style;\n    },\n    u_minimumBrightness: function () {\n      return frameState.fog.minimumBrightness;\n    },\n    u_hsbShift: function () {\n      return this.properties.hsbShift;\n    },\n    u_colorsToAlpha: function () {\n      return this.properties.colorsToAlpha;\n    },\n    u_frontFaceAlphaByDistance: function () {\n      return this.properties.frontFaceAlphaByDistance;\n    },\n    u_backFaceAlphaByDistance: function () {\n      return this.properties.backFaceAlphaByDistance;\n    },\n    u_translucencyRectangle: function () {\n      return this.properties.localizedTranslucencyRectangle;\n    },\n    u_undergroundColor: function () {\n      return this.properties.undergroundColor;\n    },\n    u_undergroundColorAlphaByDistance: function () {\n      return this.properties.undergroundColorAlphaByDistance;\n    },\n    // make a separate object so that changes to the properties are seen on\n    // derived commands that combine another uniform map with this one.\n    properties: {\n      initialColor: new Cartesian4(0.0, 0.0, 0.5, 1.0),\n      fillHighlightColor: new Color(0.0, 0.0, 0.0, 0.0),\n      zoomedOutOceanSpecularIntensity: 0.5,\n      oceanNormalMap: undefined,\n      lightingFadeDistance: new Cartesian2(6500000.0, 9000000.0),\n      nightFadeDistance: new Cartesian2(10000000.0, 40000000.0),\n      hsbShift: new Cartesian3(),\n      center3D: undefined,\n      rtc: new Cartesian3(),\n      modifiedModelView: new Matrix4(),\n      tileRectangle: new Cartesian4(),\n      dayTextures: [],\n      dayTextureTranslationAndScale: [],\n      dayTextureTexCoordsRectangle: [],\n      dayTextureUseWebMercatorT: [],\n      dayTextureAlpha: [],\n      dayTextureNightAlpha: [],\n      dayTextureDayAlpha: [],\n      dayTextureBrightness: [],\n      dayTextureContrast: [],\n      dayTextureHue: [],\n      dayTextureSaturation: [],\n      dayTextureOneOverGamma: [],\n      dayTextureSplit: [],\n      dayTextureCutoutRectangles: [],\n      dayIntensity: 0.0,\n      colorsToAlpha: [],\n      southAndNorthLatitude: new Cartesian2(),\n      southMercatorYAndOneOverHeight: new Cartesian2(),\n      waterMask: undefined,\n      waterMaskTranslationAndScale: new Cartesian4(),\n      minMaxHeight: new Cartesian2(),\n      scaleAndBias: new Matrix4(),\n      clippingPlanesEdgeColor: Color.clone(Color.WHITE),\n      clippingPlanesEdgeWidth: 0.0,\n      localizedCartographicLimitRectangle: new Cartesian4(),\n      frontFaceAlphaByDistance: new Cartesian4(),\n      backFaceAlphaByDistance: new Cartesian4(),\n      localizedTranslucencyRectangle: new Cartesian4(),\n      undergroundColor: Color.clone(Color.TRANSPARENT),\n      undergroundColorAlphaByDistance: new Cartesian4()\n    }\n  };\n\n  if (defined(globeSurfaceTileProvider.materialUniformMap)) {\n    return combine(uniformMap, globeSurfaceTileProvider.materialUniformMap);\n  }\n\n  return uniformMap;\n}\n\nfunction createWireframeVertexArrayIfNecessary(context, provider, tile) {\n  var surfaceTile = tile.data;\n  var mesh;\n  var vertexArray;\n\n  if (defined(surfaceTile.vertexArray)) {\n    mesh = surfaceTile.mesh;\n    vertexArray = surfaceTile.vertexArray;\n  } else if (defined(surfaceTile.fill) && defined(surfaceTile.fill.vertexArray)) {\n    mesh = surfaceTile.fill.mesh;\n    vertexArray = surfaceTile.fill.vertexArray;\n  }\n\n  if (!defined(mesh) || !defined(vertexArray)) {\n    return;\n  }\n\n  if (defined(surfaceTile.wireframeVertexArray)) {\n    if (surfaceTile.wireframeVertexArray.mesh === mesh) {\n      return;\n    }\n\n    surfaceTile.wireframeVertexArray.destroy();\n    surfaceTile.wireframeVertexArray = undefined;\n  }\n\n  surfaceTile.wireframeVertexArray = createWireframeVertexArray(context, vertexArray, mesh);\n  surfaceTile.wireframeVertexArray.mesh = mesh;\n}\n/**\n * Creates a vertex array for wireframe rendering of a terrain tile.\n *\n * @private\n *\n * @param {Context} context The context in which to create the vertex array.\n * @param {VertexArray} vertexArray The existing, non-wireframe vertex array.  The new vertex array\n *                      will share vertex buffers with this existing one.\n * @param {TerrainMesh} terrainMesh The terrain mesh containing non-wireframe indices.\n * @returns {VertexArray} The vertex array for wireframe rendering.\n */\n\n\nfunction createWireframeVertexArray(context, vertexArray, terrainMesh) {\n  var indices = terrainMesh.indices;\n  var geometry = {\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES\n  };\n  GeometryPipeline.toWireframe(geometry);\n  var wireframeIndices = geometry.indices;\n  var wireframeIndexBuffer = Buffer.createIndexBuffer({\n    context: context,\n    typedArray: wireframeIndices,\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: IndexDatatype.fromSizeInBytes(wireframeIndices.BYTES_PER_ELEMENT)\n  });\n  return new VertexArray({\n    context: context,\n    attributes: vertexArray._attributes,\n    indexBuffer: wireframeIndexBuffer\n  });\n}\n\nvar getDebugOrientedBoundingBox;\nvar getDebugBoundingSphere;\nvar debugDestroyPrimitive;\n\n(function () {\n  var instanceOBB = new GeometryInstance({\n    geometry: BoxOutlineGeometry.fromDimensions({\n      dimensions: new Cartesian3(2.0, 2.0, 2.0)\n    })\n  });\n  var instanceSphere = new GeometryInstance({\n    geometry: new SphereOutlineGeometry({\n      radius: 1.0\n    })\n  });\n  var modelMatrix = new Matrix4();\n  var previousVolume;\n  var primitive;\n\n  function createDebugPrimitive(instance) {\n    return new Primitive({\n      geometryInstances: instance,\n      appearance: new PerInstanceColorAppearance({\n        translucent: false,\n        flat: true\n      }),\n      asynchronous: false\n    });\n  }\n\n  getDebugOrientedBoundingBox = function (obb, color) {\n    if (obb === previousVolume) {\n      return primitive;\n    }\n\n    debugDestroyPrimitive();\n    previousVolume = obb;\n    modelMatrix = Matrix4.fromRotationTranslation(obb.halfAxes, obb.center, modelMatrix);\n    instanceOBB.modelMatrix = modelMatrix;\n    instanceOBB.attributes.color = ColorGeometryInstanceAttribute.fromColor(color);\n    primitive = createDebugPrimitive(instanceOBB);\n    return primitive;\n  };\n\n  getDebugBoundingSphere = function (sphere, color) {\n    if (sphere === previousVolume) {\n      return primitive;\n    }\n\n    debugDestroyPrimitive();\n    previousVolume = sphere;\n    modelMatrix = Matrix4.fromTranslation(sphere.center, modelMatrix);\n    modelMatrix = Matrix4.multiplyByUniformScale(modelMatrix, sphere.radius, modelMatrix);\n    instanceSphere.modelMatrix = modelMatrix;\n    instanceSphere.attributes.color = ColorGeometryInstanceAttribute.fromColor(color);\n    primitive = createDebugPrimitive(instanceSphere);\n    return primitive;\n  };\n\n  debugDestroyPrimitive = function () {\n    if (defined(primitive)) {\n      primitive.destroy();\n      primitive = undefined;\n      previousVolume = undefined;\n    }\n  };\n})();\n\nvar otherPassesInitialColor = new Cartesian4(0.0, 0.0, 0.0, 0.0);\nvar surfaceShaderSetOptionsScratch = {\n  frameState: undefined,\n  surfaceTile: undefined,\n  numberOfDayTextures: undefined,\n  applyBrightness: undefined,\n  applyContrast: undefined,\n  applyHue: undefined,\n  applySaturation: undefined,\n  applyGamma: undefined,\n  applyAlpha: undefined,\n  applyDayNightAlpha: undefined,\n  applySplit: undefined,\n  showReflectiveOcean: undefined,\n  showOceanWaves: undefined,\n  enableLighting: undefined,\n  dynamicAtmosphereLighting: undefined,\n  dynamicAtmosphereLightingFromSun: undefined,\n  showGroundAtmosphere: undefined,\n  perFragmentGroundAtmosphere: undefined,\n  hasVertexNormals: undefined,\n  useWebMercatorProjection: undefined,\n  enableFog: undefined,\n  enableClippingPlanes: undefined,\n  clippingPlanes: undefined,\n  clippedByBoundaries: undefined,\n  hasImageryLayerCutout: undefined,\n  colorCorrect: undefined,\n  colorToAlpha: undefined\n};\nvar defaultUndergroundColor = Color.TRANSPARENT;\nvar defaultundergroundColorAlphaByDistance = new NearFarScalar();\n\nfunction addDrawCommandsForTile(tileProvider, tile, frameState) {\n  var surfaceTile = tile.data;\n\n  if (!defined(surfaceTile.vertexArray)) {\n    if (surfaceTile.fill === undefined) {\n      // No fill was created for this tile, probably because this tile is not connected to\n      // any renderable tiles. So create a simple tile in the middle of the tile's possible\n      // height range.\n      surfaceTile.fill = new TerrainFillMesh(tile);\n    }\n\n    surfaceTile.fill.update(tileProvider, frameState);\n  }\n\n  var creditDisplay = frameState.creditDisplay;\n  var terrainData = surfaceTile.terrainData;\n\n  if (defined(terrainData) && defined(terrainData.credits)) {\n    var tileCredits = terrainData.credits;\n\n    for (var tileCreditIndex = 0, tileCreditLength = tileCredits.length; tileCreditIndex < tileCreditLength; ++tileCreditIndex) {\n      creditDisplay.addCredit(tileCredits[tileCreditIndex]);\n    }\n  }\n\n  var maxTextures = ContextLimits.maximumTextureImageUnits;\n  var waterMaskTexture = surfaceTile.waterMaskTexture;\n  var waterMaskTranslationAndScale = surfaceTile.waterMaskTranslationAndScale;\n\n  if (!defined(waterMaskTexture) && defined(surfaceTile.fill)) {\n    waterMaskTexture = surfaceTile.fill.waterMaskTexture;\n    waterMaskTranslationAndScale = surfaceTile.fill.waterMaskTranslationAndScale;\n  }\n\n  var cameraUnderground = frameState.cameraUnderground;\n  var globeTranslucencyState = frameState.globeTranslucencyState;\n  var translucent = globeTranslucencyState.translucent;\n  var frontFaceAlphaByDistance = globeTranslucencyState.frontFaceAlphaByDistance;\n  var backFaceAlphaByDistance = globeTranslucencyState.backFaceAlphaByDistance;\n  var translucencyRectangle = globeTranslucencyState.rectangle;\n  var undergroundColor = defaultValue(tileProvider.undergroundColor, defaultUndergroundColor);\n  var undergroundColorAlphaByDistance = defaultValue(tileProvider.undergroundColorAlphaByDistance, defaultundergroundColorAlphaByDistance);\n  var showUndergroundColor = isUndergroundVisible(tileProvider, frameState) && frameState.mode === SceneMode.SCENE3D && undergroundColor.alpha > 0.0 && (undergroundColorAlphaByDistance.nearValue > 0.0 || undergroundColorAlphaByDistance.farValue > 0.0);\n  var showReflectiveOcean = tileProvider.hasWaterMask && defined(waterMaskTexture);\n  var oceanNormalMap = tileProvider.oceanNormalMap;\n  var showOceanWaves = showReflectiveOcean && defined(oceanNormalMap);\n  var hasVertexNormals = tileProvider.terrainProvider.ready && tileProvider.terrainProvider.hasVertexNormals;\n  var enableFog = frameState.fog.enabled && !cameraUnderground;\n  var showGroundAtmosphere = tileProvider.showGroundAtmosphere && frameState.mode === SceneMode.SCENE3D;\n  var castShadows = ShadowMode.castShadows(tileProvider.shadows) && !translucent;\n  var receiveShadows = ShadowMode.receiveShadows(tileProvider.shadows) && !translucent;\n  var hueShift = tileProvider.hueShift;\n  var saturationShift = tileProvider.saturationShift;\n  var brightnessShift = tileProvider.brightnessShift;\n  var colorCorrect = !(CesiumMath.equalsEpsilon(hueShift, 0.0, CesiumMath.EPSILON7) && CesiumMath.equalsEpsilon(saturationShift, 0.0, CesiumMath.EPSILON7) && CesiumMath.equalsEpsilon(brightnessShift, 0.0, CesiumMath.EPSILON7));\n  var perFragmentGroundAtmosphere = false;\n\n  if (showGroundAtmosphere) {\n    var cameraDistance = Cartesian3.magnitude(frameState.camera.positionWC);\n    var fadeOutDistance = tileProvider.nightFadeOutDistance;\n    perFragmentGroundAtmosphere = cameraDistance > fadeOutDistance;\n  }\n\n  if (showReflectiveOcean) {\n    --maxTextures;\n  }\n\n  if (showOceanWaves) {\n    --maxTextures;\n  }\n\n  if (defined(frameState.shadowState) && frameState.shadowState.shadowsEnabled) {\n    --maxTextures;\n  }\n\n  if (defined(tileProvider.clippingPlanes) && tileProvider.clippingPlanes.enabled) {\n    --maxTextures;\n  }\n\n  maxTextures -= globeTranslucencyState.numberOfTextureUniforms;\n  var mesh = surfaceTile.renderedMesh;\n  var rtc = mesh.center;\n  var encoding = mesh.encoding; // Not used in 3D.\n\n  var tileRectangle = tileRectangleScratch; // Only used for Mercator projections.\n\n  var southLatitude = 0.0;\n  var northLatitude = 0.0;\n  var southMercatorY = 0.0;\n  var oneOverMercatorHeight = 0.0;\n  var useWebMercatorProjection = false;\n\n  if (frameState.mode !== SceneMode.SCENE3D) {\n    var projection = frameState.mapProjection;\n    var southwest = projection.project(Rectangle.southwest(tile.rectangle), southwestScratch);\n    var northeast = projection.project(Rectangle.northeast(tile.rectangle), northeastScratch);\n    tileRectangle.x = southwest.x;\n    tileRectangle.y = southwest.y;\n    tileRectangle.z = northeast.x;\n    tileRectangle.w = northeast.y; // In 2D and Columbus View, use the center of the tile for RTC rendering.\n\n    if (frameState.mode !== SceneMode.MORPHING) {\n      rtc = rtcScratch;\n      rtc.x = 0.0;\n      rtc.y = (tileRectangle.z + tileRectangle.x) * 0.5;\n      rtc.z = (tileRectangle.w + tileRectangle.y) * 0.5;\n      tileRectangle.x -= rtc.y;\n      tileRectangle.y -= rtc.z;\n      tileRectangle.z -= rtc.y;\n      tileRectangle.w -= rtc.z;\n    }\n\n    if (frameState.mode === SceneMode.SCENE2D && encoding.quantization === TerrainQuantization.BITS12) {\n      // In 2D, the texture coordinates of the tile are interpolated over the rectangle to get the position in the vertex shader.\n      // When the texture coordinates are quantized, error is introduced. This can be seen through the 1px wide cracking\n      // between the quantized tiles in 2D. To compensate for the error, move the expand the rectangle in each direction by\n      // half the error amount.\n      var epsilon = 1.0 / (Math.pow(2.0, 12.0) - 1.0) * 0.5;\n      var widthEpsilon = (tileRectangle.z - tileRectangle.x) * epsilon;\n      var heightEpsilon = (tileRectangle.w - tileRectangle.y) * epsilon;\n      tileRectangle.x -= widthEpsilon;\n      tileRectangle.y -= heightEpsilon;\n      tileRectangle.z += widthEpsilon;\n      tileRectangle.w += heightEpsilon;\n    }\n\n    if (projection instanceof WebMercatorProjection) {\n      southLatitude = tile.rectangle.south;\n      northLatitude = tile.rectangle.north;\n      southMercatorY = WebMercatorProjection.geodeticLatitudeToMercatorAngle(southLatitude);\n      oneOverMercatorHeight = 1.0 / (WebMercatorProjection.geodeticLatitudeToMercatorAngle(northLatitude) - southMercatorY);\n      useWebMercatorProjection = true;\n    }\n  }\n\n  var surfaceShaderSetOptions = surfaceShaderSetOptionsScratch;\n  surfaceShaderSetOptions.frameState = frameState;\n  surfaceShaderSetOptions.surfaceTile = surfaceTile;\n  surfaceShaderSetOptions.showReflectiveOcean = showReflectiveOcean;\n  surfaceShaderSetOptions.showOceanWaves = showOceanWaves;\n  surfaceShaderSetOptions.enableLighting = tileProvider.enableLighting;\n  surfaceShaderSetOptions.dynamicAtmosphereLighting = tileProvider.dynamicAtmosphereLighting;\n  surfaceShaderSetOptions.dynamicAtmosphereLightingFromSun = tileProvider.dynamicAtmosphereLightingFromSun;\n  surfaceShaderSetOptions.showGroundAtmosphere = showGroundAtmosphere;\n  surfaceShaderSetOptions.perFragmentGroundAtmosphere = perFragmentGroundAtmosphere;\n  surfaceShaderSetOptions.hasVertexNormals = hasVertexNormals;\n  surfaceShaderSetOptions.useWebMercatorProjection = useWebMercatorProjection;\n  surfaceShaderSetOptions.clippedByBoundaries = surfaceTile.clippedByBoundaries;\n  var tileImageryCollection = surfaceTile.imagery;\n  var imageryIndex = 0;\n  var imageryLen = tileImageryCollection.length;\n  var showSkirts = tileProvider.showSkirts && !cameraUnderground && !translucent;\n  var backFaceCulling = tileProvider.backFaceCulling && !cameraUnderground && !translucent;\n  var firstPassRenderState = backFaceCulling ? tileProvider._renderState : tileProvider._disableCullingRenderState;\n  var otherPassesRenderState = backFaceCulling ? tileProvider._blendRenderState : tileProvider._disableCullingBlendRenderState;\n  var renderState = firstPassRenderState;\n  var initialColor = tileProvider._firstPassInitialColor;\n  var context = frameState.context;\n\n  if (!defined(tileProvider._debug.boundingSphereTile)) {\n    debugDestroyPrimitive();\n  }\n\n  var materialUniformMapChanged = tileProvider._materialUniformMap !== tileProvider.materialUniformMap;\n\n  if (materialUniformMapChanged) {\n    tileProvider._materialUniformMap = tileProvider.materialUniformMap;\n    var drawCommandsLength = tileProvider._drawCommands.length;\n\n    for (var i = 0; i < drawCommandsLength; ++i) {\n      tileProvider._uniformMaps[i] = createTileUniformMap(frameState, tileProvider);\n    }\n  }\n\n  do {\n    var numberOfDayTextures = 0;\n    var command;\n    var uniformMap;\n\n    if (tileProvider._drawCommands.length <= tileProvider._usedDrawCommands) {\n      command = new DrawCommand();\n      command.owner = tile;\n      command.cull = false;\n      command.boundingVolume = new BoundingSphere();\n      command.orientedBoundingBox = undefined;\n      uniformMap = createTileUniformMap(frameState, tileProvider);\n\n      tileProvider._drawCommands.push(command);\n\n      tileProvider._uniformMaps.push(uniformMap);\n    } else {\n      command = tileProvider._drawCommands[tileProvider._usedDrawCommands];\n      uniformMap = tileProvider._uniformMaps[tileProvider._usedDrawCommands];\n    }\n\n    command.owner = tile;\n    ++tileProvider._usedDrawCommands;\n\n    if (tile === tileProvider._debug.boundingSphereTile) {\n      var obb = surfaceTile.orientedBoundingBox; // If a debug primitive already exists for this tile, it will not be\n      // re-created, to avoid allocation every frame. If it were possible\n      // to have more than one selected tile, this would have to change.\n\n      if (defined(obb)) {\n        getDebugOrientedBoundingBox(obb, Color.RED).update(frameState);\n      } else if (defined(mesh) && defined(mesh.boundingSphere3D)) {\n        getDebugBoundingSphere(mesh.boundingSphere3D, Color.RED).update(frameState);\n      }\n    }\n\n    var uniformMapProperties = uniformMap.properties;\n    Cartesian4.clone(initialColor, uniformMapProperties.initialColor);\n    uniformMapProperties.oceanNormalMap = oceanNormalMap;\n    uniformMapProperties.lightingFadeDistance.x = tileProvider.lightingFadeOutDistance;\n    uniformMapProperties.lightingFadeDistance.y = tileProvider.lightingFadeInDistance;\n    uniformMapProperties.nightFadeDistance.x = tileProvider.nightFadeOutDistance;\n    uniformMapProperties.nightFadeDistance.y = tileProvider.nightFadeInDistance;\n    uniformMapProperties.zoomedOutOceanSpecularIntensity = tileProvider.zoomedOutOceanSpecularIntensity;\n    var frontFaceAlphaByDistanceFinal = cameraUnderground ? backFaceAlphaByDistance : frontFaceAlphaByDistance;\n    var backFaceAlphaByDistanceFinal = cameraUnderground ? frontFaceAlphaByDistance : backFaceAlphaByDistance;\n\n    if (defined(frontFaceAlphaByDistanceFinal)) {\n      Cartesian4.fromElements(frontFaceAlphaByDistanceFinal.near, frontFaceAlphaByDistanceFinal.nearValue, frontFaceAlphaByDistanceFinal.far, frontFaceAlphaByDistanceFinal.farValue, uniformMapProperties.frontFaceAlphaByDistance);\n      Cartesian4.fromElements(backFaceAlphaByDistanceFinal.near, backFaceAlphaByDistanceFinal.nearValue, backFaceAlphaByDistanceFinal.far, backFaceAlphaByDistanceFinal.farValue, uniformMapProperties.backFaceAlphaByDistance);\n    }\n\n    Cartesian4.fromElements(undergroundColorAlphaByDistance.near, undergroundColorAlphaByDistance.nearValue, undergroundColorAlphaByDistance.far, undergroundColorAlphaByDistance.farValue, uniformMapProperties.undergroundColorAlphaByDistance);\n    Color.clone(undergroundColor, uniformMapProperties.undergroundColor);\n    var highlightFillTile = !defined(surfaceTile.vertexArray) && defined(tileProvider.fillHighlightColor) && tileProvider.fillHighlightColor.alpha > 0.0;\n\n    if (highlightFillTile) {\n      Color.clone(tileProvider.fillHighlightColor, uniformMapProperties.fillHighlightColor);\n    }\n\n    uniformMapProperties.center3D = mesh.center;\n    Cartesian3.clone(rtc, uniformMapProperties.rtc);\n    Cartesian4.clone(tileRectangle, uniformMapProperties.tileRectangle);\n    uniformMapProperties.southAndNorthLatitude.x = southLatitude;\n    uniformMapProperties.southAndNorthLatitude.y = northLatitude;\n    uniformMapProperties.southMercatorYAndOneOverHeight.x = southMercatorY;\n    uniformMapProperties.southMercatorYAndOneOverHeight.y = oneOverMercatorHeight; // Convert tile limiter rectangle from cartographic to texture space using the tileRectangle.\n\n    var localizedCartographicLimitRectangle = localizedCartographicLimitRectangleScratch;\n    var cartographicLimitRectangle = clipRectangleAntimeridian(tile.rectangle, tileProvider.cartographicLimitRectangle);\n    var localizedTranslucencyRectangle = localizedTranslucencyRectangleScratch;\n    var clippedTranslucencyRectangle = clipRectangleAntimeridian(tile.rectangle, translucencyRectangle);\n    Cartesian3.fromElements(hueShift, saturationShift, brightnessShift, uniformMapProperties.hsbShift);\n    var cartographicTileRectangle = tile.rectangle;\n    var inverseTileWidth = 1.0 / cartographicTileRectangle.width;\n    var inverseTileHeight = 1.0 / cartographicTileRectangle.height;\n    localizedCartographicLimitRectangle.x = (cartographicLimitRectangle.west - cartographicTileRectangle.west) * inverseTileWidth;\n    localizedCartographicLimitRectangle.y = (cartographicLimitRectangle.south - cartographicTileRectangle.south) * inverseTileHeight;\n    localizedCartographicLimitRectangle.z = (cartographicLimitRectangle.east - cartographicTileRectangle.west) * inverseTileWidth;\n    localizedCartographicLimitRectangle.w = (cartographicLimitRectangle.north - cartographicTileRectangle.south) * inverseTileHeight;\n    Cartesian4.clone(localizedCartographicLimitRectangle, uniformMapProperties.localizedCartographicLimitRectangle);\n    localizedTranslucencyRectangle.x = (clippedTranslucencyRectangle.west - cartographicTileRectangle.west) * inverseTileWidth;\n    localizedTranslucencyRectangle.y = (clippedTranslucencyRectangle.south - cartographicTileRectangle.south) * inverseTileHeight;\n    localizedTranslucencyRectangle.z = (clippedTranslucencyRectangle.east - cartographicTileRectangle.west) * inverseTileWidth;\n    localizedTranslucencyRectangle.w = (clippedTranslucencyRectangle.north - cartographicTileRectangle.south) * inverseTileHeight;\n    Cartesian4.clone(localizedTranslucencyRectangle, uniformMapProperties.localizedTranslucencyRectangle); // For performance, use fog in the shader only when the tile is in fog.\n\n    var applyFog = enableFog && CesiumMath.fog(tile._distance, frameState.fog.density) > CesiumMath.EPSILON3;\n    colorCorrect = colorCorrect && (applyFog || showGroundAtmosphere);\n    var applyBrightness = false;\n    var applyContrast = false;\n    var applyHue = false;\n    var applySaturation = false;\n    var applyGamma = false;\n    var applyAlpha = false;\n    var applyDayNightAlpha = false;\n    var applySplit = false;\n    var applyCutout = false;\n    var applyColorToAlpha = false;\n\n    while (numberOfDayTextures < maxTextures && imageryIndex < imageryLen) {\n      var tileImagery = tileImageryCollection[imageryIndex];\n      var imagery = tileImagery.readyImagery;\n      ++imageryIndex;\n\n      if (!defined(imagery) || imagery.imageryLayer.alpha === 0.0) {\n        continue;\n      }\n\n      var texture = tileImagery.useWebMercatorT ? imagery.textureWebMercator : imagery.texture; //>>includeStart('debug', pragmas.debug);\n\n      if (!defined(texture)) {\n        // Our \"ready\" texture isn't actually ready.  This should never happen.\n        //\n        // Side note: It IS possible for it to not be in the READY ImageryState, though.\n        // This can happen when a single imagery tile is shared by two terrain tiles (common)\n        // and one of them (A) needs a geographic version of the tile because it is near the poles,\n        // and the other (B) does not.  B can and will transition the imagery tile to the READY state\n        // without reprojecting to geographic.  Then, later, A will deem that same tile not-ready-yet\n        // because it only has the Web Mercator texture, and flip it back to the TRANSITIONING state.\n        // The imagery tile won't be in the READY state anymore, but it's still READY enough for B's\n        // purposes.\n        throw new DeveloperError(\"readyImagery is not actually ready!\");\n      } //>>includeEnd('debug');\n\n\n      var imageryLayer = imagery.imageryLayer;\n\n      if (!defined(tileImagery.textureTranslationAndScale)) {\n        tileImagery.textureTranslationAndScale = imageryLayer._calculateTextureTranslationAndScale(tile, tileImagery);\n      }\n\n      uniformMapProperties.dayTextures[numberOfDayTextures] = texture;\n      uniformMapProperties.dayTextureTranslationAndScale[numberOfDayTextures] = tileImagery.textureTranslationAndScale;\n      uniformMapProperties.dayTextureTexCoordsRectangle[numberOfDayTextures] = tileImagery.textureCoordinateRectangle;\n      uniformMapProperties.dayTextureUseWebMercatorT[numberOfDayTextures] = tileImagery.useWebMercatorT;\n      uniformMapProperties.dayTextureAlpha[numberOfDayTextures] = imageryLayer.alpha;\n      applyAlpha = applyAlpha || uniformMapProperties.dayTextureAlpha[numberOfDayTextures] !== 1.0;\n      uniformMapProperties.dayTextureNightAlpha[numberOfDayTextures] = imageryLayer.nightAlpha;\n      applyDayNightAlpha = applyDayNightAlpha || uniformMapProperties.dayTextureNightAlpha[numberOfDayTextures] !== 1.0;\n      uniformMapProperties.dayTextureDayAlpha[numberOfDayTextures] = imageryLayer.dayAlpha;\n      applyDayNightAlpha = applyDayNightAlpha || uniformMapProperties.dayTextureDayAlpha[numberOfDayTextures] !== 1.0;\n      uniformMapProperties.dayTextureBrightness[numberOfDayTextures] = imageryLayer.brightness;\n      applyBrightness = applyBrightness || uniformMapProperties.dayTextureBrightness[numberOfDayTextures] !== ImageryLayer.DEFAULT_BRIGHTNESS;\n      uniformMapProperties.dayTextureContrast[numberOfDayTextures] = imageryLayer.contrast;\n      applyContrast = applyContrast || uniformMapProperties.dayTextureContrast[numberOfDayTextures] !== ImageryLayer.DEFAULT_CONTRAST;\n      uniformMapProperties.dayTextureHue[numberOfDayTextures] = imageryLayer.hue;\n      applyHue = applyHue || uniformMapProperties.dayTextureHue[numberOfDayTextures] !== ImageryLayer.DEFAULT_HUE;\n      uniformMapProperties.dayTextureSaturation[numberOfDayTextures] = imageryLayer.saturation;\n      applySaturation = applySaturation || uniformMapProperties.dayTextureSaturation[numberOfDayTextures] !== ImageryLayer.DEFAULT_SATURATION;\n      uniformMapProperties.dayTextureOneOverGamma[numberOfDayTextures] = 1.0 / imageryLayer.gamma;\n      applyGamma = applyGamma || uniformMapProperties.dayTextureOneOverGamma[numberOfDayTextures] !== 1.0 / ImageryLayer.DEFAULT_GAMMA;\n      uniformMapProperties.dayTextureSplit[numberOfDayTextures] = imageryLayer.splitDirection;\n      applySplit = applySplit || uniformMapProperties.dayTextureSplit[numberOfDayTextures] !== 0.0; // Update cutout rectangle\n\n      var dayTextureCutoutRectangle = uniformMapProperties.dayTextureCutoutRectangles[numberOfDayTextures];\n\n      if (!defined(dayTextureCutoutRectangle)) {\n        dayTextureCutoutRectangle = uniformMapProperties.dayTextureCutoutRectangles[numberOfDayTextures] = new Cartesian4();\n      }\n\n      Cartesian4.clone(Cartesian4.ZERO, dayTextureCutoutRectangle);\n\n      if (defined(imageryLayer.cutoutRectangle)) {\n        var cutoutRectangle = clipRectangleAntimeridian(cartographicTileRectangle, imageryLayer.cutoutRectangle);\n        var intersection = Rectangle.simpleIntersection(cutoutRectangle, cartographicTileRectangle, rectangleIntersectionScratch);\n        applyCutout = defined(intersection) || applyCutout;\n        dayTextureCutoutRectangle.x = (cutoutRectangle.west - cartographicTileRectangle.west) * inverseTileWidth;\n        dayTextureCutoutRectangle.y = (cutoutRectangle.south - cartographicTileRectangle.south) * inverseTileHeight;\n        dayTextureCutoutRectangle.z = (cutoutRectangle.east - cartographicTileRectangle.west) * inverseTileWidth;\n        dayTextureCutoutRectangle.w = (cutoutRectangle.north - cartographicTileRectangle.south) * inverseTileHeight;\n      } // Update color to alpha\n\n\n      var colorToAlpha = uniformMapProperties.colorsToAlpha[numberOfDayTextures];\n\n      if (!defined(colorToAlpha)) {\n        colorToAlpha = uniformMapProperties.colorsToAlpha[numberOfDayTextures] = new Cartesian4();\n      }\n\n      var hasColorToAlpha = defined(imageryLayer.colorToAlpha) && imageryLayer.colorToAlphaThreshold > 0.0;\n      applyColorToAlpha = applyColorToAlpha || hasColorToAlpha;\n\n      if (hasColorToAlpha) {\n        var color = imageryLayer.colorToAlpha;\n        colorToAlpha.x = color.red;\n        colorToAlpha.y = color.green;\n        colorToAlpha.z = color.blue;\n        colorToAlpha.w = imageryLayer.colorToAlphaThreshold;\n      } else {\n        colorToAlpha.w = -1.0;\n      }\n\n      if (defined(imagery.credits)) {\n        var credits = imagery.credits;\n\n        for (var creditIndex = 0, creditLength = credits.length; creditIndex < creditLength; ++creditIndex) {\n          creditDisplay.addCredit(credits[creditIndex]);\n        }\n      }\n\n      ++numberOfDayTextures;\n    } // trim texture array to the used length so we don't end up using old textures\n    // which might get destroyed eventually\n\n\n    uniformMapProperties.dayTextures.length = numberOfDayTextures;\n    uniformMapProperties.waterMask = waterMaskTexture;\n    Cartesian4.clone(waterMaskTranslationAndScale, uniformMapProperties.waterMaskTranslationAndScale);\n    uniformMapProperties.minMaxHeight.x = encoding.minimumHeight;\n    uniformMapProperties.minMaxHeight.y = encoding.maximumHeight;\n    Matrix4.clone(encoding.matrix, uniformMapProperties.scaleAndBias); // update clipping planes\n\n    var clippingPlanes = tileProvider._clippingPlanes;\n    var clippingPlanesEnabled = defined(clippingPlanes) && clippingPlanes.enabled && tile.isClipped;\n\n    if (clippingPlanesEnabled) {\n      uniformMapProperties.clippingPlanesEdgeColor = Color.clone(clippingPlanes.edgeColor, uniformMapProperties.clippingPlanesEdgeColor);\n      uniformMapProperties.clippingPlanesEdgeWidth = clippingPlanes.edgeWidth;\n    }\n\n    surfaceShaderSetOptions.numberOfDayTextures = numberOfDayTextures;\n    surfaceShaderSetOptions.applyBrightness = applyBrightness;\n    surfaceShaderSetOptions.applyContrast = applyContrast;\n    surfaceShaderSetOptions.applyHue = applyHue;\n    surfaceShaderSetOptions.applySaturation = applySaturation;\n    surfaceShaderSetOptions.applyGamma = applyGamma;\n    surfaceShaderSetOptions.applyAlpha = applyAlpha;\n    surfaceShaderSetOptions.applyDayNightAlpha = applyDayNightAlpha;\n    surfaceShaderSetOptions.applySplit = applySplit;\n    surfaceShaderSetOptions.enableFog = applyFog;\n    surfaceShaderSetOptions.enableClippingPlanes = clippingPlanesEnabled;\n    surfaceShaderSetOptions.clippingPlanes = clippingPlanes;\n    surfaceShaderSetOptions.hasImageryLayerCutout = applyCutout;\n    surfaceShaderSetOptions.colorCorrect = colorCorrect;\n    surfaceShaderSetOptions.highlightFillTile = highlightFillTile;\n    surfaceShaderSetOptions.colorToAlpha = applyColorToAlpha;\n    surfaceShaderSetOptions.showUndergroundColor = showUndergroundColor;\n    surfaceShaderSetOptions.translucent = translucent;\n    var count = surfaceTile.renderedMesh.indices.length;\n\n    if (!showSkirts) {\n      count = surfaceTile.renderedMesh.indexCountWithoutSkirts;\n    }\n\n    command.shaderProgram = tileProvider._surfaceShaderSet.getShaderProgram(surfaceShaderSetOptions);\n    command.castShadows = castShadows;\n    command.receiveShadows = receiveShadows;\n    command.renderState = renderState;\n    command.primitiveType = PrimitiveType.TRIANGLES;\n    command.vertexArray = surfaceTile.vertexArray || surfaceTile.fill.vertexArray;\n    command.count = count;\n    command.uniformMap = uniformMap;\n    command.pass = Pass.GLOBE;\n\n    if (tileProvider._debug.wireframe) {\n      createWireframeVertexArrayIfNecessary(context, tileProvider, tile);\n\n      if (defined(surfaceTile.wireframeVertexArray)) {\n        command.vertexArray = surfaceTile.wireframeVertexArray;\n        command.primitiveType = PrimitiveType.LINES;\n        command.count = count * 2;\n      }\n    }\n\n    var boundingVolume = command.boundingVolume;\n    var orientedBoundingBox = command.orientedBoundingBox;\n\n    if (frameState.mode !== SceneMode.SCENE3D) {\n      var tileBoundingRegion = surfaceTile.tileBoundingRegion;\n      BoundingSphere.fromRectangleWithHeights2D(tile.rectangle, frameState.mapProjection, tileBoundingRegion.minimumHeight, tileBoundingRegion.maximumHeight, boundingVolume);\n      Cartesian3.fromElements(boundingVolume.center.z, boundingVolume.center.x, boundingVolume.center.y, boundingVolume.center);\n\n      if (frameState.mode === SceneMode.MORPHING) {\n        boundingVolume = BoundingSphere.union(mesh.boundingSphere3D, boundingVolume, boundingVolume);\n      }\n    } else {\n      command.boundingVolume = BoundingSphere.clone(mesh.boundingSphere3D, boundingVolume);\n      command.orientedBoundingBox = OrientedBoundingBox.clone(surfaceTile.orientedBoundingBox, orientedBoundingBox);\n    }\n\n    command.dirty = true;\n\n    if (translucent) {\n      globeTranslucencyState.updateDerivedCommands(command, frameState);\n    }\n\n    pushCommand(command, frameState);\n    renderState = otherPassesRenderState;\n    initialColor = otherPassesInitialColor;\n  } while (imageryIndex < imageryLen);\n}\n\nexport default GlobeSurfaceTileProvider;","map":{"version":3,"sources":["/home/usuario/davi/thalamus/wms/3dmaptestes/leaflet_cesium/client/node_modules/cesium/Source/Scene/GlobeSurfaceTileProvider.js"],"names":["BoundingSphere","BoxOutlineGeometry","Cartesian2","Cartesian3","Cartesian4","Cartographic","clone","Color","ColorGeometryInstanceAttribute","combine","defaultValue","defined","destroyObject","DeveloperError","Event","GeometryInstance","GeometryPipeline","IndexDatatype","Intersect","CesiumMath","Matrix4","NearFarScalar","OrientedBoundingBox","OrthographicFrustum","PrimitiveType","Rectangle","SphereOutlineGeometry","TerrainQuantization","Visibility","WebMercatorProjection","Buffer","BufferUsage","ContextLimits","DrawCommand","Pass","RenderState","VertexArray","BlendingState","ClippingPlaneCollection","DepthFunction","GlobeSurfaceTile","ImageryLayer","ImageryState","PerInstanceColorAppearance","Primitive","QuadtreeTileLoadState","SceneMode","ShadowMode","TerrainFillMesh","TerrainState","TileBoundingRegion","TileSelectionResult","GlobeSurfaceTileProvider","options","terrainProvider","imageryLayers","surfaceShaderSet","lightingFadeOutDistance","lightingFadeInDistance","hasWaterMask","oceanNormalMap","undefined","zoomedOutOceanSpecularIntensity","enableLighting","dynamicAtmosphereLighting","dynamicAtmosphereLightingFromSun","showGroundAtmosphere","shadows","RECEIVE_ONLY","fillHighlightColor","hueShift","saturationShift","brightnessShift","showSkirts","backFaceCulling","undergroundColor","undergroundColorAlphaByDistance","materialUniformMap","_materialUniformMap","_quadtree","_terrainProvider","_imageryLayers","_surfaceShaderSet","_renderState","_blendRenderState","_disableCullingRenderState","_disableCullingBlendRenderState","_errorEvent","layerAdded","addEventListener","prototype","_onLayerAdded","layerRemoved","_onLayerRemoved","layerMoved","_onLayerMoved","layerShownOrHidden","_onLayerShownOrHidden","_imageryLayersUpdatedEvent","_layerOrderChanged","_tilesToRenderByTextureCount","_drawCommands","_uniformMaps","_usedDrawCommands","_vertexArraysToDestroy","_debug","wireframe","boundingSphereTile","_baseColor","_firstPassInitialColor","baseColor","_clippingPlanes","cartographicLimitRectangle","MAX_VALUE","_hasLoadedTilesThisFrame","_hasFillTilesThisFrame","Object","defineProperties","get","set","value","fromColor","quadtree","ready","length","imageryProvider","tilingScheme","errorEvent","imageryLayersUpdatedEvent","invalidateAllTiles","clippingPlanes","setOwner","sortTileImageryByLayerIndex","a","b","aImagery","loadingImagery","readyImagery","bImagery","imageryLayer","_layerIndex","update","frameState","_update","updateCredits","surface","creditDisplay","credit","addCredit","i","len","initialize","queueReprojectionCommands","forEachLoadedTile","tile","data","imagery","sort","vertexArraysToDestroy","j","_freeVertexArray","beginUpdate","tilesToRenderByTextureCount","tiles","enabled","endUpdate","fromCache","cull","depthTest","func","LESS","LESS_OR_EQUAL","blending","ALPHA_BLEND","rs","updateFillTiles","_tilesToRender","textureCountIndex","textureCountLength","tilesToRender","tileIndex","tileLength","tileBoundingRegion","addDrawCommandsForTile","minimumTerrainHeight","Math","min","minimumHeight","pushCommand","command","globeTranslucencyState","translucent","isBlendCommand","renderState","pushDerivedCommands","commandList","push","updateForPick","drawCommands","cancelReprojections","getLevelMaximumGeometricError","level","loadTile","surfaceTile","terrainOnly","terrainStateBefore","boundingVolumeSourceTile","_lastSelectionResult","CULLED_BUT_NEEDED","terrainState","processStateMachine","computeTileVisibility","occluders","NONE","boundingSphereScratch","rectangleIntersectionScratch","splitCartographicLimitRectangleScratch","rectangleCenterScratch","clipRectangleAntimeridian","tileRectangle","west","east","splitRectangle","tileCenter","center","longitude","PI","isUndergroundVisible","tileProvider","cameraUnderground","equals","distance","computeDistanceToTile","_distance","undergroundVisible","fog","density","PARTIAL","cullingVolume","boundingVolume","orientedBoundingBox","renderedMesh","boundingSphere3D","clippedByBoundaries","clippedCartographicLimitRectangle","rectangle","areaLimitIntersection","simpleIntersection","mode","SCENE3D","fromRectangleWithHeights2D","mapProjection","maximumHeight","fromElements","z","x","y","MORPHING","union","planeIntersection","computeIntersectionWithBoundingVolume","isClipped","INSIDE","OUTSIDE","visibility","intersection","computeVisibility","INTERSECTING","FULL","ortho3D","camera","frustum","occludeePointInScaledSpace","ellipsoid","isScaledSpacePointVisiblePossiblyUnderEllipsoid","canRefine","terrainData","childAvailable","getTileDataAvailable","readyImageryScratch","canRenderTraversalStack","canRenderWithoutLosingDetail","terrainReady","initialImageryState","READY","tileImagery","isReady","state","FAILED","INVALID","layerIndex","lastFrame","_lastSelectionFrameNumber","stack","southwestChild","southeastChild","northwestChild","northeastChild","descendant","pop","lastFrameSelectionResult","_lastSelectionResultFrame","RENDERED","descendantSurface","descendantImagery","descendantTileImagery","descendantLoadingImagery","descendantIsReady","descendantLayerIndex","REFINED","tileDirectionScratch","computeTileLoadPriority","obb","cameraPosition","positionWC","cameraDirection","directionWC","tileDirection","subtract","magnitude","EPSILON5","divideByScalar","dot","modifiedModelViewScratch","modifiedModelViewProjectionScratch","tileRectangleScratch","localizedCartographicLimitRectangleScratch","localizedTranslucencyRectangleScratch","rtcScratch","centerEyeScratch","southwestScratch","northeastScratch","showTileThisFrame","readyTextureCount","tileImageryCollection","alpha","tileSet","vertexArray","debug","tilesRendered","texturesRendered","cornerPositionsScratch","computeOccludeePoint","result","ellipsoidalOccluder","_occluders","cornerPositions","fromRadians","south","north","computeHorizonCullingPointPossiblyUnderEllipsoid","heightSource","updateTileBoundingRegion","fromRectangle","max","cameraHeight","positionCartographic","height","distanceToMin","abs","distanceToMax","distanceToCamera","computeBoundingVolumes","mesh","_minimumHeight","_maximumHeight","terrainExaggeration","Number","NaN","ancestor","parent","ancestorSurfaceTile","ancestorMesh","ancestorTerrainData","isDestroyed","destroy","_tileProvider","getTileReadyCallback","tileImageriesToFree","layer","startIndex","endIndex","_createTileImagerySkeletons","freeResources","splice","index","show","that","tileImageryUpdatedEvent","_reload","_imageryCache","_loadedCallbacks","insertionPoint","LOADING","renderable","raiseEvent","numDestroyed","newIndex","oldIndex","scratchClippingPlanesMatrix","scratchInverseTransposeClippingPlanesMatrix","createTileUniformMap","globeSurfaceTileProvider","uniformMap","u_initialColor","properties","initialColor","u_fillHighlightColor","u_zoomedOutOceanSpecularIntensity","u_oceanNormalMap","u_lightingFadeDistance","lightingFadeDistance","u_nightFadeDistance","nightFadeDistance","u_center3D","center3D","u_tileRectangle","u_modifiedModelView","viewMatrix","context","uniformState","view","centerEye","multiplyByPoint","rtc","setTranslation","u_modifiedModelViewProjection","projectionMatrix","projection","multiply","u_dayTextures","dayTextures","u_dayTextureTranslationAndScale","dayTextureTranslationAndScale","u_dayTextureTexCoordsRectangle","dayTextureTexCoordsRectangle","u_dayTextureUseWebMercatorT","dayTextureUseWebMercatorT","u_dayTextureAlpha","dayTextureAlpha","u_dayTextureNightAlpha","dayTextureNightAlpha","u_dayTextureDayAlpha","dayTextureDayAlpha","u_dayTextureBrightness","dayTextureBrightness","u_dayTextureContrast","dayTextureContrast","u_dayTextureHue","dayTextureHue","u_dayTextureSaturation","dayTextureSaturation","u_dayTextureOneOverGamma","dayTextureOneOverGamma","u_dayIntensity","dayIntensity","u_southAndNorthLatitude","southAndNorthLatitude","u_southMercatorYAndOneOverHeight","southMercatorYAndOneOverHeight","u_waterMask","waterMask","u_waterMaskTranslationAndScale","waterMaskTranslationAndScale","u_minMaxHeight","minMaxHeight","u_scaleAndBias","scaleAndBias","u_dayTextureSplit","dayTextureSplit","u_dayTextureCutoutRectangles","dayTextureCutoutRectangles","u_clippingPlanes","texture","defaultTexture","u_cartographicLimitRectangle","localizedCartographicLimitRectangle","u_clippingPlanesMatrix","transform","modelMatrix","IDENTITY","inverseTranspose","u_clippingPlanesEdgeStyle","style","clippingPlanesEdgeColor","clippingPlanesEdgeWidth","u_minimumBrightness","minimumBrightness","u_hsbShift","hsbShift","u_colorsToAlpha","colorsToAlpha","u_frontFaceAlphaByDistance","frontFaceAlphaByDistance","u_backFaceAlphaByDistance","backFaceAlphaByDistance","u_translucencyRectangle","localizedTranslucencyRectangle","u_undergroundColor","u_undergroundColorAlphaByDistance","modifiedModelView","WHITE","TRANSPARENT","createWireframeVertexArrayIfNecessary","provider","fill","wireframeVertexArray","createWireframeVertexArray","terrainMesh","indices","geometry","primitiveType","TRIANGLES","toWireframe","wireframeIndices","wireframeIndexBuffer","createIndexBuffer","typedArray","usage","STATIC_DRAW","indexDatatype","fromSizeInBytes","BYTES_PER_ELEMENT","attributes","_attributes","indexBuffer","getDebugOrientedBoundingBox","getDebugBoundingSphere","debugDestroyPrimitive","instanceOBB","fromDimensions","dimensions","instanceSphere","radius","previousVolume","primitive","createDebugPrimitive","instance","geometryInstances","appearance","flat","asynchronous","color","fromRotationTranslation","halfAxes","sphere","fromTranslation","multiplyByUniformScale","otherPassesInitialColor","surfaceShaderSetOptionsScratch","numberOfDayTextures","applyBrightness","applyContrast","applyHue","applySaturation","applyGamma","applyAlpha","applyDayNightAlpha","applySplit","showReflectiveOcean","showOceanWaves","perFragmentGroundAtmosphere","hasVertexNormals","useWebMercatorProjection","enableFog","enableClippingPlanes","hasImageryLayerCutout","colorCorrect","colorToAlpha","defaultUndergroundColor","defaultundergroundColorAlphaByDistance","credits","tileCredits","tileCreditIndex","tileCreditLength","maxTextures","maximumTextureImageUnits","waterMaskTexture","translucencyRectangle","showUndergroundColor","nearValue","farValue","castShadows","receiveShadows","equalsEpsilon","EPSILON7","cameraDistance","fadeOutDistance","nightFadeOutDistance","shadowState","shadowsEnabled","numberOfTextureUniforms","encoding","southLatitude","northLatitude","southMercatorY","oneOverMercatorHeight","southwest","project","northeast","w","SCENE2D","quantization","BITS12","epsilon","pow","widthEpsilon","heightEpsilon","geodeticLatitudeToMercatorAngle","surfaceShaderSetOptions","imageryIndex","imageryLen","firstPassRenderState","otherPassesRenderState","materialUniformMapChanged","drawCommandsLength","owner","RED","uniformMapProperties","nightFadeInDistance","frontFaceAlphaByDistanceFinal","backFaceAlphaByDistanceFinal","near","far","highlightFillTile","clippedTranslucencyRectangle","cartographicTileRectangle","inverseTileWidth","width","inverseTileHeight","applyFog","EPSILON3","applyCutout","applyColorToAlpha","useWebMercatorT","textureWebMercator","textureTranslationAndScale","_calculateTextureTranslationAndScale","textureCoordinateRectangle","nightAlpha","dayAlpha","brightness","DEFAULT_BRIGHTNESS","contrast","DEFAULT_CONTRAST","hue","DEFAULT_HUE","saturation","DEFAULT_SATURATION","gamma","DEFAULT_GAMMA","splitDirection","dayTextureCutoutRectangle","ZERO","cutoutRectangle","hasColorToAlpha","colorToAlphaThreshold","red","green","blue","creditIndex","creditLength","matrix","clippingPlanesEnabled","edgeColor","edgeWidth","count","indexCountWithoutSkirts","shaderProgram","getShaderProgram","pass","GLOBE","LINES","dirty","updateDerivedCommands"],"mappings":"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","sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport BoxOutlineGeometry from \"../Core/BoxOutlineGeometry.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport ColorGeometryInstanceAttribute from \"../Core/ColorGeometryInstanceAttribute.js\";\nimport combine from \"../Core/combine.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport GeometryInstance from \"../Core/GeometryInstance.js\";\nimport GeometryPipeline from \"../Core/GeometryPipeline.js\";\nimport IndexDatatype from \"../Core/IndexDatatype.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport NearFarScalar from \"../Core/NearFarScalar.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport SphereOutlineGeometry from \"../Core/SphereOutlineGeometry.js\";\nimport TerrainQuantization from \"../Core/TerrainQuantization.js\";\nimport Visibility from \"../Core/Visibility.js\";\nimport WebMercatorProjection from \"../Core/WebMercatorProjection.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport ClippingPlaneCollection from \"./ClippingPlaneCollection.js\";\nimport DepthFunction from \"./DepthFunction.js\";\nimport GlobeSurfaceTile from \"./GlobeSurfaceTile.js\";\nimport ImageryLayer from \"./ImageryLayer.js\";\nimport ImageryState from \"./ImageryState.js\";\nimport PerInstanceColorAppearance from \"./PerInstanceColorAppearance.js\";\nimport Primitive from \"./Primitive.js\";\nimport QuadtreeTileLoadState from \"./QuadtreeTileLoadState.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\nimport TerrainFillMesh from \"./TerrainFillMesh.js\";\nimport TerrainState from \"./TerrainState.js\";\nimport TileBoundingRegion from \"./TileBoundingRegion.js\";\nimport TileSelectionResult from \"./TileSelectionResult.js\";\n\n/**\n * Provides quadtree tiles representing the surface of the globe.  This type is intended to be used\n * with {@link QuadtreePrimitive}.\n *\n * @alias GlobeSurfaceTileProvider\n * @constructor\n *\n * @param {TerrainProvider} options.terrainProvider The terrain provider that describes the surface geometry.\n * @param {ImageryLayerCollection} option.imageryLayers The collection of imagery layers describing the shading of the surface.\n * @param {GlobeSurfaceShaderSet} options.surfaceShaderSet The set of shaders used to render the surface.\n *\n * @private\n */\nfunction GlobeSurfaceTileProvider(options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(options)) {\n    throw new DeveloperError(\"options is required.\");\n  }\n  if (!defined(options.terrainProvider)) {\n    throw new DeveloperError(\"options.terrainProvider is required.\");\n  } else if (!defined(options.imageryLayers)) {\n    throw new DeveloperError(\"options.imageryLayers is required.\");\n  } else if (!defined(options.surfaceShaderSet)) {\n    throw new DeveloperError(\"options.surfaceShaderSet is required.\");\n  }\n  //>>includeEnd('debug');\n\n  this.lightingFadeOutDistance = 6500000.0;\n  this.lightingFadeInDistance = 9000000.0;\n  this.hasWaterMask = false;\n  this.oceanNormalMap = undefined;\n  this.zoomedOutOceanSpecularIntensity = 0.5;\n  this.enableLighting = false;\n  this.dynamicAtmosphereLighting = false;\n  this.dynamicAtmosphereLightingFromSun = false;\n  this.showGroundAtmosphere = false;\n  this.shadows = ShadowMode.RECEIVE_ONLY;\n\n  /**\n   * The color to use to highlight terrain fill tiles. If undefined, fill tiles are not\n   * highlighted at all. The alpha value is used to alpha blend with the tile's\n   * actual color. Because terrain fill tiles do not represent the actual terrain surface,\n   * it may be useful in some applications to indicate visually that they are not to be trusted.\n   * @type {Color}\n   * @default undefined\n   */\n  this.fillHighlightColor = undefined;\n\n  this.hueShift = 0.0;\n  this.saturationShift = 0.0;\n  this.brightnessShift = 0.0;\n\n  this.showSkirts = true;\n  this.backFaceCulling = true;\n  this.undergroundColor = undefined;\n  this.undergroundColorAlphaByDistance = undefined;\n\n  this.materialUniformMap = undefined;\n  this._materialUniformMap = undefined;\n\n  this._quadtree = undefined;\n  this._terrainProvider = options.terrainProvider;\n  this._imageryLayers = options.imageryLayers;\n  this._surfaceShaderSet = options.surfaceShaderSet;\n\n  this._renderState = undefined;\n  this._blendRenderState = undefined;\n  this._disableCullingRenderState = undefined;\n  this._disableCullingBlendRenderState = undefined;\n\n  this._errorEvent = new Event();\n\n  this._imageryLayers.layerAdded.addEventListener(\n    GlobeSurfaceTileProvider.prototype._onLayerAdded,\n    this\n  );\n  this._imageryLayers.layerRemoved.addEventListener(\n    GlobeSurfaceTileProvider.prototype._onLayerRemoved,\n    this\n  );\n  this._imageryLayers.layerMoved.addEventListener(\n    GlobeSurfaceTileProvider.prototype._onLayerMoved,\n    this\n  );\n  this._imageryLayers.layerShownOrHidden.addEventListener(\n    GlobeSurfaceTileProvider.prototype._onLayerShownOrHidden,\n    this\n  );\n  this._imageryLayersUpdatedEvent = new Event();\n\n  this._layerOrderChanged = false;\n\n  this._tilesToRenderByTextureCount = [];\n  this._drawCommands = [];\n  this._uniformMaps = [];\n  this._usedDrawCommands = 0;\n\n  this._vertexArraysToDestroy = [];\n\n  this._debug = {\n    wireframe: false,\n    boundingSphereTile: undefined,\n  };\n\n  this._baseColor = undefined;\n  this._firstPassInitialColor = undefined;\n  this.baseColor = new Color(0.0, 0.0, 0.5, 1.0);\n\n  /**\n   * A property specifying a {@link ClippingPlaneCollection} used to selectively disable rendering on the outside of each plane.\n   * @type {ClippingPlaneCollection}\n   * @private\n   */\n  this._clippingPlanes = undefined;\n\n  /**\n   * A property specifying a {@link Rectangle} used to selectively limit terrain and imagery rendering.\n   * @type {Rectangle}\n   */\n  this.cartographicLimitRectangle = Rectangle.clone(Rectangle.MAX_VALUE);\n\n  this._hasLoadedTilesThisFrame = false;\n  this._hasFillTilesThisFrame = false;\n}\n\nObject.defineProperties(GlobeSurfaceTileProvider.prototype, {\n  /**\n   * Gets or sets the color of the globe when no imagery is available.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {Color}\n   */\n  baseColor: {\n    get: function () {\n      return this._baseColor;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      this._baseColor = value;\n      this._firstPassInitialColor = Cartesian4.fromColor(\n        value,\n        this._firstPassInitialColor\n      );\n    },\n  },\n  /**\n   * Gets or sets the {@link QuadtreePrimitive} for which this provider is\n   * providing tiles.  This property may be undefined if the provider is not yet associated\n   * with a {@link QuadtreePrimitive}.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {QuadtreePrimitive}\n   */\n  quadtree: {\n    get: function () {\n      return this._quadtree;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value is required.\");\n      }\n      //>>includeEnd('debug');\n\n      this._quadtree = value;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider is ready for use.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {Boolean}\n   */\n  ready: {\n    get: function () {\n      return (\n        this._terrainProvider.ready &&\n        (this._imageryLayers.length === 0 ||\n          this._imageryLayers.get(0).imageryProvider.ready)\n      );\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by the provider.  This property should\n   * not be accessed before {@link GlobeSurfaceTileProvider#ready} returns true.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {TilingScheme}\n   */\n  tilingScheme: {\n    get: function () {\n      return this._terrainProvider.tilingScheme;\n    },\n  },\n\n  /**\n   * Gets an event that is raised when the geometry provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {Event}\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    },\n  },\n\n  /**\n   * Gets an event that is raised when an imagery layer is added, shown, hidden, moved, or removed.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {Event}\n   */\n  imageryLayersUpdatedEvent: {\n    get: function () {\n      return this._imageryLayersUpdatedEvent;\n    },\n  },\n\n  /**\n   * Gets or sets the terrain provider that describes the surface geometry.\n   * @memberof GlobeSurfaceTileProvider.prototype\n   * @type {TerrainProvider}\n   */\n  terrainProvider: {\n    get: function () {\n      return this._terrainProvider;\n    },\n    set: function (terrainProvider) {\n      if (this._terrainProvider === terrainProvider) {\n        return;\n      }\n\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(terrainProvider)) {\n        throw new DeveloperError(\"terrainProvider is required.\");\n      }\n      //>>includeEnd('debug');\n\n      this._terrainProvider = terrainProvider;\n\n      if (defined(this._quadtree)) {\n        this._quadtree.invalidateAllTiles();\n      }\n    },\n  },\n  /**\n   * The {@link ClippingPlaneCollection} used to selectively disable rendering the tileset.\n   *\n   * @type {ClippingPlaneCollection}\n   *\n   * @private\n   */\n  clippingPlanes: {\n    get: function () {\n      return this._clippingPlanes;\n    },\n    set: function (value) {\n      ClippingPlaneCollection.setOwner(value, this, \"_clippingPlanes\");\n    },\n  },\n});\n\nfunction sortTileImageryByLayerIndex(a, b) {\n  var aImagery = a.loadingImagery;\n  if (!defined(aImagery)) {\n    aImagery = a.readyImagery;\n  }\n\n  var bImagery = b.loadingImagery;\n  if (!defined(bImagery)) {\n    bImagery = b.readyImagery;\n  }\n\n  return aImagery.imageryLayer._layerIndex - bImagery.imageryLayer._layerIndex;\n}\n\n/**\n * Make updates to the tile provider that are not involved in rendering. Called before the render update cycle.\n */\nGlobeSurfaceTileProvider.prototype.update = function (frameState) {\n  // update collection: imagery indices, base layers, raise layer show/hide event\n  this._imageryLayers._update();\n};\n\nfunction updateCredits(surface, frameState) {\n  var creditDisplay = frameState.creditDisplay;\n  if (\n    surface._terrainProvider.ready &&\n    defined(surface._terrainProvider.credit)\n  ) {\n    creditDisplay.addCredit(surface._terrainProvider.credit);\n  }\n\n  var imageryLayers = surface._imageryLayers;\n  for (var i = 0, len = imageryLayers.length; i < len; ++i) {\n    var imageryProvider = imageryLayers.get(i).imageryProvider;\n    if (imageryProvider.ready && defined(imageryProvider.credit)) {\n      creditDisplay.addCredit(imageryProvider.credit);\n    }\n  }\n}\n\n/**\n * Called at the beginning of each render frame, before {@link QuadtreeTileProvider#showTileThisFrame}\n * @param {FrameState} frameState The frame state.\n */\nGlobeSurfaceTileProvider.prototype.initialize = function (frameState) {\n  // update each layer for texture reprojection.\n  this._imageryLayers.queueReprojectionCommands(frameState);\n\n  if (this._layerOrderChanged) {\n    this._layerOrderChanged = false;\n\n    // Sort the TileImagery instances in each tile by the layer index.\n    this._quadtree.forEachLoadedTile(function (tile) {\n      tile.data.imagery.sort(sortTileImageryByLayerIndex);\n    });\n  }\n\n  // Add credits for terrain and imagery providers.\n  updateCredits(this, frameState);\n\n  var vertexArraysToDestroy = this._vertexArraysToDestroy;\n  var length = vertexArraysToDestroy.length;\n  for (var j = 0; j < length; ++j) {\n    GlobeSurfaceTile._freeVertexArray(vertexArraysToDestroy[j]);\n  }\n  vertexArraysToDestroy.length = 0;\n};\n\n/**\n * Called at the beginning of the update cycle for each render frame, before {@link QuadtreeTileProvider#showTileThisFrame}\n * or any other functions.\n *\n * @param {FrameState} frameState The frame state.\n */\nGlobeSurfaceTileProvider.prototype.beginUpdate = function (frameState) {\n  var tilesToRenderByTextureCount = this._tilesToRenderByTextureCount;\n  for (var i = 0, len = tilesToRenderByTextureCount.length; i < len; ++i) {\n    var tiles = tilesToRenderByTextureCount[i];\n    if (defined(tiles)) {\n      tiles.length = 0;\n    }\n  }\n  // update clipping planes\n  var clippingPlanes = this._clippingPlanes;\n  if (defined(clippingPlanes) && clippingPlanes.enabled) {\n    clippingPlanes.update(frameState);\n  }\n  this._usedDrawCommands = 0;\n\n  this._hasLoadedTilesThisFrame = false;\n  this._hasFillTilesThisFrame = false;\n};\n\n/**\n * Called at the end of the update cycle for each render frame, after {@link QuadtreeTileProvider#showTileThisFrame}\n * and any other functions.\n *\n * @param {FrameState} frameState The frame state.\n */\nGlobeSurfaceTileProvider.prototype.endUpdate = function (frameState) {\n  if (!defined(this._renderState)) {\n    this._renderState = RenderState.fromCache({\n      // Write color and depth\n      cull: {\n        enabled: true,\n      },\n      depthTest: {\n        enabled: true,\n        func: DepthFunction.LESS,\n      },\n    });\n\n    this._blendRenderState = RenderState.fromCache({\n      // Write color and depth\n      cull: {\n        enabled: true,\n      },\n      depthTest: {\n        enabled: true,\n        func: DepthFunction.LESS_OR_EQUAL,\n      },\n      blending: BlendingState.ALPHA_BLEND,\n    });\n\n    var rs = clone(this._renderState, true);\n    rs.cull.enabled = false;\n    this._disableCullingRenderState = RenderState.fromCache(rs);\n\n    rs = clone(this._blendRenderState, true);\n    rs.cull.enabled = false;\n    this._disableCullingBlendRenderState = RenderState.fromCache(rs);\n  }\n\n  // If this frame has a mix of loaded and fill tiles, we need to propagate\n  // loaded heights to the fill tiles.\n  if (this._hasFillTilesThisFrame && this._hasLoadedTilesThisFrame) {\n    TerrainFillMesh.updateFillTiles(\n      this,\n      this._quadtree._tilesToRender,\n      frameState,\n      this._vertexArraysToDestroy\n    );\n  }\n\n  // Add the tile render commands to the command list, sorted by texture count.\n  var tilesToRenderByTextureCount = this._tilesToRenderByTextureCount;\n  for (\n    var textureCountIndex = 0,\n      textureCountLength = tilesToRenderByTextureCount.length;\n    textureCountIndex < textureCountLength;\n    ++textureCountIndex\n  ) {\n    var tilesToRender = tilesToRenderByTextureCount[textureCountIndex];\n    if (!defined(tilesToRender)) {\n      continue;\n    }\n\n    for (\n      var tileIndex = 0, tileLength = tilesToRender.length;\n      tileIndex < tileLength;\n      ++tileIndex\n    ) {\n      var tile = tilesToRender[tileIndex];\n      var tileBoundingRegion = tile.data.tileBoundingRegion;\n      addDrawCommandsForTile(this, tile, frameState);\n      frameState.minimumTerrainHeight = Math.min(\n        frameState.minimumTerrainHeight,\n        tileBoundingRegion.minimumHeight\n      );\n    }\n  }\n};\n\nfunction pushCommand(command, frameState) {\n  var globeTranslucencyState = frameState.globeTranslucencyState;\n  if (globeTranslucencyState.translucent) {\n    var isBlendCommand = command.renderState.blending.enabled;\n    globeTranslucencyState.pushDerivedCommands(\n      command,\n      isBlendCommand,\n      frameState\n    );\n  } else {\n    frameState.commandList.push(command);\n  }\n}\n\n/**\n * Adds draw commands for tiles rendered in the previous frame for a pick pass.\n *\n * @param {FrameState} frameState The frame state.\n */\nGlobeSurfaceTileProvider.prototype.updateForPick = function (frameState) {\n  // Add the tile pick commands from the tiles drawn last frame.\n  var drawCommands = this._drawCommands;\n  for (var i = 0, length = this._usedDrawCommands; i < length; ++i) {\n    pushCommand(drawCommands[i], frameState);\n  }\n};\n\n/**\n * Cancels any imagery re-projections in the queue.\n */\nGlobeSurfaceTileProvider.prototype.cancelReprojections = function () {\n  this._imageryLayers.cancelReprojections();\n};\n\n/**\n * Gets the maximum geometric error allowed in a tile at a given level, in meters.  This function should not be\n * called before {@link GlobeSurfaceTileProvider#ready} returns true.\n *\n * @param {Number} level The tile level for which to get the maximum geometric error.\n * @returns {Number} The maximum geometric error in meters.\n */\nGlobeSurfaceTileProvider.prototype.getLevelMaximumGeometricError = function (\n  level\n) {\n  return this._terrainProvider.getLevelMaximumGeometricError(level);\n};\n\n/**\n * Loads, or continues loading, a given tile.  This function will continue to be called\n * until {@link QuadtreeTile#state} is no longer {@link QuadtreeTileLoadState#LOADING}.  This function should\n * not be called before {@link GlobeSurfaceTileProvider#ready} returns true.\n *\n * @param {FrameState} frameState The frame state.\n * @param {QuadtreeTile} tile The tile to load.\n *\n * @exception {DeveloperError} <code>loadTile</code> must not be called before the tile provider is ready.\n */\nGlobeSurfaceTileProvider.prototype.loadTile = function (frameState, tile) {\n  // We don't want to load imagery until we're certain that the terrain tiles are actually visible.\n  // So if our bounding volume isn't accurate because it came from another tile, load terrain only\n  // initially. If we load some terrain and suddenly have a more accurate bounding volume and the\n  // tile is _still_ visible, give the tile a chance to load imagery immediately rather than\n  // waiting for next frame.\n\n  var surfaceTile = tile.data;\n  var terrainOnly = true;\n  var terrainStateBefore;\n  if (defined(surfaceTile)) {\n    terrainOnly =\n      surfaceTile.boundingVolumeSourceTile !== tile ||\n      tile._lastSelectionResult === TileSelectionResult.CULLED_BUT_NEEDED;\n    terrainStateBefore = surfaceTile.terrainState;\n  }\n\n  GlobeSurfaceTile.processStateMachine(\n    tile,\n    frameState,\n    this.terrainProvider,\n    this._imageryLayers,\n    this._vertexArraysToDestroy,\n    terrainOnly\n  );\n\n  surfaceTile = tile.data;\n  if (terrainOnly && terrainStateBefore !== tile.data.terrainState) {\n    // Terrain state changed. If:\n    // a) The tile is visible, and\n    // b) The bounding volume is accurate (updated as a side effect of computing visibility)\n    // Then we'll load imagery, too.\n    if (\n      this.computeTileVisibility(tile, frameState, this.quadtree.occluders) !==\n        Visibility.NONE &&\n      surfaceTile.boundingVolumeSourceTile === tile\n    ) {\n      terrainOnly = false;\n      GlobeSurfaceTile.processStateMachine(\n        tile,\n        frameState,\n        this.terrainProvider,\n        this._imageryLayers,\n        this._vertexArraysToDestroy,\n        terrainOnly\n      );\n    }\n  }\n};\n\nvar boundingSphereScratch = new BoundingSphere();\nvar rectangleIntersectionScratch = new Rectangle();\nvar splitCartographicLimitRectangleScratch = new Rectangle();\nvar rectangleCenterScratch = new Cartographic();\n\n// cartographicLimitRectangle may span the IDL, but tiles never will.\nfunction clipRectangleAntimeridian(tileRectangle, cartographicLimitRectangle) {\n  if (cartographicLimitRectangle.west < cartographicLimitRectangle.east) {\n    return cartographicLimitRectangle;\n  }\n  var splitRectangle = Rectangle.clone(\n    cartographicLimitRectangle,\n    splitCartographicLimitRectangleScratch\n  );\n  var tileCenter = Rectangle.center(tileRectangle, rectangleCenterScratch);\n  if (tileCenter.longitude > 0.0) {\n    splitRectangle.east = CesiumMath.PI;\n  } else {\n    splitRectangle.west = -CesiumMath.PI;\n  }\n  return splitRectangle;\n}\n\nfunction isUndergroundVisible(tileProvider, frameState) {\n  if (frameState.cameraUnderground) {\n    return true;\n  }\n\n  if (frameState.globeTranslucencyState.translucent) {\n    return true;\n  }\n\n  if (tileProvider.backFaceCulling) {\n    return false;\n  }\n\n  var clippingPlanes = tileProvider._clippingPlanes;\n  if (defined(clippingPlanes) && clippingPlanes.enabled) {\n    return true;\n  }\n\n  if (\n    !Rectangle.equals(\n      tileProvider.cartographicLimitRectangle,\n      Rectangle.MAX_VALUE\n    )\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Determines the visibility of a given tile.  The tile may be fully visible, partially visible, or not\n * visible at all.  Tiles that are renderable and are at least partially visible will be shown by a call\n * to {@link GlobeSurfaceTileProvider#showTileThisFrame}.\n *\n * @param {QuadtreeTile} tile The tile instance.\n * @param {FrameState} frameState The state information about the current frame.\n * @param {QuadtreeOccluders} occluders The objects that may occlude this tile.\n *\n * @returns {Visibility} Visibility.NONE if the tile is not visible,\n *                       Visibility.PARTIAL if the tile is partially visible, or\n *                       Visibility.FULL if the tile is fully visible.\n */\nGlobeSurfaceTileProvider.prototype.computeTileVisibility = function (\n  tile,\n  frameState,\n  occluders\n) {\n  var distance = this.computeDistanceToTile(tile, frameState);\n  tile._distance = distance;\n\n  var undergroundVisible = isUndergroundVisible(this, frameState);\n\n  if (frameState.fog.enabled && !undergroundVisible) {\n    if (CesiumMath.fog(distance, frameState.fog.density) >= 1.0) {\n      // Tile is completely in fog so return that it is not visible.\n      return Visibility.NONE;\n    }\n  }\n\n  var surfaceTile = tile.data;\n  var tileBoundingRegion = surfaceTile.tileBoundingRegion;\n\n  if (surfaceTile.boundingVolumeSourceTile === undefined) {\n    // We have no idea where this tile is, so let's just call it partially visible.\n    return Visibility.PARTIAL;\n  }\n\n  var cullingVolume = frameState.cullingVolume;\n  var boundingVolume = surfaceTile.orientedBoundingBox;\n\n  if (!defined(boundingVolume) && defined(surfaceTile.renderedMesh)) {\n    boundingVolume = surfaceTile.renderedMesh.boundingSphere3D;\n  }\n\n  // Check if the tile is outside the limit area in cartographic space\n  surfaceTile.clippedByBoundaries = false;\n  var clippedCartographicLimitRectangle = clipRectangleAntimeridian(\n    tile.rectangle,\n    this.cartographicLimitRectangle\n  );\n  var areaLimitIntersection = Rectangle.simpleIntersection(\n    clippedCartographicLimitRectangle,\n    tile.rectangle,\n    rectangleIntersectionScratch\n  );\n  if (!defined(areaLimitIntersection)) {\n    return Visibility.NONE;\n  }\n  if (!Rectangle.equals(areaLimitIntersection, tile.rectangle)) {\n    surfaceTile.clippedByBoundaries = true;\n  }\n\n  if (frameState.mode !== SceneMode.SCENE3D) {\n    boundingVolume = boundingSphereScratch;\n    BoundingSphere.fromRectangleWithHeights2D(\n      tile.rectangle,\n      frameState.mapProjection,\n      tileBoundingRegion.minimumHeight,\n      tileBoundingRegion.maximumHeight,\n      boundingVolume\n    );\n    Cartesian3.fromElements(\n      boundingVolume.center.z,\n      boundingVolume.center.x,\n      boundingVolume.center.y,\n      boundingVolume.center\n    );\n\n    if (\n      frameState.mode === SceneMode.MORPHING &&\n      defined(surfaceTile.renderedMesh)\n    ) {\n      boundingVolume = BoundingSphere.union(\n        surfaceTile.renderedMesh.boundingSphere3D,\n        boundingVolume,\n        boundingVolume\n      );\n    }\n  }\n\n  if (!defined(boundingVolume)) {\n    return Visibility.PARTIAL;\n  }\n\n  var clippingPlanes = this._clippingPlanes;\n  if (defined(clippingPlanes) && clippingPlanes.enabled) {\n    var planeIntersection = clippingPlanes.computeIntersectionWithBoundingVolume(\n      boundingVolume\n    );\n    tile.isClipped = planeIntersection !== Intersect.INSIDE;\n    if (planeIntersection === Intersect.OUTSIDE) {\n      return Visibility.NONE;\n    }\n  }\n\n  var visibility;\n  var intersection = cullingVolume.computeVisibility(boundingVolume);\n\n  if (intersection === Intersect.OUTSIDE) {\n    visibility = Visibility.NONE;\n  } else if (intersection === Intersect.INTERSECTING) {\n    visibility = Visibility.PARTIAL;\n  } else if (intersection === Intersect.INSIDE) {\n    visibility = Visibility.FULL;\n  }\n\n  if (visibility === Visibility.NONE) {\n    return visibility;\n  }\n\n  var ortho3D =\n    frameState.mode === SceneMode.SCENE3D &&\n    frameState.camera.frustum instanceof OrthographicFrustum;\n  if (\n    frameState.mode === SceneMode.SCENE3D &&\n    !ortho3D &&\n    defined(occluders) &&\n    !undergroundVisible\n  ) {\n    var occludeePointInScaledSpace = surfaceTile.occludeePointInScaledSpace;\n    if (!defined(occludeePointInScaledSpace)) {\n      return visibility;\n    }\n\n    if (\n      occluders.ellipsoid.isScaledSpacePointVisiblePossiblyUnderEllipsoid(\n        occludeePointInScaledSpace,\n        tileBoundingRegion.minimumHeight\n      )\n    ) {\n      return visibility;\n    }\n\n    return Visibility.NONE;\n  }\n\n  return visibility;\n};\n\n/**\n * Determines if the given tile can be refined\n * @param {QuadtreeTile} tile The tile to check.\n * @returns {boolean} True if the tile can be refined, false if it cannot.\n */\nGlobeSurfaceTileProvider.prototype.canRefine = function (tile) {\n  // Only allow refinement it we know whether or not the children of this tile exist.\n  // For a tileset with `availability`, we'll always be able to refine.\n  // We can ask for availability of _any_ child tile because we only need to confirm\n  // that we get a yes or no answer, it doesn't matter what the answer is.\n  if (defined(tile.data.terrainData)) {\n    return true;\n  }\n  var childAvailable = this.terrainProvider.getTileDataAvailable(\n    tile.x * 2,\n    tile.y * 2,\n    tile.level + 1\n  );\n  return childAvailable !== undefined;\n};\n\nvar readyImageryScratch = [];\nvar canRenderTraversalStack = [];\n\n/**\n * Determines if the given not-fully-loaded tile can be rendered without losing detail that\n * was present last frame as a result of rendering descendant tiles. This method will only be\n * called if this tile's descendants were rendered last frame. If the tile is fully loaded,\n * it is assumed that this method will return true and it will not be called.\n * @param {QuadtreeTile} tile The tile to check.\n * @returns {boolean} True if the tile can be rendered without losing detail.\n */\nGlobeSurfaceTileProvider.prototype.canRenderWithoutLosingDetail = function (\n  tile,\n  frameState\n) {\n  var surfaceTile = tile.data;\n\n  var readyImagery = readyImageryScratch;\n  readyImagery.length = this._imageryLayers.length;\n\n  var terrainReady = false;\n  var initialImageryState = false;\n  var imagery;\n\n  if (defined(surfaceTile)) {\n    // We can render even with non-ready terrain as long as all our rendered descendants\n    // are missing terrain geometry too. i.e. if we rendered fills for more detailed tiles\n    // last frame, it's ok to render a fill for this tile this frame.\n    terrainReady = surfaceTile.terrainState === TerrainState.READY;\n\n    // Initially assume all imagery layers are ready, unless imagery hasn't been initialized at all.\n    initialImageryState = true;\n\n    imagery = surfaceTile.imagery;\n  }\n\n  var i;\n  var len;\n\n  for (i = 0, len = readyImagery.length; i < len; ++i) {\n    readyImagery[i] = initialImageryState;\n  }\n\n  if (defined(imagery)) {\n    for (i = 0, len = imagery.length; i < len; ++i) {\n      var tileImagery = imagery[i];\n      var loadingImagery = tileImagery.loadingImagery;\n      var isReady =\n        !defined(loadingImagery) ||\n        loadingImagery.state === ImageryState.FAILED ||\n        loadingImagery.state === ImageryState.INVALID;\n      var layerIndex = (tileImagery.loadingImagery || tileImagery.readyImagery)\n        .imageryLayer._layerIndex;\n\n      // For a layer to be ready, all tiles belonging to that layer must be ready.\n      readyImagery[layerIndex] = isReady && readyImagery[layerIndex];\n    }\n  }\n\n  var lastFrame = this.quadtree._lastSelectionFrameNumber;\n\n  // Traverse the descendants looking for one with terrain or imagery that is not loaded on this tile.\n  var stack = canRenderTraversalStack;\n  stack.length = 0;\n  stack.push(\n    tile.southwestChild,\n    tile.southeastChild,\n    tile.northwestChild,\n    tile.northeastChild\n  );\n\n  while (stack.length > 0) {\n    var descendant = stack.pop();\n    var lastFrameSelectionResult =\n      descendant._lastSelectionResultFrame === lastFrame\n        ? descendant._lastSelectionResult\n        : TileSelectionResult.NONE;\n\n    if (lastFrameSelectionResult === TileSelectionResult.RENDERED) {\n      var descendantSurface = descendant.data;\n\n      if (!defined(descendantSurface)) {\n        // Descendant has no data, so it can't block rendering.\n        continue;\n      }\n\n      if (\n        !terrainReady &&\n        descendant.data.terrainState === TerrainState.READY\n      ) {\n        // Rendered descendant has real terrain, but we don't. Rendering is blocked.\n        return false;\n      }\n\n      var descendantImagery = descendant.data.imagery;\n      for (i = 0, len = descendantImagery.length; i < len; ++i) {\n        var descendantTileImagery = descendantImagery[i];\n        var descendantLoadingImagery = descendantTileImagery.loadingImagery;\n        var descendantIsReady =\n          !defined(descendantLoadingImagery) ||\n          descendantLoadingImagery.state === ImageryState.FAILED ||\n          descendantLoadingImagery.state === ImageryState.INVALID;\n        var descendantLayerIndex = (\n          descendantTileImagery.loadingImagery ||\n          descendantTileImagery.readyImagery\n        ).imageryLayer._layerIndex;\n\n        // If this imagery tile of a descendant is ready but the layer isn't ready in this tile,\n        // then rendering is blocked.\n        if (descendantIsReady && !readyImagery[descendantLayerIndex]) {\n          return false;\n        }\n      }\n    } else if (lastFrameSelectionResult === TileSelectionResult.REFINED) {\n      stack.push(\n        descendant.southwestChild,\n        descendant.southeastChild,\n        descendant.northwestChild,\n        descendant.northeastChild\n      );\n    }\n  }\n\n  return true;\n};\n\nvar tileDirectionScratch = new Cartesian3();\n\n/**\n * Determines the priority for loading this tile. Lower priority values load sooner.\n * @param {QuadtreeTile} tile The tile.\n * @param {FrameState} frameState The frame state.\n * @returns {Number} The load priority value.\n */\nGlobeSurfaceTileProvider.prototype.computeTileLoadPriority = function (\n  tile,\n  frameState\n) {\n  var surfaceTile = tile.data;\n  if (surfaceTile === undefined) {\n    return 0.0;\n  }\n\n  var obb = surfaceTile.orientedBoundingBox;\n  if (obb === undefined) {\n    return 0.0;\n  }\n\n  var cameraPosition = frameState.camera.positionWC;\n  var cameraDirection = frameState.camera.directionWC;\n  var tileDirection = Cartesian3.subtract(\n    obb.center,\n    cameraPosition,\n    tileDirectionScratch\n  );\n  var magnitude = Cartesian3.magnitude(tileDirection);\n  if (magnitude < CesiumMath.EPSILON5) {\n    return 0.0;\n  }\n  Cartesian3.divideByScalar(tileDirection, magnitude, tileDirection);\n  return (\n    (1.0 - Cartesian3.dot(tileDirection, cameraDirection)) * tile._distance\n  );\n};\n\nvar modifiedModelViewScratch = new Matrix4();\nvar modifiedModelViewProjectionScratch = new Matrix4();\nvar tileRectangleScratch = new Cartesian4();\nvar localizedCartographicLimitRectangleScratch = new Cartesian4();\nvar localizedTranslucencyRectangleScratch = new Cartesian4();\nvar rtcScratch = new Cartesian3();\nvar centerEyeScratch = new Cartesian3();\nvar southwestScratch = new Cartesian3();\nvar northeastScratch = new Cartesian3();\n\n/**\n * Shows a specified tile in this frame.  The provider can cause the tile to be shown by adding\n * render commands to the commandList, or use any other method as appropriate.  The tile is not\n * expected to be visible next frame as well, unless this method is called next frame, too.\n *\n * @param {QuadtreeTile} tile The tile instance.\n * @param {FrameState} frameState The state information of the current rendering frame.\n */\nGlobeSurfaceTileProvider.prototype.showTileThisFrame = function (\n  tile,\n  frameState\n) {\n  var readyTextureCount = 0;\n  var tileImageryCollection = tile.data.imagery;\n  for (var i = 0, len = tileImageryCollection.length; i < len; ++i) {\n    var tileImagery = tileImageryCollection[i];\n    if (\n      defined(tileImagery.readyImagery) &&\n      tileImagery.readyImagery.imageryLayer.alpha !== 0.0\n    ) {\n      ++readyTextureCount;\n    }\n  }\n\n  var tileSet = this._tilesToRenderByTextureCount[readyTextureCount];\n  if (!defined(tileSet)) {\n    tileSet = [];\n    this._tilesToRenderByTextureCount[readyTextureCount] = tileSet;\n  }\n\n  tileSet.push(tile);\n\n  var surfaceTile = tile.data;\n  if (!defined(surfaceTile.vertexArray)) {\n    this._hasFillTilesThisFrame = true;\n  } else {\n    this._hasLoadedTilesThisFrame = true;\n  }\n\n  var debug = this._debug;\n  ++debug.tilesRendered;\n  debug.texturesRendered += readyTextureCount;\n};\n\nvar cornerPositionsScratch = [\n  new Cartesian3(),\n  new Cartesian3(),\n  new Cartesian3(),\n  new Cartesian3(),\n];\n\nfunction computeOccludeePoint(\n  tileProvider,\n  center,\n  rectangle,\n  minimumHeight,\n  maximumHeight,\n  result\n) {\n  var ellipsoidalOccluder = tileProvider.quadtree._occluders.ellipsoid;\n  var ellipsoid = ellipsoidalOccluder.ellipsoid;\n\n  var cornerPositions = cornerPositionsScratch;\n  Cartesian3.fromRadians(\n    rectangle.west,\n    rectangle.south,\n    maximumHeight,\n    ellipsoid,\n    cornerPositions[0]\n  );\n  Cartesian3.fromRadians(\n    rectangle.east,\n    rectangle.south,\n    maximumHeight,\n    ellipsoid,\n    cornerPositions[1]\n  );\n  Cartesian3.fromRadians(\n    rectangle.west,\n    rectangle.north,\n    maximumHeight,\n    ellipsoid,\n    cornerPositions[2]\n  );\n  Cartesian3.fromRadians(\n    rectangle.east,\n    rectangle.north,\n    maximumHeight,\n    ellipsoid,\n    cornerPositions[3]\n  );\n\n  return ellipsoidalOccluder.computeHorizonCullingPointPossiblyUnderEllipsoid(\n    center,\n    cornerPositions,\n    minimumHeight,\n    result\n  );\n}\n\n/**\n * Gets the distance from the camera to the closest point on the tile.  This is used for level-of-detail selection.\n *\n * @param {QuadtreeTile} tile The tile instance.\n * @param {FrameState} frameState The state information of the current rendering frame.\n *\n * @returns {Number} The distance from the camera to the closest point on the tile, in meters.\n */\nGlobeSurfaceTileProvider.prototype.computeDistanceToTile = function (\n  tile,\n  frameState\n) {\n  // The distance should be:\n  // 1. the actual distance to the tight-fitting bounding volume, or\n  // 2. a distance that is equal to or greater than the actual distance to the tight-fitting bounding volume.\n  //\n  // When we don't know the min/max heights for a tile, but we do know the min/max of an ancestor tile, we can\n  // build a tight-fitting bounding volume horizontally, but not vertically. The min/max heights from the\n  // ancestor will likely form a volume that is much bigger than it needs to be. This means that the volume may\n  // be deemed to be much closer to the camera than it really is, causing us to select tiles that are too detailed.\n  // Loading too-detailed tiles is super expensive, so we don't want to do that. We don't know where the child\n  // tile really lies within the parent range of heights, but we _do_ know the child tile can't be any closer than\n  // the ancestor height surface (min or max) that is _farthest away_ from the camera. So if we compute distance\n  // based that conservative metric, we may end up loading tiles that are not detailed enough, but that's much\n  // better (faster) than loading tiles that are too detailed.\n\n  var heightSource = updateTileBoundingRegion(\n    tile,\n    this.terrainProvider,\n    frameState\n  );\n  var surfaceTile = tile.data;\n  var tileBoundingRegion = surfaceTile.tileBoundingRegion;\n\n  if (heightSource === undefined) {\n    // Can't find any min/max heights anywhere? Ok, let's just say the\n    // tile is really far away so we'll load and render it rather than\n    // refining.\n    return 9999999999.0;\n  } else if (surfaceTile.boundingVolumeSourceTile !== heightSource) {\n    // Heights are from a new source tile, so update the bounding volume.\n    surfaceTile.boundingVolumeSourceTile = heightSource;\n\n    var rectangle = tile.rectangle;\n    if (defined(rectangle)) {\n      surfaceTile.orientedBoundingBox = OrientedBoundingBox.fromRectangle(\n        tile.rectangle,\n        tileBoundingRegion.minimumHeight,\n        tileBoundingRegion.maximumHeight,\n        tile.tilingScheme.ellipsoid,\n        surfaceTile.orientedBoundingBox\n      );\n\n      surfaceTile.occludeePointInScaledSpace = computeOccludeePoint(\n        this,\n        surfaceTile.orientedBoundingBox.center,\n        tile.rectangle,\n        tileBoundingRegion.minimumHeight,\n        tileBoundingRegion.maximumHeight,\n        surfaceTile.occludeePointInScaledSpace\n      );\n    }\n  }\n\n  var min = tileBoundingRegion.minimumHeight;\n  var max = tileBoundingRegion.maximumHeight;\n\n  if (surfaceTile.boundingVolumeSourceTile !== tile) {\n    var cameraHeight = frameState.camera.positionCartographic.height;\n    var distanceToMin = Math.abs(cameraHeight - min);\n    var distanceToMax = Math.abs(cameraHeight - max);\n    if (distanceToMin > distanceToMax) {\n      tileBoundingRegion.minimumHeight = min;\n      tileBoundingRegion.maximumHeight = min;\n    } else {\n      tileBoundingRegion.minimumHeight = max;\n      tileBoundingRegion.maximumHeight = max;\n    }\n  }\n\n  var result = tileBoundingRegion.distanceToCamera(frameState);\n\n  tileBoundingRegion.minimumHeight = min;\n  tileBoundingRegion.maximumHeight = max;\n\n  return result;\n};\n\nfunction updateTileBoundingRegion(tile, terrainProvider, frameState) {\n  var surfaceTile = tile.data;\n  if (surfaceTile === undefined) {\n    surfaceTile = tile.data = new GlobeSurfaceTile();\n  }\n\n  if (surfaceTile.tileBoundingRegion === undefined) {\n    surfaceTile.tileBoundingRegion = new TileBoundingRegion({\n      computeBoundingVolumes: false,\n      rectangle: tile.rectangle,\n      ellipsoid: tile.tilingScheme.ellipsoid,\n      minimumHeight: 0.0,\n      maximumHeight: 0.0,\n    });\n  }\n\n  var terrainData = surfaceTile.terrainData;\n  var mesh = surfaceTile.mesh;\n  var tileBoundingRegion = surfaceTile.tileBoundingRegion;\n\n  if (\n    mesh !== undefined &&\n    mesh.minimumHeight !== undefined &&\n    mesh.maximumHeight !== undefined\n  ) {\n    // We have tight-fitting min/max heights from the mesh.\n    tileBoundingRegion.minimumHeight = mesh.minimumHeight;\n    tileBoundingRegion.maximumHeight = mesh.maximumHeight;\n    return tile;\n  }\n\n  if (\n    terrainData !== undefined &&\n    terrainData._minimumHeight !== undefined &&\n    terrainData._maximumHeight !== undefined\n  ) {\n    // We have tight-fitting min/max heights from the terrain data.\n    tileBoundingRegion.minimumHeight =\n      terrainData._minimumHeight * frameState.terrainExaggeration;\n    tileBoundingRegion.maximumHeight =\n      terrainData._maximumHeight * frameState.terrainExaggeration;\n    return tile;\n  }\n\n  // No accurate min/max heights available, so we're stuck with min/max heights from an ancestor tile.\n  tileBoundingRegion.minimumHeight = Number.NaN;\n  tileBoundingRegion.maximumHeight = Number.NaN;\n\n  var ancestor = tile.parent;\n  while (ancestor !== undefined) {\n    var ancestorSurfaceTile = ancestor.data;\n    if (ancestorSurfaceTile !== undefined) {\n      var ancestorMesh = ancestorSurfaceTile.mesh;\n      if (\n        ancestorMesh !== undefined &&\n        ancestorMesh.minimumHeight !== undefined &&\n        ancestorMesh.maximumHeight !== undefined\n      ) {\n        tileBoundingRegion.minimumHeight = ancestorMesh.minimumHeight;\n        tileBoundingRegion.maximumHeight = ancestorMesh.maximumHeight;\n        return ancestor;\n      }\n\n      var ancestorTerrainData = ancestorSurfaceTile.terrainData;\n      if (\n        ancestorTerrainData !== undefined &&\n        ancestorTerrainData._minimumHeight !== undefined &&\n        ancestorTerrainData._maximumHeight !== undefined\n      ) {\n        tileBoundingRegion.minimumHeight =\n          ancestorTerrainData._minimumHeight * frameState.terrainExaggeration;\n        tileBoundingRegion.maximumHeight =\n          ancestorTerrainData._maximumHeight * frameState.terrainExaggeration;\n        return ancestor;\n      }\n    }\n    ancestor = ancestor.parent;\n  }\n\n  return undefined;\n}\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n *\n * @see GlobeSurfaceTileProvider#destroy\n */\nGlobeSurfaceTileProvider.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * provider = provider && provider();\n *\n * @see GlobeSurfaceTileProvider#isDestroyed\n */\nGlobeSurfaceTileProvider.prototype.destroy = function () {\n  this._tileProvider = this._tileProvider && this._tileProvider.destroy();\n  this._clippingPlanes = this._clippingPlanes && this._clippingPlanes.destroy();\n\n  return destroyObject(this);\n};\n\nfunction getTileReadyCallback(tileImageriesToFree, layer, terrainProvider) {\n  return function (tile) {\n    var tileImagery;\n    var imagery;\n    var startIndex = -1;\n    var tileImageryCollection = tile.data.imagery;\n    var length = tileImageryCollection.length;\n    var i;\n    for (i = 0; i < length; ++i) {\n      tileImagery = tileImageryCollection[i];\n      imagery = defaultValue(\n        tileImagery.readyImagery,\n        tileImagery.loadingImagery\n      );\n      if (imagery.imageryLayer === layer) {\n        startIndex = i;\n        break;\n      }\n    }\n\n    if (startIndex !== -1) {\n      var endIndex = startIndex + tileImageriesToFree;\n      tileImagery = tileImageryCollection[endIndex];\n      imagery = defined(tileImagery)\n        ? defaultValue(tileImagery.readyImagery, tileImagery.loadingImagery)\n        : undefined;\n      if (!defined(imagery) || imagery.imageryLayer !== layer) {\n        // Return false to keep the callback if we have to wait on the skeletons\n        // Return true to remove the callback if something went wrong\n        return !layer._createTileImagerySkeletons(\n          tile,\n          terrainProvider,\n          endIndex\n        );\n      }\n\n      for (i = startIndex; i < endIndex; ++i) {\n        tileImageryCollection[i].freeResources();\n      }\n\n      tileImageryCollection.splice(startIndex, tileImageriesToFree);\n    }\n\n    return true; // Everything is done, so remove the callback\n  };\n}\n\nGlobeSurfaceTileProvider.prototype._onLayerAdded = function (layer, index) {\n  if (layer.show) {\n    var terrainProvider = this._terrainProvider;\n\n    var that = this;\n    var imageryProvider = layer.imageryProvider;\n    var tileImageryUpdatedEvent = this._imageryLayersUpdatedEvent;\n    imageryProvider._reload = function () {\n      // Clear the layer's cache\n      layer._imageryCache = {};\n\n      that._quadtree.forEachLoadedTile(function (tile) {\n        // If this layer is still waiting to for the loaded callback, just return\n        if (defined(tile._loadedCallbacks[layer._layerIndex])) {\n          return;\n        }\n\n        var i;\n\n        // Figure out how many TileImageries we will need to remove and where to insert new ones\n        var tileImageryCollection = tile.data.imagery;\n        var length = tileImageryCollection.length;\n        var startIndex = -1;\n        var tileImageriesToFree = 0;\n        for (i = 0; i < length; ++i) {\n          var tileImagery = tileImageryCollection[i];\n          var imagery = defaultValue(\n            tileImagery.readyImagery,\n            tileImagery.loadingImagery\n          );\n          if (imagery.imageryLayer === layer) {\n            if (startIndex === -1) {\n              startIndex = i;\n            }\n\n            ++tileImageriesToFree;\n          } else if (startIndex !== -1) {\n            // iterated past the section of TileImageries belonging to this layer, no need to continue.\n            break;\n          }\n        }\n\n        if (startIndex === -1) {\n          return;\n        }\n\n        // Insert immediately after existing TileImageries\n        var insertionPoint = startIndex + tileImageriesToFree;\n\n        // Create new TileImageries for all loaded tiles\n        if (\n          layer._createTileImagerySkeletons(\n            tile,\n            terrainProvider,\n            insertionPoint\n          )\n        ) {\n          // Add callback to remove old TileImageries when the new TileImageries are ready\n          tile._loadedCallbacks[layer._layerIndex] = getTileReadyCallback(\n            tileImageriesToFree,\n            layer,\n            terrainProvider\n          );\n\n          tile.state = QuadtreeTileLoadState.LOADING;\n        }\n      });\n    };\n\n    // create TileImageries for this layer for all previously loaded tiles\n    this._quadtree.forEachLoadedTile(function (tile) {\n      if (layer._createTileImagerySkeletons(tile, terrainProvider)) {\n        tile.state = QuadtreeTileLoadState.LOADING;\n\n        // Tiles that are not currently being rendered need to load the new layer before they're renderable.\n        // We don't mark the rendered tiles non-renderable, though, because that would make the globe disappear.\n        if (\n          tile.level !== 0 &&\n          (tile._lastSelectionResultFrame !==\n            that.quadtree._lastSelectionFrameNumber ||\n            tile._lastSelectionResult !== TileSelectionResult.RENDERED)\n        ) {\n          tile.renderable = false;\n        }\n      }\n    });\n\n    this._layerOrderChanged = true;\n    tileImageryUpdatedEvent.raiseEvent();\n  }\n};\n\nGlobeSurfaceTileProvider.prototype._onLayerRemoved = function (layer, index) {\n  // destroy TileImagerys for this layer for all previously loaded tiles\n  this._quadtree.forEachLoadedTile(function (tile) {\n    var tileImageryCollection = tile.data.imagery;\n\n    var startIndex = -1;\n    var numDestroyed = 0;\n    for (var i = 0, len = tileImageryCollection.length; i < len; ++i) {\n      var tileImagery = tileImageryCollection[i];\n      var imagery = tileImagery.loadingImagery;\n      if (!defined(imagery)) {\n        imagery = tileImagery.readyImagery;\n      }\n      if (imagery.imageryLayer === layer) {\n        if (startIndex === -1) {\n          startIndex = i;\n        }\n\n        tileImagery.freeResources();\n        ++numDestroyed;\n      } else if (startIndex !== -1) {\n        // iterated past the section of TileImagerys belonging to this layer, no need to continue.\n        break;\n      }\n    }\n\n    if (startIndex !== -1) {\n      tileImageryCollection.splice(startIndex, numDestroyed);\n    }\n  });\n\n  if (defined(layer.imageryProvider)) {\n    layer.imageryProvider._reload = undefined;\n  }\n\n  this._imageryLayersUpdatedEvent.raiseEvent();\n};\n\nGlobeSurfaceTileProvider.prototype._onLayerMoved = function (\n  layer,\n  newIndex,\n  oldIndex\n) {\n  this._layerOrderChanged = true;\n  this._imageryLayersUpdatedEvent.raiseEvent();\n};\n\nGlobeSurfaceTileProvider.prototype._onLayerShownOrHidden = function (\n  layer,\n  index,\n  show\n) {\n  if (show) {\n    this._onLayerAdded(layer, index);\n  } else {\n    this._onLayerRemoved(layer, index);\n  }\n};\n\nvar scratchClippingPlanesMatrix = new Matrix4();\nvar scratchInverseTransposeClippingPlanesMatrix = new Matrix4();\nfunction createTileUniformMap(frameState, globeSurfaceTileProvider) {\n  var uniformMap = {\n    u_initialColor: function () {\n      return this.properties.initialColor;\n    },\n    u_fillHighlightColor: function () {\n      return this.properties.fillHighlightColor;\n    },\n    u_zoomedOutOceanSpecularIntensity: function () {\n      return this.properties.zoomedOutOceanSpecularIntensity;\n    },\n    u_oceanNormalMap: function () {\n      return this.properties.oceanNormalMap;\n    },\n    u_lightingFadeDistance: function () {\n      return this.properties.lightingFadeDistance;\n    },\n    u_nightFadeDistance: function () {\n      return this.properties.nightFadeDistance;\n    },\n    u_center3D: function () {\n      return this.properties.center3D;\n    },\n    u_tileRectangle: function () {\n      return this.properties.tileRectangle;\n    },\n    u_modifiedModelView: function () {\n      var viewMatrix = frameState.context.uniformState.view;\n      var centerEye = Matrix4.multiplyByPoint(\n        viewMatrix,\n        this.properties.rtc,\n        centerEyeScratch\n      );\n      Matrix4.setTranslation(viewMatrix, centerEye, modifiedModelViewScratch);\n      return modifiedModelViewScratch;\n    },\n    u_modifiedModelViewProjection: function () {\n      var viewMatrix = frameState.context.uniformState.view;\n      var projectionMatrix = frameState.context.uniformState.projection;\n      var centerEye = Matrix4.multiplyByPoint(\n        viewMatrix,\n        this.properties.rtc,\n        centerEyeScratch\n      );\n      Matrix4.setTranslation(\n        viewMatrix,\n        centerEye,\n        modifiedModelViewProjectionScratch\n      );\n      Matrix4.multiply(\n        projectionMatrix,\n        modifiedModelViewProjectionScratch,\n        modifiedModelViewProjectionScratch\n      );\n      return modifiedModelViewProjectionScratch;\n    },\n    u_dayTextures: function () {\n      return this.properties.dayTextures;\n    },\n    u_dayTextureTranslationAndScale: function () {\n      return this.properties.dayTextureTranslationAndScale;\n    },\n    u_dayTextureTexCoordsRectangle: function () {\n      return this.properties.dayTextureTexCoordsRectangle;\n    },\n    u_dayTextureUseWebMercatorT: function () {\n      return this.properties.dayTextureUseWebMercatorT;\n    },\n    u_dayTextureAlpha: function () {\n      return this.properties.dayTextureAlpha;\n    },\n    u_dayTextureNightAlpha: function () {\n      return this.properties.dayTextureNightAlpha;\n    },\n    u_dayTextureDayAlpha: function () {\n      return this.properties.dayTextureDayAlpha;\n    },\n    u_dayTextureBrightness: function () {\n      return this.properties.dayTextureBrightness;\n    },\n    u_dayTextureContrast: function () {\n      return this.properties.dayTextureContrast;\n    },\n    u_dayTextureHue: function () {\n      return this.properties.dayTextureHue;\n    },\n    u_dayTextureSaturation: function () {\n      return this.properties.dayTextureSaturation;\n    },\n    u_dayTextureOneOverGamma: function () {\n      return this.properties.dayTextureOneOverGamma;\n    },\n    u_dayIntensity: function () {\n      return this.properties.dayIntensity;\n    },\n    u_southAndNorthLatitude: function () {\n      return this.properties.southAndNorthLatitude;\n    },\n    u_southMercatorYAndOneOverHeight: function () {\n      return this.properties.southMercatorYAndOneOverHeight;\n    },\n    u_waterMask: function () {\n      return this.properties.waterMask;\n    },\n    u_waterMaskTranslationAndScale: function () {\n      return this.properties.waterMaskTranslationAndScale;\n    },\n    u_minMaxHeight: function () {\n      return this.properties.minMaxHeight;\n    },\n    u_scaleAndBias: function () {\n      return this.properties.scaleAndBias;\n    },\n    u_dayTextureSplit: function () {\n      return this.properties.dayTextureSplit;\n    },\n    u_dayTextureCutoutRectangles: function () {\n      return this.properties.dayTextureCutoutRectangles;\n    },\n    u_clippingPlanes: function () {\n      var clippingPlanes = globeSurfaceTileProvider._clippingPlanes;\n      if (defined(clippingPlanes) && defined(clippingPlanes.texture)) {\n        // Check in case clippingPlanes hasn't been updated yet.\n        return clippingPlanes.texture;\n      }\n      return frameState.context.defaultTexture;\n    },\n    u_cartographicLimitRectangle: function () {\n      return this.properties.localizedCartographicLimitRectangle;\n    },\n    u_clippingPlanesMatrix: function () {\n      var clippingPlanes = globeSurfaceTileProvider._clippingPlanes;\n      var transform = defined(clippingPlanes)\n        ? Matrix4.multiply(\n            frameState.context.uniformState.view,\n            clippingPlanes.modelMatrix,\n            scratchClippingPlanesMatrix\n          )\n        : Matrix4.IDENTITY;\n\n      return Matrix4.inverseTranspose(\n        transform,\n        scratchInverseTransposeClippingPlanesMatrix\n      );\n    },\n    u_clippingPlanesEdgeStyle: function () {\n      var style = this.properties.clippingPlanesEdgeColor;\n      style.alpha = this.properties.clippingPlanesEdgeWidth;\n      return style;\n    },\n    u_minimumBrightness: function () {\n      return frameState.fog.minimumBrightness;\n    },\n    u_hsbShift: function () {\n      return this.properties.hsbShift;\n    },\n    u_colorsToAlpha: function () {\n      return this.properties.colorsToAlpha;\n    },\n    u_frontFaceAlphaByDistance: function () {\n      return this.properties.frontFaceAlphaByDistance;\n    },\n    u_backFaceAlphaByDistance: function () {\n      return this.properties.backFaceAlphaByDistance;\n    },\n    u_translucencyRectangle: function () {\n      return this.properties.localizedTranslucencyRectangle;\n    },\n    u_undergroundColor: function () {\n      return this.properties.undergroundColor;\n    },\n    u_undergroundColorAlphaByDistance: function () {\n      return this.properties.undergroundColorAlphaByDistance;\n    },\n\n    // make a separate object so that changes to the properties are seen on\n    // derived commands that combine another uniform map with this one.\n    properties: {\n      initialColor: new Cartesian4(0.0, 0.0, 0.5, 1.0),\n      fillHighlightColor: new Color(0.0, 0.0, 0.0, 0.0),\n      zoomedOutOceanSpecularIntensity: 0.5,\n      oceanNormalMap: undefined,\n      lightingFadeDistance: new Cartesian2(6500000.0, 9000000.0),\n      nightFadeDistance: new Cartesian2(10000000.0, 40000000.0),\n      hsbShift: new Cartesian3(),\n\n      center3D: undefined,\n      rtc: new Cartesian3(),\n      modifiedModelView: new Matrix4(),\n      tileRectangle: new Cartesian4(),\n\n      dayTextures: [],\n      dayTextureTranslationAndScale: [],\n      dayTextureTexCoordsRectangle: [],\n      dayTextureUseWebMercatorT: [],\n      dayTextureAlpha: [],\n      dayTextureNightAlpha: [],\n      dayTextureDayAlpha: [],\n      dayTextureBrightness: [],\n      dayTextureContrast: [],\n      dayTextureHue: [],\n      dayTextureSaturation: [],\n      dayTextureOneOverGamma: [],\n      dayTextureSplit: [],\n      dayTextureCutoutRectangles: [],\n      dayIntensity: 0.0,\n      colorsToAlpha: [],\n\n      southAndNorthLatitude: new Cartesian2(),\n      southMercatorYAndOneOverHeight: new Cartesian2(),\n\n      waterMask: undefined,\n      waterMaskTranslationAndScale: new Cartesian4(),\n\n      minMaxHeight: new Cartesian2(),\n      scaleAndBias: new Matrix4(),\n      clippingPlanesEdgeColor: Color.clone(Color.WHITE),\n      clippingPlanesEdgeWidth: 0.0,\n\n      localizedCartographicLimitRectangle: new Cartesian4(),\n\n      frontFaceAlphaByDistance: new Cartesian4(),\n      backFaceAlphaByDistance: new Cartesian4(),\n      localizedTranslucencyRectangle: new Cartesian4(),\n      undergroundColor: Color.clone(Color.TRANSPARENT),\n      undergroundColorAlphaByDistance: new Cartesian4(),\n    },\n  };\n\n  if (defined(globeSurfaceTileProvider.materialUniformMap)) {\n    return combine(uniformMap, globeSurfaceTileProvider.materialUniformMap);\n  }\n\n  return uniformMap;\n}\n\nfunction createWireframeVertexArrayIfNecessary(context, provider, tile) {\n  var surfaceTile = tile.data;\n\n  var mesh;\n  var vertexArray;\n\n  if (defined(surfaceTile.vertexArray)) {\n    mesh = surfaceTile.mesh;\n    vertexArray = surfaceTile.vertexArray;\n  } else if (\n    defined(surfaceTile.fill) &&\n    defined(surfaceTile.fill.vertexArray)\n  ) {\n    mesh = surfaceTile.fill.mesh;\n    vertexArray = surfaceTile.fill.vertexArray;\n  }\n\n  if (!defined(mesh) || !defined(vertexArray)) {\n    return;\n  }\n\n  if (defined(surfaceTile.wireframeVertexArray)) {\n    if (surfaceTile.wireframeVertexArray.mesh === mesh) {\n      return;\n    }\n\n    surfaceTile.wireframeVertexArray.destroy();\n    surfaceTile.wireframeVertexArray = undefined;\n  }\n\n  surfaceTile.wireframeVertexArray = createWireframeVertexArray(\n    context,\n    vertexArray,\n    mesh\n  );\n  surfaceTile.wireframeVertexArray.mesh = mesh;\n}\n\n/**\n * Creates a vertex array for wireframe rendering of a terrain tile.\n *\n * @private\n *\n * @param {Context} context The context in which to create the vertex array.\n * @param {VertexArray} vertexArray The existing, non-wireframe vertex array.  The new vertex array\n *                      will share vertex buffers with this existing one.\n * @param {TerrainMesh} terrainMesh The terrain mesh containing non-wireframe indices.\n * @returns {VertexArray} The vertex array for wireframe rendering.\n */\nfunction createWireframeVertexArray(context, vertexArray, terrainMesh) {\n  var indices = terrainMesh.indices;\n\n  var geometry = {\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n  };\n\n  GeometryPipeline.toWireframe(geometry);\n\n  var wireframeIndices = geometry.indices;\n  var wireframeIndexBuffer = Buffer.createIndexBuffer({\n    context: context,\n    typedArray: wireframeIndices,\n    usage: BufferUsage.STATIC_DRAW,\n    indexDatatype: IndexDatatype.fromSizeInBytes(\n      wireframeIndices.BYTES_PER_ELEMENT\n    ),\n  });\n  return new VertexArray({\n    context: context,\n    attributes: vertexArray._attributes,\n    indexBuffer: wireframeIndexBuffer,\n  });\n}\n\nvar getDebugOrientedBoundingBox;\nvar getDebugBoundingSphere;\nvar debugDestroyPrimitive;\n\n(function () {\n  var instanceOBB = new GeometryInstance({\n    geometry: BoxOutlineGeometry.fromDimensions({\n      dimensions: new Cartesian3(2.0, 2.0, 2.0),\n    }),\n  });\n  var instanceSphere = new GeometryInstance({\n    geometry: new SphereOutlineGeometry({ radius: 1.0 }),\n  });\n  var modelMatrix = new Matrix4();\n  var previousVolume;\n  var primitive;\n\n  function createDebugPrimitive(instance) {\n    return new Primitive({\n      geometryInstances: instance,\n      appearance: new PerInstanceColorAppearance({\n        translucent: false,\n        flat: true,\n      }),\n      asynchronous: false,\n    });\n  }\n\n  getDebugOrientedBoundingBox = function (obb, color) {\n    if (obb === previousVolume) {\n      return primitive;\n    }\n    debugDestroyPrimitive();\n\n    previousVolume = obb;\n    modelMatrix = Matrix4.fromRotationTranslation(\n      obb.halfAxes,\n      obb.center,\n      modelMatrix\n    );\n\n    instanceOBB.modelMatrix = modelMatrix;\n    instanceOBB.attributes.color = ColorGeometryInstanceAttribute.fromColor(\n      color\n    );\n\n    primitive = createDebugPrimitive(instanceOBB);\n    return primitive;\n  };\n\n  getDebugBoundingSphere = function (sphere, color) {\n    if (sphere === previousVolume) {\n      return primitive;\n    }\n    debugDestroyPrimitive();\n\n    previousVolume = sphere;\n    modelMatrix = Matrix4.fromTranslation(sphere.center, modelMatrix);\n    modelMatrix = Matrix4.multiplyByUniformScale(\n      modelMatrix,\n      sphere.radius,\n      modelMatrix\n    );\n\n    instanceSphere.modelMatrix = modelMatrix;\n    instanceSphere.attributes.color = ColorGeometryInstanceAttribute.fromColor(\n      color\n    );\n\n    primitive = createDebugPrimitive(instanceSphere);\n    return primitive;\n  };\n\n  debugDestroyPrimitive = function () {\n    if (defined(primitive)) {\n      primitive.destroy();\n      primitive = undefined;\n      previousVolume = undefined;\n    }\n  };\n})();\n\nvar otherPassesInitialColor = new Cartesian4(0.0, 0.0, 0.0, 0.0);\nvar surfaceShaderSetOptionsScratch = {\n  frameState: undefined,\n  surfaceTile: undefined,\n  numberOfDayTextures: undefined,\n  applyBrightness: undefined,\n  applyContrast: undefined,\n  applyHue: undefined,\n  applySaturation: undefined,\n  applyGamma: undefined,\n  applyAlpha: undefined,\n  applyDayNightAlpha: undefined,\n  applySplit: undefined,\n  showReflectiveOcean: undefined,\n  showOceanWaves: undefined,\n  enableLighting: undefined,\n  dynamicAtmosphereLighting: undefined,\n  dynamicAtmosphereLightingFromSun: undefined,\n  showGroundAtmosphere: undefined,\n  perFragmentGroundAtmosphere: undefined,\n  hasVertexNormals: undefined,\n  useWebMercatorProjection: undefined,\n  enableFog: undefined,\n  enableClippingPlanes: undefined,\n  clippingPlanes: undefined,\n  clippedByBoundaries: undefined,\n  hasImageryLayerCutout: undefined,\n  colorCorrect: undefined,\n  colorToAlpha: undefined,\n};\n\nvar defaultUndergroundColor = Color.TRANSPARENT;\nvar defaultundergroundColorAlphaByDistance = new NearFarScalar();\n\nfunction addDrawCommandsForTile(tileProvider, tile, frameState) {\n  var surfaceTile = tile.data;\n\n  if (!defined(surfaceTile.vertexArray)) {\n    if (surfaceTile.fill === undefined) {\n      // No fill was created for this tile, probably because this tile is not connected to\n      // any renderable tiles. So create a simple tile in the middle of the tile's possible\n      // height range.\n      surfaceTile.fill = new TerrainFillMesh(tile);\n    }\n    surfaceTile.fill.update(tileProvider, frameState);\n  }\n\n  var creditDisplay = frameState.creditDisplay;\n\n  var terrainData = surfaceTile.terrainData;\n  if (defined(terrainData) && defined(terrainData.credits)) {\n    var tileCredits = terrainData.credits;\n    for (\n      var tileCreditIndex = 0, tileCreditLength = tileCredits.length;\n      tileCreditIndex < tileCreditLength;\n      ++tileCreditIndex\n    ) {\n      creditDisplay.addCredit(tileCredits[tileCreditIndex]);\n    }\n  }\n\n  var maxTextures = ContextLimits.maximumTextureImageUnits;\n\n  var waterMaskTexture = surfaceTile.waterMaskTexture;\n  var waterMaskTranslationAndScale = surfaceTile.waterMaskTranslationAndScale;\n  if (!defined(waterMaskTexture) && defined(surfaceTile.fill)) {\n    waterMaskTexture = surfaceTile.fill.waterMaskTexture;\n    waterMaskTranslationAndScale =\n      surfaceTile.fill.waterMaskTranslationAndScale;\n  }\n\n  var cameraUnderground = frameState.cameraUnderground;\n\n  var globeTranslucencyState = frameState.globeTranslucencyState;\n  var translucent = globeTranslucencyState.translucent;\n  var frontFaceAlphaByDistance =\n    globeTranslucencyState.frontFaceAlphaByDistance;\n  var backFaceAlphaByDistance = globeTranslucencyState.backFaceAlphaByDistance;\n  var translucencyRectangle = globeTranslucencyState.rectangle;\n\n  var undergroundColor = defaultValue(\n    tileProvider.undergroundColor,\n    defaultUndergroundColor\n  );\n  var undergroundColorAlphaByDistance = defaultValue(\n    tileProvider.undergroundColorAlphaByDistance,\n    defaultundergroundColorAlphaByDistance\n  );\n  var showUndergroundColor =\n    isUndergroundVisible(tileProvider, frameState) &&\n    frameState.mode === SceneMode.SCENE3D &&\n    undergroundColor.alpha > 0.0 &&\n    (undergroundColorAlphaByDistance.nearValue > 0.0 ||\n      undergroundColorAlphaByDistance.farValue > 0.0);\n\n  var showReflectiveOcean =\n    tileProvider.hasWaterMask && defined(waterMaskTexture);\n  var oceanNormalMap = tileProvider.oceanNormalMap;\n  var showOceanWaves = showReflectiveOcean && defined(oceanNormalMap);\n  var hasVertexNormals =\n    tileProvider.terrainProvider.ready &&\n    tileProvider.terrainProvider.hasVertexNormals;\n  var enableFog = frameState.fog.enabled && !cameraUnderground;\n  var showGroundAtmosphere =\n    tileProvider.showGroundAtmosphere && frameState.mode === SceneMode.SCENE3D;\n  var castShadows =\n    ShadowMode.castShadows(tileProvider.shadows) && !translucent;\n  var receiveShadows =\n    ShadowMode.receiveShadows(tileProvider.shadows) && !translucent;\n\n  var hueShift = tileProvider.hueShift;\n  var saturationShift = tileProvider.saturationShift;\n  var brightnessShift = tileProvider.brightnessShift;\n\n  var colorCorrect = !(\n    CesiumMath.equalsEpsilon(hueShift, 0.0, CesiumMath.EPSILON7) &&\n    CesiumMath.equalsEpsilon(saturationShift, 0.0, CesiumMath.EPSILON7) &&\n    CesiumMath.equalsEpsilon(brightnessShift, 0.0, CesiumMath.EPSILON7)\n  );\n\n  var perFragmentGroundAtmosphere = false;\n  if (showGroundAtmosphere) {\n    var cameraDistance = Cartesian3.magnitude(frameState.camera.positionWC);\n    var fadeOutDistance = tileProvider.nightFadeOutDistance;\n    perFragmentGroundAtmosphere = cameraDistance > fadeOutDistance;\n  }\n\n  if (showReflectiveOcean) {\n    --maxTextures;\n  }\n  if (showOceanWaves) {\n    --maxTextures;\n  }\n  if (\n    defined(frameState.shadowState) &&\n    frameState.shadowState.shadowsEnabled\n  ) {\n    --maxTextures;\n  }\n  if (\n    defined(tileProvider.clippingPlanes) &&\n    tileProvider.clippingPlanes.enabled\n  ) {\n    --maxTextures;\n  }\n\n  maxTextures -= globeTranslucencyState.numberOfTextureUniforms;\n\n  var mesh = surfaceTile.renderedMesh;\n  var rtc = mesh.center;\n  var encoding = mesh.encoding;\n\n  // Not used in 3D.\n  var tileRectangle = tileRectangleScratch;\n\n  // Only used for Mercator projections.\n  var southLatitude = 0.0;\n  var northLatitude = 0.0;\n  var southMercatorY = 0.0;\n  var oneOverMercatorHeight = 0.0;\n\n  var useWebMercatorProjection = false;\n\n  if (frameState.mode !== SceneMode.SCENE3D) {\n    var projection = frameState.mapProjection;\n    var southwest = projection.project(\n      Rectangle.southwest(tile.rectangle),\n      southwestScratch\n    );\n    var northeast = projection.project(\n      Rectangle.northeast(tile.rectangle),\n      northeastScratch\n    );\n\n    tileRectangle.x = southwest.x;\n    tileRectangle.y = southwest.y;\n    tileRectangle.z = northeast.x;\n    tileRectangle.w = northeast.y;\n\n    // In 2D and Columbus View, use the center of the tile for RTC rendering.\n    if (frameState.mode !== SceneMode.MORPHING) {\n      rtc = rtcScratch;\n      rtc.x = 0.0;\n      rtc.y = (tileRectangle.z + tileRectangle.x) * 0.5;\n      rtc.z = (tileRectangle.w + tileRectangle.y) * 0.5;\n      tileRectangle.x -= rtc.y;\n      tileRectangle.y -= rtc.z;\n      tileRectangle.z -= rtc.y;\n      tileRectangle.w -= rtc.z;\n    }\n\n    if (\n      frameState.mode === SceneMode.SCENE2D &&\n      encoding.quantization === TerrainQuantization.BITS12\n    ) {\n      // In 2D, the texture coordinates of the tile are interpolated over the rectangle to get the position in the vertex shader.\n      // When the texture coordinates are quantized, error is introduced. This can be seen through the 1px wide cracking\n      // between the quantized tiles in 2D. To compensate for the error, move the expand the rectangle in each direction by\n      // half the error amount.\n      var epsilon = (1.0 / (Math.pow(2.0, 12.0) - 1.0)) * 0.5;\n      var widthEpsilon = (tileRectangle.z - tileRectangle.x) * epsilon;\n      var heightEpsilon = (tileRectangle.w - tileRectangle.y) * epsilon;\n      tileRectangle.x -= widthEpsilon;\n      tileRectangle.y -= heightEpsilon;\n      tileRectangle.z += widthEpsilon;\n      tileRectangle.w += heightEpsilon;\n    }\n\n    if (projection instanceof WebMercatorProjection) {\n      southLatitude = tile.rectangle.south;\n      northLatitude = tile.rectangle.north;\n\n      southMercatorY = WebMercatorProjection.geodeticLatitudeToMercatorAngle(\n        southLatitude\n      );\n\n      oneOverMercatorHeight =\n        1.0 /\n        (WebMercatorProjection.geodeticLatitudeToMercatorAngle(northLatitude) -\n          southMercatorY);\n\n      useWebMercatorProjection = true;\n    }\n  }\n\n  var surfaceShaderSetOptions = surfaceShaderSetOptionsScratch;\n  surfaceShaderSetOptions.frameState = frameState;\n  surfaceShaderSetOptions.surfaceTile = surfaceTile;\n  surfaceShaderSetOptions.showReflectiveOcean = showReflectiveOcean;\n  surfaceShaderSetOptions.showOceanWaves = showOceanWaves;\n  surfaceShaderSetOptions.enableLighting = tileProvider.enableLighting;\n  surfaceShaderSetOptions.dynamicAtmosphereLighting =\n    tileProvider.dynamicAtmosphereLighting;\n  surfaceShaderSetOptions.dynamicAtmosphereLightingFromSun =\n    tileProvider.dynamicAtmosphereLightingFromSun;\n  surfaceShaderSetOptions.showGroundAtmosphere = showGroundAtmosphere;\n  surfaceShaderSetOptions.perFragmentGroundAtmosphere = perFragmentGroundAtmosphere;\n  surfaceShaderSetOptions.hasVertexNormals = hasVertexNormals;\n  surfaceShaderSetOptions.useWebMercatorProjection = useWebMercatorProjection;\n  surfaceShaderSetOptions.clippedByBoundaries = surfaceTile.clippedByBoundaries;\n\n  var tileImageryCollection = surfaceTile.imagery;\n  var imageryIndex = 0;\n  var imageryLen = tileImageryCollection.length;\n\n  var showSkirts =\n    tileProvider.showSkirts && !cameraUnderground && !translucent;\n  var backFaceCulling =\n    tileProvider.backFaceCulling && !cameraUnderground && !translucent;\n  var firstPassRenderState = backFaceCulling\n    ? tileProvider._renderState\n    : tileProvider._disableCullingRenderState;\n  var otherPassesRenderState = backFaceCulling\n    ? tileProvider._blendRenderState\n    : tileProvider._disableCullingBlendRenderState;\n  var renderState = firstPassRenderState;\n\n  var initialColor = tileProvider._firstPassInitialColor;\n\n  var context = frameState.context;\n\n  if (!defined(tileProvider._debug.boundingSphereTile)) {\n    debugDestroyPrimitive();\n  }\n\n  var materialUniformMapChanged =\n    tileProvider._materialUniformMap !== tileProvider.materialUniformMap;\n  if (materialUniformMapChanged) {\n    tileProvider._materialUniformMap = tileProvider.materialUniformMap;\n    var drawCommandsLength = tileProvider._drawCommands.length;\n    for (var i = 0; i < drawCommandsLength; ++i) {\n      tileProvider._uniformMaps[i] = createTileUniformMap(\n        frameState,\n        tileProvider\n      );\n    }\n  }\n\n  do {\n    var numberOfDayTextures = 0;\n\n    var command;\n    var uniformMap;\n\n    if (tileProvider._drawCommands.length <= tileProvider._usedDrawCommands) {\n      command = new DrawCommand();\n      command.owner = tile;\n      command.cull = false;\n      command.boundingVolume = new BoundingSphere();\n      command.orientedBoundingBox = undefined;\n\n      uniformMap = createTileUniformMap(frameState, tileProvider);\n\n      tileProvider._drawCommands.push(command);\n      tileProvider._uniformMaps.push(uniformMap);\n    } else {\n      command = tileProvider._drawCommands[tileProvider._usedDrawCommands];\n      uniformMap = tileProvider._uniformMaps[tileProvider._usedDrawCommands];\n    }\n\n    command.owner = tile;\n\n    ++tileProvider._usedDrawCommands;\n\n    if (tile === tileProvider._debug.boundingSphereTile) {\n      var obb = surfaceTile.orientedBoundingBox;\n      // If a debug primitive already exists for this tile, it will not be\n      // re-created, to avoid allocation every frame. If it were possible\n      // to have more than one selected tile, this would have to change.\n      if (defined(obb)) {\n        getDebugOrientedBoundingBox(obb, Color.RED).update(frameState);\n      } else if (defined(mesh) && defined(mesh.boundingSphere3D)) {\n        getDebugBoundingSphere(mesh.boundingSphere3D, Color.RED).update(\n          frameState\n        );\n      }\n    }\n\n    var uniformMapProperties = uniformMap.properties;\n    Cartesian4.clone(initialColor, uniformMapProperties.initialColor);\n    uniformMapProperties.oceanNormalMap = oceanNormalMap;\n    uniformMapProperties.lightingFadeDistance.x =\n      tileProvider.lightingFadeOutDistance;\n    uniformMapProperties.lightingFadeDistance.y =\n      tileProvider.lightingFadeInDistance;\n    uniformMapProperties.nightFadeDistance.x =\n      tileProvider.nightFadeOutDistance;\n    uniformMapProperties.nightFadeDistance.y = tileProvider.nightFadeInDistance;\n    uniformMapProperties.zoomedOutOceanSpecularIntensity =\n      tileProvider.zoomedOutOceanSpecularIntensity;\n\n    var frontFaceAlphaByDistanceFinal = cameraUnderground\n      ? backFaceAlphaByDistance\n      : frontFaceAlphaByDistance;\n    var backFaceAlphaByDistanceFinal = cameraUnderground\n      ? frontFaceAlphaByDistance\n      : backFaceAlphaByDistance;\n\n    if (defined(frontFaceAlphaByDistanceFinal)) {\n      Cartesian4.fromElements(\n        frontFaceAlphaByDistanceFinal.near,\n        frontFaceAlphaByDistanceFinal.nearValue,\n        frontFaceAlphaByDistanceFinal.far,\n        frontFaceAlphaByDistanceFinal.farValue,\n        uniformMapProperties.frontFaceAlphaByDistance\n      );\n      Cartesian4.fromElements(\n        backFaceAlphaByDistanceFinal.near,\n        backFaceAlphaByDistanceFinal.nearValue,\n        backFaceAlphaByDistanceFinal.far,\n        backFaceAlphaByDistanceFinal.farValue,\n        uniformMapProperties.backFaceAlphaByDistance\n      );\n    }\n\n    Cartesian4.fromElements(\n      undergroundColorAlphaByDistance.near,\n      undergroundColorAlphaByDistance.nearValue,\n      undergroundColorAlphaByDistance.far,\n      undergroundColorAlphaByDistance.farValue,\n      uniformMapProperties.undergroundColorAlphaByDistance\n    );\n    Color.clone(undergroundColor, uniformMapProperties.undergroundColor);\n\n    var highlightFillTile =\n      !defined(surfaceTile.vertexArray) &&\n      defined(tileProvider.fillHighlightColor) &&\n      tileProvider.fillHighlightColor.alpha > 0.0;\n    if (highlightFillTile) {\n      Color.clone(\n        tileProvider.fillHighlightColor,\n        uniformMapProperties.fillHighlightColor\n      );\n    }\n\n    uniformMapProperties.center3D = mesh.center;\n    Cartesian3.clone(rtc, uniformMapProperties.rtc);\n\n    Cartesian4.clone(tileRectangle, uniformMapProperties.tileRectangle);\n    uniformMapProperties.southAndNorthLatitude.x = southLatitude;\n    uniformMapProperties.southAndNorthLatitude.y = northLatitude;\n    uniformMapProperties.southMercatorYAndOneOverHeight.x = southMercatorY;\n    uniformMapProperties.southMercatorYAndOneOverHeight.y = oneOverMercatorHeight;\n\n    // Convert tile limiter rectangle from cartographic to texture space using the tileRectangle.\n    var localizedCartographicLimitRectangle = localizedCartographicLimitRectangleScratch;\n    var cartographicLimitRectangle = clipRectangleAntimeridian(\n      tile.rectangle,\n      tileProvider.cartographicLimitRectangle\n    );\n\n    var localizedTranslucencyRectangle = localizedTranslucencyRectangleScratch;\n    var clippedTranslucencyRectangle = clipRectangleAntimeridian(\n      tile.rectangle,\n      translucencyRectangle\n    );\n\n    Cartesian3.fromElements(\n      hueShift,\n      saturationShift,\n      brightnessShift,\n      uniformMapProperties.hsbShift\n    );\n\n    var cartographicTileRectangle = tile.rectangle;\n    var inverseTileWidth = 1.0 / cartographicTileRectangle.width;\n    var inverseTileHeight = 1.0 / cartographicTileRectangle.height;\n    localizedCartographicLimitRectangle.x =\n      (cartographicLimitRectangle.west - cartographicTileRectangle.west) *\n      inverseTileWidth;\n    localizedCartographicLimitRectangle.y =\n      (cartographicLimitRectangle.south - cartographicTileRectangle.south) *\n      inverseTileHeight;\n    localizedCartographicLimitRectangle.z =\n      (cartographicLimitRectangle.east - cartographicTileRectangle.west) *\n      inverseTileWidth;\n    localizedCartographicLimitRectangle.w =\n      (cartographicLimitRectangle.north - cartographicTileRectangle.south) *\n      inverseTileHeight;\n\n    Cartesian4.clone(\n      localizedCartographicLimitRectangle,\n      uniformMapProperties.localizedCartographicLimitRectangle\n    );\n\n    localizedTranslucencyRectangle.x =\n      (clippedTranslucencyRectangle.west - cartographicTileRectangle.west) *\n      inverseTileWidth;\n    localizedTranslucencyRectangle.y =\n      (clippedTranslucencyRectangle.south - cartographicTileRectangle.south) *\n      inverseTileHeight;\n    localizedTranslucencyRectangle.z =\n      (clippedTranslucencyRectangle.east - cartographicTileRectangle.west) *\n      inverseTileWidth;\n    localizedTranslucencyRectangle.w =\n      (clippedTranslucencyRectangle.north - cartographicTileRectangle.south) *\n      inverseTileHeight;\n\n    Cartesian4.clone(\n      localizedTranslucencyRectangle,\n      uniformMapProperties.localizedTranslucencyRectangle\n    );\n\n    // For performance, use fog in the shader only when the tile is in fog.\n    var applyFog =\n      enableFog &&\n      CesiumMath.fog(tile._distance, frameState.fog.density) >\n        CesiumMath.EPSILON3;\n    colorCorrect = colorCorrect && (applyFog || showGroundAtmosphere);\n\n    var applyBrightness = false;\n    var applyContrast = false;\n    var applyHue = false;\n    var applySaturation = false;\n    var applyGamma = false;\n    var applyAlpha = false;\n    var applyDayNightAlpha = false;\n    var applySplit = false;\n    var applyCutout = false;\n    var applyColorToAlpha = false;\n\n    while (numberOfDayTextures < maxTextures && imageryIndex < imageryLen) {\n      var tileImagery = tileImageryCollection[imageryIndex];\n      var imagery = tileImagery.readyImagery;\n      ++imageryIndex;\n\n      if (!defined(imagery) || imagery.imageryLayer.alpha === 0.0) {\n        continue;\n      }\n\n      var texture = tileImagery.useWebMercatorT\n        ? imagery.textureWebMercator\n        : imagery.texture;\n\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(texture)) {\n        // Our \"ready\" texture isn't actually ready.  This should never happen.\n        //\n        // Side note: It IS possible for it to not be in the READY ImageryState, though.\n        // This can happen when a single imagery tile is shared by two terrain tiles (common)\n        // and one of them (A) needs a geographic version of the tile because it is near the poles,\n        // and the other (B) does not.  B can and will transition the imagery tile to the READY state\n        // without reprojecting to geographic.  Then, later, A will deem that same tile not-ready-yet\n        // because it only has the Web Mercator texture, and flip it back to the TRANSITIONING state.\n        // The imagery tile won't be in the READY state anymore, but it's still READY enough for B's\n        // purposes.\n        throw new DeveloperError(\"readyImagery is not actually ready!\");\n      }\n      //>>includeEnd('debug');\n\n      var imageryLayer = imagery.imageryLayer;\n\n      if (!defined(tileImagery.textureTranslationAndScale)) {\n        tileImagery.textureTranslationAndScale = imageryLayer._calculateTextureTranslationAndScale(\n          tile,\n          tileImagery\n        );\n      }\n\n      uniformMapProperties.dayTextures[numberOfDayTextures] = texture;\n      uniformMapProperties.dayTextureTranslationAndScale[numberOfDayTextures] =\n        tileImagery.textureTranslationAndScale;\n      uniformMapProperties.dayTextureTexCoordsRectangle[numberOfDayTextures] =\n        tileImagery.textureCoordinateRectangle;\n      uniformMapProperties.dayTextureUseWebMercatorT[numberOfDayTextures] =\n        tileImagery.useWebMercatorT;\n\n      uniformMapProperties.dayTextureAlpha[numberOfDayTextures] =\n        imageryLayer.alpha;\n      applyAlpha =\n        applyAlpha ||\n        uniformMapProperties.dayTextureAlpha[numberOfDayTextures] !== 1.0;\n\n      uniformMapProperties.dayTextureNightAlpha[numberOfDayTextures] =\n        imageryLayer.nightAlpha;\n      applyDayNightAlpha =\n        applyDayNightAlpha ||\n        uniformMapProperties.dayTextureNightAlpha[numberOfDayTextures] !== 1.0;\n\n      uniformMapProperties.dayTextureDayAlpha[numberOfDayTextures] =\n        imageryLayer.dayAlpha;\n      applyDayNightAlpha =\n        applyDayNightAlpha ||\n        uniformMapProperties.dayTextureDayAlpha[numberOfDayTextures] !== 1.0;\n\n      uniformMapProperties.dayTextureBrightness[numberOfDayTextures] =\n        imageryLayer.brightness;\n      applyBrightness =\n        applyBrightness ||\n        uniformMapProperties.dayTextureBrightness[numberOfDayTextures] !==\n          ImageryLayer.DEFAULT_BRIGHTNESS;\n\n      uniformMapProperties.dayTextureContrast[numberOfDayTextures] =\n        imageryLayer.contrast;\n      applyContrast =\n        applyContrast ||\n        uniformMapProperties.dayTextureContrast[numberOfDayTextures] !==\n          ImageryLayer.DEFAULT_CONTRAST;\n\n      uniformMapProperties.dayTextureHue[numberOfDayTextures] =\n        imageryLayer.hue;\n      applyHue =\n        applyHue ||\n        uniformMapProperties.dayTextureHue[numberOfDayTextures] !==\n          ImageryLayer.DEFAULT_HUE;\n\n      uniformMapProperties.dayTextureSaturation[numberOfDayTextures] =\n        imageryLayer.saturation;\n      applySaturation =\n        applySaturation ||\n        uniformMapProperties.dayTextureSaturation[numberOfDayTextures] !==\n          ImageryLayer.DEFAULT_SATURATION;\n\n      uniformMapProperties.dayTextureOneOverGamma[numberOfDayTextures] =\n        1.0 / imageryLayer.gamma;\n      applyGamma =\n        applyGamma ||\n        uniformMapProperties.dayTextureOneOverGamma[numberOfDayTextures] !==\n          1.0 / ImageryLayer.DEFAULT_GAMMA;\n\n      uniformMapProperties.dayTextureSplit[numberOfDayTextures] =\n        imageryLayer.splitDirection;\n      applySplit =\n        applySplit ||\n        uniformMapProperties.dayTextureSplit[numberOfDayTextures] !== 0.0;\n\n      // Update cutout rectangle\n      var dayTextureCutoutRectangle =\n        uniformMapProperties.dayTextureCutoutRectangles[numberOfDayTextures];\n      if (!defined(dayTextureCutoutRectangle)) {\n        dayTextureCutoutRectangle = uniformMapProperties.dayTextureCutoutRectangles[\n          numberOfDayTextures\n        ] = new Cartesian4();\n      }\n\n      Cartesian4.clone(Cartesian4.ZERO, dayTextureCutoutRectangle);\n      if (defined(imageryLayer.cutoutRectangle)) {\n        var cutoutRectangle = clipRectangleAntimeridian(\n          cartographicTileRectangle,\n          imageryLayer.cutoutRectangle\n        );\n        var intersection = Rectangle.simpleIntersection(\n          cutoutRectangle,\n          cartographicTileRectangle,\n          rectangleIntersectionScratch\n        );\n        applyCutout = defined(intersection) || applyCutout;\n\n        dayTextureCutoutRectangle.x =\n          (cutoutRectangle.west - cartographicTileRectangle.west) *\n          inverseTileWidth;\n        dayTextureCutoutRectangle.y =\n          (cutoutRectangle.south - cartographicTileRectangle.south) *\n          inverseTileHeight;\n        dayTextureCutoutRectangle.z =\n          (cutoutRectangle.east - cartographicTileRectangle.west) *\n          inverseTileWidth;\n        dayTextureCutoutRectangle.w =\n          (cutoutRectangle.north - cartographicTileRectangle.south) *\n          inverseTileHeight;\n      }\n\n      // Update color to alpha\n      var colorToAlpha =\n        uniformMapProperties.colorsToAlpha[numberOfDayTextures];\n      if (!defined(colorToAlpha)) {\n        colorToAlpha = uniformMapProperties.colorsToAlpha[\n          numberOfDayTextures\n        ] = new Cartesian4();\n      }\n\n      var hasColorToAlpha =\n        defined(imageryLayer.colorToAlpha) &&\n        imageryLayer.colorToAlphaThreshold > 0.0;\n      applyColorToAlpha = applyColorToAlpha || hasColorToAlpha;\n\n      if (hasColorToAlpha) {\n        var color = imageryLayer.colorToAlpha;\n        colorToAlpha.x = color.red;\n        colorToAlpha.y = color.green;\n        colorToAlpha.z = color.blue;\n        colorToAlpha.w = imageryLayer.colorToAlphaThreshold;\n      } else {\n        colorToAlpha.w = -1.0;\n      }\n\n      if (defined(imagery.credits)) {\n        var credits = imagery.credits;\n        for (\n          var creditIndex = 0, creditLength = credits.length;\n          creditIndex < creditLength;\n          ++creditIndex\n        ) {\n          creditDisplay.addCredit(credits[creditIndex]);\n        }\n      }\n\n      ++numberOfDayTextures;\n    }\n\n    // trim texture array to the used length so we don't end up using old textures\n    // which might get destroyed eventually\n    uniformMapProperties.dayTextures.length = numberOfDayTextures;\n    uniformMapProperties.waterMask = waterMaskTexture;\n    Cartesian4.clone(\n      waterMaskTranslationAndScale,\n      uniformMapProperties.waterMaskTranslationAndScale\n    );\n\n    uniformMapProperties.minMaxHeight.x = encoding.minimumHeight;\n    uniformMapProperties.minMaxHeight.y = encoding.maximumHeight;\n    Matrix4.clone(encoding.matrix, uniformMapProperties.scaleAndBias);\n\n    // update clipping planes\n    var clippingPlanes = tileProvider._clippingPlanes;\n    var clippingPlanesEnabled =\n      defined(clippingPlanes) && clippingPlanes.enabled && tile.isClipped;\n    if (clippingPlanesEnabled) {\n      uniformMapProperties.clippingPlanesEdgeColor = Color.clone(\n        clippingPlanes.edgeColor,\n        uniformMapProperties.clippingPlanesEdgeColor\n      );\n      uniformMapProperties.clippingPlanesEdgeWidth = clippingPlanes.edgeWidth;\n    }\n\n    surfaceShaderSetOptions.numberOfDayTextures = numberOfDayTextures;\n    surfaceShaderSetOptions.applyBrightness = applyBrightness;\n    surfaceShaderSetOptions.applyContrast = applyContrast;\n    surfaceShaderSetOptions.applyHue = applyHue;\n    surfaceShaderSetOptions.applySaturation = applySaturation;\n    surfaceShaderSetOptions.applyGamma = applyGamma;\n    surfaceShaderSetOptions.applyAlpha = applyAlpha;\n    surfaceShaderSetOptions.applyDayNightAlpha = applyDayNightAlpha;\n    surfaceShaderSetOptions.applySplit = applySplit;\n    surfaceShaderSetOptions.enableFog = applyFog;\n    surfaceShaderSetOptions.enableClippingPlanes = clippingPlanesEnabled;\n    surfaceShaderSetOptions.clippingPlanes = clippingPlanes;\n    surfaceShaderSetOptions.hasImageryLayerCutout = applyCutout;\n    surfaceShaderSetOptions.colorCorrect = colorCorrect;\n    surfaceShaderSetOptions.highlightFillTile = highlightFillTile;\n    surfaceShaderSetOptions.colorToAlpha = applyColorToAlpha;\n    surfaceShaderSetOptions.showUndergroundColor = showUndergroundColor;\n    surfaceShaderSetOptions.translucent = translucent;\n\n    var count = surfaceTile.renderedMesh.indices.length;\n    if (!showSkirts) {\n      count = surfaceTile.renderedMesh.indexCountWithoutSkirts;\n    }\n\n    command.shaderProgram = tileProvider._surfaceShaderSet.getShaderProgram(\n      surfaceShaderSetOptions\n    );\n    command.castShadows = castShadows;\n    command.receiveShadows = receiveShadows;\n    command.renderState = renderState;\n    command.primitiveType = PrimitiveType.TRIANGLES;\n    command.vertexArray =\n      surfaceTile.vertexArray || surfaceTile.fill.vertexArray;\n    command.count = count;\n    command.uniformMap = uniformMap;\n    command.pass = Pass.GLOBE;\n\n    if (tileProvider._debug.wireframe) {\n      createWireframeVertexArrayIfNecessary(context, tileProvider, tile);\n      if (defined(surfaceTile.wireframeVertexArray)) {\n        command.vertexArray = surfaceTile.wireframeVertexArray;\n        command.primitiveType = PrimitiveType.LINES;\n        command.count = count * 2;\n      }\n    }\n\n    var boundingVolume = command.boundingVolume;\n    var orientedBoundingBox = command.orientedBoundingBox;\n\n    if (frameState.mode !== SceneMode.SCENE3D) {\n      var tileBoundingRegion = surfaceTile.tileBoundingRegion;\n      BoundingSphere.fromRectangleWithHeights2D(\n        tile.rectangle,\n        frameState.mapProjection,\n        tileBoundingRegion.minimumHeight,\n        tileBoundingRegion.maximumHeight,\n        boundingVolume\n      );\n      Cartesian3.fromElements(\n        boundingVolume.center.z,\n        boundingVolume.center.x,\n        boundingVolume.center.y,\n        boundingVolume.center\n      );\n\n      if (frameState.mode === SceneMode.MORPHING) {\n        boundingVolume = BoundingSphere.union(\n          mesh.boundingSphere3D,\n          boundingVolume,\n          boundingVolume\n        );\n      }\n    } else {\n      command.boundingVolume = BoundingSphere.clone(\n        mesh.boundingSphere3D,\n        boundingVolume\n      );\n      command.orientedBoundingBox = OrientedBoundingBox.clone(\n        surfaceTile.orientedBoundingBox,\n        orientedBoundingBox\n      );\n    }\n\n    command.dirty = true;\n\n    if (translucent) {\n      globeTranslucencyState.updateDerivedCommands(command, frameState);\n    }\n\n    pushCommand(command, frameState);\n\n    renderState = otherPassesRenderState;\n    initialColor = otherPassesInitialColor;\n  } while (imageryIndex < imageryLen);\n}\nexport default GlobeSurfaceTileProvider;\n"]},"metadata":{},"sourceType":"module"}