{"ast":null,"code":"import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport PixelDatatype from \"./PixelDatatype.js\";\n/**\n * @private\n */\n\nfunction CubeMapFace(context, texture, textureTarget, targetFace, internalFormat, pixelFormat, pixelDatatype, size, preMultiplyAlpha, flipY, initialized) {\n  this._context = context;\n  this._texture = texture;\n  this._textureTarget = textureTarget;\n  this._targetFace = targetFace;\n  this._pixelDatatype = pixelDatatype;\n  this._internalFormat = internalFormat;\n  this._pixelFormat = pixelFormat;\n  this._size = size;\n  this._preMultiplyAlpha = preMultiplyAlpha;\n  this._flipY = flipY;\n  this._initialized = initialized;\n}\n\nObject.defineProperties(CubeMapFace.prototype, {\n  pixelFormat: {\n    get: function () {\n      return this._pixelFormat;\n    }\n  },\n  pixelDatatype: {\n    get: function () {\n      return this._pixelDatatype;\n    }\n  },\n  _target: {\n    get: function () {\n      return this._targetFace;\n    }\n  }\n});\n/**\n * Copies texels from the source to the cubemap's face.\n *\n * @param {Object} source The source ImageData, HTMLImageElement, HTMLCanvasElement, HTMLVideoElement, or an object with a width, height, and typed array as shown in the example.\n * @param {Number} [xOffset=0] An offset in the x direction in the cubemap where copying begins.\n * @param {Number} [yOffset=0] An offset in the y direction in the cubemap where copying begins.\n *\n * @exception {DeveloperError} xOffset must be greater than or equal to zero.\n * @exception {DeveloperError} yOffset must be greater than or equal to zero.\n * @exception {DeveloperError} xOffset + source.width must be less than or equal to width.\n * @exception {DeveloperError} yOffset + source.height must be less than or equal to height.\n * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.\n *\n * @example\n * // Create a cubemap with 1x1 faces, and make the +x face red.\n * var cubeMap = new CubeMap({\n *   context : context\n *   width : 1,\n *   height : 1\n * });\n * cubeMap.positiveX.copyFrom({\n *   width : 1,\n *   height : 1,\n *   arrayBufferView : new Uint8Array([255, 0, 0, 255])\n * });\n */\n\nCubeMapFace.prototype.copyFrom = function (source, xOffset, yOffset) {\n  xOffset = defaultValue(xOffset, 0);\n  yOffset = defaultValue(yOffset, 0); //>>includeStart('debug', pragmas.debug);\n\n  Check.defined(\"source\", source);\n  Check.typeOf.number.greaterThanOrEquals(\"xOffset\", xOffset, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"yOffset\", yOffset, 0);\n\n  if (xOffset + source.width > this._size) {\n    throw new DeveloperError(\"xOffset + source.width must be less than or equal to width.\");\n  }\n\n  if (yOffset + source.height > this._size) {\n    throw new DeveloperError(\"yOffset + source.height must be less than or equal to height.\");\n  } //>>includeEnd('debug');\n\n\n  var gl = this._context._gl;\n  var target = this._textureTarget;\n  var targetFace = this._targetFace;\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(target, this._texture);\n  var width = source.width;\n  var height = source.height;\n  var arrayBufferView = source.arrayBufferView;\n  var size = this._size;\n  var pixelFormat = this._pixelFormat;\n  var internalFormat = this._internalFormat;\n  var pixelDatatype = this._pixelDatatype;\n  var preMultiplyAlpha = this._preMultiplyAlpha;\n  var flipY = this._flipY;\n  var unpackAlignment = 4;\n\n  if (defined(arrayBufferView)) {\n    unpackAlignment = PixelFormat.alignmentInBytes(pixelFormat, pixelDatatype, width);\n  }\n\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);\n  var uploaded = false;\n\n  if (!this._initialized) {\n    if (xOffset === 0 && yOffset === 0 && width === size && height === size) {\n      // initialize the entire texture\n      if (defined(arrayBufferView)) {\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n\n        if (flipY) {\n          arrayBufferView = PixelFormat.flipY(arrayBufferView, pixelFormat, pixelDatatype, size, size);\n        }\n\n        gl.texImage2D(targetFace, 0, internalFormat, size, size, 0, pixelFormat, PixelDatatype.toWebGLConstant(pixelDatatype, this._context), arrayBufferView);\n      } else {\n        // Only valid for DOM-Element uploads\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);\n        gl.texImage2D(targetFace, 0, internalFormat, pixelFormat, PixelDatatype.toWebGLConstant(pixelDatatype, this._context), source);\n      }\n\n      uploaded = true;\n    } else {\n      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false); // initialize the entire texture to zero\n\n      var bufferView = PixelFormat.createTypedArray(pixelFormat, pixelDatatype, size, size);\n      gl.texImage2D(targetFace, 0, internalFormat, size, size, 0, pixelFormat, PixelDatatype.toWebGLConstant(pixelDatatype, this._context), bufferView);\n    }\n\n    this._initialized = true;\n  }\n\n  if (!uploaded) {\n    if (defined(arrayBufferView)) {\n      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n\n      if (flipY) {\n        arrayBufferView = PixelFormat.flipY(arrayBufferView, pixelFormat, pixelDatatype, width, height);\n      }\n\n      gl.texSubImage2D(targetFace, 0, xOffset, yOffset, width, height, pixelFormat, PixelDatatype.toWebGLConstant(pixelDatatype, this._context), arrayBufferView);\n    } else {\n      // Only valid for DOM-Element uploads\n      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);\n      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY); // Source: ImageData, HTMLImageElement, HTMLCanvasElement, or HTMLVideoElement\n\n      gl.texSubImage2D(targetFace, 0, xOffset, yOffset, pixelFormat, PixelDatatype.toWebGLConstant(pixelDatatype, this._context), source);\n    }\n  }\n\n  gl.bindTexture(target, null);\n};\n/**\n * Copies texels from the framebuffer to the cubemap's face.\n *\n * @param {Number} [xOffset=0] An offset in the x direction in the cubemap where copying begins.\n * @param {Number} [yOffset=0] An offset in the y direction in the cubemap where copying begins.\n * @param {Number} [framebufferXOffset=0] An offset in the x direction in the framebuffer where copying begins from.\n * @param {Number} [framebufferYOffset=0] An offset in the y direction in the framebuffer where copying begins from.\n * @param {Number} [width=CubeMap's width] The width of the subimage to copy.\n * @param {Number} [height=CubeMap's height] The height of the subimage to copy.\n *\n * @exception {DeveloperError} Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT.\n * @exception {DeveloperError} Cannot call copyFromFramebuffer when the texture pixel data type is HALF_FLOAT.\n * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.\n * @exception {DeveloperError} xOffset must be greater than or equal to zero.\n * @exception {DeveloperError} yOffset must be greater than or equal to zero.\n * @exception {DeveloperError} framebufferXOffset must be greater than or equal to zero.\n * @exception {DeveloperError} framebufferYOffset must be greater than or equal to zero.\n * @exception {DeveloperError} xOffset + source.width must be less than or equal to width.\n * @exception {DeveloperError} yOffset + source.height must be less than or equal to height.\n * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.\n *\n * @example\n * // Copy the framebuffer contents to the +x cube map face.\n * cubeMap.positiveX.copyFromFramebuffer();\n */\n\n\nCubeMapFace.prototype.copyFromFramebuffer = function (xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height) {\n  xOffset = defaultValue(xOffset, 0);\n  yOffset = defaultValue(yOffset, 0);\n  framebufferXOffset = defaultValue(framebufferXOffset, 0);\n  framebufferYOffset = defaultValue(framebufferYOffset, 0);\n  width = defaultValue(width, this._size);\n  height = defaultValue(height, this._size); //>>includeStart('debug', pragmas.debug);\n\n  Check.typeOf.number.greaterThanOrEquals(\"xOffset\", xOffset, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"yOffset\", yOffset, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"framebufferXOffset\", framebufferXOffset, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"framebufferYOffset\", framebufferYOffset, 0);\n\n  if (xOffset + width > this._size) {\n    throw new DeveloperError(\"xOffset + source.width must be less than or equal to width.\");\n  }\n\n  if (yOffset + height > this._size) {\n    throw new DeveloperError(\"yOffset + source.height must be less than or equal to height.\");\n  }\n\n  if (this._pixelDatatype === PixelDatatype.FLOAT) {\n    throw new DeveloperError(\"Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT.\");\n  }\n\n  if (this._pixelDatatype === PixelDatatype.HALF_FLOAT) {\n    throw new DeveloperError(\"Cannot call copyFromFramebuffer when the texture pixel data type is HALF_FLOAT.\");\n  } //>>includeEnd('debug');\n\n\n  var gl = this._context._gl;\n  var target = this._textureTarget;\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(target, this._texture);\n  gl.copyTexSubImage2D(this._targetFace, 0, xOffset, yOffset, framebufferXOffset, framebufferYOffset, width, height);\n  gl.bindTexture(target, null);\n  this._initialized = true;\n};\n\nexport default CubeMapFace;","map":{"version":3,"sources":["/home/usuario/davi/thalamus/wms/3dmaptestes/leaflet_cesium/client/node_modules/cesium/Source/Renderer/CubeMapFace.js"],"names":["Check","defaultValue","defined","DeveloperError","PixelFormat","PixelDatatype","CubeMapFace","context","texture","textureTarget","targetFace","internalFormat","pixelFormat","pixelDatatype","size","preMultiplyAlpha","flipY","initialized","_context","_texture","_textureTarget","_targetFace","_pixelDatatype","_internalFormat","_pixelFormat","_size","_preMultiplyAlpha","_flipY","_initialized","Object","defineProperties","prototype","get","_target","copyFrom","source","xOffset","yOffset","typeOf","number","greaterThanOrEquals","width","height","gl","_gl","target","activeTexture","TEXTURE0","bindTexture","arrayBufferView","unpackAlignment","alignmentInBytes","pixelStorei","UNPACK_ALIGNMENT","uploaded","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_FLIP_Y_WEBGL","texImage2D","toWebGLConstant","bufferView","createTypedArray","texSubImage2D","copyFromFramebuffer","framebufferXOffset","framebufferYOffset","FLOAT","HALF_FLOAT","copyTexSubImage2D"],"mappings":"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","sourcesContent":["import Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport PixelFormat from \"../Core/PixelFormat.js\";\nimport PixelDatatype from \"./PixelDatatype.js\";\n\n/**\n * @private\n */\nfunction CubeMapFace(\n  context,\n  texture,\n  textureTarget,\n  targetFace,\n  internalFormat,\n  pixelFormat,\n  pixelDatatype,\n  size,\n  preMultiplyAlpha,\n  flipY,\n  initialized\n) {\n  this._context = context;\n  this._texture = texture;\n  this._textureTarget = textureTarget;\n  this._targetFace = targetFace;\n  this._pixelDatatype = pixelDatatype;\n  this._internalFormat = internalFormat;\n  this._pixelFormat = pixelFormat;\n  this._size = size;\n  this._preMultiplyAlpha = preMultiplyAlpha;\n  this._flipY = flipY;\n  this._initialized = initialized;\n}\n\nObject.defineProperties(CubeMapFace.prototype, {\n  pixelFormat: {\n    get: function () {\n      return this._pixelFormat;\n    },\n  },\n  pixelDatatype: {\n    get: function () {\n      return this._pixelDatatype;\n    },\n  },\n  _target: {\n    get: function () {\n      return this._targetFace;\n    },\n  },\n});\n\n/**\n * Copies texels from the source to the cubemap's face.\n *\n * @param {Object} source The source ImageData, HTMLImageElement, HTMLCanvasElement, HTMLVideoElement, or an object with a width, height, and typed array as shown in the example.\n * @param {Number} [xOffset=0] An offset in the x direction in the cubemap where copying begins.\n * @param {Number} [yOffset=0] An offset in the y direction in the cubemap where copying begins.\n *\n * @exception {DeveloperError} xOffset must be greater than or equal to zero.\n * @exception {DeveloperError} yOffset must be greater than or equal to zero.\n * @exception {DeveloperError} xOffset + source.width must be less than or equal to width.\n * @exception {DeveloperError} yOffset + source.height must be less than or equal to height.\n * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.\n *\n * @example\n * // Create a cubemap with 1x1 faces, and make the +x face red.\n * var cubeMap = new CubeMap({\n *   context : context\n *   width : 1,\n *   height : 1\n * });\n * cubeMap.positiveX.copyFrom({\n *   width : 1,\n *   height : 1,\n *   arrayBufferView : new Uint8Array([255, 0, 0, 255])\n * });\n */\nCubeMapFace.prototype.copyFrom = function (source, xOffset, yOffset) {\n  xOffset = defaultValue(xOffset, 0);\n  yOffset = defaultValue(yOffset, 0);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"source\", source);\n  Check.typeOf.number.greaterThanOrEquals(\"xOffset\", xOffset, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"yOffset\", yOffset, 0);\n  if (xOffset + source.width > this._size) {\n    throw new DeveloperError(\n      \"xOffset + source.width must be less than or equal to width.\"\n    );\n  }\n  if (yOffset + source.height > this._size) {\n    throw new DeveloperError(\n      \"yOffset + source.height must be less than or equal to height.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var gl = this._context._gl;\n  var target = this._textureTarget;\n  var targetFace = this._targetFace;\n\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(target, this._texture);\n\n  var width = source.width;\n  var height = source.height;\n  var arrayBufferView = source.arrayBufferView;\n\n  var size = this._size;\n  var pixelFormat = this._pixelFormat;\n  var internalFormat = this._internalFormat;\n  var pixelDatatype = this._pixelDatatype;\n\n  var preMultiplyAlpha = this._preMultiplyAlpha;\n  var flipY = this._flipY;\n\n  var unpackAlignment = 4;\n  if (defined(arrayBufferView)) {\n    unpackAlignment = PixelFormat.alignmentInBytes(\n      pixelFormat,\n      pixelDatatype,\n      width\n    );\n  }\n\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);\n\n  var uploaded = false;\n  if (!this._initialized) {\n    if (xOffset === 0 && yOffset === 0 && width === size && height === size) {\n      // initialize the entire texture\n      if (defined(arrayBufferView)) {\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n\n        if (flipY) {\n          arrayBufferView = PixelFormat.flipY(\n            arrayBufferView,\n            pixelFormat,\n            pixelDatatype,\n            size,\n            size\n          );\n        }\n        gl.texImage2D(\n          targetFace,\n          0,\n          internalFormat,\n          size,\n          size,\n          0,\n          pixelFormat,\n          PixelDatatype.toWebGLConstant(pixelDatatype, this._context),\n          arrayBufferView\n        );\n      } else {\n        // Only valid for DOM-Element uploads\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);\n\n        gl.texImage2D(\n          targetFace,\n          0,\n          internalFormat,\n          pixelFormat,\n          PixelDatatype.toWebGLConstant(pixelDatatype, this._context),\n          source\n        );\n      }\n      uploaded = true;\n    } else {\n      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n\n      // initialize the entire texture to zero\n      var bufferView = PixelFormat.createTypedArray(\n        pixelFormat,\n        pixelDatatype,\n        size,\n        size\n      );\n      gl.texImage2D(\n        targetFace,\n        0,\n        internalFormat,\n        size,\n        size,\n        0,\n        pixelFormat,\n        PixelDatatype.toWebGLConstant(pixelDatatype, this._context),\n        bufferView\n      );\n    }\n    this._initialized = true;\n  }\n\n  if (!uploaded) {\n    if (defined(arrayBufferView)) {\n      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n\n      if (flipY) {\n        arrayBufferView = PixelFormat.flipY(\n          arrayBufferView,\n          pixelFormat,\n          pixelDatatype,\n          width,\n          height\n        );\n      }\n      gl.texSubImage2D(\n        targetFace,\n        0,\n        xOffset,\n        yOffset,\n        width,\n        height,\n        pixelFormat,\n        PixelDatatype.toWebGLConstant(pixelDatatype, this._context),\n        arrayBufferView\n      );\n    } else {\n      // Only valid for DOM-Element uploads\n      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, preMultiplyAlpha);\n      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);\n\n      // Source: ImageData, HTMLImageElement, HTMLCanvasElement, or HTMLVideoElement\n      gl.texSubImage2D(\n        targetFace,\n        0,\n        xOffset,\n        yOffset,\n        pixelFormat,\n        PixelDatatype.toWebGLConstant(pixelDatatype, this._context),\n        source\n      );\n    }\n  }\n\n  gl.bindTexture(target, null);\n};\n\n/**\n * Copies texels from the framebuffer to the cubemap's face.\n *\n * @param {Number} [xOffset=0] An offset in the x direction in the cubemap where copying begins.\n * @param {Number} [yOffset=0] An offset in the y direction in the cubemap where copying begins.\n * @param {Number} [framebufferXOffset=0] An offset in the x direction in the framebuffer where copying begins from.\n * @param {Number} [framebufferYOffset=0] An offset in the y direction in the framebuffer where copying begins from.\n * @param {Number} [width=CubeMap's width] The width of the subimage to copy.\n * @param {Number} [height=CubeMap's height] The height of the subimage to copy.\n *\n * @exception {DeveloperError} Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT.\n * @exception {DeveloperError} Cannot call copyFromFramebuffer when the texture pixel data type is HALF_FLOAT.\n * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.\n * @exception {DeveloperError} xOffset must be greater than or equal to zero.\n * @exception {DeveloperError} yOffset must be greater than or equal to zero.\n * @exception {DeveloperError} framebufferXOffset must be greater than or equal to zero.\n * @exception {DeveloperError} framebufferYOffset must be greater than or equal to zero.\n * @exception {DeveloperError} xOffset + source.width must be less than or equal to width.\n * @exception {DeveloperError} yOffset + source.height must be less than or equal to height.\n * @exception {DeveloperError} This CubeMap was destroyed, i.e., destroy() was called.\n *\n * @example\n * // Copy the framebuffer contents to the +x cube map face.\n * cubeMap.positiveX.copyFromFramebuffer();\n */\nCubeMapFace.prototype.copyFromFramebuffer = function (\n  xOffset,\n  yOffset,\n  framebufferXOffset,\n  framebufferYOffset,\n  width,\n  height\n) {\n  xOffset = defaultValue(xOffset, 0);\n  yOffset = defaultValue(yOffset, 0);\n  framebufferXOffset = defaultValue(framebufferXOffset, 0);\n  framebufferYOffset = defaultValue(framebufferYOffset, 0);\n  width = defaultValue(width, this._size);\n  height = defaultValue(height, this._size);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"xOffset\", xOffset, 0);\n  Check.typeOf.number.greaterThanOrEquals(\"yOffset\", yOffset, 0);\n  Check.typeOf.number.greaterThanOrEquals(\n    \"framebufferXOffset\",\n    framebufferXOffset,\n    0\n  );\n  Check.typeOf.number.greaterThanOrEquals(\n    \"framebufferYOffset\",\n    framebufferYOffset,\n    0\n  );\n  if (xOffset + width > this._size) {\n    throw new DeveloperError(\n      \"xOffset + source.width must be less than or equal to width.\"\n    );\n  }\n  if (yOffset + height > this._size) {\n    throw new DeveloperError(\n      \"yOffset + source.height must be less than or equal to height.\"\n    );\n  }\n  if (this._pixelDatatype === PixelDatatype.FLOAT) {\n    throw new DeveloperError(\n      \"Cannot call copyFromFramebuffer when the texture pixel data type is FLOAT.\"\n    );\n  }\n  if (this._pixelDatatype === PixelDatatype.HALF_FLOAT) {\n    throw new DeveloperError(\n      \"Cannot call copyFromFramebuffer when the texture pixel data type is HALF_FLOAT.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var gl = this._context._gl;\n  var target = this._textureTarget;\n\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(target, this._texture);\n  gl.copyTexSubImage2D(\n    this._targetFace,\n    0,\n    xOffset,\n    yOffset,\n    framebufferXOffset,\n    framebufferYOffset,\n    width,\n    height\n  );\n  gl.bindTexture(target, null);\n  this._initialized = true;\n};\nexport default CubeMapFace;\n"]},"metadata":{},"sourceType":"module"}