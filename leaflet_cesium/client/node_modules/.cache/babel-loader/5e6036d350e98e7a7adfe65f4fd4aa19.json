{"ast":null,"code":"import defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport webGLConstantToGlslType from \"../Core/webGLConstantToGlslType.js\";\nimport addToArray from \"../ThirdParty/GltfPipeline/addToArray.js\";\nimport ForEach from \"../ThirdParty/GltfPipeline/ForEach.js\";\nimport hasExtension from \"../ThirdParty/GltfPipeline/hasExtension.js\";\nimport ModelUtility from \"./ModelUtility.js\";\n/**\n * @private\n */\n\nfunction processModelMaterialsCommon(gltf, options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  if (!defined(gltf)) {\n    return;\n  }\n\n  if (!hasExtension(gltf, \"KHR_materials_common\")) {\n    return;\n  }\n\n  if (!hasExtension(gltf, \"KHR_techniques_webgl\")) {\n    if (!defined(gltf.extensions)) {\n      gltf.extensions = {};\n    }\n\n    gltf.extensions.KHR_techniques_webgl = {\n      programs: [],\n      shaders: [],\n      techniques: []\n    };\n    gltf.extensionsUsed.push(\"KHR_techniques_webgl\");\n    gltf.extensionsRequired.push(\"KHR_techniques_webgl\");\n  }\n\n  var techniquesWebgl = gltf.extensions.KHR_techniques_webgl;\n  lightDefaults(gltf);\n  var lightParameters = generateLightParameters(gltf);\n  var primitiveByMaterial = ModelUtility.splitIncompatibleMaterials(gltf);\n  var techniques = {};\n  var generatedTechniques = false;\n  ForEach.material(gltf, function (material, materialIndex) {\n    if (defined(material.extensions) && defined(material.extensions.KHR_materials_common)) {\n      var khrMaterialsCommon = material.extensions.KHR_materials_common;\n      var primitiveInfo = primitiveByMaterial[materialIndex];\n      var techniqueKey = getTechniqueKey(khrMaterialsCommon, primitiveInfo);\n      var technique = techniques[techniqueKey];\n\n      if (!defined(technique)) {\n        technique = generateTechnique(gltf, techniquesWebgl, primitiveInfo, khrMaterialsCommon, lightParameters, options.addBatchIdToGeneratedShaders);\n        techniques[techniqueKey] = technique;\n        generatedTechniques = true;\n      }\n\n      var materialValues = {};\n      var values = khrMaterialsCommon.values;\n      var uniformName;\n\n      for (var valueName in values) {\n        if (values.hasOwnProperty(valueName) && valueName !== \"transparent\" && valueName !== \"doubleSided\") {\n          uniformName = \"u_\" + valueName.toLowerCase();\n          materialValues[uniformName] = values[valueName];\n        }\n      }\n\n      material.extensions.KHR_techniques_webgl = {\n        technique: technique,\n        values: materialValues\n      };\n      material.alphaMode = \"OPAQUE\";\n\n      if (khrMaterialsCommon.transparent) {\n        material.alphaMode = \"BLEND\";\n      }\n\n      if (khrMaterialsCommon.doubleSided) {\n        material.doubleSided = true;\n      }\n    }\n  });\n\n  if (!generatedTechniques) {\n    return gltf;\n  } // If any primitives have semantics that aren't declared in the generated\n  // shaders, we want to preserve them.\n\n\n  ModelUtility.ensureSemanticExistence(gltf);\n  return gltf;\n}\n\nfunction generateLightParameters(gltf) {\n  var result = {};\n  var lights;\n\n  if (defined(gltf.extensions) && defined(gltf.extensions.KHR_materials_common)) {\n    lights = gltf.extensions.KHR_materials_common.lights;\n  }\n\n  if (defined(lights)) {\n    // Figure out which node references the light\n    var nodes = gltf.nodes;\n\n    for (var nodeName in nodes) {\n      if (nodes.hasOwnProperty(nodeName)) {\n        var node = nodes[nodeName];\n\n        if (defined(node.extensions) && defined(node.extensions.KHR_materials_common)) {\n          var nodeLightId = node.extensions.KHR_materials_common.light;\n\n          if (defined(nodeLightId) && defined(lights[nodeLightId])) {\n            lights[nodeLightId].node = nodeName;\n          }\n\n          delete node.extensions.KHR_materials_common;\n        }\n      }\n    } // Add light parameters to result\n\n\n    var lightCount = 0;\n\n    for (var lightName in lights) {\n      if (lights.hasOwnProperty(lightName)) {\n        var light = lights[lightName];\n        var lightType = light.type;\n\n        if (lightType !== \"ambient\" && !defined(light.node)) {\n          delete lights[lightName];\n          continue;\n        }\n\n        var lightBaseName = \"light\" + lightCount.toString();\n        light.baseName = lightBaseName;\n\n        switch (lightType) {\n          case \"ambient\":\n            var ambient = light.ambient;\n            result[lightBaseName + \"Color\"] = {\n              type: WebGLConstants.FLOAT_VEC3,\n              value: ambient.color\n            };\n            break;\n\n          case \"directional\":\n            var directional = light.directional;\n            result[lightBaseName + \"Color\"] = {\n              type: WebGLConstants.FLOAT_VEC3,\n              value: directional.color\n            };\n\n            if (defined(light.node)) {\n              result[lightBaseName + \"Transform\"] = {\n                node: light.node,\n                semantic: \"MODELVIEW\",\n                type: WebGLConstants.FLOAT_MAT4\n              };\n            }\n\n            break;\n\n          case \"point\":\n            var point = light.point;\n            result[lightBaseName + \"Color\"] = {\n              type: WebGLConstants.FLOAT_VEC3,\n              value: point.color\n            };\n\n            if (defined(light.node)) {\n              result[lightBaseName + \"Transform\"] = {\n                node: light.node,\n                semantic: \"MODELVIEW\",\n                type: WebGLConstants.FLOAT_MAT4\n              };\n            }\n\n            result[lightBaseName + \"Attenuation\"] = {\n              type: WebGLConstants.FLOAT_VEC3,\n              value: [point.constantAttenuation, point.linearAttenuation, point.quadraticAttenuation]\n            };\n            break;\n\n          case \"spot\":\n            var spot = light.spot;\n            result[lightBaseName + \"Color\"] = {\n              type: WebGLConstants.FLOAT_VEC3,\n              value: spot.color\n            };\n\n            if (defined(light.node)) {\n              result[lightBaseName + \"Transform\"] = {\n                node: light.node,\n                semantic: \"MODELVIEW\",\n                type: WebGLConstants.FLOAT_MAT4\n              };\n              result[lightBaseName + \"InverseTransform\"] = {\n                node: light.node,\n                semantic: \"MODELVIEWINVERSE\",\n                type: WebGLConstants.FLOAT_MAT4,\n                useInFragment: true\n              };\n            }\n\n            result[lightBaseName + \"Attenuation\"] = {\n              type: WebGLConstants.FLOAT_VEC3,\n              value: [spot.constantAttenuation, spot.linearAttenuation, spot.quadraticAttenuation]\n            };\n            result[lightBaseName + \"FallOff\"] = {\n              type: WebGLConstants.FLOAT_VEC2,\n              value: [spot.fallOffAngle, spot.fallOffExponent]\n            };\n            break;\n        }\n\n        ++lightCount;\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction generateTechnique(gltf, techniquesWebgl, primitiveInfo, khrMaterialsCommon, lightParameters, addBatchIdToGeneratedShaders) {\n  if (!defined(khrMaterialsCommon)) {\n    khrMaterialsCommon = {};\n  }\n\n  addBatchIdToGeneratedShaders = defaultValue(addBatchIdToGeneratedShaders, false);\n  var techniques = techniquesWebgl.techniques;\n  var shaders = techniquesWebgl.shaders;\n  var programs = techniquesWebgl.programs;\n  var lightingModel = khrMaterialsCommon.technique.toUpperCase();\n  var lights;\n\n  if (defined(gltf.extensions) && defined(gltf.extensions.KHR_materials_common)) {\n    lights = gltf.extensions.KHR_materials_common.lights;\n  }\n\n  var parameterValues = khrMaterialsCommon.values;\n  var jointCount = defaultValue(khrMaterialsCommon.jointCount, 0);\n  var skinningInfo;\n  var hasSkinning = false;\n  var hasVertexColors = false;\n\n  if (defined(primitiveInfo)) {\n    skinningInfo = primitiveInfo.skinning;\n    hasSkinning = skinningInfo.skinned;\n    hasVertexColors = primitiveInfo.hasVertexColors;\n  }\n\n  var vertexShader = \"precision highp float;\\n\";\n  var fragmentShader = \"precision highp float;\\n\";\n  var hasNormals = lightingModel !== \"CONSTANT\"; // Add techniques\n\n  var techniqueUniforms = {\n    u_modelViewMatrix: {\n      semantic: hasExtension(gltf, \"CESIUM_RTC\") ? \"CESIUM_RTC_MODELVIEW\" : \"MODELVIEW\",\n      type: WebGLConstants.FLOAT_MAT4\n    },\n    u_projectionMatrix: {\n      semantic: \"PROJECTION\",\n      type: WebGLConstants.FLOAT_MAT4\n    }\n  };\n\n  if (hasNormals) {\n    techniqueUniforms.u_normalMatrix = {\n      semantic: \"MODELVIEWINVERSETRANSPOSE\",\n      type: WebGLConstants.FLOAT_MAT3\n    };\n  }\n\n  if (hasSkinning) {\n    techniqueUniforms.u_jointMatrix = {\n      count: jointCount,\n      semantic: \"JOINTMATRIX\",\n      type: WebGLConstants.FLOAT_MAT4\n    };\n  } // Add material values\n\n\n  var uniformName;\n  var hasTexCoords = false;\n\n  for (var name in parameterValues) {\n    //generate shader parameters for KHR_materials_common attributes\n    //(including a check, because some boolean flags should not be used as shader parameters)\n    if (parameterValues.hasOwnProperty(name) && name !== \"transparent\" && name !== \"doubleSided\") {\n      var uniformType = getKHRMaterialsCommonValueType(name, parameterValues[name]);\n      uniformName = \"u_\" + name.toLowerCase();\n\n      if (!hasTexCoords && uniformType === WebGLConstants.SAMPLER_2D) {\n        hasTexCoords = true;\n      }\n\n      techniqueUniforms[uniformName] = {\n        type: uniformType\n      };\n    }\n  } // Give the diffuse uniform a semantic to support color replacement in 3D Tiles\n\n\n  if (defined(techniqueUniforms.u_diffuse)) {\n    techniqueUniforms.u_diffuse.semantic = \"_3DTILESDIFFUSE\";\n  } // Copy light parameters into technique parameters\n\n\n  if (defined(lightParameters)) {\n    for (var lightParamName in lightParameters) {\n      if (lightParameters.hasOwnProperty(lightParamName)) {\n        uniformName = \"u_\" + lightParamName;\n        techniqueUniforms[uniformName] = lightParameters[lightParamName];\n      }\n    }\n  } // Add uniforms to shaders\n\n\n  for (uniformName in techniqueUniforms) {\n    if (techniqueUniforms.hasOwnProperty(uniformName)) {\n      var uniform = techniqueUniforms[uniformName];\n      var arraySize = defined(uniform.count) ? \"[\" + uniform.count + \"]\" : \"\";\n\n      if (uniform.type !== WebGLConstants.FLOAT_MAT3 && uniform.type !== WebGLConstants.FLOAT_MAT4 || uniform.useInFragment) {\n        fragmentShader += \"uniform \" + webGLConstantToGlslType(uniform.type) + \" \" + uniformName + arraySize + \";\\n\";\n        delete uniform.useInFragment;\n      } else {\n        vertexShader += \"uniform \" + webGLConstantToGlslType(uniform.type) + \" \" + uniformName + arraySize + \";\\n\";\n      }\n    }\n  } // Add attributes with semantics\n\n\n  var vertexShaderMain = \"\";\n\n  if (hasSkinning) {\n    vertexShaderMain += \"    mat4 skinMatrix =\\n\" + \"        a_weight.x * u_jointMatrix[int(a_joint.x)] +\\n\" + \"        a_weight.y * u_jointMatrix[int(a_joint.y)] +\\n\" + \"        a_weight.z * u_jointMatrix[int(a_joint.z)] +\\n\" + \"        a_weight.w * u_jointMatrix[int(a_joint.w)];\\n\";\n  } // Add position always\n\n\n  var techniqueAttributes = {\n    a_position: {\n      semantic: \"POSITION\"\n    }\n  };\n  vertexShader += \"attribute vec3 a_position;\\n\";\n  vertexShader += \"varying vec3 v_positionEC;\\n\";\n\n  if (hasSkinning) {\n    vertexShaderMain += \"  vec4 pos = u_modelViewMatrix * skinMatrix * vec4(a_position,1.0);\\n\";\n  } else {\n    vertexShaderMain += \"  vec4 pos = u_modelViewMatrix * vec4(a_position,1.0);\\n\";\n  }\n\n  vertexShaderMain += \"  v_positionEC = pos.xyz;\\n\";\n  vertexShaderMain += \"  gl_Position = u_projectionMatrix * pos;\\n\";\n  fragmentShader += \"varying vec3 v_positionEC;\\n\"; // Add normal if we don't have constant lighting\n\n  if (hasNormals) {\n    techniqueAttributes.a_normal = {\n      semantic: \"NORMAL\"\n    };\n    vertexShader += \"attribute vec3 a_normal;\\n\";\n    vertexShader += \"varying vec3 v_normal;\\n\";\n\n    if (hasSkinning) {\n      vertexShaderMain += \"  v_normal = u_normalMatrix * mat3(skinMatrix) * a_normal;\\n\";\n    } else {\n      vertexShaderMain += \"  v_normal = u_normalMatrix * a_normal;\\n\";\n    }\n\n    fragmentShader += \"varying vec3 v_normal;\\n\";\n  } // Add texture coordinates if the material uses them\n\n\n  var v_texcoord;\n\n  if (hasTexCoords) {\n    techniqueAttributes.a_texcoord_0 = {\n      semantic: \"TEXCOORD_0\"\n    };\n    v_texcoord = \"v_texcoord_0\";\n    vertexShader += \"attribute vec2 a_texcoord_0;\\n\";\n    vertexShader += \"varying vec2 \" + v_texcoord + \";\\n\";\n    vertexShaderMain += \"  \" + v_texcoord + \" = a_texcoord_0;\\n\";\n    fragmentShader += \"varying vec2 \" + v_texcoord + \";\\n\";\n  }\n\n  if (hasSkinning) {\n    techniqueAttributes.a_joint = {\n      semantic: \"JOINTS_0\"\n    };\n    techniqueAttributes.a_weight = {\n      semantic: \"WEIGHTS_0\"\n    };\n    vertexShader += \"attribute vec4 a_joint;\\n\";\n    vertexShader += \"attribute vec4 a_weight;\\n\";\n  }\n\n  if (hasVertexColors) {\n    techniqueAttributes.a_vertexColor = {\n      semantic: \"COLOR_0\"\n    };\n    vertexShader += \"attribute vec4 a_vertexColor;\\n\";\n    vertexShader += \"varying vec4 v_vertexColor;\\n\";\n    vertexShaderMain += \"  v_vertexColor = a_vertexColor;\\n\";\n    fragmentShader += \"varying vec4 v_vertexColor;\\n\";\n  }\n\n  if (addBatchIdToGeneratedShaders) {\n    techniqueAttributes.a_batchId = {\n      semantic: \"_BATCHID\"\n    };\n    vertexShader += \"attribute float a_batchId;\\n\";\n  }\n\n  var hasSpecular = hasNormals && (lightingModel === \"BLINN\" || lightingModel === \"PHONG\") && defined(techniqueUniforms.u_specular) && defined(techniqueUniforms.u_shininess) && techniqueUniforms.u_shininess > 0.0; // Generate lighting code blocks\n\n  var hasNonAmbientLights = false;\n  var hasAmbientLights = false;\n  var fragmentLightingBlock = \"\";\n\n  for (var lightName in lights) {\n    if (lights.hasOwnProperty(lightName)) {\n      var light = lights[lightName];\n      var lightType = light.type.toLowerCase();\n      var lightBaseName = light.baseName;\n      fragmentLightingBlock += \"  {\\n\";\n      var lightColorName = \"u_\" + lightBaseName + \"Color\";\n      var varyingDirectionName;\n      var varyingPositionName;\n\n      if (lightType === \"ambient\") {\n        hasAmbientLights = true;\n        fragmentLightingBlock += \"    ambientLight += \" + lightColorName + \";\\n\";\n      } else if (hasNormals) {\n        hasNonAmbientLights = true;\n        varyingDirectionName = \"v_\" + lightBaseName + \"Direction\";\n        varyingPositionName = \"v_\" + lightBaseName + \"Position\";\n\n        if (lightType !== \"point\") {\n          vertexShader += \"varying vec3 \" + varyingDirectionName + \";\\n\";\n          fragmentShader += \"varying vec3 \" + varyingDirectionName + \";\\n\";\n          vertexShaderMain += \"  \" + varyingDirectionName + \" = mat3(u_\" + lightBaseName + \"Transform) * vec3(0.,0.,1.);\\n\";\n\n          if (lightType === \"directional\") {\n            fragmentLightingBlock += \"    vec3 l = normalize(\" + varyingDirectionName + \");\\n\";\n          }\n        }\n\n        if (lightType !== \"directional\") {\n          vertexShader += \"varying vec3 \" + varyingPositionName + \";\\n\";\n          fragmentShader += \"varying vec3 \" + varyingPositionName + \";\\n\";\n          vertexShaderMain += \"  \" + varyingPositionName + \" = u_\" + lightBaseName + \"Transform[3].xyz;\\n\";\n          fragmentLightingBlock += \"    vec3 VP = \" + varyingPositionName + \" - v_positionEC;\\n\";\n          fragmentLightingBlock += \"    vec3 l = normalize(VP);\\n\";\n          fragmentLightingBlock += \"    float range = length(VP);\\n\";\n          fragmentLightingBlock += \"    float attenuation = 1.0 / (u_\" + lightBaseName + \"Attenuation.x + \";\n          fragmentLightingBlock += \"(u_\" + lightBaseName + \"Attenuation.y * range) + \";\n          fragmentLightingBlock += \"(u_\" + lightBaseName + \"Attenuation.z * range * range));\\n\";\n        } else {\n          fragmentLightingBlock += \"    float attenuation = 1.0;\\n\";\n        }\n\n        if (lightType === \"spot\") {\n          fragmentLightingBlock += \"    float spotDot = dot(l, normalize(\" + varyingDirectionName + \"));\\n\";\n          fragmentLightingBlock += \"    if (spotDot < cos(u_\" + lightBaseName + \"FallOff.x * 0.5))\\n\";\n          fragmentLightingBlock += \"    {\\n\";\n          fragmentLightingBlock += \"      attenuation = 0.0;\\n\";\n          fragmentLightingBlock += \"    }\\n\";\n          fragmentLightingBlock += \"    else\\n\";\n          fragmentLightingBlock += \"    {\\n\";\n          fragmentLightingBlock += \"        attenuation *= max(0.0, pow(spotDot, u_\" + lightBaseName + \"FallOff.y));\\n\";\n          fragmentLightingBlock += \"    }\\n\";\n        }\n\n        fragmentLightingBlock += \"    diffuseLight += \" + lightColorName + \"* max(dot(normal,l), 0.) * attenuation;\\n\";\n\n        if (hasSpecular) {\n          if (lightingModel === \"BLINN\") {\n            fragmentLightingBlock += \"    vec3 h = normalize(l + viewDir);\\n\";\n            fragmentLightingBlock += \"    float specularIntensity = max(0., pow(max(dot(normal, h), 0.), u_shininess)) * attenuation;\\n\";\n          } else {\n            // PHONG\n            fragmentLightingBlock += \"    vec3 reflectDir = reflect(-l, normal);\\n\";\n            fragmentLightingBlock += \"    float specularIntensity = max(0., pow(max(dot(reflectDir, viewDir), 0.), u_shininess)) * attenuation;\\n\";\n          }\n\n          fragmentLightingBlock += \"    specularLight += \" + lightColorName + \" * specularIntensity;\\n\";\n        }\n      }\n\n      fragmentLightingBlock += \"  }\\n\";\n    }\n  }\n\n  if (!hasAmbientLights) {\n    // Add an ambient light if we don't have one\n    fragmentLightingBlock += \"  ambientLight += vec3(0.2, 0.2, 0.2);\\n\";\n  }\n\n  if (!hasNonAmbientLights && lightingModel !== \"CONSTANT\") {\n    fragmentShader += \"#ifdef USE_CUSTOM_LIGHT_COLOR \\n\";\n    fragmentShader += \"uniform vec3 gltf_lightColor; \\n\";\n    fragmentShader += \"#endif \\n\";\n    fragmentLightingBlock += \"#ifndef USE_CUSTOM_LIGHT_COLOR \\n\";\n    fragmentLightingBlock += \"    vec3 lightColor = czm_lightColor;\\n\";\n    fragmentLightingBlock += \"#else \\n\";\n    fragmentLightingBlock += \"    vec3 lightColor = gltf_lightColor;\\n\";\n    fragmentLightingBlock += \"#endif \\n\";\n    fragmentLightingBlock += \"  vec3 l = normalize(czm_lightDirectionEC);\\n\";\n    var minimumLighting = \"0.2\"; // Use strings instead of values as 0.0 -> 0 when stringified\n\n    fragmentLightingBlock += \"  diffuseLight += lightColor * max(dot(normal,l), \" + minimumLighting + \");\\n\";\n\n    if (hasSpecular) {\n      if (lightingModel === \"BLINN\") {\n        fragmentLightingBlock += \"  vec3 h = normalize(l + viewDir);\\n\";\n        fragmentLightingBlock += \"  float specularIntensity = max(0., pow(max(dot(normal, h), 0.), u_shininess));\\n\";\n      } else {\n        // PHONG\n        fragmentLightingBlock += \"  vec3 reflectDir = reflect(-l, normal);\\n\";\n        fragmentLightingBlock += \"  float specularIntensity = max(0., pow(max(dot(reflectDir, viewDir), 0.), u_shininess));\\n\";\n      }\n\n      fragmentLightingBlock += \"  specularLight += lightColor * specularIntensity;\\n\";\n    }\n  }\n\n  vertexShader += \"void main(void) {\\n\";\n  vertexShader += vertexShaderMain;\n  vertexShader += \"}\\n\";\n  fragmentShader += \"void main(void) {\\n\";\n  var colorCreationBlock = \"  vec3 color = vec3(0.0, 0.0, 0.0);\\n\";\n\n  if (hasNormals) {\n    fragmentShader += \"  vec3 normal = normalize(v_normal);\\n\";\n\n    if (khrMaterialsCommon.doubleSided) {\n      fragmentShader += \"  if (czm_backFacing())\\n\";\n      fragmentShader += \"  {\\n\";\n      fragmentShader += \"    normal = -normal;\\n\";\n      fragmentShader += \"  }\\n\";\n    }\n  }\n\n  var finalColorComputation;\n\n  if (lightingModel !== \"CONSTANT\") {\n    if (defined(techniqueUniforms.u_diffuse)) {\n      if (techniqueUniforms.u_diffuse.type === WebGLConstants.SAMPLER_2D) {\n        fragmentShader += \"  vec4 diffuse = texture2D(u_diffuse, \" + v_texcoord + \");\\n\";\n      } else {\n        fragmentShader += \"  vec4 diffuse = u_diffuse;\\n\";\n      }\n\n      fragmentShader += \"  vec3 diffuseLight = vec3(0.0, 0.0, 0.0);\\n\";\n      colorCreationBlock += \"  color += diffuse.rgb * diffuseLight;\\n\";\n    }\n\n    if (hasSpecular) {\n      if (techniqueUniforms.u_specular.type === WebGLConstants.SAMPLER_2D) {\n        fragmentShader += \"  vec3 specular = texture2D(u_specular, \" + v_texcoord + \").rgb;\\n\";\n      } else {\n        fragmentShader += \"  vec3 specular = u_specular.rgb;\\n\";\n      }\n\n      fragmentShader += \"  vec3 specularLight = vec3(0.0, 0.0, 0.0);\\n\";\n      colorCreationBlock += \"  color += specular * specularLight;\\n\";\n    }\n\n    if (defined(techniqueUniforms.u_transparency)) {\n      finalColorComputation = \"  gl_FragColor = vec4(color * diffuse.a * u_transparency, diffuse.a * u_transparency);\\n\";\n    } else {\n      finalColorComputation = \"  gl_FragColor = vec4(color * diffuse.a, diffuse.a);\\n\";\n    }\n  } else if (defined(techniqueUniforms.u_transparency)) {\n    finalColorComputation = \"  gl_FragColor = vec4(color * u_transparency, u_transparency);\\n\";\n  } else {\n    finalColorComputation = \"  gl_FragColor = vec4(color, 1.0);\\n\";\n  }\n\n  if (hasVertexColors) {\n    colorCreationBlock += \"  color *= v_vertexColor.rgb;\\n\";\n  }\n\n  if (defined(techniqueUniforms.u_emission)) {\n    if (techniqueUniforms.u_emission.type === WebGLConstants.SAMPLER_2D) {\n      fragmentShader += \"  vec3 emission = texture2D(u_emission, \" + v_texcoord + \").rgb;\\n\";\n    } else {\n      fragmentShader += \"  vec3 emission = u_emission.rgb;\\n\";\n    }\n\n    colorCreationBlock += \"  color += emission;\\n\";\n  }\n\n  if (defined(techniqueUniforms.u_ambient) || lightingModel !== \"CONSTANT\") {\n    if (defined(techniqueUniforms.u_ambient)) {\n      if (techniqueUniforms.u_ambient.type === WebGLConstants.SAMPLER_2D) {\n        fragmentShader += \"  vec3 ambient = texture2D(u_ambient, \" + v_texcoord + \").rgb;\\n\";\n      } else {\n        fragmentShader += \"  vec3 ambient = u_ambient.rgb;\\n\";\n      }\n    } else {\n      fragmentShader += \"  vec3 ambient = diffuse.rgb;\\n\";\n    }\n\n    colorCreationBlock += \"  color += ambient * ambientLight;\\n\";\n  }\n\n  fragmentShader += \"  vec3 viewDir = -normalize(v_positionEC);\\n\";\n  fragmentShader += \"  vec3 ambientLight = vec3(0.0, 0.0, 0.0);\\n\"; // Add in light computations\n\n  fragmentShader += fragmentLightingBlock;\n  fragmentShader += colorCreationBlock;\n  fragmentShader += finalColorComputation;\n  fragmentShader += \"}\\n\"; // Add shaders\n\n  var vertexShaderId = addToArray(shaders, {\n    type: WebGLConstants.VERTEX_SHADER,\n    extras: {\n      _pipeline: {\n        source: vertexShader,\n        extension: \".glsl\"\n      }\n    }\n  });\n  var fragmentShaderId = addToArray(shaders, {\n    type: WebGLConstants.FRAGMENT_SHADER,\n    extras: {\n      _pipeline: {\n        source: fragmentShader,\n        extension: \".glsl\"\n      }\n    }\n  }); // Add program\n\n  var programId = addToArray(programs, {\n    fragmentShader: fragmentShaderId,\n    vertexShader: vertexShaderId\n  });\n  var techniqueId = addToArray(techniques, {\n    attributes: techniqueAttributes,\n    program: programId,\n    uniforms: techniqueUniforms\n  });\n  return techniqueId;\n}\n\nfunction getKHRMaterialsCommonValueType(paramName, paramValue) {\n  var value; // Backwards compatibility for COLLADA2GLTF v1.0-draft when it encoding\n  // materials using KHR_materials_common with explicit type/value members\n\n  if (defined(paramValue.value)) {\n    value = paramValue.value;\n  } else if (defined(paramValue.index)) {\n    value = [paramValue.index];\n  } else {\n    value = paramValue;\n  }\n\n  switch (paramName) {\n    case \"ambient\":\n      return value.length === 1 ? WebGLConstants.SAMPLER_2D : WebGLConstants.FLOAT_VEC4;\n\n    case \"diffuse\":\n      return value.length === 1 ? WebGLConstants.SAMPLER_2D : WebGLConstants.FLOAT_VEC4;\n\n    case \"emission\":\n      return value.length === 1 ? WebGLConstants.SAMPLER_2D : WebGLConstants.FLOAT_VEC4;\n\n    case \"specular\":\n      return value.length === 1 ? WebGLConstants.SAMPLER_2D : WebGLConstants.FLOAT_VEC4;\n\n    case \"shininess\":\n      return WebGLConstants.FLOAT;\n\n    case \"transparency\":\n      return WebGLConstants.FLOAT;\n    // these two are usually not used directly within shaders,\n    // they are just added here for completeness\n\n    case \"transparent\":\n      return WebGLConstants.BOOL;\n\n    case \"doubleSided\":\n      return WebGLConstants.BOOL;\n  }\n}\n\nfunction getTechniqueKey(khrMaterialsCommon, primitiveInfo) {\n  var techniqueKey = \"\";\n  techniqueKey += \"technique:\" + khrMaterialsCommon.technique + \";\";\n  var values = khrMaterialsCommon.values;\n  var keys = Object.keys(values).sort();\n  var keysCount = keys.length;\n\n  for (var i = 0; i < keysCount; ++i) {\n    var name = keys[i];\n\n    if (values.hasOwnProperty(name)) {\n      techniqueKey += name + \":\" + getKHRMaterialsCommonValueType(name, values[name]);\n      techniqueKey += \";\";\n    }\n  }\n\n  var jointCount = defaultValue(khrMaterialsCommon.jointCount, 0);\n  techniqueKey += jointCount.toString() + \";\";\n\n  if (defined(primitiveInfo)) {\n    var skinningInfo = primitiveInfo.skinning;\n\n    if (jointCount > 0) {\n      techniqueKey += skinningInfo.type + \";\";\n    }\n\n    techniqueKey += primitiveInfo.hasVertexColors;\n  }\n\n  return techniqueKey;\n}\n\nfunction lightDefaults(gltf) {\n  var khrMaterialsCommon = gltf.extensions.KHR_materials_common;\n\n  if (!defined(khrMaterialsCommon) || !defined(khrMaterialsCommon.lights)) {\n    return;\n  }\n\n  var lights = khrMaterialsCommon.lights;\n  var lightsLength = lights.length;\n\n  for (var lightId = 0; lightId < lightsLength; lightId++) {\n    var light = lights[lightId];\n\n    if (light.type === \"ambient\") {\n      if (!defined(light.ambient)) {\n        light.ambient = {};\n      }\n\n      var ambientLight = light.ambient;\n\n      if (!defined(ambientLight.color)) {\n        ambientLight.color = [1.0, 1.0, 1.0];\n      }\n    } else if (light.type === \"directional\") {\n      if (!defined(light.directional)) {\n        light.directional = {};\n      }\n\n      var directionalLight = light.directional;\n\n      if (!defined(directionalLight.color)) {\n        directionalLight.color = [1.0, 1.0, 1.0];\n      }\n    } else if (light.type === \"point\") {\n      if (!defined(light.point)) {\n        light.point = {};\n      }\n\n      var pointLight = light.point;\n\n      if (!defined(pointLight.color)) {\n        pointLight.color = [1.0, 1.0, 1.0];\n      }\n\n      pointLight.constantAttenuation = defaultValue(pointLight.constantAttenuation, 1.0);\n      pointLight.linearAttenuation = defaultValue(pointLight.linearAttenuation, 0.0);\n      pointLight.quadraticAttenuation = defaultValue(pointLight.quadraticAttenuation, 0.0);\n    } else if (light.type === \"spot\") {\n      if (!defined(light.spot)) {\n        light.spot = {};\n      }\n\n      var spotLight = light.spot;\n\n      if (!defined(spotLight.color)) {\n        spotLight.color = [1.0, 1.0, 1.0];\n      }\n\n      spotLight.constantAttenuation = defaultValue(spotLight.constantAttenuation, 1.0);\n      spotLight.fallOffAngle = defaultValue(spotLight.fallOffAngle, 3.14159265);\n      spotLight.fallOffExponent = defaultValue(spotLight.fallOffExponent, 0.0);\n      spotLight.linearAttenuation = defaultValue(spotLight.linearAttenuation, 0.0);\n      spotLight.quadraticAttenuation = defaultValue(spotLight.quadraticAttenuation, 0.0);\n    }\n  }\n}\n\nexport default processModelMaterialsCommon;","map":{"version":3,"sources":["/home/usuario/davi/thalamus/wms/3dmaptestes/leaflet_cesium/client/node_modules/cesium/Source/Scene/processModelMaterialsCommon.js"],"names":["defaultValue","defined","WebGLConstants","webGLConstantToGlslType","addToArray","ForEach","hasExtension","ModelUtility","processModelMaterialsCommon","gltf","options","EMPTY_OBJECT","extensions","KHR_techniques_webgl","programs","shaders","techniques","extensionsUsed","push","extensionsRequired","techniquesWebgl","lightDefaults","lightParameters","generateLightParameters","primitiveByMaterial","splitIncompatibleMaterials","generatedTechniques","material","materialIndex","KHR_materials_common","khrMaterialsCommon","primitiveInfo","techniqueKey","getTechniqueKey","technique","generateTechnique","addBatchIdToGeneratedShaders","materialValues","values","uniformName","valueName","hasOwnProperty","toLowerCase","alphaMode","transparent","doubleSided","ensureSemanticExistence","result","lights","nodes","nodeName","node","nodeLightId","light","lightCount","lightName","lightType","type","lightBaseName","toString","baseName","ambient","FLOAT_VEC3","value","color","directional","semantic","FLOAT_MAT4","point","constantAttenuation","linearAttenuation","quadraticAttenuation","spot","useInFragment","FLOAT_VEC2","fallOffAngle","fallOffExponent","lightingModel","toUpperCase","parameterValues","jointCount","skinningInfo","hasSkinning","hasVertexColors","skinning","skinned","vertexShader","fragmentShader","hasNormals","techniqueUniforms","u_modelViewMatrix","u_projectionMatrix","u_normalMatrix","FLOAT_MAT3","u_jointMatrix","count","hasTexCoords","name","uniformType","getKHRMaterialsCommonValueType","SAMPLER_2D","u_diffuse","lightParamName","uniform","arraySize","vertexShaderMain","techniqueAttributes","a_position","a_normal","v_texcoord","a_texcoord_0","a_joint","a_weight","a_vertexColor","a_batchId","hasSpecular","u_specular","u_shininess","hasNonAmbientLights","hasAmbientLights","fragmentLightingBlock","lightColorName","varyingDirectionName","varyingPositionName","minimumLighting","colorCreationBlock","finalColorComputation","u_transparency","u_emission","u_ambient","vertexShaderId","VERTEX_SHADER","extras","_pipeline","source","extension","fragmentShaderId","FRAGMENT_SHADER","programId","techniqueId","attributes","program","uniforms","paramName","paramValue","index","length","FLOAT_VEC4","FLOAT","BOOL","keys","Object","sort","keysCount","i","lightsLength","lightId","ambientLight","directionalLight","pointLight","spotLight"],"mappings":"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","sourcesContent":["import defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport WebGLConstants from \"../Core/WebGLConstants.js\";\nimport webGLConstantToGlslType from \"../Core/webGLConstantToGlslType.js\";\nimport addToArray from \"../ThirdParty/GltfPipeline/addToArray.js\";\nimport ForEach from \"../ThirdParty/GltfPipeline/ForEach.js\";\nimport hasExtension from \"../ThirdParty/GltfPipeline/hasExtension.js\";\nimport ModelUtility from \"./ModelUtility.js\";\n\n/**\n * @private\n */\nfunction processModelMaterialsCommon(gltf, options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  if (!defined(gltf)) {\n    return;\n  }\n\n  if (!hasExtension(gltf, \"KHR_materials_common\")) {\n    return;\n  }\n\n  if (!hasExtension(gltf, \"KHR_techniques_webgl\")) {\n    if (!defined(gltf.extensions)) {\n      gltf.extensions = {};\n    }\n\n    gltf.extensions.KHR_techniques_webgl = {\n      programs: [],\n      shaders: [],\n      techniques: [],\n    };\n    gltf.extensionsUsed.push(\"KHR_techniques_webgl\");\n    gltf.extensionsRequired.push(\"KHR_techniques_webgl\");\n  }\n\n  var techniquesWebgl = gltf.extensions.KHR_techniques_webgl;\n\n  lightDefaults(gltf);\n\n  var lightParameters = generateLightParameters(gltf);\n\n  var primitiveByMaterial = ModelUtility.splitIncompatibleMaterials(gltf);\n\n  var techniques = {};\n  var generatedTechniques = false;\n  ForEach.material(gltf, function (material, materialIndex) {\n    if (\n      defined(material.extensions) &&\n      defined(material.extensions.KHR_materials_common)\n    ) {\n      var khrMaterialsCommon = material.extensions.KHR_materials_common;\n      var primitiveInfo = primitiveByMaterial[materialIndex];\n\n      var techniqueKey = getTechniqueKey(khrMaterialsCommon, primitiveInfo);\n      var technique = techniques[techniqueKey];\n\n      if (!defined(technique)) {\n        technique = generateTechnique(\n          gltf,\n          techniquesWebgl,\n          primitiveInfo,\n          khrMaterialsCommon,\n          lightParameters,\n          options.addBatchIdToGeneratedShaders\n        );\n        techniques[techniqueKey] = technique;\n        generatedTechniques = true;\n      }\n\n      var materialValues = {};\n      var values = khrMaterialsCommon.values;\n      var uniformName;\n      for (var valueName in values) {\n        if (\n          values.hasOwnProperty(valueName) &&\n          valueName !== \"transparent\" &&\n          valueName !== \"doubleSided\"\n        ) {\n          uniformName = \"u_\" + valueName.toLowerCase();\n          materialValues[uniformName] = values[valueName];\n        }\n      }\n\n      material.extensions.KHR_techniques_webgl = {\n        technique: technique,\n        values: materialValues,\n      };\n\n      material.alphaMode = \"OPAQUE\";\n      if (khrMaterialsCommon.transparent) {\n        material.alphaMode = \"BLEND\";\n      }\n\n      if (khrMaterialsCommon.doubleSided) {\n        material.doubleSided = true;\n      }\n    }\n  });\n\n  if (!generatedTechniques) {\n    return gltf;\n  }\n\n  // If any primitives have semantics that aren't declared in the generated\n  // shaders, we want to preserve them.\n  ModelUtility.ensureSemanticExistence(gltf);\n\n  return gltf;\n}\n\nfunction generateLightParameters(gltf) {\n  var result = {};\n\n  var lights;\n  if (\n    defined(gltf.extensions) &&\n    defined(gltf.extensions.KHR_materials_common)\n  ) {\n    lights = gltf.extensions.KHR_materials_common.lights;\n  }\n\n  if (defined(lights)) {\n    // Figure out which node references the light\n    var nodes = gltf.nodes;\n    for (var nodeName in nodes) {\n      if (nodes.hasOwnProperty(nodeName)) {\n        var node = nodes[nodeName];\n        if (\n          defined(node.extensions) &&\n          defined(node.extensions.KHR_materials_common)\n        ) {\n          var nodeLightId = node.extensions.KHR_materials_common.light;\n          if (defined(nodeLightId) && defined(lights[nodeLightId])) {\n            lights[nodeLightId].node = nodeName;\n          }\n          delete node.extensions.KHR_materials_common;\n        }\n      }\n    }\n\n    // Add light parameters to result\n    var lightCount = 0;\n    for (var lightName in lights) {\n      if (lights.hasOwnProperty(lightName)) {\n        var light = lights[lightName];\n        var lightType = light.type;\n        if (lightType !== \"ambient\" && !defined(light.node)) {\n          delete lights[lightName];\n          continue;\n        }\n        var lightBaseName = \"light\" + lightCount.toString();\n        light.baseName = lightBaseName;\n        switch (lightType) {\n          case \"ambient\":\n            var ambient = light.ambient;\n            result[lightBaseName + \"Color\"] = {\n              type: WebGLConstants.FLOAT_VEC3,\n              value: ambient.color,\n            };\n            break;\n          case \"directional\":\n            var directional = light.directional;\n            result[lightBaseName + \"Color\"] = {\n              type: WebGLConstants.FLOAT_VEC3,\n              value: directional.color,\n            };\n            if (defined(light.node)) {\n              result[lightBaseName + \"Transform\"] = {\n                node: light.node,\n                semantic: \"MODELVIEW\",\n                type: WebGLConstants.FLOAT_MAT4,\n              };\n            }\n            break;\n          case \"point\":\n            var point = light.point;\n            result[lightBaseName + \"Color\"] = {\n              type: WebGLConstants.FLOAT_VEC3,\n              value: point.color,\n            };\n            if (defined(light.node)) {\n              result[lightBaseName + \"Transform\"] = {\n                node: light.node,\n                semantic: \"MODELVIEW\",\n                type: WebGLConstants.FLOAT_MAT4,\n              };\n            }\n            result[lightBaseName + \"Attenuation\"] = {\n              type: WebGLConstants.FLOAT_VEC3,\n              value: [\n                point.constantAttenuation,\n                point.linearAttenuation,\n                point.quadraticAttenuation,\n              ],\n            };\n            break;\n          case \"spot\":\n            var spot = light.spot;\n            result[lightBaseName + \"Color\"] = {\n              type: WebGLConstants.FLOAT_VEC3,\n              value: spot.color,\n            };\n            if (defined(light.node)) {\n              result[lightBaseName + \"Transform\"] = {\n                node: light.node,\n                semantic: \"MODELVIEW\",\n                type: WebGLConstants.FLOAT_MAT4,\n              };\n              result[lightBaseName + \"InverseTransform\"] = {\n                node: light.node,\n                semantic: \"MODELVIEWINVERSE\",\n                type: WebGLConstants.FLOAT_MAT4,\n                useInFragment: true,\n              };\n            }\n            result[lightBaseName + \"Attenuation\"] = {\n              type: WebGLConstants.FLOAT_VEC3,\n              value: [\n                spot.constantAttenuation,\n                spot.linearAttenuation,\n                spot.quadraticAttenuation,\n              ],\n            };\n\n            result[lightBaseName + \"FallOff\"] = {\n              type: WebGLConstants.FLOAT_VEC2,\n              value: [spot.fallOffAngle, spot.fallOffExponent],\n            };\n            break;\n        }\n        ++lightCount;\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction generateTechnique(\n  gltf,\n  techniquesWebgl,\n  primitiveInfo,\n  khrMaterialsCommon,\n  lightParameters,\n  addBatchIdToGeneratedShaders\n) {\n  if (!defined(khrMaterialsCommon)) {\n    khrMaterialsCommon = {};\n  }\n\n  addBatchIdToGeneratedShaders = defaultValue(\n    addBatchIdToGeneratedShaders,\n    false\n  );\n\n  var techniques = techniquesWebgl.techniques;\n  var shaders = techniquesWebgl.shaders;\n  var programs = techniquesWebgl.programs;\n  var lightingModel = khrMaterialsCommon.technique.toUpperCase();\n  var lights;\n  if (\n    defined(gltf.extensions) &&\n    defined(gltf.extensions.KHR_materials_common)\n  ) {\n    lights = gltf.extensions.KHR_materials_common.lights;\n  }\n\n  var parameterValues = khrMaterialsCommon.values;\n  var jointCount = defaultValue(khrMaterialsCommon.jointCount, 0);\n\n  var skinningInfo;\n  var hasSkinning = false;\n  var hasVertexColors = false;\n\n  if (defined(primitiveInfo)) {\n    skinningInfo = primitiveInfo.skinning;\n    hasSkinning = skinningInfo.skinned;\n    hasVertexColors = primitiveInfo.hasVertexColors;\n  }\n\n  var vertexShader = \"precision highp float;\\n\";\n  var fragmentShader = \"precision highp float;\\n\";\n\n  var hasNormals = lightingModel !== \"CONSTANT\";\n\n  // Add techniques\n  var techniqueUniforms = {\n    u_modelViewMatrix: {\n      semantic: hasExtension(gltf, \"CESIUM_RTC\")\n        ? \"CESIUM_RTC_MODELVIEW\"\n        : \"MODELVIEW\",\n      type: WebGLConstants.FLOAT_MAT4,\n    },\n    u_projectionMatrix: {\n      semantic: \"PROJECTION\",\n      type: WebGLConstants.FLOAT_MAT4,\n    },\n  };\n\n  if (hasNormals) {\n    techniqueUniforms.u_normalMatrix = {\n      semantic: \"MODELVIEWINVERSETRANSPOSE\",\n      type: WebGLConstants.FLOAT_MAT3,\n    };\n  }\n\n  if (hasSkinning) {\n    techniqueUniforms.u_jointMatrix = {\n      count: jointCount,\n      semantic: \"JOINTMATRIX\",\n      type: WebGLConstants.FLOAT_MAT4,\n    };\n  }\n\n  // Add material values\n  var uniformName;\n  var hasTexCoords = false;\n  for (var name in parameterValues) {\n    //generate shader parameters for KHR_materials_common attributes\n    //(including a check, because some boolean flags should not be used as shader parameters)\n    if (\n      parameterValues.hasOwnProperty(name) &&\n      name !== \"transparent\" &&\n      name !== \"doubleSided\"\n    ) {\n      var uniformType = getKHRMaterialsCommonValueType(\n        name,\n        parameterValues[name]\n      );\n      uniformName = \"u_\" + name.toLowerCase();\n      if (!hasTexCoords && uniformType === WebGLConstants.SAMPLER_2D) {\n        hasTexCoords = true;\n      }\n\n      techniqueUniforms[uniformName] = {\n        type: uniformType,\n      };\n    }\n  }\n\n  // Give the diffuse uniform a semantic to support color replacement in 3D Tiles\n  if (defined(techniqueUniforms.u_diffuse)) {\n    techniqueUniforms.u_diffuse.semantic = \"_3DTILESDIFFUSE\";\n  }\n\n  // Copy light parameters into technique parameters\n  if (defined(lightParameters)) {\n    for (var lightParamName in lightParameters) {\n      if (lightParameters.hasOwnProperty(lightParamName)) {\n        uniformName = \"u_\" + lightParamName;\n        techniqueUniforms[uniformName] = lightParameters[lightParamName];\n      }\n    }\n  }\n\n  // Add uniforms to shaders\n  for (uniformName in techniqueUniforms) {\n    if (techniqueUniforms.hasOwnProperty(uniformName)) {\n      var uniform = techniqueUniforms[uniformName];\n      var arraySize = defined(uniform.count) ? \"[\" + uniform.count + \"]\" : \"\";\n      if (\n        (uniform.type !== WebGLConstants.FLOAT_MAT3 &&\n          uniform.type !== WebGLConstants.FLOAT_MAT4) ||\n        uniform.useInFragment\n      ) {\n        fragmentShader +=\n          \"uniform \" +\n          webGLConstantToGlslType(uniform.type) +\n          \" \" +\n          uniformName +\n          arraySize +\n          \";\\n\";\n        delete uniform.useInFragment;\n      } else {\n        vertexShader +=\n          \"uniform \" +\n          webGLConstantToGlslType(uniform.type) +\n          \" \" +\n          uniformName +\n          arraySize +\n          \";\\n\";\n      }\n    }\n  }\n\n  // Add attributes with semantics\n  var vertexShaderMain = \"\";\n  if (hasSkinning) {\n    vertexShaderMain +=\n      \"    mat4 skinMatrix =\\n\" +\n      \"        a_weight.x * u_jointMatrix[int(a_joint.x)] +\\n\" +\n      \"        a_weight.y * u_jointMatrix[int(a_joint.y)] +\\n\" +\n      \"        a_weight.z * u_jointMatrix[int(a_joint.z)] +\\n\" +\n      \"        a_weight.w * u_jointMatrix[int(a_joint.w)];\\n\";\n  }\n\n  // Add position always\n  var techniqueAttributes = {\n    a_position: {\n      semantic: \"POSITION\",\n    },\n  };\n  vertexShader += \"attribute vec3 a_position;\\n\";\n  vertexShader += \"varying vec3 v_positionEC;\\n\";\n  if (hasSkinning) {\n    vertexShaderMain +=\n      \"  vec4 pos = u_modelViewMatrix * skinMatrix * vec4(a_position,1.0);\\n\";\n  } else {\n    vertexShaderMain +=\n      \"  vec4 pos = u_modelViewMatrix * vec4(a_position,1.0);\\n\";\n  }\n  vertexShaderMain += \"  v_positionEC = pos.xyz;\\n\";\n  vertexShaderMain += \"  gl_Position = u_projectionMatrix * pos;\\n\";\n  fragmentShader += \"varying vec3 v_positionEC;\\n\";\n\n  // Add normal if we don't have constant lighting\n  if (hasNormals) {\n    techniqueAttributes.a_normal = {\n      semantic: \"NORMAL\",\n    };\n    vertexShader += \"attribute vec3 a_normal;\\n\";\n    vertexShader += \"varying vec3 v_normal;\\n\";\n    if (hasSkinning) {\n      vertexShaderMain +=\n        \"  v_normal = u_normalMatrix * mat3(skinMatrix) * a_normal;\\n\";\n    } else {\n      vertexShaderMain += \"  v_normal = u_normalMatrix * a_normal;\\n\";\n    }\n\n    fragmentShader += \"varying vec3 v_normal;\\n\";\n  }\n\n  // Add texture coordinates if the material uses them\n  var v_texcoord;\n  if (hasTexCoords) {\n    techniqueAttributes.a_texcoord_0 = {\n      semantic: \"TEXCOORD_0\",\n    };\n\n    v_texcoord = \"v_texcoord_0\";\n    vertexShader += \"attribute vec2 a_texcoord_0;\\n\";\n    vertexShader += \"varying vec2 \" + v_texcoord + \";\\n\";\n    vertexShaderMain += \"  \" + v_texcoord + \" = a_texcoord_0;\\n\";\n\n    fragmentShader += \"varying vec2 \" + v_texcoord + \";\\n\";\n  }\n\n  if (hasSkinning) {\n    techniqueAttributes.a_joint = {\n      semantic: \"JOINTS_0\",\n    };\n    techniqueAttributes.a_weight = {\n      semantic: \"WEIGHTS_0\",\n    };\n\n    vertexShader += \"attribute vec4 a_joint;\\n\";\n    vertexShader += \"attribute vec4 a_weight;\\n\";\n  }\n\n  if (hasVertexColors) {\n    techniqueAttributes.a_vertexColor = {\n      semantic: \"COLOR_0\",\n    };\n    vertexShader += \"attribute vec4 a_vertexColor;\\n\";\n    vertexShader += \"varying vec4 v_vertexColor;\\n\";\n    vertexShaderMain += \"  v_vertexColor = a_vertexColor;\\n\";\n    fragmentShader += \"varying vec4 v_vertexColor;\\n\";\n  }\n\n  if (addBatchIdToGeneratedShaders) {\n    techniqueAttributes.a_batchId = {\n      semantic: \"_BATCHID\",\n    };\n    vertexShader += \"attribute float a_batchId;\\n\";\n  }\n\n  var hasSpecular =\n    hasNormals &&\n    (lightingModel === \"BLINN\" || lightingModel === \"PHONG\") &&\n    defined(techniqueUniforms.u_specular) &&\n    defined(techniqueUniforms.u_shininess) &&\n    techniqueUniforms.u_shininess > 0.0;\n\n  // Generate lighting code blocks\n  var hasNonAmbientLights = false;\n  var hasAmbientLights = false;\n  var fragmentLightingBlock = \"\";\n  for (var lightName in lights) {\n    if (lights.hasOwnProperty(lightName)) {\n      var light = lights[lightName];\n      var lightType = light.type.toLowerCase();\n      var lightBaseName = light.baseName;\n      fragmentLightingBlock += \"  {\\n\";\n      var lightColorName = \"u_\" + lightBaseName + \"Color\";\n      var varyingDirectionName;\n      var varyingPositionName;\n      if (lightType === \"ambient\") {\n        hasAmbientLights = true;\n        fragmentLightingBlock +=\n          \"    ambientLight += \" + lightColorName + \";\\n\";\n      } else if (hasNormals) {\n        hasNonAmbientLights = true;\n        varyingDirectionName = \"v_\" + lightBaseName + \"Direction\";\n        varyingPositionName = \"v_\" + lightBaseName + \"Position\";\n\n        if (lightType !== \"point\") {\n          vertexShader += \"varying vec3 \" + varyingDirectionName + \";\\n\";\n          fragmentShader += \"varying vec3 \" + varyingDirectionName + \";\\n\";\n\n          vertexShaderMain +=\n            \"  \" +\n            varyingDirectionName +\n            \" = mat3(u_\" +\n            lightBaseName +\n            \"Transform) * vec3(0.,0.,1.);\\n\";\n          if (lightType === \"directional\") {\n            fragmentLightingBlock +=\n              \"    vec3 l = normalize(\" + varyingDirectionName + \");\\n\";\n          }\n        }\n\n        if (lightType !== \"directional\") {\n          vertexShader += \"varying vec3 \" + varyingPositionName + \";\\n\";\n          fragmentShader += \"varying vec3 \" + varyingPositionName + \";\\n\";\n\n          vertexShaderMain +=\n            \"  \" +\n            varyingPositionName +\n            \" = u_\" +\n            lightBaseName +\n            \"Transform[3].xyz;\\n\";\n          fragmentLightingBlock +=\n            \"    vec3 VP = \" + varyingPositionName + \" - v_positionEC;\\n\";\n          fragmentLightingBlock += \"    vec3 l = normalize(VP);\\n\";\n          fragmentLightingBlock += \"    float range = length(VP);\\n\";\n          fragmentLightingBlock +=\n            \"    float attenuation = 1.0 / (u_\" +\n            lightBaseName +\n            \"Attenuation.x + \";\n          fragmentLightingBlock +=\n            \"(u_\" + lightBaseName + \"Attenuation.y * range) + \";\n          fragmentLightingBlock +=\n            \"(u_\" + lightBaseName + \"Attenuation.z * range * range));\\n\";\n        } else {\n          fragmentLightingBlock += \"    float attenuation = 1.0;\\n\";\n        }\n\n        if (lightType === \"spot\") {\n          fragmentLightingBlock +=\n            \"    float spotDot = dot(l, normalize(\" +\n            varyingDirectionName +\n            \"));\\n\";\n          fragmentLightingBlock +=\n            \"    if (spotDot < cos(u_\" + lightBaseName + \"FallOff.x * 0.5))\\n\";\n          fragmentLightingBlock += \"    {\\n\";\n          fragmentLightingBlock += \"      attenuation = 0.0;\\n\";\n          fragmentLightingBlock += \"    }\\n\";\n          fragmentLightingBlock += \"    else\\n\";\n          fragmentLightingBlock += \"    {\\n\";\n          fragmentLightingBlock +=\n            \"        attenuation *= max(0.0, pow(spotDot, u_\" +\n            lightBaseName +\n            \"FallOff.y));\\n\";\n          fragmentLightingBlock += \"    }\\n\";\n        }\n\n        fragmentLightingBlock +=\n          \"    diffuseLight += \" +\n          lightColorName +\n          \"* max(dot(normal,l), 0.) * attenuation;\\n\";\n\n        if (hasSpecular) {\n          if (lightingModel === \"BLINN\") {\n            fragmentLightingBlock += \"    vec3 h = normalize(l + viewDir);\\n\";\n            fragmentLightingBlock +=\n              \"    float specularIntensity = max(0., pow(max(dot(normal, h), 0.), u_shininess)) * attenuation;\\n\";\n          } else {\n            // PHONG\n            fragmentLightingBlock +=\n              \"    vec3 reflectDir = reflect(-l, normal);\\n\";\n            fragmentLightingBlock +=\n              \"    float specularIntensity = max(0., pow(max(dot(reflectDir, viewDir), 0.), u_shininess)) * attenuation;\\n\";\n          }\n          fragmentLightingBlock +=\n            \"    specularLight += \" +\n            lightColorName +\n            \" * specularIntensity;\\n\";\n        }\n      }\n      fragmentLightingBlock += \"  }\\n\";\n    }\n  }\n\n  if (!hasAmbientLights) {\n    // Add an ambient light if we don't have one\n    fragmentLightingBlock += \"  ambientLight += vec3(0.2, 0.2, 0.2);\\n\";\n  }\n\n  if (!hasNonAmbientLights && lightingModel !== \"CONSTANT\") {\n    fragmentShader += \"#ifdef USE_CUSTOM_LIGHT_COLOR \\n\";\n    fragmentShader += \"uniform vec3 gltf_lightColor; \\n\";\n    fragmentShader += \"#endif \\n\";\n\n    fragmentLightingBlock += \"#ifndef USE_CUSTOM_LIGHT_COLOR \\n\";\n    fragmentLightingBlock += \"    vec3 lightColor = czm_lightColor;\\n\";\n    fragmentLightingBlock += \"#else \\n\";\n    fragmentLightingBlock += \"    vec3 lightColor = gltf_lightColor;\\n\";\n    fragmentLightingBlock += \"#endif \\n\";\n\n    fragmentLightingBlock += \"  vec3 l = normalize(czm_lightDirectionEC);\\n\";\n    var minimumLighting = \"0.2\"; // Use strings instead of values as 0.0 -> 0 when stringified\n    fragmentLightingBlock +=\n      \"  diffuseLight += lightColor * max(dot(normal,l), \" +\n      minimumLighting +\n      \");\\n\";\n\n    if (hasSpecular) {\n      if (lightingModel === \"BLINN\") {\n        fragmentLightingBlock += \"  vec3 h = normalize(l + viewDir);\\n\";\n        fragmentLightingBlock +=\n          \"  float specularIntensity = max(0., pow(max(dot(normal, h), 0.), u_shininess));\\n\";\n      } else {\n        // PHONG\n        fragmentLightingBlock += \"  vec3 reflectDir = reflect(-l, normal);\\n\";\n        fragmentLightingBlock +=\n          \"  float specularIntensity = max(0., pow(max(dot(reflectDir, viewDir), 0.), u_shininess));\\n\";\n      }\n\n      fragmentLightingBlock +=\n        \"  specularLight += lightColor * specularIntensity;\\n\";\n    }\n  }\n\n  vertexShader += \"void main(void) {\\n\";\n  vertexShader += vertexShaderMain;\n  vertexShader += \"}\\n\";\n\n  fragmentShader += \"void main(void) {\\n\";\n  var colorCreationBlock = \"  vec3 color = vec3(0.0, 0.0, 0.0);\\n\";\n  if (hasNormals) {\n    fragmentShader += \"  vec3 normal = normalize(v_normal);\\n\";\n    if (khrMaterialsCommon.doubleSided) {\n      fragmentShader += \"  if (czm_backFacing())\\n\";\n      fragmentShader += \"  {\\n\";\n      fragmentShader += \"    normal = -normal;\\n\";\n      fragmentShader += \"  }\\n\";\n    }\n  }\n\n  var finalColorComputation;\n  if (lightingModel !== \"CONSTANT\") {\n    if (defined(techniqueUniforms.u_diffuse)) {\n      if (techniqueUniforms.u_diffuse.type === WebGLConstants.SAMPLER_2D) {\n        fragmentShader +=\n          \"  vec4 diffuse = texture2D(u_diffuse, \" + v_texcoord + \");\\n\";\n      } else {\n        fragmentShader += \"  vec4 diffuse = u_diffuse;\\n\";\n      }\n      fragmentShader += \"  vec3 diffuseLight = vec3(0.0, 0.0, 0.0);\\n\";\n      colorCreationBlock += \"  color += diffuse.rgb * diffuseLight;\\n\";\n    }\n\n    if (hasSpecular) {\n      if (techniqueUniforms.u_specular.type === WebGLConstants.SAMPLER_2D) {\n        fragmentShader +=\n          \"  vec3 specular = texture2D(u_specular, \" + v_texcoord + \").rgb;\\n\";\n      } else {\n        fragmentShader += \"  vec3 specular = u_specular.rgb;\\n\";\n      }\n      fragmentShader += \"  vec3 specularLight = vec3(0.0, 0.0, 0.0);\\n\";\n      colorCreationBlock += \"  color += specular * specularLight;\\n\";\n    }\n\n    if (defined(techniqueUniforms.u_transparency)) {\n      finalColorComputation =\n        \"  gl_FragColor = vec4(color * diffuse.a * u_transparency, diffuse.a * u_transparency);\\n\";\n    } else {\n      finalColorComputation =\n        \"  gl_FragColor = vec4(color * diffuse.a, diffuse.a);\\n\";\n    }\n  } else if (defined(techniqueUniforms.u_transparency)) {\n    finalColorComputation =\n      \"  gl_FragColor = vec4(color * u_transparency, u_transparency);\\n\";\n  } else {\n    finalColorComputation = \"  gl_FragColor = vec4(color, 1.0);\\n\";\n  }\n\n  if (hasVertexColors) {\n    colorCreationBlock += \"  color *= v_vertexColor.rgb;\\n\";\n  }\n\n  if (defined(techniqueUniforms.u_emission)) {\n    if (techniqueUniforms.u_emission.type === WebGLConstants.SAMPLER_2D) {\n      fragmentShader +=\n        \"  vec3 emission = texture2D(u_emission, \" + v_texcoord + \").rgb;\\n\";\n    } else {\n      fragmentShader += \"  vec3 emission = u_emission.rgb;\\n\";\n    }\n    colorCreationBlock += \"  color += emission;\\n\";\n  }\n\n  if (defined(techniqueUniforms.u_ambient) || lightingModel !== \"CONSTANT\") {\n    if (defined(techniqueUniforms.u_ambient)) {\n      if (techniqueUniforms.u_ambient.type === WebGLConstants.SAMPLER_2D) {\n        fragmentShader +=\n          \"  vec3 ambient = texture2D(u_ambient, \" + v_texcoord + \").rgb;\\n\";\n      } else {\n        fragmentShader += \"  vec3 ambient = u_ambient.rgb;\\n\";\n      }\n    } else {\n      fragmentShader += \"  vec3 ambient = diffuse.rgb;\\n\";\n    }\n    colorCreationBlock += \"  color += ambient * ambientLight;\\n\";\n  }\n  fragmentShader += \"  vec3 viewDir = -normalize(v_positionEC);\\n\";\n  fragmentShader += \"  vec3 ambientLight = vec3(0.0, 0.0, 0.0);\\n\";\n\n  // Add in light computations\n  fragmentShader += fragmentLightingBlock;\n\n  fragmentShader += colorCreationBlock;\n  fragmentShader += finalColorComputation;\n  fragmentShader += \"}\\n\";\n\n  // Add shaders\n  var vertexShaderId = addToArray(shaders, {\n    type: WebGLConstants.VERTEX_SHADER,\n    extras: {\n      _pipeline: {\n        source: vertexShader,\n        extension: \".glsl\",\n      },\n    },\n  });\n\n  var fragmentShaderId = addToArray(shaders, {\n    type: WebGLConstants.FRAGMENT_SHADER,\n    extras: {\n      _pipeline: {\n        source: fragmentShader,\n        extension: \".glsl\",\n      },\n    },\n  });\n\n  // Add program\n  var programId = addToArray(programs, {\n    fragmentShader: fragmentShaderId,\n    vertexShader: vertexShaderId,\n  });\n\n  var techniqueId = addToArray(techniques, {\n    attributes: techniqueAttributes,\n    program: programId,\n    uniforms: techniqueUniforms,\n  });\n\n  return techniqueId;\n}\n\nfunction getKHRMaterialsCommonValueType(paramName, paramValue) {\n  var value;\n\n  // Backwards compatibility for COLLADA2GLTF v1.0-draft when it encoding\n  // materials using KHR_materials_common with explicit type/value members\n  if (defined(paramValue.value)) {\n    value = paramValue.value;\n  } else if (defined(paramValue.index)) {\n    value = [paramValue.index];\n  } else {\n    value = paramValue;\n  }\n\n  switch (paramName) {\n    case \"ambient\":\n      return value.length === 1\n        ? WebGLConstants.SAMPLER_2D\n        : WebGLConstants.FLOAT_VEC4;\n    case \"diffuse\":\n      return value.length === 1\n        ? WebGLConstants.SAMPLER_2D\n        : WebGLConstants.FLOAT_VEC4;\n    case \"emission\":\n      return value.length === 1\n        ? WebGLConstants.SAMPLER_2D\n        : WebGLConstants.FLOAT_VEC4;\n    case \"specular\":\n      return value.length === 1\n        ? WebGLConstants.SAMPLER_2D\n        : WebGLConstants.FLOAT_VEC4;\n    case \"shininess\":\n      return WebGLConstants.FLOAT;\n    case \"transparency\":\n      return WebGLConstants.FLOAT;\n\n    // these two are usually not used directly within shaders,\n    // they are just added here for completeness\n    case \"transparent\":\n      return WebGLConstants.BOOL;\n    case \"doubleSided\":\n      return WebGLConstants.BOOL;\n  }\n}\n\nfunction getTechniqueKey(khrMaterialsCommon, primitiveInfo) {\n  var techniqueKey = \"\";\n  techniqueKey += \"technique:\" + khrMaterialsCommon.technique + \";\";\n\n  var values = khrMaterialsCommon.values;\n  var keys = Object.keys(values).sort();\n  var keysCount = keys.length;\n  for (var i = 0; i < keysCount; ++i) {\n    var name = keys[i];\n    if (values.hasOwnProperty(name)) {\n      techniqueKey +=\n        name + \":\" + getKHRMaterialsCommonValueType(name, values[name]);\n      techniqueKey += \";\";\n    }\n  }\n\n  var jointCount = defaultValue(khrMaterialsCommon.jointCount, 0);\n  techniqueKey += jointCount.toString() + \";\";\n  if (defined(primitiveInfo)) {\n    var skinningInfo = primitiveInfo.skinning;\n    if (jointCount > 0) {\n      techniqueKey += skinningInfo.type + \";\";\n    }\n    techniqueKey += primitiveInfo.hasVertexColors;\n  }\n\n  return techniqueKey;\n}\n\nfunction lightDefaults(gltf) {\n  var khrMaterialsCommon = gltf.extensions.KHR_materials_common;\n  if (!defined(khrMaterialsCommon) || !defined(khrMaterialsCommon.lights)) {\n    return;\n  }\n\n  var lights = khrMaterialsCommon.lights;\n\n  var lightsLength = lights.length;\n  for (var lightId = 0; lightId < lightsLength; lightId++) {\n    var light = lights[lightId];\n    if (light.type === \"ambient\") {\n      if (!defined(light.ambient)) {\n        light.ambient = {};\n      }\n      var ambientLight = light.ambient;\n\n      if (!defined(ambientLight.color)) {\n        ambientLight.color = [1.0, 1.0, 1.0];\n      }\n    } else if (light.type === \"directional\") {\n      if (!defined(light.directional)) {\n        light.directional = {};\n      }\n      var directionalLight = light.directional;\n\n      if (!defined(directionalLight.color)) {\n        directionalLight.color = [1.0, 1.0, 1.0];\n      }\n    } else if (light.type === \"point\") {\n      if (!defined(light.point)) {\n        light.point = {};\n      }\n      var pointLight = light.point;\n\n      if (!defined(pointLight.color)) {\n        pointLight.color = [1.0, 1.0, 1.0];\n      }\n\n      pointLight.constantAttenuation = defaultValue(\n        pointLight.constantAttenuation,\n        1.0\n      );\n      pointLight.linearAttenuation = defaultValue(\n        pointLight.linearAttenuation,\n        0.0\n      );\n      pointLight.quadraticAttenuation = defaultValue(\n        pointLight.quadraticAttenuation,\n        0.0\n      );\n    } else if (light.type === \"spot\") {\n      if (!defined(light.spot)) {\n        light.spot = {};\n      }\n      var spotLight = light.spot;\n\n      if (!defined(spotLight.color)) {\n        spotLight.color = [1.0, 1.0, 1.0];\n      }\n\n      spotLight.constantAttenuation = defaultValue(\n        spotLight.constantAttenuation,\n        1.0\n      );\n      spotLight.fallOffAngle = defaultValue(spotLight.fallOffAngle, 3.14159265);\n      spotLight.fallOffExponent = defaultValue(spotLight.fallOffExponent, 0.0);\n      spotLight.linearAttenuation = defaultValue(\n        spotLight.linearAttenuation,\n        0.0\n      );\n      spotLight.quadraticAttenuation = defaultValue(\n        spotLight.quadraticAttenuation,\n        0.0\n      );\n    }\n  }\n}\nexport default processModelMaterialsCommon;\n"]},"metadata":{},"sourceType":"module"}