{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EncodedCartesian3 from \"../Core/EncodedCartesian3.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport Geometry from \"../Core/Geometry.js\";\nimport GeometryAttribute from \"../Core/GeometryAttribute.js\";\nimport GeometryAttributes from \"../Core/GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"../Core/GeometryOffsetAttribute.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Plane from \"../Core/Plane.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport subdivideArray from \"../Core/subdivideArray.js\";\nimport TaskProcessor from \"../Core/TaskProcessor.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport when from \"../ThirdParty/when.js\";\nimport BatchTable from \"./BatchTable.js\";\nimport CullFace from \"./CullFace.js\";\nimport DepthFunction from \"./DepthFunction.js\";\nimport PrimitivePipeline from \"./PrimitivePipeline.js\";\nimport PrimitiveState from \"./PrimitiveState.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\n/**\n * A primitive represents geometry in the {@link Scene}.  The geometry can be from a single {@link GeometryInstance}\n * as shown in example 1 below, or from an array of instances, even if the geometry is from different\n * geometry types, e.g., an {@link RectangleGeometry} and an {@link EllipsoidGeometry} as shown in Code Example 2.\n * <p>\n * A primitive combines geometry instances with an {@link Appearance} that describes the full shading, including\n * {@link Material} and {@link RenderState}.  Roughly, the geometry instance defines the structure and placement,\n * and the appearance defines the visual characteristics.  Decoupling geometry and appearance allows us to mix\n * and match most of them and add a new geometry or appearance independently of each other.\n * </p>\n * <p>\n * Combining multiple instances into one primitive is called batching, and significantly improves performance for static data.\n * Instances can be individually picked; {@link Scene#pick} returns their {@link GeometryInstance#id}.  Using\n * per-instance appearances like {@link PerInstanceColorAppearance}, each instance can also have a unique color.\n * </p>\n * <p>\n * {@link Geometry} can either be created and batched on a web worker or the main thread. The first two examples\n * show geometry that will be created on a web worker by using the descriptions of the geometry. The third example\n * shows how to create the geometry on the main thread by explicitly calling the <code>createGeometry</code> method.\n * </p>\n *\n * @alias Primitive\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {GeometryInstance[]|GeometryInstance} [options.geometryInstances] The geometry instances - or a single geometry instance - to render.\n * @param {Appearance} [options.appearance] The appearance used to render the primitive.\n * @param {Appearance} [options.depthFailAppearance] The appearance used to shade this primitive when it fails the depth test.\n * @param {Boolean} [options.show=true] Determines if this primitive will be shown.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms the primitive (all geometry instances) from model to world coordinates.\n * @param {Boolean} [options.vertexCacheOptimize=false] When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.\n * @param {Boolean} [options.interleave=false] When <code>true</code>, geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time.\n * @param {Boolean} [options.compressVertices=true] When <code>true</code>, the geometry vertices are compressed, which will save memory.\n * @param {Boolean} [options.releaseGeometryInstances=true] When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n * @param {Boolean} [options.cull=true] When <code>true</code>, the renderer frustum culls and horizon culls the primitive's commands based on their bounding volume.  Set this to <code>false</code> for a small performance gain if you are manually culling the primitive.\n * @param {Boolean} [options.asynchronous=true] Determines if the primitive will be created asynchronously or block until ready.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {ShadowMode} [options.shadows=ShadowMode.DISABLED] Determines whether this primitive casts or receives shadows from light sources.\n *\n * @example\n * // 1. Draw a translucent ellipse on the surface with a checkerboard pattern\n * var instance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.EllipseGeometry({\n *       center : Cesium.Cartesian3.fromDegrees(-100.0, 20.0),\n *       semiMinorAxis : 500000.0,\n *       semiMajorAxis : 1000000.0,\n *       rotation : Cesium.Math.PI_OVER_FOUR,\n *       vertexFormat : Cesium.VertexFormat.POSITION_AND_ST\n *   }),\n *   id : 'object returned when this instance is picked and to get/set per-instance attributes'\n * });\n * scene.primitives.add(new Cesium.Primitive({\n *   geometryInstances : instance,\n *   appearance : new Cesium.EllipsoidSurfaceAppearance({\n *     material : Cesium.Material.fromType('Checkerboard')\n *   })\n * }));\n *\n * @example\n * // 2. Draw different instances each with a unique color\n * var rectangleInstance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.RectangleGeometry({\n *     rectangle : Cesium.Rectangle.fromDegrees(-140.0, 30.0, -100.0, 40.0),\n *     vertexFormat : Cesium.PerInstanceColorAppearance.VERTEX_FORMAT\n *   }),\n *   id : 'rectangle',\n *   attributes : {\n *     color : new Cesium.ColorGeometryInstanceAttribute(0.0, 1.0, 1.0, 0.5)\n *   }\n * });\n * var ellipsoidInstance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.EllipsoidGeometry({\n *     radii : new Cesium.Cartesian3(500000.0, 500000.0, 1000000.0),\n *     vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL\n *   }),\n *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *     Cesium.Cartesian3.fromDegrees(-95.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 500000.0), new Cesium.Matrix4()),\n *   id : 'ellipsoid',\n *   attributes : {\n *     color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)\n *   }\n * });\n * scene.primitives.add(new Cesium.Primitive({\n *   geometryInstances : [rectangleInstance, ellipsoidInstance],\n *   appearance : new Cesium.PerInstanceColorAppearance()\n * }));\n *\n * @example\n * // 3. Create the geometry on the main thread.\n * scene.primitives.add(new Cesium.Primitive({\n *   geometryInstances : new Cesium.GeometryInstance({\n *       geometry : Cesium.EllipsoidGeometry.createGeometry(new Cesium.EllipsoidGeometry({\n *         radii : new Cesium.Cartesian3(500000.0, 500000.0, 1000000.0),\n *         vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL\n *       })),\n *       modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *         Cesium.Cartesian3.fromDegrees(-95.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 500000.0), new Cesium.Matrix4()),\n *       id : 'ellipsoid',\n *       attributes : {\n *         color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)\n *       }\n *   }),\n *   appearance : new Cesium.PerInstanceColorAppearance()\n * }));\n *\n * @see GeometryInstance\n * @see Appearance\n * @see ClassificationPrimitive\n * @see GroundPrimitive\n */\n\nfunction Primitive(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  /**\n   * The geometry instances rendered with this primitive.  This may\n   * be <code>undefined</code> if <code>options.releaseGeometryInstances</code>\n   * is <code>true</code> when the primitive is constructed.\n   * <p>\n   * Changing this property after the primitive is rendered has no effect.\n   * </p>\n   *\n   * @readonly\n   * @type GeometryInstance[]|GeometryInstance\n   *\n   * @default undefined\n   */\n\n  this.geometryInstances = options.geometryInstances;\n  /**\n   * The {@link Appearance} used to shade this primitive. Each geometry\n   * instance is shaded with the same appearance.  Some appearances, like\n   * {@link PerInstanceColorAppearance} allow giving each instance unique\n   * properties.\n   *\n   * @type Appearance\n   *\n   * @default undefined\n   */\n\n  this.appearance = options.appearance;\n  this._appearance = undefined;\n  this._material = undefined;\n  /**\n   * The {@link Appearance} used to shade this primitive when it fails the depth test. Each geometry\n   * instance is shaded with the same appearance.  Some appearances, like\n   * {@link PerInstanceColorAppearance} allow giving each instance unique\n   * properties.\n   *\n   * <p>\n   * When using an appearance that requires a color attribute, like PerInstanceColorAppearance,\n   * add a depthFailColor per-instance attribute instead.\n   * </p>\n   *\n   * <p>\n   * Requires the EXT_frag_depth WebGL extension to render properly. If the extension is not supported,\n   * there may be artifacts.\n   * </p>\n   * @type Appearance\n   *\n   * @default undefined\n   */\n\n  this.depthFailAppearance = options.depthFailAppearance;\n  this._depthFailAppearance = undefined;\n  this._depthFailMaterial = undefined;\n  /**\n   * The 4x4 transformation matrix that transforms the primitive (all geometry instances) from model to world coordinates.\n   * When this is the identity matrix, the primitive is drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * <p>\n   * This property is only supported in 3D mode.\n   * </p>\n   *\n   * @type Matrix4\n   *\n   * @default Matrix4.IDENTITY\n   *\n   * @example\n   * var origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);\n   * p.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);\n   */\n\n  this.modelMatrix = Matrix4.clone(defaultValue(options.modelMatrix, Matrix4.IDENTITY));\n  this._modelMatrix = new Matrix4();\n  /**\n   * Determines if the primitive will be shown.  This affects all geometry\n   * instances in the primitive.\n   *\n   * @type Boolean\n   *\n   * @default true\n   */\n\n  this.show = defaultValue(options.show, true);\n  this._vertexCacheOptimize = defaultValue(options.vertexCacheOptimize, false);\n  this._interleave = defaultValue(options.interleave, false);\n  this._releaseGeometryInstances = defaultValue(options.releaseGeometryInstances, true);\n  this._allowPicking = defaultValue(options.allowPicking, true);\n  this._asynchronous = defaultValue(options.asynchronous, true);\n  this._compressVertices = defaultValue(options.compressVertices, true);\n  /**\n   * When <code>true</code>, the renderer frustum culls and horizon culls the primitive's commands\n   * based on their bounding volume.  Set this to <code>false</code> for a small performance gain\n   * if you are manually culling the primitive.\n   *\n   * @type {Boolean}\n   *\n   * @default true\n   */\n\n  this.cull = defaultValue(options.cull, true);\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n\n  this.debugShowBoundingVolume = defaultValue(options.debugShowBoundingVolume, false);\n  /**\n   * @private\n   */\n\n  this.rtcCenter = options.rtcCenter; //>>includeStart('debug', pragmas.debug);\n\n  if (defined(this.rtcCenter) && (!defined(this.geometryInstances) || Array.isArray(this.geometryInstances) && this.geometryInstances.length !== 1)) {\n    throw new DeveloperError(\"Relative-to-center rendering only supports one geometry instance.\");\n  } //>>includeEnd('debug');\n\n  /**\n   * Determines whether this primitive casts or receives shadows from light sources.\n   *\n   * @type {ShadowMode}\n   *\n   * @default ShadowMode.DISABLED\n   */\n\n\n  this.shadows = defaultValue(options.shadows, ShadowMode.DISABLED);\n  this._translucent = undefined;\n  this._state = PrimitiveState.READY;\n  this._geometries = [];\n  this._error = undefined;\n  this._numberOfInstances = 0;\n  this._boundingSpheres = [];\n  this._boundingSphereWC = [];\n  this._boundingSphereCV = [];\n  this._boundingSphere2D = [];\n  this._boundingSphereMorph = [];\n  this._perInstanceAttributeCache = [];\n  this._instanceIds = [];\n  this._lastPerInstanceAttributeIndex = 0;\n  this._va = [];\n  this._attributeLocations = undefined;\n  this._primitiveType = undefined;\n  this._frontFaceRS = undefined;\n  this._backFaceRS = undefined;\n  this._sp = undefined;\n  this._depthFailAppearance = undefined;\n  this._spDepthFail = undefined;\n  this._frontFaceDepthFailRS = undefined;\n  this._backFaceDepthFailRS = undefined;\n  this._pickIds = [];\n  this._colorCommands = [];\n  this._pickCommands = [];\n  this._createBoundingVolumeFunction = options._createBoundingVolumeFunction;\n  this._createRenderStatesFunction = options._createRenderStatesFunction;\n  this._createShaderProgramFunction = options._createShaderProgramFunction;\n  this._createCommandsFunction = options._createCommandsFunction;\n  this._updateAndQueueCommandsFunction = options._updateAndQueueCommandsFunction;\n  this._createPickOffsets = options._createPickOffsets;\n  this._pickOffsets = undefined;\n  this._createGeometryResults = undefined;\n  this._ready = false;\n  this._readyPromise = when.defer();\n  this._batchTable = undefined;\n  this._batchTableAttributeIndices = undefined;\n  this._offsetInstanceExtend = undefined;\n  this._batchTableOffsetAttribute2DIndex = undefined;\n  this._batchTableOffsetsUpdated = false;\n  this._instanceBoundingSpheres = undefined;\n  this._instanceBoundingSpheresCV = undefined;\n  this._tempBoundingSpheres = undefined;\n  this._recomputeBoundingSpheres = false;\n  this._batchTableBoundingSpheresUpdated = false;\n  this._batchTableBoundingSphereAttributeIndices = undefined;\n}\n\nObject.defineProperties(Primitive.prototype, {\n  /**\n   * When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  vertexCacheOptimize: {\n    get: function () {\n      return this._vertexCacheOptimize;\n    }\n  },\n\n  /**\n   * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  interleave: {\n    get: function () {\n      return this._interleave;\n    }\n  },\n\n  /**\n   * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  releaseGeometryInstances: {\n    get: function () {\n      return this._releaseGeometryInstances;\n    }\n  },\n\n  /**\n   * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.         *\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  allowPicking: {\n    get: function () {\n      return this._allowPicking;\n    }\n  },\n\n  /**\n   * Determines if the geometry instances will be created and batched on a web worker.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  asynchronous: {\n    get: function () {\n      return this._asynchronous;\n    }\n  },\n\n  /**\n   * When <code>true</code>, geometry vertices are compressed, which will save memory.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  compressVertices: {\n    get: function () {\n      return this._compressVertices;\n    }\n  },\n\n  /**\n   * Determines if the primitive is complete and ready to render.  If this property is\n   * true, the primitive will be rendered the next time that {@link Primitive#update}\n   * is called.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    }\n  },\n\n  /**\n   * Gets a promise that resolves when the primitive is ready to render.\n   * @memberof Primitive.prototype\n   * @type {Promise.<Primitive>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    }\n  }\n});\n\nfunction getCommonPerInstanceAttributeNames(instances) {\n  var length = instances.length;\n  var attributesInAllInstances = [];\n  var attributes0 = instances[0].attributes;\n  var name;\n\n  for (name in attributes0) {\n    if (attributes0.hasOwnProperty(name) && defined(attributes0[name])) {\n      var attribute = attributes0[name];\n      var inAllInstances = true; // Does this same attribute exist in all instances?\n\n      for (var i = 1; i < length; ++i) {\n        var otherAttribute = instances[i].attributes[name];\n\n        if (!defined(otherAttribute) || attribute.componentDatatype !== otherAttribute.componentDatatype || attribute.componentsPerAttribute !== otherAttribute.componentsPerAttribute || attribute.normalize !== otherAttribute.normalize) {\n          inAllInstances = false;\n          break;\n        }\n      }\n\n      if (inAllInstances) {\n        attributesInAllInstances.push(name);\n      }\n    }\n  }\n\n  return attributesInAllInstances;\n}\n\nvar scratchGetAttributeCartesian2 = new Cartesian2();\nvar scratchGetAttributeCartesian3 = new Cartesian3();\nvar scratchGetAttributeCartesian4 = new Cartesian4();\n\nfunction getAttributeValue(value) {\n  var componentsPerAttribute = value.length;\n\n  if (componentsPerAttribute === 1) {\n    return value[0];\n  } else if (componentsPerAttribute === 2) {\n    return Cartesian2.unpack(value, 0, scratchGetAttributeCartesian2);\n  } else if (componentsPerAttribute === 3) {\n    return Cartesian3.unpack(value, 0, scratchGetAttributeCartesian3);\n  } else if (componentsPerAttribute === 4) {\n    return Cartesian4.unpack(value, 0, scratchGetAttributeCartesian4);\n  }\n}\n\nfunction createBatchTable(primitive, context) {\n  var geometryInstances = primitive.geometryInstances;\n  var instances = Array.isArray(geometryInstances) ? geometryInstances : [geometryInstances];\n  var numberOfInstances = instances.length;\n\n  if (numberOfInstances === 0) {\n    return;\n  }\n\n  var names = getCommonPerInstanceAttributeNames(instances);\n  var length = names.length;\n  var attributes = [];\n  var attributeIndices = {};\n  var boundingSphereAttributeIndices = {};\n  var offset2DIndex;\n  var firstInstance = instances[0];\n  var instanceAttributes = firstInstance.attributes;\n  var i;\n  var name;\n  var attribute;\n\n  for (i = 0; i < length; ++i) {\n    name = names[i];\n    attribute = instanceAttributes[name];\n    attributeIndices[name] = i;\n    attributes.push({\n      functionName: \"czm_batchTable_\" + name,\n      componentDatatype: attribute.componentDatatype,\n      componentsPerAttribute: attribute.componentsPerAttribute,\n      normalize: attribute.normalize\n    });\n  }\n\n  if (names.indexOf(\"distanceDisplayCondition\") !== -1) {\n    attributes.push({\n      functionName: \"czm_batchTable_boundingSphereCenter3DHigh\",\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3\n    }, {\n      functionName: \"czm_batchTable_boundingSphereCenter3DLow\",\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3\n    }, {\n      functionName: \"czm_batchTable_boundingSphereCenter2DHigh\",\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3\n    }, {\n      functionName: \"czm_batchTable_boundingSphereCenter2DLow\",\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3\n    }, {\n      functionName: \"czm_batchTable_boundingSphereRadius\",\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 1\n    });\n    boundingSphereAttributeIndices.center3DHigh = attributes.length - 5;\n    boundingSphereAttributeIndices.center3DLow = attributes.length - 4;\n    boundingSphereAttributeIndices.center2DHigh = attributes.length - 3;\n    boundingSphereAttributeIndices.center2DLow = attributes.length - 2;\n    boundingSphereAttributeIndices.radius = attributes.length - 1;\n  }\n\n  if (names.indexOf(\"offset\") !== -1) {\n    attributes.push({\n      functionName: \"czm_batchTable_offset2D\",\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3\n    });\n    offset2DIndex = attributes.length - 1;\n  }\n\n  attributes.push({\n    functionName: \"czm_batchTable_pickColor\",\n    componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n    componentsPerAttribute: 4,\n    normalize: true\n  });\n  var attributesLength = attributes.length;\n  var batchTable = new BatchTable(context, attributes, numberOfInstances);\n\n  for (i = 0; i < numberOfInstances; ++i) {\n    var instance = instances[i];\n    instanceAttributes = instance.attributes;\n\n    for (var j = 0; j < length; ++j) {\n      name = names[j];\n      attribute = instanceAttributes[name];\n      var value = getAttributeValue(attribute.value);\n      var attributeIndex = attributeIndices[name];\n      batchTable.setBatchedAttribute(i, attributeIndex, value);\n    }\n\n    var pickObject = {\n      primitive: defaultValue(instance.pickPrimitive, primitive)\n    };\n\n    if (defined(instance.id)) {\n      pickObject.id = instance.id;\n    }\n\n    var pickId = context.createPickId(pickObject);\n\n    primitive._pickIds.push(pickId);\n\n    var pickColor = pickId.color;\n    var color = scratchGetAttributeCartesian4;\n    color.x = Color.floatToByte(pickColor.red);\n    color.y = Color.floatToByte(pickColor.green);\n    color.z = Color.floatToByte(pickColor.blue);\n    color.w = Color.floatToByte(pickColor.alpha);\n    batchTable.setBatchedAttribute(i, attributesLength - 1, color);\n  }\n\n  primitive._batchTable = batchTable;\n  primitive._batchTableAttributeIndices = attributeIndices;\n  primitive._batchTableBoundingSphereAttributeIndices = boundingSphereAttributeIndices;\n  primitive._batchTableOffsetAttribute2DIndex = offset2DIndex;\n}\n\nfunction cloneAttribute(attribute) {\n  var clonedValues;\n\n  if (Array.isArray(attribute.values)) {\n    clonedValues = attribute.values.slice(0);\n  } else {\n    clonedValues = new attribute.values.constructor(attribute.values);\n  }\n\n  return new GeometryAttribute({\n    componentDatatype: attribute.componentDatatype,\n    componentsPerAttribute: attribute.componentsPerAttribute,\n    normalize: attribute.normalize,\n    values: clonedValues\n  });\n}\n\nfunction cloneGeometry(geometry) {\n  var attributes = geometry.attributes;\n  var newAttributes = new GeometryAttributes();\n\n  for (var property in attributes) {\n    if (attributes.hasOwnProperty(property) && defined(attributes[property])) {\n      newAttributes[property] = cloneAttribute(attributes[property]);\n    }\n  }\n\n  var indices;\n\n  if (defined(geometry.indices)) {\n    var sourceValues = geometry.indices;\n\n    if (Array.isArray(sourceValues)) {\n      indices = sourceValues.slice(0);\n    } else {\n      indices = new sourceValues.constructor(sourceValues);\n    }\n  }\n\n  return new Geometry({\n    attributes: newAttributes,\n    indices: indices,\n    primitiveType: geometry.primitiveType,\n    boundingSphere: BoundingSphere.clone(geometry.boundingSphere)\n  });\n}\n\nfunction cloneInstance(instance, geometry) {\n  return {\n    geometry: geometry,\n    attributes: instance.attributes,\n    modelMatrix: Matrix4.clone(instance.modelMatrix),\n    pickPrimitive: instance.pickPrimitive,\n    id: instance.id\n  };\n}\n\nvar positionRegex = /attribute\\s+vec(?:3|4)\\s+(.*)3DHigh;/g;\n\nPrimitive._modifyShaderPosition = function (primitive, vertexShaderSource, scene3DOnly) {\n  var match;\n  var forwardDecl = \"\";\n  var attributes = \"\";\n  var computeFunctions = \"\";\n\n  while ((match = positionRegex.exec(vertexShaderSource)) !== null) {\n    var name = match[1];\n    var functionName = \"vec4 czm_compute\" + name[0].toUpperCase() + name.substr(1) + \"()\"; // Don't forward-declare czm_computePosition because computePosition.glsl already does.\n\n    if (functionName !== \"vec4 czm_computePosition()\") {\n      forwardDecl += functionName + \";\\n\";\n    }\n\n    if (!defined(primitive.rtcCenter)) {\n      // Use GPU RTE\n      if (!scene3DOnly) {\n        attributes += \"attribute vec3 \" + name + \"2DHigh;\\n\" + \"attribute vec3 \" + name + \"2DLow;\\n\";\n        computeFunctions += functionName + \"\\n\" + \"{\\n\" + \"    vec4 p;\\n\" + \"    if (czm_morphTime == 1.0)\\n\" + \"    {\\n\" + \"        p = czm_translateRelativeToEye(\" + name + \"3DHigh, \" + name + \"3DLow);\\n\" + \"    }\\n\" + \"    else if (czm_morphTime == 0.0)\\n\" + \"    {\\n\" + \"        p = czm_translateRelativeToEye(\" + name + \"2DHigh.zxy, \" + name + \"2DLow.zxy);\\n\" + \"    }\\n\" + \"    else\\n\" + \"    {\\n\" + \"        p = czm_columbusViewMorph(\\n\" + \"                czm_translateRelativeToEye(\" + name + \"2DHigh.zxy, \" + name + \"2DLow.zxy),\\n\" + \"                czm_translateRelativeToEye(\" + name + \"3DHigh, \" + name + \"3DLow),\\n\" + \"                czm_morphTime);\\n\" + \"    }\\n\" + \"    return p;\\n\" + \"}\\n\\n\";\n      } else {\n        computeFunctions += functionName + \"\\n\" + \"{\\n\" + \"    return czm_translateRelativeToEye(\" + name + \"3DHigh, \" + name + \"3DLow);\\n\" + \"}\\n\\n\";\n      }\n    } else {\n      // Use RTC\n      vertexShaderSource = vertexShaderSource.replace(/attribute\\s+vec(?:3|4)\\s+position3DHigh;/g, \"\");\n      vertexShaderSource = vertexShaderSource.replace(/attribute\\s+vec(?:3|4)\\s+position3DLow;/g, \"\");\n      forwardDecl += \"uniform mat4 u_modifiedModelView;\\n\";\n      attributes += \"attribute vec4 position;\\n\";\n      computeFunctions += functionName + \"\\n\" + \"{\\n\" + \"    return u_modifiedModelView * position;\\n\" + \"}\\n\\n\";\n      vertexShaderSource = vertexShaderSource.replace(/czm_modelViewRelativeToEye\\s+\\*\\s+/g, \"\");\n      vertexShaderSource = vertexShaderSource.replace(/czm_modelViewProjectionRelativeToEye/g, \"czm_projection\");\n    }\n  }\n\n  return [forwardDecl, attributes, vertexShaderSource, computeFunctions].join(\"\\n\");\n};\n\nPrimitive._appendShowToShader = function (primitive, vertexShaderSource) {\n  if (!defined(primitive._batchTableAttributeIndices.show)) {\n    return vertexShaderSource;\n  }\n\n  var renamedVS = ShaderSource.replaceMain(vertexShaderSource, \"czm_non_show_main\");\n  var showMain = \"void main() \\n\" + \"{ \\n\" + \"    czm_non_show_main(); \\n\" + \"    gl_Position *= czm_batchTable_show(batchId); \\n\" + \"}\";\n  return renamedVS + \"\\n\" + showMain;\n};\n\nPrimitive._updateColorAttribute = function (primitive, vertexShaderSource, isDepthFail) {\n  // some appearances have a color attribute for per vertex color.\n  // only remove if color is a per instance attribute.\n  if (!defined(primitive._batchTableAttributeIndices.color) && !defined(primitive._batchTableAttributeIndices.depthFailColor)) {\n    return vertexShaderSource;\n  }\n\n  if (vertexShaderSource.search(/attribute\\s+vec4\\s+color;/g) === -1) {\n    return vertexShaderSource;\n  } //>>includeStart('debug', pragmas.debug);\n\n\n  if (isDepthFail && !defined(primitive._batchTableAttributeIndices.depthFailColor)) {\n    throw new DeveloperError(\"A depthFailColor per-instance attribute is required when using a depth fail appearance that uses a color attribute.\");\n  } //>>includeEnd('debug');\n\n\n  var modifiedVS = vertexShaderSource;\n  modifiedVS = modifiedVS.replace(/attribute\\s+vec4\\s+color;/g, \"\");\n\n  if (!isDepthFail) {\n    modifiedVS = modifiedVS.replace(/(\\b)color(\\b)/g, \"$1czm_batchTable_color(batchId)$2\");\n  } else {\n    modifiedVS = modifiedVS.replace(/(\\b)color(\\b)/g, \"$1czm_batchTable_depthFailColor(batchId)$2\");\n  }\n\n  return modifiedVS;\n};\n\nfunction appendPickToVertexShader(source) {\n  var renamedVS = ShaderSource.replaceMain(source, \"czm_non_pick_main\");\n  var pickMain = \"varying vec4 v_pickColor; \\n\" + \"void main() \\n\" + \"{ \\n\" + \"    czm_non_pick_main(); \\n\" + \"    v_pickColor = czm_batchTable_pickColor(batchId); \\n\" + \"}\";\n  return renamedVS + \"\\n\" + pickMain;\n}\n\nfunction appendPickToFragmentShader(source) {\n  return \"varying vec4 v_pickColor;\\n\" + source;\n}\n\nPrimitive._updatePickColorAttribute = function (source) {\n  var vsPick = source.replace(/attribute\\s+vec4\\s+pickColor;/g, \"\");\n  vsPick = vsPick.replace(/(\\b)pickColor(\\b)/g, \"$1czm_batchTable_pickColor(batchId)$2\");\n  return vsPick;\n};\n\nPrimitive._appendOffsetToShader = function (primitive, vertexShaderSource) {\n  if (!defined(primitive._batchTableAttributeIndices.offset)) {\n    return vertexShaderSource;\n  }\n\n  var attr = \"attribute float batchId;\\n\";\n  attr += \"attribute float applyOffset;\";\n  var modifiedShader = vertexShaderSource.replace(/attribute\\s+float\\s+batchId;/g, attr);\n  var str = \"vec4 $1 = czm_computePosition();\\n\";\n  str += \"    if (czm_sceneMode == czm_sceneMode3D)\\n\";\n  str += \"    {\\n\";\n  str += \"        $1 = $1 + vec4(czm_batchTable_offset(batchId) * applyOffset, 0.0);\";\n  str += \"    }\\n\";\n  str += \"    else\\n\";\n  str += \"    {\\n\";\n  str += \"        $1 = $1 + vec4(czm_batchTable_offset2D(batchId) * applyOffset, 0.0);\";\n  str += \"    }\\n\";\n  modifiedShader = modifiedShader.replace(/vec4\\s+([A-Za-z0-9_]+)\\s+=\\s+czm_computePosition\\(\\);/g, str);\n  return modifiedShader;\n};\n\nPrimitive._appendDistanceDisplayConditionToShader = function (primitive, vertexShaderSource, scene3DOnly) {\n  if (!defined(primitive._batchTableAttributeIndices.distanceDisplayCondition)) {\n    return vertexShaderSource;\n  }\n\n  var renamedVS = ShaderSource.replaceMain(vertexShaderSource, \"czm_non_distanceDisplayCondition_main\");\n  var distanceDisplayConditionMain = \"void main() \\n\" + \"{ \\n\" + \"    czm_non_distanceDisplayCondition_main(); \\n\" + \"    vec2 distanceDisplayCondition = czm_batchTable_distanceDisplayCondition(batchId);\\n\" + \"    vec3 boundingSphereCenter3DHigh = czm_batchTable_boundingSphereCenter3DHigh(batchId);\\n\" + \"    vec3 boundingSphereCenter3DLow = czm_batchTable_boundingSphereCenter3DLow(batchId);\\n\" + \"    float boundingSphereRadius = czm_batchTable_boundingSphereRadius(batchId);\\n\";\n\n  if (!scene3DOnly) {\n    distanceDisplayConditionMain += \"    vec3 boundingSphereCenter2DHigh = czm_batchTable_boundingSphereCenter2DHigh(batchId);\\n\" + \"    vec3 boundingSphereCenter2DLow = czm_batchTable_boundingSphereCenter2DLow(batchId);\\n\" + \"    vec4 centerRTE;\\n\" + \"    if (czm_morphTime == 1.0)\\n\" + \"    {\\n\" + \"        centerRTE = czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow);\\n\" + \"    }\\n\" + \"    else if (czm_morphTime == 0.0)\\n\" + \"    {\\n\" + \"        centerRTE = czm_translateRelativeToEye(boundingSphereCenter2DHigh.zxy, boundingSphereCenter2DLow.zxy);\\n\" + \"    }\\n\" + \"    else\\n\" + \"    {\\n\" + \"        centerRTE = czm_columbusViewMorph(\\n\" + \"                czm_translateRelativeToEye(boundingSphereCenter2DHigh.zxy, boundingSphereCenter2DLow.zxy),\\n\" + \"                czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow),\\n\" + \"                czm_morphTime);\\n\" + \"    }\\n\";\n  } else {\n    distanceDisplayConditionMain += \"    vec4 centerRTE = czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow);\\n\";\n  }\n\n  distanceDisplayConditionMain += \"    float radiusSq = boundingSphereRadius * boundingSphereRadius; \\n\" + \"    float distanceSq; \\n\" + \"    if (czm_sceneMode == czm_sceneMode2D) \\n\" + \"    { \\n\" + \"        distanceSq = czm_eyeHeight2D.y - radiusSq; \\n\" + \"    } \\n\" + \"    else \\n\" + \"    { \\n\" + \"        distanceSq = dot(centerRTE.xyz, centerRTE.xyz) - radiusSq; \\n\" + \"    } \\n\" + \"    distanceSq = max(distanceSq, 0.0); \\n\" + \"    float nearSq = distanceDisplayCondition.x * distanceDisplayCondition.x; \\n\" + \"    float farSq = distanceDisplayCondition.y * distanceDisplayCondition.y; \\n\" + \"    float show = (distanceSq >= nearSq && distanceSq <= farSq) ? 1.0 : 0.0; \\n\" + \"    gl_Position *= show; \\n\" + \"}\";\n  return renamedVS + \"\\n\" + distanceDisplayConditionMain;\n};\n\nfunction modifyForEncodedNormals(primitive, vertexShaderSource) {\n  if (!primitive.compressVertices) {\n    return vertexShaderSource;\n  }\n\n  var containsNormal = vertexShaderSource.search(/attribute\\s+vec3\\s+normal;/g) !== -1;\n  var containsSt = vertexShaderSource.search(/attribute\\s+vec2\\s+st;/g) !== -1;\n\n  if (!containsNormal && !containsSt) {\n    return vertexShaderSource;\n  }\n\n  var containsTangent = vertexShaderSource.search(/attribute\\s+vec3\\s+tangent;/g) !== -1;\n  var containsBitangent = vertexShaderSource.search(/attribute\\s+vec3\\s+bitangent;/g) !== -1;\n  var numComponents = containsSt && containsNormal ? 2.0 : 1.0;\n  numComponents += containsTangent || containsBitangent ? 1 : 0;\n  var type = numComponents > 1 ? \"vec\" + numComponents : \"float\";\n  var attributeName = \"compressedAttributes\";\n  var attributeDecl = \"attribute \" + type + \" \" + attributeName + \";\";\n  var globalDecl = \"\";\n  var decode = \"\";\n\n  if (containsSt) {\n    globalDecl += \"vec2 st;\\n\";\n    var stComponent = numComponents > 1 ? attributeName + \".x\" : attributeName;\n    decode += \"    st = czm_decompressTextureCoordinates(\" + stComponent + \");\\n\";\n  }\n\n  if (containsNormal && containsTangent && containsBitangent) {\n    globalDecl += \"vec3 normal;\\n\" + \"vec3 tangent;\\n\" + \"vec3 bitangent;\\n\";\n    decode += \"    czm_octDecode(\" + attributeName + \".\" + (containsSt ? \"yz\" : \"xy\") + \", normal, tangent, bitangent);\\n\";\n  } else {\n    if (containsNormal) {\n      globalDecl += \"vec3 normal;\\n\";\n      decode += \"    normal = czm_octDecode(\" + attributeName + (numComponents > 1 ? \".\" + (containsSt ? \"y\" : \"x\") : \"\") + \");\\n\";\n    }\n\n    if (containsTangent) {\n      globalDecl += \"vec3 tangent;\\n\";\n      decode += \"    tangent = czm_octDecode(\" + attributeName + \".\" + (containsSt && containsNormal ? \"z\" : \"y\") + \");\\n\";\n    }\n\n    if (containsBitangent) {\n      globalDecl += \"vec3 bitangent;\\n\";\n      decode += \"    bitangent = czm_octDecode(\" + attributeName + \".\" + (containsSt && containsNormal ? \"z\" : \"y\") + \");\\n\";\n    }\n  }\n\n  var modifiedVS = vertexShaderSource;\n  modifiedVS = modifiedVS.replace(/attribute\\s+vec3\\s+normal;/g, \"\");\n  modifiedVS = modifiedVS.replace(/attribute\\s+vec2\\s+st;/g, \"\");\n  modifiedVS = modifiedVS.replace(/attribute\\s+vec3\\s+tangent;/g, \"\");\n  modifiedVS = modifiedVS.replace(/attribute\\s+vec3\\s+bitangent;/g, \"\");\n  modifiedVS = ShaderSource.replaceMain(modifiedVS, \"czm_non_compressed_main\");\n  var compressedMain = \"void main() \\n\" + \"{ \\n\" + decode + \"    czm_non_compressed_main(); \\n\" + \"}\";\n  return [attributeDecl, globalDecl, modifiedVS, compressedMain].join(\"\\n\");\n}\n\nfunction depthClampVS(vertexShaderSource) {\n  var modifiedVS = ShaderSource.replaceMain(vertexShaderSource, \"czm_non_depth_clamp_main\");\n  modifiedVS += \"void main() {\\n\" + \"    czm_non_depth_clamp_main();\\n\" + \"    gl_Position = czm_depthClamp(gl_Position);\" + \"}\\n\";\n  return modifiedVS;\n}\n\nfunction depthClampFS(fragmentShaderSource) {\n  var modifiedFS = ShaderSource.replaceMain(fragmentShaderSource, \"czm_non_depth_clamp_main\");\n  modifiedFS += \"void main() {\\n\" + \"    czm_non_depth_clamp_main();\\n\" + \"#if defined(GL_EXT_frag_depth)\\n\" + \"    #if defined(LOG_DEPTH)\\n\" + \"        czm_writeLogDepth();\\n\" + \"    #else\\n\" + \"        czm_writeDepthClamp();\\n\" + \"    #endif\\n\" + \"#endif\\n\" + \"}\\n\";\n  modifiedFS = \"#ifdef GL_EXT_frag_depth\\n\" + \"#extension GL_EXT_frag_depth : enable\\n\" + \"#endif\\n\" + modifiedFS;\n  return modifiedFS;\n}\n\nfunction validateShaderMatching(shaderProgram, attributeLocations) {\n  // For a VAO and shader program to be compatible, the VAO must have\n  // all active attribute in the shader program.  The VAO may have\n  // extra attributes with the only concern being a potential\n  // performance hit due to extra memory bandwidth and cache pollution.\n  // The shader source could have extra attributes that are not used,\n  // but there is no guarantee they will be optimized out.\n  //\n  // Here, we validate that the VAO has all attributes required\n  // to match the shader program.\n  var shaderAttributes = shaderProgram.vertexAttributes; //>>includeStart('debug', pragmas.debug);\n\n  for (var name in shaderAttributes) {\n    if (shaderAttributes.hasOwnProperty(name)) {\n      if (!defined(attributeLocations[name])) {\n        throw new DeveloperError(\"Appearance/Geometry mismatch.  The appearance requires vertex shader attribute input '\" + name + \"', which was not computed as part of the Geometry.  Use the appearance's vertexFormat property when constructing the geometry.\");\n      }\n    }\n  } //>>includeEnd('debug');\n\n}\n\nfunction getUniformFunction(uniforms, name) {\n  return function () {\n    return uniforms[name];\n  };\n}\n\nvar numberOfCreationWorkers = Math.max(FeatureDetection.hardwareConcurrency - 1, 1);\nvar createGeometryTaskProcessors;\nvar combineGeometryTaskProcessor = new TaskProcessor(\"combineGeometry\");\n\nfunction loadAsynchronous(primitive, frameState) {\n  var instances;\n  var geometry;\n  var i;\n  var j;\n  var instanceIds = primitive._instanceIds;\n\n  if (primitive._state === PrimitiveState.READY) {\n    instances = Array.isArray(primitive.geometryInstances) ? primitive.geometryInstances : [primitive.geometryInstances];\n    var length = primitive._numberOfInstances = instances.length;\n    var promises = [];\n    var subTasks = [];\n\n    for (i = 0; i < length; ++i) {\n      geometry = instances[i].geometry;\n      instanceIds.push(instances[i].id); //>>includeStart('debug', pragmas.debug);\n\n      if (!defined(geometry._workerName)) {\n        throw new DeveloperError(\"_workerName must be defined for asynchronous geometry.\");\n      } //>>includeEnd('debug');\n\n\n      subTasks.push({\n        moduleName: geometry._workerName,\n        geometry: geometry\n      });\n    }\n\n    if (!defined(createGeometryTaskProcessors)) {\n      createGeometryTaskProcessors = new Array(numberOfCreationWorkers);\n\n      for (i = 0; i < numberOfCreationWorkers; i++) {\n        createGeometryTaskProcessors[i] = new TaskProcessor(\"createGeometry\");\n      }\n    }\n\n    var subTask;\n    subTasks = subdivideArray(subTasks, numberOfCreationWorkers);\n\n    for (i = 0; i < subTasks.length; i++) {\n      var packedLength = 0;\n      var workerSubTasks = subTasks[i];\n      var workerSubTasksLength = workerSubTasks.length;\n\n      for (j = 0; j < workerSubTasksLength; ++j) {\n        subTask = workerSubTasks[j];\n        geometry = subTask.geometry;\n\n        if (defined(geometry.constructor.pack)) {\n          subTask.offset = packedLength;\n          packedLength += defaultValue(geometry.constructor.packedLength, geometry.packedLength);\n        }\n      }\n\n      var subTaskTransferableObjects;\n\n      if (packedLength > 0) {\n        var array = new Float64Array(packedLength);\n        subTaskTransferableObjects = [array.buffer];\n\n        for (j = 0; j < workerSubTasksLength; ++j) {\n          subTask = workerSubTasks[j];\n          geometry = subTask.geometry;\n\n          if (defined(geometry.constructor.pack)) {\n            geometry.constructor.pack(geometry, array, subTask.offset);\n            subTask.geometry = array;\n          }\n        }\n      }\n\n      promises.push(createGeometryTaskProcessors[i].scheduleTask({\n        subTasks: subTasks[i]\n      }, subTaskTransferableObjects));\n    }\n\n    primitive._state = PrimitiveState.CREATING;\n    when.all(promises, function (results) {\n      primitive._createGeometryResults = results;\n      primitive._state = PrimitiveState.CREATED;\n    }).otherwise(function (error) {\n      setReady(primitive, frameState, PrimitiveState.FAILED, error);\n    });\n  } else if (primitive._state === PrimitiveState.CREATED) {\n    var transferableObjects = [];\n    instances = Array.isArray(primitive.geometryInstances) ? primitive.geometryInstances : [primitive.geometryInstances];\n    var scene3DOnly = frameState.scene3DOnly;\n    var projection = frameState.mapProjection;\n    var promise = combineGeometryTaskProcessor.scheduleTask(PrimitivePipeline.packCombineGeometryParameters({\n      createGeometryResults: primitive._createGeometryResults,\n      instances: instances,\n      ellipsoid: projection.ellipsoid,\n      projection: projection,\n      elementIndexUintSupported: frameState.context.elementIndexUint,\n      scene3DOnly: scene3DOnly,\n      vertexCacheOptimize: primitive.vertexCacheOptimize,\n      compressVertices: primitive.compressVertices,\n      modelMatrix: primitive.modelMatrix,\n      createPickOffsets: primitive._createPickOffsets\n    }, transferableObjects), transferableObjects);\n    primitive._createGeometryResults = undefined;\n    primitive._state = PrimitiveState.COMBINING;\n    when(promise, function (packedResult) {\n      var result = PrimitivePipeline.unpackCombineGeometryResults(packedResult);\n      primitive._geometries = result.geometries;\n      primitive._attributeLocations = result.attributeLocations;\n      primitive.modelMatrix = Matrix4.clone(result.modelMatrix, primitive.modelMatrix);\n      primitive._pickOffsets = result.pickOffsets;\n      primitive._offsetInstanceExtend = result.offsetInstanceExtend;\n      primitive._instanceBoundingSpheres = result.boundingSpheres;\n      primitive._instanceBoundingSpheresCV = result.boundingSpheresCV;\n\n      if (defined(primitive._geometries) && primitive._geometries.length > 0) {\n        primitive._recomputeBoundingSpheres = true;\n        primitive._state = PrimitiveState.COMBINED;\n      } else {\n        setReady(primitive, frameState, PrimitiveState.FAILED, undefined);\n      }\n    }).otherwise(function (error) {\n      setReady(primitive, frameState, PrimitiveState.FAILED, error);\n    });\n  }\n}\n\nfunction loadSynchronous(primitive, frameState) {\n  var instances = Array.isArray(primitive.geometryInstances) ? primitive.geometryInstances : [primitive.geometryInstances];\n  var length = primitive._numberOfInstances = instances.length;\n  var clonedInstances = new Array(length);\n  var instanceIds = primitive._instanceIds;\n  var instance;\n  var i;\n  var geometryIndex = 0;\n\n  for (i = 0; i < length; i++) {\n    instance = instances[i];\n    var geometry = instance.geometry;\n    var createdGeometry;\n\n    if (defined(geometry.attributes) && defined(geometry.primitiveType)) {\n      createdGeometry = cloneGeometry(geometry);\n    } else {\n      createdGeometry = geometry.constructor.createGeometry(geometry);\n    }\n\n    clonedInstances[geometryIndex++] = cloneInstance(instance, createdGeometry);\n    instanceIds.push(instance.id);\n  }\n\n  clonedInstances.length = geometryIndex;\n  var scene3DOnly = frameState.scene3DOnly;\n  var projection = frameState.mapProjection;\n  var result = PrimitivePipeline.combineGeometry({\n    instances: clonedInstances,\n    ellipsoid: projection.ellipsoid,\n    projection: projection,\n    elementIndexUintSupported: frameState.context.elementIndexUint,\n    scene3DOnly: scene3DOnly,\n    vertexCacheOptimize: primitive.vertexCacheOptimize,\n    compressVertices: primitive.compressVertices,\n    modelMatrix: primitive.modelMatrix,\n    createPickOffsets: primitive._createPickOffsets\n  });\n  primitive._geometries = result.geometries;\n  primitive._attributeLocations = result.attributeLocations;\n  primitive.modelMatrix = Matrix4.clone(result.modelMatrix, primitive.modelMatrix);\n  primitive._pickOffsets = result.pickOffsets;\n  primitive._offsetInstanceExtend = result.offsetInstanceExtend;\n  primitive._instanceBoundingSpheres = result.boundingSpheres;\n  primitive._instanceBoundingSpheresCV = result.boundingSpheresCV;\n\n  if (defined(primitive._geometries) && primitive._geometries.length > 0) {\n    primitive._recomputeBoundingSpheres = true;\n    primitive._state = PrimitiveState.COMBINED;\n  } else {\n    setReady(primitive, frameState, PrimitiveState.FAILED, undefined);\n  }\n}\n\nfunction recomputeBoundingSpheres(primitive, frameState) {\n  var offsetIndex = primitive._batchTableAttributeIndices.offset;\n\n  if (!primitive._recomputeBoundingSpheres || !defined(offsetIndex)) {\n    primitive._recomputeBoundingSpheres = false;\n    return;\n  }\n\n  var i;\n  var offsetInstanceExtend = primitive._offsetInstanceExtend;\n  var boundingSpheres = primitive._instanceBoundingSpheres;\n  var length = boundingSpheres.length;\n  var newBoundingSpheres = primitive._tempBoundingSpheres;\n\n  if (!defined(newBoundingSpheres)) {\n    newBoundingSpheres = new Array(length);\n\n    for (i = 0; i < length; i++) {\n      newBoundingSpheres[i] = new BoundingSphere();\n    }\n\n    primitive._tempBoundingSpheres = newBoundingSpheres;\n  }\n\n  for (i = 0; i < length; ++i) {\n    var newBS = newBoundingSpheres[i];\n\n    var offset = primitive._batchTable.getBatchedAttribute(i, offsetIndex, new Cartesian3());\n\n    newBS = boundingSpheres[i].clone(newBS);\n    transformBoundingSphere(newBS, offset, offsetInstanceExtend[i]);\n  }\n\n  var combinedBS = [];\n  var combinedWestBS = [];\n  var combinedEastBS = [];\n\n  for (i = 0; i < length; ++i) {\n    var bs = newBoundingSpheres[i];\n    var minX = bs.center.x - bs.radius;\n\n    if (minX > 0 || BoundingSphere.intersectPlane(bs, Plane.ORIGIN_ZX_PLANE) !== Intersect.INTERSECTING) {\n      combinedBS.push(bs);\n    } else {\n      combinedWestBS.push(bs);\n      combinedEastBS.push(bs);\n    }\n  }\n\n  var resultBS1 = combinedBS[0];\n  var resultBS2 = combinedEastBS[0];\n  var resultBS3 = combinedWestBS[0];\n\n  for (i = 1; i < combinedBS.length; i++) {\n    resultBS1 = BoundingSphere.union(resultBS1, combinedBS[i]);\n  }\n\n  for (i = 1; i < combinedEastBS.length; i++) {\n    resultBS2 = BoundingSphere.union(resultBS2, combinedEastBS[i]);\n  }\n\n  for (i = 1; i < combinedWestBS.length; i++) {\n    resultBS3 = BoundingSphere.union(resultBS3, combinedWestBS[i]);\n  }\n\n  var result = [];\n\n  if (defined(resultBS1)) {\n    result.push(resultBS1);\n  }\n\n  if (defined(resultBS2)) {\n    result.push(resultBS2);\n  }\n\n  if (defined(resultBS3)) {\n    result.push(resultBS3);\n  }\n\n  for (i = 0; i < result.length; i++) {\n    var boundingSphere = result[i].clone(primitive._boundingSpheres[i]);\n    primitive._boundingSpheres[i] = boundingSphere;\n    primitive._boundingSphereCV[i] = BoundingSphere.projectTo2D(boundingSphere, frameState.mapProjection, primitive._boundingSphereCV[i]);\n  }\n\n  Primitive._updateBoundingVolumes(primitive, frameState, primitive.modelMatrix, true);\n\n  primitive._recomputeBoundingSpheres = false;\n}\n\nvar scratchBoundingSphereCenterEncoded = new EncodedCartesian3();\nvar scratchBoundingSphereCartographic = new Cartographic();\nvar scratchBoundingSphereCenter2D = new Cartesian3();\nvar scratchBoundingSphere = new BoundingSphere();\n\nfunction updateBatchTableBoundingSpheres(primitive, frameState) {\n  var hasDistanceDisplayCondition = defined(primitive._batchTableAttributeIndices.distanceDisplayCondition);\n\n  if (!hasDistanceDisplayCondition || primitive._batchTableBoundingSpheresUpdated) {\n    return;\n  }\n\n  var indices = primitive._batchTableBoundingSphereAttributeIndices;\n  var center3DHighIndex = indices.center3DHigh;\n  var center3DLowIndex = indices.center3DLow;\n  var center2DHighIndex = indices.center2DHigh;\n  var center2DLowIndex = indices.center2DLow;\n  var radiusIndex = indices.radius;\n  var projection = frameState.mapProjection;\n  var ellipsoid = projection.ellipsoid;\n  var batchTable = primitive._batchTable;\n  var boundingSpheres = primitive._instanceBoundingSpheres;\n  var length = boundingSpheres.length;\n\n  for (var i = 0; i < length; ++i) {\n    var boundingSphere = boundingSpheres[i];\n\n    if (!defined(boundingSphere)) {\n      continue;\n    }\n\n    var modelMatrix = primitive.modelMatrix;\n\n    if (defined(modelMatrix)) {\n      boundingSphere = BoundingSphere.transform(boundingSphere, modelMatrix, scratchBoundingSphere);\n    }\n\n    var center = boundingSphere.center;\n    var radius = boundingSphere.radius;\n    var encodedCenter = EncodedCartesian3.fromCartesian(center, scratchBoundingSphereCenterEncoded);\n    batchTable.setBatchedAttribute(i, center3DHighIndex, encodedCenter.high);\n    batchTable.setBatchedAttribute(i, center3DLowIndex, encodedCenter.low);\n\n    if (!frameState.scene3DOnly) {\n      var cartographic = ellipsoid.cartesianToCartographic(center, scratchBoundingSphereCartographic);\n      var center2D = projection.project(cartographic, scratchBoundingSphereCenter2D);\n      encodedCenter = EncodedCartesian3.fromCartesian(center2D, scratchBoundingSphereCenterEncoded);\n      batchTable.setBatchedAttribute(i, center2DHighIndex, encodedCenter.high);\n      batchTable.setBatchedAttribute(i, center2DLowIndex, encodedCenter.low);\n    }\n\n    batchTable.setBatchedAttribute(i, radiusIndex, radius);\n  }\n\n  primitive._batchTableBoundingSpheresUpdated = true;\n}\n\nvar offsetScratchCartesian = new Cartesian3();\nvar offsetCenterScratch = new Cartesian3();\n\nfunction updateBatchTableOffsets(primitive, frameState) {\n  var hasOffset = defined(primitive._batchTableAttributeIndices.offset);\n\n  if (!hasOffset || primitive._batchTableOffsetsUpdated || frameState.scene3DOnly) {\n    return;\n  }\n\n  var index2D = primitive._batchTableOffsetAttribute2DIndex;\n  var projection = frameState.mapProjection;\n  var ellipsoid = projection.ellipsoid;\n  var batchTable = primitive._batchTable;\n  var boundingSpheres = primitive._instanceBoundingSpheres;\n  var length = boundingSpheres.length;\n\n  for (var i = 0; i < length; ++i) {\n    var boundingSphere = boundingSpheres[i];\n\n    if (!defined(boundingSphere)) {\n      continue;\n    }\n\n    var offset = batchTable.getBatchedAttribute(i, primitive._batchTableAttributeIndices.offset);\n\n    if (Cartesian3.equals(offset, Cartesian3.ZERO)) {\n      batchTable.setBatchedAttribute(i, index2D, Cartesian3.ZERO);\n      continue;\n    }\n\n    var modelMatrix = primitive.modelMatrix;\n\n    if (defined(modelMatrix)) {\n      boundingSphere = BoundingSphere.transform(boundingSphere, modelMatrix, scratchBoundingSphere);\n    }\n\n    var center = boundingSphere.center;\n    center = ellipsoid.scaleToGeodeticSurface(center, offsetCenterScratch);\n    var cartographic = ellipsoid.cartesianToCartographic(center, scratchBoundingSphereCartographic);\n    var center2D = projection.project(cartographic, scratchBoundingSphereCenter2D);\n    var newPoint = Cartesian3.add(offset, center, offsetScratchCartesian);\n    cartographic = ellipsoid.cartesianToCartographic(newPoint, cartographic);\n    var newPointProjected = projection.project(cartographic, offsetScratchCartesian);\n    var newVector = Cartesian3.subtract(newPointProjected, center2D, offsetScratchCartesian);\n    var x = newVector.x;\n    newVector.x = newVector.z;\n    newVector.z = newVector.y;\n    newVector.y = x;\n    batchTable.setBatchedAttribute(i, index2D, newVector);\n  }\n\n  primitive._batchTableOffsetsUpdated = true;\n}\n\nfunction createVertexArray(primitive, frameState) {\n  var attributeLocations = primitive._attributeLocations;\n  var geometries = primitive._geometries;\n  var scene3DOnly = frameState.scene3DOnly;\n  var context = frameState.context;\n  var va = [];\n  var length = geometries.length;\n\n  for (var i = 0; i < length; ++i) {\n    var geometry = geometries[i];\n    va.push(VertexArray.fromGeometry({\n      context: context,\n      geometry: geometry,\n      attributeLocations: attributeLocations,\n      bufferUsage: BufferUsage.STATIC_DRAW,\n      interleave: primitive._interleave\n    }));\n\n    if (defined(primitive._createBoundingVolumeFunction)) {\n      primitive._createBoundingVolumeFunction(frameState, geometry);\n    } else {\n      primitive._boundingSpheres.push(BoundingSphere.clone(geometry.boundingSphere));\n\n      primitive._boundingSphereWC.push(new BoundingSphere());\n\n      if (!scene3DOnly) {\n        var center = geometry.boundingSphereCV.center;\n        var x = center.x;\n        var y = center.y;\n        var z = center.z;\n        center.x = z;\n        center.y = x;\n        center.z = y;\n\n        primitive._boundingSphereCV.push(BoundingSphere.clone(geometry.boundingSphereCV));\n\n        primitive._boundingSphere2D.push(new BoundingSphere());\n\n        primitive._boundingSphereMorph.push(new BoundingSphere());\n      }\n    }\n  }\n\n  primitive._va = va;\n  primitive._primitiveType = geometries[0].primitiveType;\n\n  if (primitive.releaseGeometryInstances) {\n    primitive.geometryInstances = undefined;\n  }\n\n  primitive._geometries = undefined;\n  setReady(primitive, frameState, PrimitiveState.COMPLETE, undefined);\n}\n\nfunction createRenderStates(primitive, context, appearance, twoPasses) {\n  var renderState = appearance.getRenderState();\n  var rs;\n\n  if (twoPasses) {\n    rs = clone(renderState, false);\n    rs.cull = {\n      enabled: true,\n      face: CullFace.BACK\n    };\n    primitive._frontFaceRS = RenderState.fromCache(rs);\n    rs.cull.face = CullFace.FRONT;\n    primitive._backFaceRS = RenderState.fromCache(rs);\n  } else {\n    primitive._frontFaceRS = RenderState.fromCache(renderState);\n    primitive._backFaceRS = primitive._frontFaceRS;\n  }\n\n  rs = clone(renderState, false);\n\n  if (defined(primitive._depthFailAppearance)) {\n    rs.depthTest.enabled = false;\n  }\n\n  if (defined(primitive._depthFailAppearance)) {\n    renderState = primitive._depthFailAppearance.getRenderState();\n    rs = clone(renderState, false);\n    rs.depthTest.func = DepthFunction.GREATER;\n\n    if (twoPasses) {\n      rs.cull = {\n        enabled: true,\n        face: CullFace.BACK\n      };\n      primitive._frontFaceDepthFailRS = RenderState.fromCache(rs);\n      rs.cull.face = CullFace.FRONT;\n      primitive._backFaceDepthFailRS = RenderState.fromCache(rs);\n    } else {\n      primitive._frontFaceDepthFailRS = RenderState.fromCache(rs);\n      primitive._backFaceDepthFailRS = primitive._frontFaceRS;\n    }\n  }\n}\n\nfunction createShaderProgram(primitive, frameState, appearance) {\n  var context = frameState.context;\n  var attributeLocations = primitive._attributeLocations;\n\n  var vs = primitive._batchTable.getVertexShaderCallback()(appearance.vertexShaderSource);\n\n  vs = Primitive._appendOffsetToShader(primitive, vs);\n  vs = Primitive._appendShowToShader(primitive, vs);\n  vs = Primitive._appendDistanceDisplayConditionToShader(primitive, vs, frameState.scene3DOnly);\n  vs = appendPickToVertexShader(vs);\n  vs = Primitive._updateColorAttribute(primitive, vs, false);\n  vs = modifyForEncodedNormals(primitive, vs);\n  vs = Primitive._modifyShaderPosition(primitive, vs, frameState.scene3DOnly);\n  var fs = appearance.getFragmentShaderSource();\n  fs = appendPickToFragmentShader(fs);\n  primitive._sp = ShaderProgram.replaceCache({\n    context: context,\n    shaderProgram: primitive._sp,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations\n  });\n  validateShaderMatching(primitive._sp, attributeLocations);\n\n  if (defined(primitive._depthFailAppearance)) {\n    vs = primitive._batchTable.getVertexShaderCallback()(primitive._depthFailAppearance.vertexShaderSource);\n    vs = Primitive._appendShowToShader(primitive, vs);\n    vs = Primitive._appendDistanceDisplayConditionToShader(primitive, vs, frameState.scene3DOnly);\n    vs = appendPickToVertexShader(vs);\n    vs = Primitive._updateColorAttribute(primitive, vs, true);\n    vs = modifyForEncodedNormals(primitive, vs);\n    vs = Primitive._modifyShaderPosition(primitive, vs, frameState.scene3DOnly);\n    vs = depthClampVS(vs);\n    fs = primitive._depthFailAppearance.getFragmentShaderSource();\n    fs = appendPickToFragmentShader(fs);\n    fs = depthClampFS(fs);\n    primitive._spDepthFail = ShaderProgram.replaceCache({\n      context: context,\n      shaderProgram: primitive._spDepthFail,\n      vertexShaderSource: vs,\n      fragmentShaderSource: fs,\n      attributeLocations: attributeLocations\n    });\n    validateShaderMatching(primitive._spDepthFail, attributeLocations);\n  }\n}\n\nvar modifiedModelViewScratch = new Matrix4();\nvar rtcScratch = new Cartesian3();\n\nfunction getUniforms(primitive, appearance, material, frameState) {\n  // Create uniform map by combining uniforms from the appearance and material if either have uniforms.\n  var materialUniformMap = defined(material) ? material._uniforms : undefined;\n  var appearanceUniformMap = {};\n  var appearanceUniforms = appearance.uniforms;\n\n  if (defined(appearanceUniforms)) {\n    // Convert to uniform map of functions for the renderer\n    for (var name in appearanceUniforms) {\n      if (appearanceUniforms.hasOwnProperty(name)) {\n        //>>includeStart('debug', pragmas.debug);\n        if (defined(materialUniformMap) && defined(materialUniformMap[name])) {\n          // Later, we could rename uniforms behind-the-scenes if needed.\n          throw new DeveloperError(\"Appearance and material have a uniform with the same name: \" + name);\n        } //>>includeEnd('debug');\n\n\n        appearanceUniformMap[name] = getUniformFunction(appearanceUniforms, name);\n      }\n    }\n  }\n\n  var uniforms = combine(appearanceUniformMap, materialUniformMap);\n  uniforms = primitive._batchTable.getUniformMapCallback()(uniforms);\n\n  if (defined(primitive.rtcCenter)) {\n    uniforms.u_modifiedModelView = function () {\n      var viewMatrix = frameState.context.uniformState.view;\n      Matrix4.multiply(viewMatrix, primitive._modelMatrix, modifiedModelViewScratch);\n      Matrix4.multiplyByPoint(modifiedModelViewScratch, primitive.rtcCenter, rtcScratch);\n      Matrix4.setTranslation(modifiedModelViewScratch, rtcScratch, modifiedModelViewScratch);\n      return modifiedModelViewScratch;\n    };\n  }\n\n  return uniforms;\n}\n\nfunction createCommands(primitive, appearance, material, translucent, twoPasses, colorCommands, pickCommands, frameState) {\n  var uniforms = getUniforms(primitive, appearance, material, frameState);\n  var depthFailUniforms;\n\n  if (defined(primitive._depthFailAppearance)) {\n    depthFailUniforms = getUniforms(primitive, primitive._depthFailAppearance, primitive._depthFailAppearance.material, frameState);\n  }\n\n  var pass = translucent ? Pass.TRANSLUCENT : Pass.OPAQUE;\n  var multiplier = twoPasses ? 2 : 1;\n  multiplier *= defined(primitive._depthFailAppearance) ? 2 : 1;\n  colorCommands.length = primitive._va.length * multiplier;\n  var length = colorCommands.length;\n  var vaIndex = 0;\n\n  for (var i = 0; i < length; ++i) {\n    var colorCommand;\n\n    if (twoPasses) {\n      colorCommand = colorCommands[i];\n\n      if (!defined(colorCommand)) {\n        colorCommand = colorCommands[i] = new DrawCommand({\n          owner: primitive,\n          primitiveType: primitive._primitiveType\n        });\n      }\n\n      colorCommand.vertexArray = primitive._va[vaIndex];\n      colorCommand.renderState = primitive._backFaceRS;\n      colorCommand.shaderProgram = primitive._sp;\n      colorCommand.uniformMap = uniforms;\n      colorCommand.pass = pass;\n      ++i;\n    }\n\n    colorCommand = colorCommands[i];\n\n    if (!defined(colorCommand)) {\n      colorCommand = colorCommands[i] = new DrawCommand({\n        owner: primitive,\n        primitiveType: primitive._primitiveType\n      });\n    }\n\n    colorCommand.vertexArray = primitive._va[vaIndex];\n    colorCommand.renderState = primitive._frontFaceRS;\n    colorCommand.shaderProgram = primitive._sp;\n    colorCommand.uniformMap = uniforms;\n    colorCommand.pass = pass;\n\n    if (defined(primitive._depthFailAppearance)) {\n      if (twoPasses) {\n        ++i;\n        colorCommand = colorCommands[i];\n\n        if (!defined(colorCommand)) {\n          colorCommand = colorCommands[i] = new DrawCommand({\n            owner: primitive,\n            primitiveType: primitive._primitiveType\n          });\n        }\n\n        colorCommand.vertexArray = primitive._va[vaIndex];\n        colorCommand.renderState = primitive._backFaceDepthFailRS;\n        colorCommand.shaderProgram = primitive._spDepthFail;\n        colorCommand.uniformMap = depthFailUniforms;\n        colorCommand.pass = pass;\n      }\n\n      ++i;\n      colorCommand = colorCommands[i];\n\n      if (!defined(colorCommand)) {\n        colorCommand = colorCommands[i] = new DrawCommand({\n          owner: primitive,\n          primitiveType: primitive._primitiveType\n        });\n      }\n\n      colorCommand.vertexArray = primitive._va[vaIndex];\n      colorCommand.renderState = primitive._frontFaceDepthFailRS;\n      colorCommand.shaderProgram = primitive._spDepthFail;\n      colorCommand.uniformMap = depthFailUniforms;\n      colorCommand.pass = pass;\n    }\n\n    ++vaIndex;\n  }\n}\n\nPrimitive._updateBoundingVolumes = function (primitive, frameState, modelMatrix, forceUpdate) {\n  var i;\n  var length;\n  var boundingSphere;\n\n  if (forceUpdate || !Matrix4.equals(modelMatrix, primitive._modelMatrix)) {\n    Matrix4.clone(modelMatrix, primitive._modelMatrix);\n    length = primitive._boundingSpheres.length;\n\n    for (i = 0; i < length; ++i) {\n      boundingSphere = primitive._boundingSpheres[i];\n\n      if (defined(boundingSphere)) {\n        primitive._boundingSphereWC[i] = BoundingSphere.transform(boundingSphere, modelMatrix, primitive._boundingSphereWC[i]);\n\n        if (!frameState.scene3DOnly) {\n          primitive._boundingSphere2D[i] = BoundingSphere.clone(primitive._boundingSphereCV[i], primitive._boundingSphere2D[i]);\n          primitive._boundingSphere2D[i].center.x = 0.0;\n          primitive._boundingSphereMorph[i] = BoundingSphere.union(primitive._boundingSphereWC[i], primitive._boundingSphereCV[i]);\n        }\n      }\n    }\n  } // Update bounding volumes for primitives that are sized in pixels.\n  // The pixel size in meters varies based on the distance from the camera.\n\n\n  var pixelSize = primitive.appearance.pixelSize;\n\n  if (defined(pixelSize)) {\n    length = primitive._boundingSpheres.length;\n\n    for (i = 0; i < length; ++i) {\n      boundingSphere = primitive._boundingSpheres[i];\n      var boundingSphereWC = primitive._boundingSphereWC[i];\n      var pixelSizeInMeters = frameState.camera.getPixelSize(boundingSphere, frameState.context.drawingBufferWidth, frameState.context.drawingBufferHeight);\n      var sizeInMeters = pixelSizeInMeters * pixelSize;\n      boundingSphereWC.radius = boundingSphere.radius + sizeInMeters;\n    }\n  }\n};\n\nfunction updateAndQueueCommands(primitive, frameState, colorCommands, pickCommands, modelMatrix, cull, debugShowBoundingVolume, twoPasses) {\n  //>>includeStart('debug', pragmas.debug);\n  if (frameState.mode !== SceneMode.SCENE3D && !Matrix4.equals(modelMatrix, Matrix4.IDENTITY)) {\n    throw new DeveloperError(\"Primitive.modelMatrix is only supported in 3D mode.\");\n  } //>>includeEnd('debug');\n\n\n  Primitive._updateBoundingVolumes(primitive, frameState, modelMatrix);\n\n  var boundingSpheres;\n\n  if (frameState.mode === SceneMode.SCENE3D) {\n    boundingSpheres = primitive._boundingSphereWC;\n  } else if (frameState.mode === SceneMode.COLUMBUS_VIEW) {\n    boundingSpheres = primitive._boundingSphereCV;\n  } else if (frameState.mode === SceneMode.SCENE2D && defined(primitive._boundingSphere2D)) {\n    boundingSpheres = primitive._boundingSphere2D;\n  } else if (defined(primitive._boundingSphereMorph)) {\n    boundingSpheres = primitive._boundingSphereMorph;\n  }\n\n  var commandList = frameState.commandList;\n  var passes = frameState.passes;\n\n  if (passes.render || passes.pick) {\n    var allowPicking = primitive.allowPicking;\n    var castShadows = ShadowMode.castShadows(primitive.shadows);\n    var receiveShadows = ShadowMode.receiveShadows(primitive.shadows);\n    var colorLength = colorCommands.length;\n    var factor = twoPasses ? 2 : 1;\n    factor *= defined(primitive._depthFailAppearance) ? 2 : 1;\n\n    for (var j = 0; j < colorLength; ++j) {\n      var sphereIndex = Math.floor(j / factor);\n      var colorCommand = colorCommands[j];\n      colorCommand.modelMatrix = modelMatrix;\n      colorCommand.boundingVolume = boundingSpheres[sphereIndex];\n      colorCommand.cull = cull;\n      colorCommand.debugShowBoundingVolume = debugShowBoundingVolume;\n      colorCommand.castShadows = castShadows;\n      colorCommand.receiveShadows = receiveShadows;\n\n      if (allowPicking) {\n        colorCommand.pickId = \"v_pickColor\";\n      } else {\n        colorCommand.pickId = undefined;\n      }\n\n      commandList.push(colorCommand);\n    }\n  }\n}\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {DeveloperError} All instance geometries must have the same primitiveType.\n * @exception {DeveloperError} Appearance and material have a uniform with the same name.\n * @exception {DeveloperError} Primitive.modelMatrix is only supported in 3D mode.\n * @exception {RuntimeError} Vertex texture fetch support is required to render primitives with per-instance attributes. The maximum number of vertex texture image units must be greater than zero.\n */\n\n\nPrimitive.prototype.update = function (frameState) {\n  if (!defined(this.geometryInstances) && this._va.length === 0 || defined(this.geometryInstances) && Array.isArray(this.geometryInstances) && this.geometryInstances.length === 0 || !defined(this.appearance) || frameState.mode !== SceneMode.SCENE3D && frameState.scene3DOnly || !frameState.passes.render && !frameState.passes.pick) {\n    return;\n  }\n\n  if (defined(this._error)) {\n    throw this._error;\n  } //>>includeStart('debug', pragmas.debug);\n\n\n  if (defined(this.rtcCenter) && !frameState.scene3DOnly) {\n    throw new DeveloperError(\"RTC rendering is only available for 3D only scenes.\");\n  } //>>includeEnd('debug');\n\n\n  if (this._state === PrimitiveState.FAILED) {\n    return;\n  }\n\n  var context = frameState.context;\n\n  if (!defined(this._batchTable)) {\n    createBatchTable(this, context);\n  }\n\n  if (this._batchTable.attributes.length > 0) {\n    if (ContextLimits.maximumVertexTextureImageUnits === 0) {\n      throw new RuntimeError(\"Vertex texture fetch support is required to render primitives with per-instance attributes. The maximum number of vertex texture image units must be greater than zero.\");\n    }\n\n    this._batchTable.update(frameState);\n  }\n\n  if (this._state !== PrimitiveState.COMPLETE && this._state !== PrimitiveState.COMBINED) {\n    if (this.asynchronous) {\n      loadAsynchronous(this, frameState);\n    } else {\n      loadSynchronous(this, frameState);\n    }\n  }\n\n  if (this._state === PrimitiveState.COMBINED) {\n    updateBatchTableBoundingSpheres(this, frameState);\n    updateBatchTableOffsets(this, frameState);\n    createVertexArray(this, frameState);\n  }\n\n  if (!this.show || this._state !== PrimitiveState.COMPLETE) {\n    return;\n  }\n\n  if (!this._batchTableOffsetsUpdated) {\n    updateBatchTableOffsets(this, frameState);\n  }\n\n  if (this._recomputeBoundingSpheres) {\n    recomputeBoundingSpheres(this, frameState);\n  } // Create or recreate render state and shader program if appearance/material changed\n\n\n  var appearance = this.appearance;\n  var material = appearance.material;\n  var createRS = false;\n  var createSP = false;\n\n  if (this._appearance !== appearance) {\n    this._appearance = appearance;\n    this._material = material;\n    createRS = true;\n    createSP = true;\n  } else if (this._material !== material) {\n    this._material = material;\n    createSP = true;\n  }\n\n  var depthFailAppearance = this.depthFailAppearance;\n  var depthFailMaterial = defined(depthFailAppearance) ? depthFailAppearance.material : undefined;\n\n  if (this._depthFailAppearance !== depthFailAppearance) {\n    this._depthFailAppearance = depthFailAppearance;\n    this._depthFailMaterial = depthFailMaterial;\n    createRS = true;\n    createSP = true;\n  } else if (this._depthFailMaterial !== depthFailMaterial) {\n    this._depthFailMaterial = depthFailMaterial;\n    createSP = true;\n  }\n\n  var translucent = this._appearance.isTranslucent();\n\n  if (this._translucent !== translucent) {\n    this._translucent = translucent;\n    createRS = true;\n  }\n\n  if (defined(this._material)) {\n    this._material.update(context);\n  }\n\n  var twoPasses = appearance.closed && translucent;\n\n  if (createRS) {\n    var rsFunc = defaultValue(this._createRenderStatesFunction, createRenderStates);\n    rsFunc(this, context, appearance, twoPasses);\n  }\n\n  if (createSP) {\n    var spFunc = defaultValue(this._createShaderProgramFunction, createShaderProgram);\n    spFunc(this, frameState, appearance);\n  }\n\n  if (createRS || createSP) {\n    var commandFunc = defaultValue(this._createCommandsFunction, createCommands);\n    commandFunc(this, appearance, material, translucent, twoPasses, this._colorCommands, this._pickCommands, frameState);\n  }\n\n  var updateAndQueueCommandsFunc = defaultValue(this._updateAndQueueCommandsFunction, updateAndQueueCommands);\n  updateAndQueueCommandsFunc(this, frameState, this._colorCommands, this._pickCommands, this.modelMatrix, this.cull, this.debugShowBoundingVolume, twoPasses);\n};\n\nvar offsetBoundingSphereScratch1 = new BoundingSphere();\nvar offsetBoundingSphereScratch2 = new BoundingSphere();\n\nfunction transformBoundingSphere(boundingSphere, offset, offsetAttribute) {\n  if (offsetAttribute === GeometryOffsetAttribute.TOP) {\n    var origBS = BoundingSphere.clone(boundingSphere, offsetBoundingSphereScratch1);\n    var offsetBS = BoundingSphere.clone(boundingSphere, offsetBoundingSphereScratch2);\n    offsetBS.center = Cartesian3.add(offsetBS.center, offset, offsetBS.center);\n    boundingSphere = BoundingSphere.union(origBS, offsetBS, boundingSphere);\n  } else if (offsetAttribute === GeometryOffsetAttribute.ALL) {\n    boundingSphere.center = Cartesian3.add(boundingSphere.center, offset, boundingSphere.center);\n  }\n\n  return boundingSphere;\n}\n\nfunction createGetFunction(batchTable, instanceIndex, attributeIndex) {\n  return function () {\n    var attributeValue = batchTable.getBatchedAttribute(instanceIndex, attributeIndex);\n    var attribute = batchTable.attributes[attributeIndex];\n    var componentsPerAttribute = attribute.componentsPerAttribute;\n    var value = ComponentDatatype.createTypedArray(attribute.componentDatatype, componentsPerAttribute);\n\n    if (defined(attributeValue.constructor.pack)) {\n      attributeValue.constructor.pack(attributeValue, value, 0);\n    } else {\n      value[0] = attributeValue;\n    }\n\n    return value;\n  };\n}\n\nfunction createSetFunction(batchTable, instanceIndex, attributeIndex, primitive, name) {\n  return function (value) {\n    //>>includeStart('debug', pragmas.debug);\n    if (!defined(value) || !defined(value.length) || value.length < 1 || value.length > 4) {\n      throw new DeveloperError(\"value must be and array with length between 1 and 4.\");\n    } //>>includeEnd('debug');\n\n\n    var attributeValue = getAttributeValue(value);\n    batchTable.setBatchedAttribute(instanceIndex, attributeIndex, attributeValue);\n\n    if (name === \"offset\") {\n      primitive._recomputeBoundingSpheres = true;\n      primitive._batchTableOffsetsUpdated = false;\n    }\n  };\n}\n\nvar offsetScratch = new Cartesian3();\n\nfunction createBoundingSphereProperties(primitive, properties, index) {\n  properties.boundingSphere = {\n    get: function () {\n      var boundingSphere = primitive._instanceBoundingSpheres[index];\n\n      if (defined(boundingSphere)) {\n        boundingSphere = boundingSphere.clone();\n        var modelMatrix = primitive.modelMatrix;\n        var offset = properties.offset;\n\n        if (defined(offset)) {\n          transformBoundingSphere(boundingSphere, Cartesian3.fromArray(offset.get(), 0, offsetScratch), primitive._offsetInstanceExtend[index]);\n        }\n\n        if (defined(modelMatrix)) {\n          boundingSphere = BoundingSphere.transform(boundingSphere, modelMatrix);\n        }\n      }\n\n      return boundingSphere;\n    }\n  };\n  properties.boundingSphereCV = {\n    get: function () {\n      return primitive._instanceBoundingSpheresCV[index];\n    }\n  };\n}\n\nfunction createPickIdProperty(primitive, properties, index) {\n  properties.pickId = {\n    get: function () {\n      return primitive._pickIds[index];\n    }\n  };\n}\n/**\n * Returns the modifiable per-instance attributes for a {@link GeometryInstance}.\n *\n * @param {*} id The id of the {@link GeometryInstance}.\n * @returns {Object} The typed array in the attribute's format or undefined if the is no instance with id.\n *\n * @exception {DeveloperError} must call update before calling getGeometryInstanceAttributes.\n *\n * @example\n * var attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);\n * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);\n * attributes.distanceDisplayCondition = Cesium.DistanceDisplayConditionGeometryInstanceAttribute.toValue(100.0, 10000.0);\n * attributes.offset = Cesium.OffsetGeometryInstanceAttribute.toValue(Cartesian3.IDENTITY);\n */\n\n\nPrimitive.prototype.getGeometryInstanceAttributes = function (id) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(id)) {\n    throw new DeveloperError(\"id is required\");\n  }\n\n  if (!defined(this._batchTable)) {\n    throw new DeveloperError(\"must call update before calling getGeometryInstanceAttributes\");\n  } //>>includeEnd('debug');\n\n\n  var index = -1;\n  var lastIndex = this._lastPerInstanceAttributeIndex;\n  var ids = this._instanceIds;\n  var length = ids.length;\n\n  for (var i = 0; i < length; ++i) {\n    var curIndex = (lastIndex + i) % length;\n\n    if (id === ids[curIndex]) {\n      index = curIndex;\n      break;\n    }\n  }\n\n  if (index === -1) {\n    return undefined;\n  }\n\n  var attributes = this._perInstanceAttributeCache[index];\n\n  if (defined(attributes)) {\n    return attributes;\n  }\n\n  var batchTable = this._batchTable;\n  var perInstanceAttributeIndices = this._batchTableAttributeIndices;\n  attributes = {};\n  var properties = {};\n\n  for (var name in perInstanceAttributeIndices) {\n    if (perInstanceAttributeIndices.hasOwnProperty(name)) {\n      var attributeIndex = perInstanceAttributeIndices[name];\n      properties[name] = {\n        get: createGetFunction(batchTable, index, attributeIndex),\n        set: createSetFunction(batchTable, index, attributeIndex, this, name)\n      };\n    }\n  }\n\n  createBoundingSphereProperties(this, properties, index);\n  createPickIdProperty(this, properties, index);\n  Object.defineProperties(attributes, properties);\n  this._lastPerInstanceAttributeIndex = index;\n  this._perInstanceAttributeCache[index] = attributes;\n  return attributes;\n};\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see Primitive#destroy\n */\n\n\nPrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * e = e && e.destroy();\n *\n * @see Primitive#isDestroyed\n */\n\n\nPrimitive.prototype.destroy = function () {\n  var length;\n  var i;\n  this._sp = this._sp && this._sp.destroy();\n  this._spDepthFail = this._spDepthFail && this._spDepthFail.destroy();\n  var va = this._va;\n  length = va.length;\n\n  for (i = 0; i < length; ++i) {\n    va[i].destroy();\n  }\n\n  this._va = undefined;\n  var pickIds = this._pickIds;\n  length = pickIds.length;\n\n  for (i = 0; i < length; ++i) {\n    pickIds[i].destroy();\n  }\n\n  this._pickIds = undefined;\n  this._batchTable = this._batchTable && this._batchTable.destroy(); //These objects may be fairly large and reference other large objects (like Entities)\n  //We explicitly set them to undefined here so that the memory can be freed\n  //even if a reference to the destroyed Primitive has been kept around.\n\n  this._instanceIds = undefined;\n  this._perInstanceAttributeCache = undefined;\n  this._attributeLocations = undefined;\n  return destroyObject(this);\n};\n\nfunction setReady(primitive, frameState, state, error) {\n  primitive._error = error;\n  primitive._state = state;\n  frameState.afterRender.push(function () {\n    primitive._ready = primitive._state === PrimitiveState.COMPLETE || primitive._state === PrimitiveState.FAILED;\n\n    if (!defined(error)) {\n      primitive._readyPromise.resolve(primitive);\n    } else {\n      primitive._readyPromise.reject(error);\n    }\n  });\n}\n\nexport default Primitive;","map":{"version":3,"sources":["/home/usuario/davi/thalamus/wms/3dmaptestes/leaflet_cesium/client/node_modules/cesium/Source/Scene/Primitive.js"],"names":["BoundingSphere","Cartesian2","Cartesian3","Cartesian4","Cartographic","clone","Color","combine","ComponentDatatype","defaultValue","defined","destroyObject","DeveloperError","EncodedCartesian3","FeatureDetection","Geometry","GeometryAttribute","GeometryAttributes","GeometryOffsetAttribute","Intersect","Matrix4","Plane","RuntimeError","subdivideArray","TaskProcessor","BufferUsage","ContextLimits","DrawCommand","Pass","RenderState","ShaderProgram","ShaderSource","VertexArray","when","BatchTable","CullFace","DepthFunction","PrimitivePipeline","PrimitiveState","SceneMode","ShadowMode","Primitive","options","EMPTY_OBJECT","geometryInstances","appearance","_appearance","undefined","_material","depthFailAppearance","_depthFailAppearance","_depthFailMaterial","modelMatrix","IDENTITY","_modelMatrix","show","_vertexCacheOptimize","vertexCacheOptimize","_interleave","interleave","_releaseGeometryInstances","releaseGeometryInstances","_allowPicking","allowPicking","_asynchronous","asynchronous","_compressVertices","compressVertices","cull","debugShowBoundingVolume","rtcCenter","Array","isArray","length","shadows","DISABLED","_translucent","_state","READY","_geometries","_error","_numberOfInstances","_boundingSpheres","_boundingSphereWC","_boundingSphereCV","_boundingSphere2D","_boundingSphereMorph","_perInstanceAttributeCache","_instanceIds","_lastPerInstanceAttributeIndex","_va","_attributeLocations","_primitiveType","_frontFaceRS","_backFaceRS","_sp","_spDepthFail","_frontFaceDepthFailRS","_backFaceDepthFailRS","_pickIds","_colorCommands","_pickCommands","_createBoundingVolumeFunction","_createRenderStatesFunction","_createShaderProgramFunction","_createCommandsFunction","_updateAndQueueCommandsFunction","_createPickOffsets","_pickOffsets","_createGeometryResults","_ready","_readyPromise","defer","_batchTable","_batchTableAttributeIndices","_offsetInstanceExtend","_batchTableOffsetAttribute2DIndex","_batchTableOffsetsUpdated","_instanceBoundingSpheres","_instanceBoundingSpheresCV","_tempBoundingSpheres","_recomputeBoundingSpheres","_batchTableBoundingSpheresUpdated","_batchTableBoundingSphereAttributeIndices","Object","defineProperties","prototype","get","ready","readyPromise","promise","getCommonPerInstanceAttributeNames","instances","attributesInAllInstances","attributes0","attributes","name","hasOwnProperty","attribute","inAllInstances","i","otherAttribute","componentDatatype","componentsPerAttribute","normalize","push","scratchGetAttributeCartesian2","scratchGetAttributeCartesian3","scratchGetAttributeCartesian4","getAttributeValue","value","unpack","createBatchTable","primitive","context","numberOfInstances","names","attributeIndices","boundingSphereAttributeIndices","offset2DIndex","firstInstance","instanceAttributes","functionName","indexOf","FLOAT","center3DHigh","center3DLow","center2DHigh","center2DLow","radius","UNSIGNED_BYTE","attributesLength","batchTable","instance","j","attributeIndex","setBatchedAttribute","pickObject","pickPrimitive","id","pickId","createPickId","pickColor","color","x","floatToByte","red","y","green","z","blue","w","alpha","cloneAttribute","clonedValues","values","slice","constructor","cloneGeometry","geometry","newAttributes","property","indices","sourceValues","primitiveType","boundingSphere","cloneInstance","positionRegex","_modifyShaderPosition","vertexShaderSource","scene3DOnly","match","forwardDecl","computeFunctions","exec","toUpperCase","substr","replace","join","_appendShowToShader","renamedVS","replaceMain","showMain","_updateColorAttribute","isDepthFail","depthFailColor","search","modifiedVS","appendPickToVertexShader","source","pickMain","appendPickToFragmentShader","_updatePickColorAttribute","vsPick","_appendOffsetToShader","offset","attr","modifiedShader","str","_appendDistanceDisplayConditionToShader","distanceDisplayCondition","distanceDisplayConditionMain","modifyForEncodedNormals","containsNormal","containsSt","containsTangent","containsBitangent","numComponents","type","attributeName","attributeDecl","globalDecl","decode","stComponent","compressedMain","depthClampVS","depthClampFS","fragmentShaderSource","modifiedFS","validateShaderMatching","shaderProgram","attributeLocations","shaderAttributes","vertexAttributes","getUniformFunction","uniforms","numberOfCreationWorkers","Math","max","hardwareConcurrency","createGeometryTaskProcessors","combineGeometryTaskProcessor","loadAsynchronous","frameState","instanceIds","promises","subTasks","_workerName","moduleName","subTask","packedLength","workerSubTasks","workerSubTasksLength","pack","subTaskTransferableObjects","array","Float64Array","buffer","scheduleTask","CREATING","all","results","CREATED","otherwise","error","setReady","FAILED","transferableObjects","projection","mapProjection","packCombineGeometryParameters","createGeometryResults","ellipsoid","elementIndexUintSupported","elementIndexUint","createPickOffsets","COMBINING","packedResult","result","unpackCombineGeometryResults","geometries","pickOffsets","offsetInstanceExtend","boundingSpheres","boundingSpheresCV","COMBINED","loadSynchronous","clonedInstances","geometryIndex","createdGeometry","createGeometry","combineGeometry","recomputeBoundingSpheres","offsetIndex","newBoundingSpheres","newBS","getBatchedAttribute","transformBoundingSphere","combinedBS","combinedWestBS","combinedEastBS","bs","minX","center","intersectPlane","ORIGIN_ZX_PLANE","INTERSECTING","resultBS1","resultBS2","resultBS3","union","projectTo2D","_updateBoundingVolumes","scratchBoundingSphereCenterEncoded","scratchBoundingSphereCartographic","scratchBoundingSphereCenter2D","scratchBoundingSphere","updateBatchTableBoundingSpheres","hasDistanceDisplayCondition","center3DHighIndex","center3DLowIndex","center2DHighIndex","center2DLowIndex","radiusIndex","transform","encodedCenter","fromCartesian","high","low","cartographic","cartesianToCartographic","center2D","project","offsetScratchCartesian","offsetCenterScratch","updateBatchTableOffsets","hasOffset","index2D","equals","ZERO","scaleToGeodeticSurface","newPoint","add","newPointProjected","newVector","subtract","createVertexArray","va","fromGeometry","bufferUsage","STATIC_DRAW","boundingSphereCV","COMPLETE","createRenderStates","twoPasses","renderState","getRenderState","rs","enabled","face","BACK","fromCache","FRONT","depthTest","func","GREATER","createShaderProgram","vs","getVertexShaderCallback","fs","getFragmentShaderSource","replaceCache","modifiedModelViewScratch","rtcScratch","getUniforms","material","materialUniformMap","_uniforms","appearanceUniformMap","appearanceUniforms","getUniformMapCallback","u_modifiedModelView","viewMatrix","uniformState","view","multiply","multiplyByPoint","setTranslation","createCommands","translucent","colorCommands","pickCommands","depthFailUniforms","pass","TRANSLUCENT","OPAQUE","multiplier","vaIndex","colorCommand","owner","vertexArray","uniformMap","forceUpdate","pixelSize","boundingSphereWC","pixelSizeInMeters","camera","getPixelSize","drawingBufferWidth","drawingBufferHeight","sizeInMeters","updateAndQueueCommands","mode","SCENE3D","COLUMBUS_VIEW","SCENE2D","commandList","passes","render","pick","castShadows","receiveShadows","colorLength","factor","sphereIndex","floor","boundingVolume","update","maximumVertexTextureImageUnits","createRS","createSP","depthFailMaterial","isTranslucent","closed","rsFunc","spFunc","commandFunc","updateAndQueueCommandsFunc","offsetBoundingSphereScratch1","offsetBoundingSphereScratch2","offsetAttribute","TOP","origBS","offsetBS","ALL","createGetFunction","instanceIndex","attributeValue","createTypedArray","createSetFunction","offsetScratch","createBoundingSphereProperties","properties","index","fromArray","createPickIdProperty","getGeometryInstanceAttributes","lastIndex","ids","curIndex","perInstanceAttributeIndices","set","isDestroyed","destroy","pickIds","state","afterRender","resolve","reject"],"mappings":"AAAA,OAAOA,cAAP,MAA2B,2BAA3B;AACA,OAAOC,UAAP,MAAuB,uBAAvB;AACA,OAAOC,UAAP,MAAuB,uBAAvB;AACA,OAAOC,UAAP,MAAuB,uBAAvB;AACA,OAAOC,YAAP,MAAyB,yBAAzB;AACA,OAAOC,KAAP,MAAkB,kBAAlB;AACA,OAAOC,KAAP,MAAkB,kBAAlB;AACA,OAAOC,OAAP,MAAoB,oBAApB;AACA,OAAOC,iBAAP,MAA8B,8BAA9B;AACA,OAAOC,YAAP,MAAyB,yBAAzB;AACA,OAAOC,OAAP,MAAoB,oBAApB;AACA,OAAOC,aAAP,MAA0B,0BAA1B;AACA,OAAOC,cAAP,MAA2B,2BAA3B;AACA,OAAOC,iBAAP,MAA8B,8BAA9B;AACA,OAAOC,gBAAP,MAA6B,6BAA7B;AACA,OAAOC,QAAP,MAAqB,qBAArB;AACA,OAAOC,iBAAP,MAA8B,8BAA9B;AACA,OAAOC,kBAAP,MAA+B,+BAA/B;AACA,OAAOC,uBAAP,MAAoC,oCAApC;AACA,OAAOC,SAAP,MAAsB,sBAAtB;AACA,OAAOC,OAAP,MAAoB,oBAApB;AACA,OAAOC,KAAP,MAAkB,kBAAlB;AACA,OAAOC,YAAP,MAAyB,yBAAzB;AACA,OAAOC,cAAP,MAA2B,2BAA3B;AACA,OAAOC,aAAP,MAA0B,0BAA1B;AACA,OAAOC,WAAP,MAAwB,4BAAxB;AACA,OAAOC,aAAP,MAA0B,8BAA1B;AACA,OAAOC,WAAP,MAAwB,4BAAxB;AACA,OAAOC,IAAP,MAAiB,qBAAjB;AACA,OAAOC,WAAP,MAAwB,4BAAxB;AACA,OAAOC,aAAP,MAA0B,8BAA1B;AACA,OAAOC,YAAP,MAAyB,6BAAzB;AACA,OAAOC,WAAP,MAAwB,4BAAxB;AACA,OAAOC,IAAP,MAAiB,uBAAjB;AACA,OAAOC,UAAP,MAAuB,iBAAvB;AACA,OAAOC,QAAP,MAAqB,eAArB;AACA,OAAOC,aAAP,MAA0B,oBAA1B;AACA,OAAOC,iBAAP,MAA8B,wBAA9B;AACA,OAAOC,cAAP,MAA2B,qBAA3B;AACA,OAAOC,SAAP,MAAsB,gBAAtB;AACA,OAAOC,UAAP,MAAuB,iBAAvB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,SAAT,CAAmBC,OAAnB,EAA4B;AAC1BA,EAAAA,OAAO,GAAGjC,YAAY,CAACiC,OAAD,EAAUjC,YAAY,CAACkC,YAAvB,CAAtB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,iBAAL,GAAyBF,OAAO,CAACE,iBAAjC;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKC,UAAL,GAAkBH,OAAO,CAACG,UAA1B;AACA,OAAKC,WAAL,GAAmBC,SAAnB;AACA,OAAKC,SAAL,GAAiBD,SAAjB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,OAAKE,mBAAL,GAA2BP,OAAO,CAACO,mBAAnC;AACA,OAAKC,oBAAL,GAA4BH,SAA5B;AACA,OAAKI,kBAAL,GAA0BJ,SAA1B;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A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","sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EncodedCartesian3 from \"../Core/EncodedCartesian3.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport Geometry from \"../Core/Geometry.js\";\nimport GeometryAttribute from \"../Core/GeometryAttribute.js\";\nimport GeometryAttributes from \"../Core/GeometryAttributes.js\";\nimport GeometryOffsetAttribute from \"../Core/GeometryOffsetAttribute.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Plane from \"../Core/Plane.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport subdivideArray from \"../Core/subdivideArray.js\";\nimport TaskProcessor from \"../Core/TaskProcessor.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport ContextLimits from \"../Renderer/ContextLimits.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport when from \"../ThirdParty/when.js\";\nimport BatchTable from \"./BatchTable.js\";\nimport CullFace from \"./CullFace.js\";\nimport DepthFunction from \"./DepthFunction.js\";\nimport PrimitivePipeline from \"./PrimitivePipeline.js\";\nimport PrimitiveState from \"./PrimitiveState.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\n\n/**\n * A primitive represents geometry in the {@link Scene}.  The geometry can be from a single {@link GeometryInstance}\n * as shown in example 1 below, or from an array of instances, even if the geometry is from different\n * geometry types, e.g., an {@link RectangleGeometry} and an {@link EllipsoidGeometry} as shown in Code Example 2.\n * <p>\n * A primitive combines geometry instances with an {@link Appearance} that describes the full shading, including\n * {@link Material} and {@link RenderState}.  Roughly, the geometry instance defines the structure and placement,\n * and the appearance defines the visual characteristics.  Decoupling geometry and appearance allows us to mix\n * and match most of them and add a new geometry or appearance independently of each other.\n * </p>\n * <p>\n * Combining multiple instances into one primitive is called batching, and significantly improves performance for static data.\n * Instances can be individually picked; {@link Scene#pick} returns their {@link GeometryInstance#id}.  Using\n * per-instance appearances like {@link PerInstanceColorAppearance}, each instance can also have a unique color.\n * </p>\n * <p>\n * {@link Geometry} can either be created and batched on a web worker or the main thread. The first two examples\n * show geometry that will be created on a web worker by using the descriptions of the geometry. The third example\n * shows how to create the geometry on the main thread by explicitly calling the <code>createGeometry</code> method.\n * </p>\n *\n * @alias Primitive\n * @constructor\n *\n * @param {Object} [options] Object with the following properties:\n * @param {GeometryInstance[]|GeometryInstance} [options.geometryInstances] The geometry instances - or a single geometry instance - to render.\n * @param {Appearance} [options.appearance] The appearance used to render the primitive.\n * @param {Appearance} [options.depthFailAppearance] The appearance used to shade this primitive when it fails the depth test.\n * @param {Boolean} [options.show=true] Determines if this primitive will be shown.\n * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms the primitive (all geometry instances) from model to world coordinates.\n * @param {Boolean} [options.vertexCacheOptimize=false] When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.\n * @param {Boolean} [options.interleave=false] When <code>true</code>, geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time.\n * @param {Boolean} [options.compressVertices=true] When <code>true</code>, the geometry vertices are compressed, which will save memory.\n * @param {Boolean} [options.releaseGeometryInstances=true] When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.\n * @param {Boolean} [options.cull=true] When <code>true</code>, the renderer frustum culls and horizon culls the primitive's commands based on their bounding volume.  Set this to <code>false</code> for a small performance gain if you are manually culling the primitive.\n * @param {Boolean} [options.asynchronous=true] Determines if the primitive will be created asynchronously or block until ready.\n * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.\n * @param {ShadowMode} [options.shadows=ShadowMode.DISABLED] Determines whether this primitive casts or receives shadows from light sources.\n *\n * @example\n * // 1. Draw a translucent ellipse on the surface with a checkerboard pattern\n * var instance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.EllipseGeometry({\n *       center : Cesium.Cartesian3.fromDegrees(-100.0, 20.0),\n *       semiMinorAxis : 500000.0,\n *       semiMajorAxis : 1000000.0,\n *       rotation : Cesium.Math.PI_OVER_FOUR,\n *       vertexFormat : Cesium.VertexFormat.POSITION_AND_ST\n *   }),\n *   id : 'object returned when this instance is picked and to get/set per-instance attributes'\n * });\n * scene.primitives.add(new Cesium.Primitive({\n *   geometryInstances : instance,\n *   appearance : new Cesium.EllipsoidSurfaceAppearance({\n *     material : Cesium.Material.fromType('Checkerboard')\n *   })\n * }));\n *\n * @example\n * // 2. Draw different instances each with a unique color\n * var rectangleInstance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.RectangleGeometry({\n *     rectangle : Cesium.Rectangle.fromDegrees(-140.0, 30.0, -100.0, 40.0),\n *     vertexFormat : Cesium.PerInstanceColorAppearance.VERTEX_FORMAT\n *   }),\n *   id : 'rectangle',\n *   attributes : {\n *     color : new Cesium.ColorGeometryInstanceAttribute(0.0, 1.0, 1.0, 0.5)\n *   }\n * });\n * var ellipsoidInstance = new Cesium.GeometryInstance({\n *   geometry : new Cesium.EllipsoidGeometry({\n *     radii : new Cesium.Cartesian3(500000.0, 500000.0, 1000000.0),\n *     vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL\n *   }),\n *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *     Cesium.Cartesian3.fromDegrees(-95.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 500000.0), new Cesium.Matrix4()),\n *   id : 'ellipsoid',\n *   attributes : {\n *     color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)\n *   }\n * });\n * scene.primitives.add(new Cesium.Primitive({\n *   geometryInstances : [rectangleInstance, ellipsoidInstance],\n *   appearance : new Cesium.PerInstanceColorAppearance()\n * }));\n *\n * @example\n * // 3. Create the geometry on the main thread.\n * scene.primitives.add(new Cesium.Primitive({\n *   geometryInstances : new Cesium.GeometryInstance({\n *       geometry : Cesium.EllipsoidGeometry.createGeometry(new Cesium.EllipsoidGeometry({\n *         radii : new Cesium.Cartesian3(500000.0, 500000.0, 1000000.0),\n *         vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL\n *       })),\n *       modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n *         Cesium.Cartesian3.fromDegrees(-95.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 500000.0), new Cesium.Matrix4()),\n *       id : 'ellipsoid',\n *       attributes : {\n *         color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)\n *       }\n *   }),\n *   appearance : new Cesium.PerInstanceColorAppearance()\n * }));\n *\n * @see GeometryInstance\n * @see Appearance\n * @see ClassificationPrimitive\n * @see GroundPrimitive\n */\nfunction Primitive(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * The geometry instances rendered with this primitive.  This may\n   * be <code>undefined</code> if <code>options.releaseGeometryInstances</code>\n   * is <code>true</code> when the primitive is constructed.\n   * <p>\n   * Changing this property after the primitive is rendered has no effect.\n   * </p>\n   *\n   * @readonly\n   * @type GeometryInstance[]|GeometryInstance\n   *\n   * @default undefined\n   */\n  this.geometryInstances = options.geometryInstances;\n\n  /**\n   * The {@link Appearance} used to shade this primitive. Each geometry\n   * instance is shaded with the same appearance.  Some appearances, like\n   * {@link PerInstanceColorAppearance} allow giving each instance unique\n   * properties.\n   *\n   * @type Appearance\n   *\n   * @default undefined\n   */\n  this.appearance = options.appearance;\n  this._appearance = undefined;\n  this._material = undefined;\n\n  /**\n   * The {@link Appearance} used to shade this primitive when it fails the depth test. Each geometry\n   * instance is shaded with the same appearance.  Some appearances, like\n   * {@link PerInstanceColorAppearance} allow giving each instance unique\n   * properties.\n   *\n   * <p>\n   * When using an appearance that requires a color attribute, like PerInstanceColorAppearance,\n   * add a depthFailColor per-instance attribute instead.\n   * </p>\n   *\n   * <p>\n   * Requires the EXT_frag_depth WebGL extension to render properly. If the extension is not supported,\n   * there may be artifacts.\n   * </p>\n   * @type Appearance\n   *\n   * @default undefined\n   */\n  this.depthFailAppearance = options.depthFailAppearance;\n  this._depthFailAppearance = undefined;\n  this._depthFailMaterial = undefined;\n\n  /**\n   * The 4x4 transformation matrix that transforms the primitive (all geometry instances) from model to world coordinates.\n   * When this is the identity matrix, the primitive is drawn in world coordinates, i.e., Earth's WGS84 coordinates.\n   * Local reference frames can be used by providing a different transformation matrix, like that returned\n   * by {@link Transforms.eastNorthUpToFixedFrame}.\n   *\n   * <p>\n   * This property is only supported in 3D mode.\n   * </p>\n   *\n   * @type Matrix4\n   *\n   * @default Matrix4.IDENTITY\n   *\n   * @example\n   * var origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);\n   * p.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);\n   */\n  this.modelMatrix = Matrix4.clone(\n    defaultValue(options.modelMatrix, Matrix4.IDENTITY)\n  );\n  this._modelMatrix = new Matrix4();\n\n  /**\n   * Determines if the primitive will be shown.  This affects all geometry\n   * instances in the primitive.\n   *\n   * @type Boolean\n   *\n   * @default true\n   */\n  this.show = defaultValue(options.show, true);\n\n  this._vertexCacheOptimize = defaultValue(options.vertexCacheOptimize, false);\n  this._interleave = defaultValue(options.interleave, false);\n  this._releaseGeometryInstances = defaultValue(\n    options.releaseGeometryInstances,\n    true\n  );\n  this._allowPicking = defaultValue(options.allowPicking, true);\n  this._asynchronous = defaultValue(options.asynchronous, true);\n  this._compressVertices = defaultValue(options.compressVertices, true);\n\n  /**\n   * When <code>true</code>, the renderer frustum culls and horizon culls the primitive's commands\n   * based on their bounding volume.  Set this to <code>false</code> for a small performance gain\n   * if you are manually culling the primitive.\n   *\n   * @type {Boolean}\n   *\n   * @default true\n   */\n  this.cull = defaultValue(options.cull, true);\n\n  /**\n   * This property is for debugging only; it is not for production use nor is it optimized.\n   * <p>\n   * Draws the bounding sphere for each draw command in the primitive.\n   * </p>\n   *\n   * @type {Boolean}\n   *\n   * @default false\n   */\n  this.debugShowBoundingVolume = defaultValue(\n    options.debugShowBoundingVolume,\n    false\n  );\n\n  /**\n   * @private\n   */\n  this.rtcCenter = options.rtcCenter;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    defined(this.rtcCenter) &&\n    (!defined(this.geometryInstances) ||\n      (Array.isArray(this.geometryInstances) &&\n        this.geometryInstances.length !== 1))\n  ) {\n    throw new DeveloperError(\n      \"Relative-to-center rendering only supports one geometry instance.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  /**\n   * Determines whether this primitive casts or receives shadows from light sources.\n   *\n   * @type {ShadowMode}\n   *\n   * @default ShadowMode.DISABLED\n   */\n  this.shadows = defaultValue(options.shadows, ShadowMode.DISABLED);\n\n  this._translucent = undefined;\n\n  this._state = PrimitiveState.READY;\n  this._geometries = [];\n  this._error = undefined;\n  this._numberOfInstances = 0;\n\n  this._boundingSpheres = [];\n  this._boundingSphereWC = [];\n  this._boundingSphereCV = [];\n  this._boundingSphere2D = [];\n  this._boundingSphereMorph = [];\n  this._perInstanceAttributeCache = [];\n  this._instanceIds = [];\n  this._lastPerInstanceAttributeIndex = 0;\n\n  this._va = [];\n  this._attributeLocations = undefined;\n  this._primitiveType = undefined;\n\n  this._frontFaceRS = undefined;\n  this._backFaceRS = undefined;\n  this._sp = undefined;\n\n  this._depthFailAppearance = undefined;\n  this._spDepthFail = undefined;\n  this._frontFaceDepthFailRS = undefined;\n  this._backFaceDepthFailRS = undefined;\n\n  this._pickIds = [];\n\n  this._colorCommands = [];\n  this._pickCommands = [];\n\n  this._createBoundingVolumeFunction = options._createBoundingVolumeFunction;\n  this._createRenderStatesFunction = options._createRenderStatesFunction;\n  this._createShaderProgramFunction = options._createShaderProgramFunction;\n  this._createCommandsFunction = options._createCommandsFunction;\n  this._updateAndQueueCommandsFunction =\n    options._updateAndQueueCommandsFunction;\n\n  this._createPickOffsets = options._createPickOffsets;\n  this._pickOffsets = undefined;\n\n  this._createGeometryResults = undefined;\n  this._ready = false;\n  this._readyPromise = when.defer();\n\n  this._batchTable = undefined;\n  this._batchTableAttributeIndices = undefined;\n  this._offsetInstanceExtend = undefined;\n  this._batchTableOffsetAttribute2DIndex = undefined;\n  this._batchTableOffsetsUpdated = false;\n  this._instanceBoundingSpheres = undefined;\n  this._instanceBoundingSpheresCV = undefined;\n  this._tempBoundingSpheres = undefined;\n  this._recomputeBoundingSpheres = false;\n  this._batchTableBoundingSpheresUpdated = false;\n  this._batchTableBoundingSphereAttributeIndices = undefined;\n}\n\nObject.defineProperties(Primitive.prototype, {\n  /**\n   * When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  vertexCacheOptimize: {\n    get: function () {\n      return this._vertexCacheOptimize;\n    },\n  },\n\n  /**\n   * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  interleave: {\n    get: function () {\n      return this._interleave;\n    },\n  },\n\n  /**\n   * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  releaseGeometryInstances: {\n    get: function () {\n      return this._releaseGeometryInstances;\n    },\n  },\n\n  /**\n   * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.         *\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  allowPicking: {\n    get: function () {\n      return this._allowPicking;\n    },\n  },\n\n  /**\n   * Determines if the geometry instances will be created and batched on a web worker.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  asynchronous: {\n    get: function () {\n      return this._asynchronous;\n    },\n  },\n\n  /**\n   * When <code>true</code>, geometry vertices are compressed, which will save memory.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  compressVertices: {\n    get: function () {\n      return this._compressVertices;\n    },\n  },\n\n  /**\n   * Determines if the primitive is complete and ready to render.  If this property is\n   * true, the primitive will be rendered the next time that {@link Primitive#update}\n   * is called.\n   *\n   * @memberof Primitive.prototype\n   *\n   * @type {Boolean}\n   * @readonly\n   */\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  /**\n   * Gets a promise that resolves when the primitive is ready to render.\n   * @memberof Primitive.prototype\n   * @type {Promise.<Primitive>}\n   * @readonly\n   */\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    },\n  },\n});\n\nfunction getCommonPerInstanceAttributeNames(instances) {\n  var length = instances.length;\n\n  var attributesInAllInstances = [];\n  var attributes0 = instances[0].attributes;\n  var name;\n\n  for (name in attributes0) {\n    if (attributes0.hasOwnProperty(name) && defined(attributes0[name])) {\n      var attribute = attributes0[name];\n      var inAllInstances = true;\n\n      // Does this same attribute exist in all instances?\n      for (var i = 1; i < length; ++i) {\n        var otherAttribute = instances[i].attributes[name];\n\n        if (\n          !defined(otherAttribute) ||\n          attribute.componentDatatype !== otherAttribute.componentDatatype ||\n          attribute.componentsPerAttribute !==\n            otherAttribute.componentsPerAttribute ||\n          attribute.normalize !== otherAttribute.normalize\n        ) {\n          inAllInstances = false;\n          break;\n        }\n      }\n\n      if (inAllInstances) {\n        attributesInAllInstances.push(name);\n      }\n    }\n  }\n\n  return attributesInAllInstances;\n}\n\nvar scratchGetAttributeCartesian2 = new Cartesian2();\nvar scratchGetAttributeCartesian3 = new Cartesian3();\nvar scratchGetAttributeCartesian4 = new Cartesian4();\n\nfunction getAttributeValue(value) {\n  var componentsPerAttribute = value.length;\n  if (componentsPerAttribute === 1) {\n    return value[0];\n  } else if (componentsPerAttribute === 2) {\n    return Cartesian2.unpack(value, 0, scratchGetAttributeCartesian2);\n  } else if (componentsPerAttribute === 3) {\n    return Cartesian3.unpack(value, 0, scratchGetAttributeCartesian3);\n  } else if (componentsPerAttribute === 4) {\n    return Cartesian4.unpack(value, 0, scratchGetAttributeCartesian4);\n  }\n}\n\nfunction createBatchTable(primitive, context) {\n  var geometryInstances = primitive.geometryInstances;\n  var instances = Array.isArray(geometryInstances)\n    ? geometryInstances\n    : [geometryInstances];\n  var numberOfInstances = instances.length;\n  if (numberOfInstances === 0) {\n    return;\n  }\n\n  var names = getCommonPerInstanceAttributeNames(instances);\n  var length = names.length;\n\n  var attributes = [];\n  var attributeIndices = {};\n  var boundingSphereAttributeIndices = {};\n  var offset2DIndex;\n\n  var firstInstance = instances[0];\n  var instanceAttributes = firstInstance.attributes;\n\n  var i;\n  var name;\n  var attribute;\n\n  for (i = 0; i < length; ++i) {\n    name = names[i];\n    attribute = instanceAttributes[name];\n\n    attributeIndices[name] = i;\n    attributes.push({\n      functionName: \"czm_batchTable_\" + name,\n      componentDatatype: attribute.componentDatatype,\n      componentsPerAttribute: attribute.componentsPerAttribute,\n      normalize: attribute.normalize,\n    });\n  }\n\n  if (names.indexOf(\"distanceDisplayCondition\") !== -1) {\n    attributes.push(\n      {\n        functionName: \"czm_batchTable_boundingSphereCenter3DHigh\",\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n      },\n      {\n        functionName: \"czm_batchTable_boundingSphereCenter3DLow\",\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n      },\n      {\n        functionName: \"czm_batchTable_boundingSphereCenter2DHigh\",\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n      },\n      {\n        functionName: \"czm_batchTable_boundingSphereCenter2DLow\",\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 3,\n      },\n      {\n        functionName: \"czm_batchTable_boundingSphereRadius\",\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 1,\n      }\n    );\n    boundingSphereAttributeIndices.center3DHigh = attributes.length - 5;\n    boundingSphereAttributeIndices.center3DLow = attributes.length - 4;\n    boundingSphereAttributeIndices.center2DHigh = attributes.length - 3;\n    boundingSphereAttributeIndices.center2DLow = attributes.length - 2;\n    boundingSphereAttributeIndices.radius = attributes.length - 1;\n  }\n\n  if (names.indexOf(\"offset\") !== -1) {\n    attributes.push({\n      functionName: \"czm_batchTable_offset2D\",\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 3,\n    });\n    offset2DIndex = attributes.length - 1;\n  }\n\n  attributes.push({\n    functionName: \"czm_batchTable_pickColor\",\n    componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n    componentsPerAttribute: 4,\n    normalize: true,\n  });\n\n  var attributesLength = attributes.length;\n  var batchTable = new BatchTable(context, attributes, numberOfInstances);\n\n  for (i = 0; i < numberOfInstances; ++i) {\n    var instance = instances[i];\n    instanceAttributes = instance.attributes;\n\n    for (var j = 0; j < length; ++j) {\n      name = names[j];\n      attribute = instanceAttributes[name];\n      var value = getAttributeValue(attribute.value);\n      var attributeIndex = attributeIndices[name];\n      batchTable.setBatchedAttribute(i, attributeIndex, value);\n    }\n\n    var pickObject = {\n      primitive: defaultValue(instance.pickPrimitive, primitive),\n    };\n\n    if (defined(instance.id)) {\n      pickObject.id = instance.id;\n    }\n\n    var pickId = context.createPickId(pickObject);\n    primitive._pickIds.push(pickId);\n\n    var pickColor = pickId.color;\n    var color = scratchGetAttributeCartesian4;\n    color.x = Color.floatToByte(pickColor.red);\n    color.y = Color.floatToByte(pickColor.green);\n    color.z = Color.floatToByte(pickColor.blue);\n    color.w = Color.floatToByte(pickColor.alpha);\n\n    batchTable.setBatchedAttribute(i, attributesLength - 1, color);\n  }\n\n  primitive._batchTable = batchTable;\n  primitive._batchTableAttributeIndices = attributeIndices;\n  primitive._batchTableBoundingSphereAttributeIndices = boundingSphereAttributeIndices;\n  primitive._batchTableOffsetAttribute2DIndex = offset2DIndex;\n}\n\nfunction cloneAttribute(attribute) {\n  var clonedValues;\n  if (Array.isArray(attribute.values)) {\n    clonedValues = attribute.values.slice(0);\n  } else {\n    clonedValues = new attribute.values.constructor(attribute.values);\n  }\n  return new GeometryAttribute({\n    componentDatatype: attribute.componentDatatype,\n    componentsPerAttribute: attribute.componentsPerAttribute,\n    normalize: attribute.normalize,\n    values: clonedValues,\n  });\n}\n\nfunction cloneGeometry(geometry) {\n  var attributes = geometry.attributes;\n  var newAttributes = new GeometryAttributes();\n  for (var property in attributes) {\n    if (attributes.hasOwnProperty(property) && defined(attributes[property])) {\n      newAttributes[property] = cloneAttribute(attributes[property]);\n    }\n  }\n\n  var indices;\n  if (defined(geometry.indices)) {\n    var sourceValues = geometry.indices;\n    if (Array.isArray(sourceValues)) {\n      indices = sourceValues.slice(0);\n    } else {\n      indices = new sourceValues.constructor(sourceValues);\n    }\n  }\n\n  return new Geometry({\n    attributes: newAttributes,\n    indices: indices,\n    primitiveType: geometry.primitiveType,\n    boundingSphere: BoundingSphere.clone(geometry.boundingSphere),\n  });\n}\n\nfunction cloneInstance(instance, geometry) {\n  return {\n    geometry: geometry,\n    attributes: instance.attributes,\n    modelMatrix: Matrix4.clone(instance.modelMatrix),\n    pickPrimitive: instance.pickPrimitive,\n    id: instance.id,\n  };\n}\n\nvar positionRegex = /attribute\\s+vec(?:3|4)\\s+(.*)3DHigh;/g;\n\nPrimitive._modifyShaderPosition = function (\n  primitive,\n  vertexShaderSource,\n  scene3DOnly\n) {\n  var match;\n\n  var forwardDecl = \"\";\n  var attributes = \"\";\n  var computeFunctions = \"\";\n\n  while ((match = positionRegex.exec(vertexShaderSource)) !== null) {\n    var name = match[1];\n\n    var functionName =\n      \"vec4 czm_compute\" + name[0].toUpperCase() + name.substr(1) + \"()\";\n\n    // Don't forward-declare czm_computePosition because computePosition.glsl already does.\n    if (functionName !== \"vec4 czm_computePosition()\") {\n      forwardDecl += functionName + \";\\n\";\n    }\n\n    if (!defined(primitive.rtcCenter)) {\n      // Use GPU RTE\n      if (!scene3DOnly) {\n        attributes +=\n          \"attribute vec3 \" +\n          name +\n          \"2DHigh;\\n\" +\n          \"attribute vec3 \" +\n          name +\n          \"2DLow;\\n\";\n\n        computeFunctions +=\n          functionName +\n          \"\\n\" +\n          \"{\\n\" +\n          \"    vec4 p;\\n\" +\n          \"    if (czm_morphTime == 1.0)\\n\" +\n          \"    {\\n\" +\n          \"        p = czm_translateRelativeToEye(\" +\n          name +\n          \"3DHigh, \" +\n          name +\n          \"3DLow);\\n\" +\n          \"    }\\n\" +\n          \"    else if (czm_morphTime == 0.0)\\n\" +\n          \"    {\\n\" +\n          \"        p = czm_translateRelativeToEye(\" +\n          name +\n          \"2DHigh.zxy, \" +\n          name +\n          \"2DLow.zxy);\\n\" +\n          \"    }\\n\" +\n          \"    else\\n\" +\n          \"    {\\n\" +\n          \"        p = czm_columbusViewMorph(\\n\" +\n          \"                czm_translateRelativeToEye(\" +\n          name +\n          \"2DHigh.zxy, \" +\n          name +\n          \"2DLow.zxy),\\n\" +\n          \"                czm_translateRelativeToEye(\" +\n          name +\n          \"3DHigh, \" +\n          name +\n          \"3DLow),\\n\" +\n          \"                czm_morphTime);\\n\" +\n          \"    }\\n\" +\n          \"    return p;\\n\" +\n          \"}\\n\\n\";\n      } else {\n        computeFunctions +=\n          functionName +\n          \"\\n\" +\n          \"{\\n\" +\n          \"    return czm_translateRelativeToEye(\" +\n          name +\n          \"3DHigh, \" +\n          name +\n          \"3DLow);\\n\" +\n          \"}\\n\\n\";\n      }\n    } else {\n      // Use RTC\n      vertexShaderSource = vertexShaderSource.replace(\n        /attribute\\s+vec(?:3|4)\\s+position3DHigh;/g,\n        \"\"\n      );\n      vertexShaderSource = vertexShaderSource.replace(\n        /attribute\\s+vec(?:3|4)\\s+position3DLow;/g,\n        \"\"\n      );\n\n      forwardDecl += \"uniform mat4 u_modifiedModelView;\\n\";\n      attributes += \"attribute vec4 position;\\n\";\n\n      computeFunctions +=\n        functionName +\n        \"\\n\" +\n        \"{\\n\" +\n        \"    return u_modifiedModelView * position;\\n\" +\n        \"}\\n\\n\";\n\n      vertexShaderSource = vertexShaderSource.replace(\n        /czm_modelViewRelativeToEye\\s+\\*\\s+/g,\n        \"\"\n      );\n      vertexShaderSource = vertexShaderSource.replace(\n        /czm_modelViewProjectionRelativeToEye/g,\n        \"czm_projection\"\n      );\n    }\n  }\n\n  return [forwardDecl, attributes, vertexShaderSource, computeFunctions].join(\n    \"\\n\"\n  );\n};\n\nPrimitive._appendShowToShader = function (primitive, vertexShaderSource) {\n  if (!defined(primitive._batchTableAttributeIndices.show)) {\n    return vertexShaderSource;\n  }\n\n  var renamedVS = ShaderSource.replaceMain(\n    vertexShaderSource,\n    \"czm_non_show_main\"\n  );\n  var showMain =\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    czm_non_show_main(); \\n\" +\n    \"    gl_Position *= czm_batchTable_show(batchId); \\n\" +\n    \"}\";\n\n  return renamedVS + \"\\n\" + showMain;\n};\n\nPrimitive._updateColorAttribute = function (\n  primitive,\n  vertexShaderSource,\n  isDepthFail\n) {\n  // some appearances have a color attribute for per vertex color.\n  // only remove if color is a per instance attribute.\n  if (\n    !defined(primitive._batchTableAttributeIndices.color) &&\n    !defined(primitive._batchTableAttributeIndices.depthFailColor)\n  ) {\n    return vertexShaderSource;\n  }\n\n  if (vertexShaderSource.search(/attribute\\s+vec4\\s+color;/g) === -1) {\n    return vertexShaderSource;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    isDepthFail &&\n    !defined(primitive._batchTableAttributeIndices.depthFailColor)\n  ) {\n    throw new DeveloperError(\n      \"A depthFailColor per-instance attribute is required when using a depth fail appearance that uses a color attribute.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var modifiedVS = vertexShaderSource;\n  modifiedVS = modifiedVS.replace(/attribute\\s+vec4\\s+color;/g, \"\");\n  if (!isDepthFail) {\n    modifiedVS = modifiedVS.replace(\n      /(\\b)color(\\b)/g,\n      \"$1czm_batchTable_color(batchId)$2\"\n    );\n  } else {\n    modifiedVS = modifiedVS.replace(\n      /(\\b)color(\\b)/g,\n      \"$1czm_batchTable_depthFailColor(batchId)$2\"\n    );\n  }\n  return modifiedVS;\n};\n\nfunction appendPickToVertexShader(source) {\n  var renamedVS = ShaderSource.replaceMain(source, \"czm_non_pick_main\");\n  var pickMain =\n    \"varying vec4 v_pickColor; \\n\" +\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    czm_non_pick_main(); \\n\" +\n    \"    v_pickColor = czm_batchTable_pickColor(batchId); \\n\" +\n    \"}\";\n\n  return renamedVS + \"\\n\" + pickMain;\n}\n\nfunction appendPickToFragmentShader(source) {\n  return \"varying vec4 v_pickColor;\\n\" + source;\n}\n\nPrimitive._updatePickColorAttribute = function (source) {\n  var vsPick = source.replace(/attribute\\s+vec4\\s+pickColor;/g, \"\");\n  vsPick = vsPick.replace(\n    /(\\b)pickColor(\\b)/g,\n    \"$1czm_batchTable_pickColor(batchId)$2\"\n  );\n  return vsPick;\n};\n\nPrimitive._appendOffsetToShader = function (primitive, vertexShaderSource) {\n  if (!defined(primitive._batchTableAttributeIndices.offset)) {\n    return vertexShaderSource;\n  }\n\n  var attr = \"attribute float batchId;\\n\";\n  attr += \"attribute float applyOffset;\";\n  var modifiedShader = vertexShaderSource.replace(\n    /attribute\\s+float\\s+batchId;/g,\n    attr\n  );\n\n  var str = \"vec4 $1 = czm_computePosition();\\n\";\n  str += \"    if (czm_sceneMode == czm_sceneMode3D)\\n\";\n  str += \"    {\\n\";\n  str +=\n    \"        $1 = $1 + vec4(czm_batchTable_offset(batchId) * applyOffset, 0.0);\";\n  str += \"    }\\n\";\n  str += \"    else\\n\";\n  str += \"    {\\n\";\n  str +=\n    \"        $1 = $1 + vec4(czm_batchTable_offset2D(batchId) * applyOffset, 0.0);\";\n  str += \"    }\\n\";\n  modifiedShader = modifiedShader.replace(\n    /vec4\\s+([A-Za-z0-9_]+)\\s+=\\s+czm_computePosition\\(\\);/g,\n    str\n  );\n  return modifiedShader;\n};\n\nPrimitive._appendDistanceDisplayConditionToShader = function (\n  primitive,\n  vertexShaderSource,\n  scene3DOnly\n) {\n  if (\n    !defined(primitive._batchTableAttributeIndices.distanceDisplayCondition)\n  ) {\n    return vertexShaderSource;\n  }\n\n  var renamedVS = ShaderSource.replaceMain(\n    vertexShaderSource,\n    \"czm_non_distanceDisplayCondition_main\"\n  );\n  var distanceDisplayConditionMain =\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    czm_non_distanceDisplayCondition_main(); \\n\" +\n    \"    vec2 distanceDisplayCondition = czm_batchTable_distanceDisplayCondition(batchId);\\n\" +\n    \"    vec3 boundingSphereCenter3DHigh = czm_batchTable_boundingSphereCenter3DHigh(batchId);\\n\" +\n    \"    vec3 boundingSphereCenter3DLow = czm_batchTable_boundingSphereCenter3DLow(batchId);\\n\" +\n    \"    float boundingSphereRadius = czm_batchTable_boundingSphereRadius(batchId);\\n\";\n\n  if (!scene3DOnly) {\n    distanceDisplayConditionMain +=\n      \"    vec3 boundingSphereCenter2DHigh = czm_batchTable_boundingSphereCenter2DHigh(batchId);\\n\" +\n      \"    vec3 boundingSphereCenter2DLow = czm_batchTable_boundingSphereCenter2DLow(batchId);\\n\" +\n      \"    vec4 centerRTE;\\n\" +\n      \"    if (czm_morphTime == 1.0)\\n\" +\n      \"    {\\n\" +\n      \"        centerRTE = czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow);\\n\" +\n      \"    }\\n\" +\n      \"    else if (czm_morphTime == 0.0)\\n\" +\n      \"    {\\n\" +\n      \"        centerRTE = czm_translateRelativeToEye(boundingSphereCenter2DHigh.zxy, boundingSphereCenter2DLow.zxy);\\n\" +\n      \"    }\\n\" +\n      \"    else\\n\" +\n      \"    {\\n\" +\n      \"        centerRTE = czm_columbusViewMorph(\\n\" +\n      \"                czm_translateRelativeToEye(boundingSphereCenter2DHigh.zxy, boundingSphereCenter2DLow.zxy),\\n\" +\n      \"                czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow),\\n\" +\n      \"                czm_morphTime);\\n\" +\n      \"    }\\n\";\n  } else {\n    distanceDisplayConditionMain +=\n      \"    vec4 centerRTE = czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow);\\n\";\n  }\n\n  distanceDisplayConditionMain +=\n    \"    float radiusSq = boundingSphereRadius * boundingSphereRadius; \\n\" +\n    \"    float distanceSq; \\n\" +\n    \"    if (czm_sceneMode == czm_sceneMode2D) \\n\" +\n    \"    { \\n\" +\n    \"        distanceSq = czm_eyeHeight2D.y - radiusSq; \\n\" +\n    \"    } \\n\" +\n    \"    else \\n\" +\n    \"    { \\n\" +\n    \"        distanceSq = dot(centerRTE.xyz, centerRTE.xyz) - radiusSq; \\n\" +\n    \"    } \\n\" +\n    \"    distanceSq = max(distanceSq, 0.0); \\n\" +\n    \"    float nearSq = distanceDisplayCondition.x * distanceDisplayCondition.x; \\n\" +\n    \"    float farSq = distanceDisplayCondition.y * distanceDisplayCondition.y; \\n\" +\n    \"    float show = (distanceSq >= nearSq && distanceSq <= farSq) ? 1.0 : 0.0; \\n\" +\n    \"    gl_Position *= show; \\n\" +\n    \"}\";\n  return renamedVS + \"\\n\" + distanceDisplayConditionMain;\n};\n\nfunction modifyForEncodedNormals(primitive, vertexShaderSource) {\n  if (!primitive.compressVertices) {\n    return vertexShaderSource;\n  }\n\n  var containsNormal =\n    vertexShaderSource.search(/attribute\\s+vec3\\s+normal;/g) !== -1;\n  var containsSt = vertexShaderSource.search(/attribute\\s+vec2\\s+st;/g) !== -1;\n  if (!containsNormal && !containsSt) {\n    return vertexShaderSource;\n  }\n\n  var containsTangent =\n    vertexShaderSource.search(/attribute\\s+vec3\\s+tangent;/g) !== -1;\n  var containsBitangent =\n    vertexShaderSource.search(/attribute\\s+vec3\\s+bitangent;/g) !== -1;\n\n  var numComponents = containsSt && containsNormal ? 2.0 : 1.0;\n  numComponents += containsTangent || containsBitangent ? 1 : 0;\n\n  var type = numComponents > 1 ? \"vec\" + numComponents : \"float\";\n\n  var attributeName = \"compressedAttributes\";\n  var attributeDecl = \"attribute \" + type + \" \" + attributeName + \";\";\n\n  var globalDecl = \"\";\n  var decode = \"\";\n\n  if (containsSt) {\n    globalDecl += \"vec2 st;\\n\";\n    var stComponent = numComponents > 1 ? attributeName + \".x\" : attributeName;\n    decode +=\n      \"    st = czm_decompressTextureCoordinates(\" + stComponent + \");\\n\";\n  }\n\n  if (containsNormal && containsTangent && containsBitangent) {\n    globalDecl += \"vec3 normal;\\n\" + \"vec3 tangent;\\n\" + \"vec3 bitangent;\\n\";\n    decode +=\n      \"    czm_octDecode(\" +\n      attributeName +\n      \".\" +\n      (containsSt ? \"yz\" : \"xy\") +\n      \", normal, tangent, bitangent);\\n\";\n  } else {\n    if (containsNormal) {\n      globalDecl += \"vec3 normal;\\n\";\n      decode +=\n        \"    normal = czm_octDecode(\" +\n        attributeName +\n        (numComponents > 1 ? \".\" + (containsSt ? \"y\" : \"x\") : \"\") +\n        \");\\n\";\n    }\n\n    if (containsTangent) {\n      globalDecl += \"vec3 tangent;\\n\";\n      decode +=\n        \"    tangent = czm_octDecode(\" +\n        attributeName +\n        \".\" +\n        (containsSt && containsNormal ? \"z\" : \"y\") +\n        \");\\n\";\n    }\n\n    if (containsBitangent) {\n      globalDecl += \"vec3 bitangent;\\n\";\n      decode +=\n        \"    bitangent = czm_octDecode(\" +\n        attributeName +\n        \".\" +\n        (containsSt && containsNormal ? \"z\" : \"y\") +\n        \");\\n\";\n    }\n  }\n\n  var modifiedVS = vertexShaderSource;\n  modifiedVS = modifiedVS.replace(/attribute\\s+vec3\\s+normal;/g, \"\");\n  modifiedVS = modifiedVS.replace(/attribute\\s+vec2\\s+st;/g, \"\");\n  modifiedVS = modifiedVS.replace(/attribute\\s+vec3\\s+tangent;/g, \"\");\n  modifiedVS = modifiedVS.replace(/attribute\\s+vec3\\s+bitangent;/g, \"\");\n  modifiedVS = ShaderSource.replaceMain(modifiedVS, \"czm_non_compressed_main\");\n  var compressedMain =\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    decode +\n    \"    czm_non_compressed_main(); \\n\" +\n    \"}\";\n\n  return [attributeDecl, globalDecl, modifiedVS, compressedMain].join(\"\\n\");\n}\n\nfunction depthClampVS(vertexShaderSource) {\n  var modifiedVS = ShaderSource.replaceMain(\n    vertexShaderSource,\n    \"czm_non_depth_clamp_main\"\n  );\n  modifiedVS +=\n    \"void main() {\\n\" +\n    \"    czm_non_depth_clamp_main();\\n\" +\n    \"    gl_Position = czm_depthClamp(gl_Position);\" +\n    \"}\\n\";\n  return modifiedVS;\n}\n\nfunction depthClampFS(fragmentShaderSource) {\n  var modifiedFS = ShaderSource.replaceMain(\n    fragmentShaderSource,\n    \"czm_non_depth_clamp_main\"\n  );\n  modifiedFS +=\n    \"void main() {\\n\" +\n    \"    czm_non_depth_clamp_main();\\n\" +\n    \"#if defined(GL_EXT_frag_depth)\\n\" +\n    \"    #if defined(LOG_DEPTH)\\n\" +\n    \"        czm_writeLogDepth();\\n\" +\n    \"    #else\\n\" +\n    \"        czm_writeDepthClamp();\\n\" +\n    \"    #endif\\n\" +\n    \"#endif\\n\" +\n    \"}\\n\";\n  modifiedFS =\n    \"#ifdef GL_EXT_frag_depth\\n\" +\n    \"#extension GL_EXT_frag_depth : enable\\n\" +\n    \"#endif\\n\" +\n    modifiedFS;\n  return modifiedFS;\n}\n\nfunction validateShaderMatching(shaderProgram, attributeLocations) {\n  // For a VAO and shader program to be compatible, the VAO must have\n  // all active attribute in the shader program.  The VAO may have\n  // extra attributes with the only concern being a potential\n  // performance hit due to extra memory bandwidth and cache pollution.\n  // The shader source could have extra attributes that are not used,\n  // but there is no guarantee they will be optimized out.\n  //\n  // Here, we validate that the VAO has all attributes required\n  // to match the shader program.\n  var shaderAttributes = shaderProgram.vertexAttributes;\n\n  //>>includeStart('debug', pragmas.debug);\n  for (var name in shaderAttributes) {\n    if (shaderAttributes.hasOwnProperty(name)) {\n      if (!defined(attributeLocations[name])) {\n        throw new DeveloperError(\n          \"Appearance/Geometry mismatch.  The appearance requires vertex shader attribute input '\" +\n            name +\n            \"', which was not computed as part of the Geometry.  Use the appearance's vertexFormat property when constructing the geometry.\"\n        );\n      }\n    }\n  }\n  //>>includeEnd('debug');\n}\n\nfunction getUniformFunction(uniforms, name) {\n  return function () {\n    return uniforms[name];\n  };\n}\n\nvar numberOfCreationWorkers = Math.max(\n  FeatureDetection.hardwareConcurrency - 1,\n  1\n);\nvar createGeometryTaskProcessors;\nvar combineGeometryTaskProcessor = new TaskProcessor(\"combineGeometry\");\n\nfunction loadAsynchronous(primitive, frameState) {\n  var instances;\n  var geometry;\n  var i;\n  var j;\n\n  var instanceIds = primitive._instanceIds;\n\n  if (primitive._state === PrimitiveState.READY) {\n    instances = Array.isArray(primitive.geometryInstances)\n      ? primitive.geometryInstances\n      : [primitive.geometryInstances];\n    var length = (primitive._numberOfInstances = instances.length);\n\n    var promises = [];\n    var subTasks = [];\n    for (i = 0; i < length; ++i) {\n      geometry = instances[i].geometry;\n      instanceIds.push(instances[i].id);\n\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(geometry._workerName)) {\n        throw new DeveloperError(\n          \"_workerName must be defined for asynchronous geometry.\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      subTasks.push({\n        moduleName: geometry._workerName,\n        geometry: geometry,\n      });\n    }\n\n    if (!defined(createGeometryTaskProcessors)) {\n      createGeometryTaskProcessors = new Array(numberOfCreationWorkers);\n      for (i = 0; i < numberOfCreationWorkers; i++) {\n        createGeometryTaskProcessors[i] = new TaskProcessor(\"createGeometry\");\n      }\n    }\n\n    var subTask;\n    subTasks = subdivideArray(subTasks, numberOfCreationWorkers);\n\n    for (i = 0; i < subTasks.length; i++) {\n      var packedLength = 0;\n      var workerSubTasks = subTasks[i];\n      var workerSubTasksLength = workerSubTasks.length;\n      for (j = 0; j < workerSubTasksLength; ++j) {\n        subTask = workerSubTasks[j];\n        geometry = subTask.geometry;\n        if (defined(geometry.constructor.pack)) {\n          subTask.offset = packedLength;\n          packedLength += defaultValue(\n            geometry.constructor.packedLength,\n            geometry.packedLength\n          );\n        }\n      }\n\n      var subTaskTransferableObjects;\n\n      if (packedLength > 0) {\n        var array = new Float64Array(packedLength);\n        subTaskTransferableObjects = [array.buffer];\n\n        for (j = 0; j < workerSubTasksLength; ++j) {\n          subTask = workerSubTasks[j];\n          geometry = subTask.geometry;\n          if (defined(geometry.constructor.pack)) {\n            geometry.constructor.pack(geometry, array, subTask.offset);\n            subTask.geometry = array;\n          }\n        }\n      }\n\n      promises.push(\n        createGeometryTaskProcessors[i].scheduleTask(\n          {\n            subTasks: subTasks[i],\n          },\n          subTaskTransferableObjects\n        )\n      );\n    }\n\n    primitive._state = PrimitiveState.CREATING;\n\n    when\n      .all(promises, function (results) {\n        primitive._createGeometryResults = results;\n        primitive._state = PrimitiveState.CREATED;\n      })\n      .otherwise(function (error) {\n        setReady(primitive, frameState, PrimitiveState.FAILED, error);\n      });\n  } else if (primitive._state === PrimitiveState.CREATED) {\n    var transferableObjects = [];\n    instances = Array.isArray(primitive.geometryInstances)\n      ? primitive.geometryInstances\n      : [primitive.geometryInstances];\n\n    var scene3DOnly = frameState.scene3DOnly;\n    var projection = frameState.mapProjection;\n\n    var promise = combineGeometryTaskProcessor.scheduleTask(\n      PrimitivePipeline.packCombineGeometryParameters(\n        {\n          createGeometryResults: primitive._createGeometryResults,\n          instances: instances,\n          ellipsoid: projection.ellipsoid,\n          projection: projection,\n          elementIndexUintSupported: frameState.context.elementIndexUint,\n          scene3DOnly: scene3DOnly,\n          vertexCacheOptimize: primitive.vertexCacheOptimize,\n          compressVertices: primitive.compressVertices,\n          modelMatrix: primitive.modelMatrix,\n          createPickOffsets: primitive._createPickOffsets,\n        },\n        transferableObjects\n      ),\n      transferableObjects\n    );\n\n    primitive._createGeometryResults = undefined;\n    primitive._state = PrimitiveState.COMBINING;\n\n    when(promise, function (packedResult) {\n      var result = PrimitivePipeline.unpackCombineGeometryResults(packedResult);\n      primitive._geometries = result.geometries;\n      primitive._attributeLocations = result.attributeLocations;\n      primitive.modelMatrix = Matrix4.clone(\n        result.modelMatrix,\n        primitive.modelMatrix\n      );\n      primitive._pickOffsets = result.pickOffsets;\n      primitive._offsetInstanceExtend = result.offsetInstanceExtend;\n      primitive._instanceBoundingSpheres = result.boundingSpheres;\n      primitive._instanceBoundingSpheresCV = result.boundingSpheresCV;\n\n      if (defined(primitive._geometries) && primitive._geometries.length > 0) {\n        primitive._recomputeBoundingSpheres = true;\n        primitive._state = PrimitiveState.COMBINED;\n      } else {\n        setReady(primitive, frameState, PrimitiveState.FAILED, undefined);\n      }\n    }).otherwise(function (error) {\n      setReady(primitive, frameState, PrimitiveState.FAILED, error);\n    });\n  }\n}\n\nfunction loadSynchronous(primitive, frameState) {\n  var instances = Array.isArray(primitive.geometryInstances)\n    ? primitive.geometryInstances\n    : [primitive.geometryInstances];\n  var length = (primitive._numberOfInstances = instances.length);\n  var clonedInstances = new Array(length);\n  var instanceIds = primitive._instanceIds;\n\n  var instance;\n  var i;\n\n  var geometryIndex = 0;\n  for (i = 0; i < length; i++) {\n    instance = instances[i];\n    var geometry = instance.geometry;\n\n    var createdGeometry;\n    if (defined(geometry.attributes) && defined(geometry.primitiveType)) {\n      createdGeometry = cloneGeometry(geometry);\n    } else {\n      createdGeometry = geometry.constructor.createGeometry(geometry);\n    }\n\n    clonedInstances[geometryIndex++] = cloneInstance(instance, createdGeometry);\n    instanceIds.push(instance.id);\n  }\n\n  clonedInstances.length = geometryIndex;\n\n  var scene3DOnly = frameState.scene3DOnly;\n  var projection = frameState.mapProjection;\n\n  var result = PrimitivePipeline.combineGeometry({\n    instances: clonedInstances,\n    ellipsoid: projection.ellipsoid,\n    projection: projection,\n    elementIndexUintSupported: frameState.context.elementIndexUint,\n    scene3DOnly: scene3DOnly,\n    vertexCacheOptimize: primitive.vertexCacheOptimize,\n    compressVertices: primitive.compressVertices,\n    modelMatrix: primitive.modelMatrix,\n    createPickOffsets: primitive._createPickOffsets,\n  });\n\n  primitive._geometries = result.geometries;\n  primitive._attributeLocations = result.attributeLocations;\n  primitive.modelMatrix = Matrix4.clone(\n    result.modelMatrix,\n    primitive.modelMatrix\n  );\n  primitive._pickOffsets = result.pickOffsets;\n  primitive._offsetInstanceExtend = result.offsetInstanceExtend;\n  primitive._instanceBoundingSpheres = result.boundingSpheres;\n  primitive._instanceBoundingSpheresCV = result.boundingSpheresCV;\n\n  if (defined(primitive._geometries) && primitive._geometries.length > 0) {\n    primitive._recomputeBoundingSpheres = true;\n    primitive._state = PrimitiveState.COMBINED;\n  } else {\n    setReady(primitive, frameState, PrimitiveState.FAILED, undefined);\n  }\n}\n\nfunction recomputeBoundingSpheres(primitive, frameState) {\n  var offsetIndex = primitive._batchTableAttributeIndices.offset;\n  if (!primitive._recomputeBoundingSpheres || !defined(offsetIndex)) {\n    primitive._recomputeBoundingSpheres = false;\n    return;\n  }\n\n  var i;\n  var offsetInstanceExtend = primitive._offsetInstanceExtend;\n  var boundingSpheres = primitive._instanceBoundingSpheres;\n  var length = boundingSpheres.length;\n  var newBoundingSpheres = primitive._tempBoundingSpheres;\n  if (!defined(newBoundingSpheres)) {\n    newBoundingSpheres = new Array(length);\n    for (i = 0; i < length; i++) {\n      newBoundingSpheres[i] = new BoundingSphere();\n    }\n    primitive._tempBoundingSpheres = newBoundingSpheres;\n  }\n  for (i = 0; i < length; ++i) {\n    var newBS = newBoundingSpheres[i];\n    var offset = primitive._batchTable.getBatchedAttribute(\n      i,\n      offsetIndex,\n      new Cartesian3()\n    );\n    newBS = boundingSpheres[i].clone(newBS);\n    transformBoundingSphere(newBS, offset, offsetInstanceExtend[i]);\n  }\n  var combinedBS = [];\n  var combinedWestBS = [];\n  var combinedEastBS = [];\n\n  for (i = 0; i < length; ++i) {\n    var bs = newBoundingSpheres[i];\n\n    var minX = bs.center.x - bs.radius;\n    if (\n      minX > 0 ||\n      BoundingSphere.intersectPlane(bs, Plane.ORIGIN_ZX_PLANE) !==\n        Intersect.INTERSECTING\n    ) {\n      combinedBS.push(bs);\n    } else {\n      combinedWestBS.push(bs);\n      combinedEastBS.push(bs);\n    }\n  }\n\n  var resultBS1 = combinedBS[0];\n  var resultBS2 = combinedEastBS[0];\n  var resultBS3 = combinedWestBS[0];\n\n  for (i = 1; i < combinedBS.length; i++) {\n    resultBS1 = BoundingSphere.union(resultBS1, combinedBS[i]);\n  }\n  for (i = 1; i < combinedEastBS.length; i++) {\n    resultBS2 = BoundingSphere.union(resultBS2, combinedEastBS[i]);\n  }\n  for (i = 1; i < combinedWestBS.length; i++) {\n    resultBS3 = BoundingSphere.union(resultBS3, combinedWestBS[i]);\n  }\n  var result = [];\n  if (defined(resultBS1)) {\n    result.push(resultBS1);\n  }\n  if (defined(resultBS2)) {\n    result.push(resultBS2);\n  }\n  if (defined(resultBS3)) {\n    result.push(resultBS3);\n  }\n\n  for (i = 0; i < result.length; i++) {\n    var boundingSphere = result[i].clone(primitive._boundingSpheres[i]);\n    primitive._boundingSpheres[i] = boundingSphere;\n    primitive._boundingSphereCV[i] = BoundingSphere.projectTo2D(\n      boundingSphere,\n      frameState.mapProjection,\n      primitive._boundingSphereCV[i]\n    );\n  }\n\n  Primitive._updateBoundingVolumes(\n    primitive,\n    frameState,\n    primitive.modelMatrix,\n    true\n  );\n  primitive._recomputeBoundingSpheres = false;\n}\n\nvar scratchBoundingSphereCenterEncoded = new EncodedCartesian3();\nvar scratchBoundingSphereCartographic = new Cartographic();\nvar scratchBoundingSphereCenter2D = new Cartesian3();\nvar scratchBoundingSphere = new BoundingSphere();\n\nfunction updateBatchTableBoundingSpheres(primitive, frameState) {\n  var hasDistanceDisplayCondition = defined(\n    primitive._batchTableAttributeIndices.distanceDisplayCondition\n  );\n  if (\n    !hasDistanceDisplayCondition ||\n    primitive._batchTableBoundingSpheresUpdated\n  ) {\n    return;\n  }\n\n  var indices = primitive._batchTableBoundingSphereAttributeIndices;\n  var center3DHighIndex = indices.center3DHigh;\n  var center3DLowIndex = indices.center3DLow;\n  var center2DHighIndex = indices.center2DHigh;\n  var center2DLowIndex = indices.center2DLow;\n  var radiusIndex = indices.radius;\n\n  var projection = frameState.mapProjection;\n  var ellipsoid = projection.ellipsoid;\n\n  var batchTable = primitive._batchTable;\n  var boundingSpheres = primitive._instanceBoundingSpheres;\n  var length = boundingSpheres.length;\n\n  for (var i = 0; i < length; ++i) {\n    var boundingSphere = boundingSpheres[i];\n    if (!defined(boundingSphere)) {\n      continue;\n    }\n\n    var modelMatrix = primitive.modelMatrix;\n    if (defined(modelMatrix)) {\n      boundingSphere = BoundingSphere.transform(\n        boundingSphere,\n        modelMatrix,\n        scratchBoundingSphere\n      );\n    }\n\n    var center = boundingSphere.center;\n    var radius = boundingSphere.radius;\n\n    var encodedCenter = EncodedCartesian3.fromCartesian(\n      center,\n      scratchBoundingSphereCenterEncoded\n    );\n    batchTable.setBatchedAttribute(i, center3DHighIndex, encodedCenter.high);\n    batchTable.setBatchedAttribute(i, center3DLowIndex, encodedCenter.low);\n\n    if (!frameState.scene3DOnly) {\n      var cartographic = ellipsoid.cartesianToCartographic(\n        center,\n        scratchBoundingSphereCartographic\n      );\n      var center2D = projection.project(\n        cartographic,\n        scratchBoundingSphereCenter2D\n      );\n      encodedCenter = EncodedCartesian3.fromCartesian(\n        center2D,\n        scratchBoundingSphereCenterEncoded\n      );\n      batchTable.setBatchedAttribute(i, center2DHighIndex, encodedCenter.high);\n      batchTable.setBatchedAttribute(i, center2DLowIndex, encodedCenter.low);\n    }\n\n    batchTable.setBatchedAttribute(i, radiusIndex, radius);\n  }\n\n  primitive._batchTableBoundingSpheresUpdated = true;\n}\n\nvar offsetScratchCartesian = new Cartesian3();\nvar offsetCenterScratch = new Cartesian3();\nfunction updateBatchTableOffsets(primitive, frameState) {\n  var hasOffset = defined(primitive._batchTableAttributeIndices.offset);\n  if (\n    !hasOffset ||\n    primitive._batchTableOffsetsUpdated ||\n    frameState.scene3DOnly\n  ) {\n    return;\n  }\n\n  var index2D = primitive._batchTableOffsetAttribute2DIndex;\n\n  var projection = frameState.mapProjection;\n  var ellipsoid = projection.ellipsoid;\n\n  var batchTable = primitive._batchTable;\n  var boundingSpheres = primitive._instanceBoundingSpheres;\n  var length = boundingSpheres.length;\n\n  for (var i = 0; i < length; ++i) {\n    var boundingSphere = boundingSpheres[i];\n    if (!defined(boundingSphere)) {\n      continue;\n    }\n    var offset = batchTable.getBatchedAttribute(\n      i,\n      primitive._batchTableAttributeIndices.offset\n    );\n    if (Cartesian3.equals(offset, Cartesian3.ZERO)) {\n      batchTable.setBatchedAttribute(i, index2D, Cartesian3.ZERO);\n      continue;\n    }\n\n    var modelMatrix = primitive.modelMatrix;\n    if (defined(modelMatrix)) {\n      boundingSphere = BoundingSphere.transform(\n        boundingSphere,\n        modelMatrix,\n        scratchBoundingSphere\n      );\n    }\n\n    var center = boundingSphere.center;\n    center = ellipsoid.scaleToGeodeticSurface(center, offsetCenterScratch);\n    var cartographic = ellipsoid.cartesianToCartographic(\n      center,\n      scratchBoundingSphereCartographic\n    );\n    var center2D = projection.project(\n      cartographic,\n      scratchBoundingSphereCenter2D\n    );\n\n    var newPoint = Cartesian3.add(offset, center, offsetScratchCartesian);\n    cartographic = ellipsoid.cartesianToCartographic(newPoint, cartographic);\n\n    var newPointProjected = projection.project(\n      cartographic,\n      offsetScratchCartesian\n    );\n\n    var newVector = Cartesian3.subtract(\n      newPointProjected,\n      center2D,\n      offsetScratchCartesian\n    );\n\n    var x = newVector.x;\n    newVector.x = newVector.z;\n    newVector.z = newVector.y;\n    newVector.y = x;\n\n    batchTable.setBatchedAttribute(i, index2D, newVector);\n  }\n\n  primitive._batchTableOffsetsUpdated = true;\n}\n\nfunction createVertexArray(primitive, frameState) {\n  var attributeLocations = primitive._attributeLocations;\n  var geometries = primitive._geometries;\n  var scene3DOnly = frameState.scene3DOnly;\n  var context = frameState.context;\n\n  var va = [];\n  var length = geometries.length;\n  for (var i = 0; i < length; ++i) {\n    var geometry = geometries[i];\n\n    va.push(\n      VertexArray.fromGeometry({\n        context: context,\n        geometry: geometry,\n        attributeLocations: attributeLocations,\n        bufferUsage: BufferUsage.STATIC_DRAW,\n        interleave: primitive._interleave,\n      })\n    );\n\n    if (defined(primitive._createBoundingVolumeFunction)) {\n      primitive._createBoundingVolumeFunction(frameState, geometry);\n    } else {\n      primitive._boundingSpheres.push(\n        BoundingSphere.clone(geometry.boundingSphere)\n      );\n      primitive._boundingSphereWC.push(new BoundingSphere());\n\n      if (!scene3DOnly) {\n        var center = geometry.boundingSphereCV.center;\n        var x = center.x;\n        var y = center.y;\n        var z = center.z;\n        center.x = z;\n        center.y = x;\n        center.z = y;\n\n        primitive._boundingSphereCV.push(\n          BoundingSphere.clone(geometry.boundingSphereCV)\n        );\n        primitive._boundingSphere2D.push(new BoundingSphere());\n        primitive._boundingSphereMorph.push(new BoundingSphere());\n      }\n    }\n  }\n\n  primitive._va = va;\n  primitive._primitiveType = geometries[0].primitiveType;\n\n  if (primitive.releaseGeometryInstances) {\n    primitive.geometryInstances = undefined;\n  }\n\n  primitive._geometries = undefined;\n  setReady(primitive, frameState, PrimitiveState.COMPLETE, undefined);\n}\n\nfunction createRenderStates(primitive, context, appearance, twoPasses) {\n  var renderState = appearance.getRenderState();\n  var rs;\n\n  if (twoPasses) {\n    rs = clone(renderState, false);\n    rs.cull = {\n      enabled: true,\n      face: CullFace.BACK,\n    };\n    primitive._frontFaceRS = RenderState.fromCache(rs);\n\n    rs.cull.face = CullFace.FRONT;\n    primitive._backFaceRS = RenderState.fromCache(rs);\n  } else {\n    primitive._frontFaceRS = RenderState.fromCache(renderState);\n    primitive._backFaceRS = primitive._frontFaceRS;\n  }\n\n  rs = clone(renderState, false);\n  if (defined(primitive._depthFailAppearance)) {\n    rs.depthTest.enabled = false;\n  }\n\n  if (defined(primitive._depthFailAppearance)) {\n    renderState = primitive._depthFailAppearance.getRenderState();\n    rs = clone(renderState, false);\n    rs.depthTest.func = DepthFunction.GREATER;\n    if (twoPasses) {\n      rs.cull = {\n        enabled: true,\n        face: CullFace.BACK,\n      };\n      primitive._frontFaceDepthFailRS = RenderState.fromCache(rs);\n\n      rs.cull.face = CullFace.FRONT;\n      primitive._backFaceDepthFailRS = RenderState.fromCache(rs);\n    } else {\n      primitive._frontFaceDepthFailRS = RenderState.fromCache(rs);\n      primitive._backFaceDepthFailRS = primitive._frontFaceRS;\n    }\n  }\n}\n\nfunction createShaderProgram(primitive, frameState, appearance) {\n  var context = frameState.context;\n\n  var attributeLocations = primitive._attributeLocations;\n\n  var vs = primitive._batchTable.getVertexShaderCallback()(\n    appearance.vertexShaderSource\n  );\n  vs = Primitive._appendOffsetToShader(primitive, vs);\n  vs = Primitive._appendShowToShader(primitive, vs);\n  vs = Primitive._appendDistanceDisplayConditionToShader(\n    primitive,\n    vs,\n    frameState.scene3DOnly\n  );\n  vs = appendPickToVertexShader(vs);\n  vs = Primitive._updateColorAttribute(primitive, vs, false);\n  vs = modifyForEncodedNormals(primitive, vs);\n  vs = Primitive._modifyShaderPosition(primitive, vs, frameState.scene3DOnly);\n  var fs = appearance.getFragmentShaderSource();\n  fs = appendPickToFragmentShader(fs);\n\n  primitive._sp = ShaderProgram.replaceCache({\n    context: context,\n    shaderProgram: primitive._sp,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations,\n  });\n  validateShaderMatching(primitive._sp, attributeLocations);\n\n  if (defined(primitive._depthFailAppearance)) {\n    vs = primitive._batchTable.getVertexShaderCallback()(\n      primitive._depthFailAppearance.vertexShaderSource\n    );\n    vs = Primitive._appendShowToShader(primitive, vs);\n    vs = Primitive._appendDistanceDisplayConditionToShader(\n      primitive,\n      vs,\n      frameState.scene3DOnly\n    );\n    vs = appendPickToVertexShader(vs);\n    vs = Primitive._updateColorAttribute(primitive, vs, true);\n    vs = modifyForEncodedNormals(primitive, vs);\n    vs = Primitive._modifyShaderPosition(primitive, vs, frameState.scene3DOnly);\n    vs = depthClampVS(vs);\n\n    fs = primitive._depthFailAppearance.getFragmentShaderSource();\n    fs = appendPickToFragmentShader(fs);\n    fs = depthClampFS(fs);\n\n    primitive._spDepthFail = ShaderProgram.replaceCache({\n      context: context,\n      shaderProgram: primitive._spDepthFail,\n      vertexShaderSource: vs,\n      fragmentShaderSource: fs,\n      attributeLocations: attributeLocations,\n    });\n    validateShaderMatching(primitive._spDepthFail, attributeLocations);\n  }\n}\n\nvar modifiedModelViewScratch = new Matrix4();\nvar rtcScratch = new Cartesian3();\n\nfunction getUniforms(primitive, appearance, material, frameState) {\n  // Create uniform map by combining uniforms from the appearance and material if either have uniforms.\n  var materialUniformMap = defined(material) ? material._uniforms : undefined;\n  var appearanceUniformMap = {};\n  var appearanceUniforms = appearance.uniforms;\n  if (defined(appearanceUniforms)) {\n    // Convert to uniform map of functions for the renderer\n    for (var name in appearanceUniforms) {\n      if (appearanceUniforms.hasOwnProperty(name)) {\n        //>>includeStart('debug', pragmas.debug);\n        if (defined(materialUniformMap) && defined(materialUniformMap[name])) {\n          // Later, we could rename uniforms behind-the-scenes if needed.\n          throw new DeveloperError(\n            \"Appearance and material have a uniform with the same name: \" + name\n          );\n        }\n        //>>includeEnd('debug');\n\n        appearanceUniformMap[name] = getUniformFunction(\n          appearanceUniforms,\n          name\n        );\n      }\n    }\n  }\n  var uniforms = combine(appearanceUniformMap, materialUniformMap);\n  uniforms = primitive._batchTable.getUniformMapCallback()(uniforms);\n\n  if (defined(primitive.rtcCenter)) {\n    uniforms.u_modifiedModelView = function () {\n      var viewMatrix = frameState.context.uniformState.view;\n      Matrix4.multiply(\n        viewMatrix,\n        primitive._modelMatrix,\n        modifiedModelViewScratch\n      );\n      Matrix4.multiplyByPoint(\n        modifiedModelViewScratch,\n        primitive.rtcCenter,\n        rtcScratch\n      );\n      Matrix4.setTranslation(\n        modifiedModelViewScratch,\n        rtcScratch,\n        modifiedModelViewScratch\n      );\n      return modifiedModelViewScratch;\n    };\n  }\n\n  return uniforms;\n}\n\nfunction createCommands(\n  primitive,\n  appearance,\n  material,\n  translucent,\n  twoPasses,\n  colorCommands,\n  pickCommands,\n  frameState\n) {\n  var uniforms = getUniforms(primitive, appearance, material, frameState);\n\n  var depthFailUniforms;\n  if (defined(primitive._depthFailAppearance)) {\n    depthFailUniforms = getUniforms(\n      primitive,\n      primitive._depthFailAppearance,\n      primitive._depthFailAppearance.material,\n      frameState\n    );\n  }\n\n  var pass = translucent ? Pass.TRANSLUCENT : Pass.OPAQUE;\n\n  var multiplier = twoPasses ? 2 : 1;\n  multiplier *= defined(primitive._depthFailAppearance) ? 2 : 1;\n  colorCommands.length = primitive._va.length * multiplier;\n\n  var length = colorCommands.length;\n  var vaIndex = 0;\n  for (var i = 0; i < length; ++i) {\n    var colorCommand;\n\n    if (twoPasses) {\n      colorCommand = colorCommands[i];\n      if (!defined(colorCommand)) {\n        colorCommand = colorCommands[i] = new DrawCommand({\n          owner: primitive,\n          primitiveType: primitive._primitiveType,\n        });\n      }\n      colorCommand.vertexArray = primitive._va[vaIndex];\n      colorCommand.renderState = primitive._backFaceRS;\n      colorCommand.shaderProgram = primitive._sp;\n      colorCommand.uniformMap = uniforms;\n      colorCommand.pass = pass;\n\n      ++i;\n    }\n\n    colorCommand = colorCommands[i];\n    if (!defined(colorCommand)) {\n      colorCommand = colorCommands[i] = new DrawCommand({\n        owner: primitive,\n        primitiveType: primitive._primitiveType,\n      });\n    }\n    colorCommand.vertexArray = primitive._va[vaIndex];\n    colorCommand.renderState = primitive._frontFaceRS;\n    colorCommand.shaderProgram = primitive._sp;\n    colorCommand.uniformMap = uniforms;\n    colorCommand.pass = pass;\n\n    if (defined(primitive._depthFailAppearance)) {\n      if (twoPasses) {\n        ++i;\n\n        colorCommand = colorCommands[i];\n        if (!defined(colorCommand)) {\n          colorCommand = colorCommands[i] = new DrawCommand({\n            owner: primitive,\n            primitiveType: primitive._primitiveType,\n          });\n        }\n        colorCommand.vertexArray = primitive._va[vaIndex];\n        colorCommand.renderState = primitive._backFaceDepthFailRS;\n        colorCommand.shaderProgram = primitive._spDepthFail;\n        colorCommand.uniformMap = depthFailUniforms;\n        colorCommand.pass = pass;\n      }\n\n      ++i;\n\n      colorCommand = colorCommands[i];\n      if (!defined(colorCommand)) {\n        colorCommand = colorCommands[i] = new DrawCommand({\n          owner: primitive,\n          primitiveType: primitive._primitiveType,\n        });\n      }\n      colorCommand.vertexArray = primitive._va[vaIndex];\n      colorCommand.renderState = primitive._frontFaceDepthFailRS;\n      colorCommand.shaderProgram = primitive._spDepthFail;\n      colorCommand.uniformMap = depthFailUniforms;\n      colorCommand.pass = pass;\n    }\n\n    ++vaIndex;\n  }\n}\n\nPrimitive._updateBoundingVolumes = function (\n  primitive,\n  frameState,\n  modelMatrix,\n  forceUpdate\n) {\n  var i;\n  var length;\n  var boundingSphere;\n\n  if (forceUpdate || !Matrix4.equals(modelMatrix, primitive._modelMatrix)) {\n    Matrix4.clone(modelMatrix, primitive._modelMatrix);\n    length = primitive._boundingSpheres.length;\n    for (i = 0; i < length; ++i) {\n      boundingSphere = primitive._boundingSpheres[i];\n      if (defined(boundingSphere)) {\n        primitive._boundingSphereWC[i] = BoundingSphere.transform(\n          boundingSphere,\n          modelMatrix,\n          primitive._boundingSphereWC[i]\n        );\n        if (!frameState.scene3DOnly) {\n          primitive._boundingSphere2D[i] = BoundingSphere.clone(\n            primitive._boundingSphereCV[i],\n            primitive._boundingSphere2D[i]\n          );\n          primitive._boundingSphere2D[i].center.x = 0.0;\n          primitive._boundingSphereMorph[i] = BoundingSphere.union(\n            primitive._boundingSphereWC[i],\n            primitive._boundingSphereCV[i]\n          );\n        }\n      }\n    }\n  }\n\n  // Update bounding volumes for primitives that are sized in pixels.\n  // The pixel size in meters varies based on the distance from the camera.\n  var pixelSize = primitive.appearance.pixelSize;\n  if (defined(pixelSize)) {\n    length = primitive._boundingSpheres.length;\n    for (i = 0; i < length; ++i) {\n      boundingSphere = primitive._boundingSpheres[i];\n      var boundingSphereWC = primitive._boundingSphereWC[i];\n      var pixelSizeInMeters = frameState.camera.getPixelSize(\n        boundingSphere,\n        frameState.context.drawingBufferWidth,\n        frameState.context.drawingBufferHeight\n      );\n      var sizeInMeters = pixelSizeInMeters * pixelSize;\n      boundingSphereWC.radius = boundingSphere.radius + sizeInMeters;\n    }\n  }\n};\n\nfunction updateAndQueueCommands(\n  primitive,\n  frameState,\n  colorCommands,\n  pickCommands,\n  modelMatrix,\n  cull,\n  debugShowBoundingVolume,\n  twoPasses\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    frameState.mode !== SceneMode.SCENE3D &&\n    !Matrix4.equals(modelMatrix, Matrix4.IDENTITY)\n  ) {\n    throw new DeveloperError(\n      \"Primitive.modelMatrix is only supported in 3D mode.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  Primitive._updateBoundingVolumes(primitive, frameState, modelMatrix);\n\n  var boundingSpheres;\n  if (frameState.mode === SceneMode.SCENE3D) {\n    boundingSpheres = primitive._boundingSphereWC;\n  } else if (frameState.mode === SceneMode.COLUMBUS_VIEW) {\n    boundingSpheres = primitive._boundingSphereCV;\n  } else if (\n    frameState.mode === SceneMode.SCENE2D &&\n    defined(primitive._boundingSphere2D)\n  ) {\n    boundingSpheres = primitive._boundingSphere2D;\n  } else if (defined(primitive._boundingSphereMorph)) {\n    boundingSpheres = primitive._boundingSphereMorph;\n  }\n\n  var commandList = frameState.commandList;\n  var passes = frameState.passes;\n  if (passes.render || passes.pick) {\n    var allowPicking = primitive.allowPicking;\n    var castShadows = ShadowMode.castShadows(primitive.shadows);\n    var receiveShadows = ShadowMode.receiveShadows(primitive.shadows);\n    var colorLength = colorCommands.length;\n\n    var factor = twoPasses ? 2 : 1;\n    factor *= defined(primitive._depthFailAppearance) ? 2 : 1;\n\n    for (var j = 0; j < colorLength; ++j) {\n      var sphereIndex = Math.floor(j / factor);\n      var colorCommand = colorCommands[j];\n      colorCommand.modelMatrix = modelMatrix;\n      colorCommand.boundingVolume = boundingSpheres[sphereIndex];\n      colorCommand.cull = cull;\n      colorCommand.debugShowBoundingVolume = debugShowBoundingVolume;\n      colorCommand.castShadows = castShadows;\n      colorCommand.receiveShadows = receiveShadows;\n\n      if (allowPicking) {\n        colorCommand.pickId = \"v_pickColor\";\n      } else {\n        colorCommand.pickId = undefined;\n      }\n\n      commandList.push(colorCommand);\n    }\n  }\n}\n\n/**\n * Called when {@link Viewer} or {@link CesiumWidget} render the scene to\n * get the draw commands needed to render this primitive.\n * <p>\n * Do not call this function directly.  This is documented just to\n * list the exceptions that may be propagated when the scene is rendered:\n * </p>\n *\n * @exception {DeveloperError} All instance geometries must have the same primitiveType.\n * @exception {DeveloperError} Appearance and material have a uniform with the same name.\n * @exception {DeveloperError} Primitive.modelMatrix is only supported in 3D mode.\n * @exception {RuntimeError} Vertex texture fetch support is required to render primitives with per-instance attributes. The maximum number of vertex texture image units must be greater than zero.\n */\nPrimitive.prototype.update = function (frameState) {\n  if (\n    (!defined(this.geometryInstances) && this._va.length === 0) ||\n    (defined(this.geometryInstances) &&\n      Array.isArray(this.geometryInstances) &&\n      this.geometryInstances.length === 0) ||\n    !defined(this.appearance) ||\n    (frameState.mode !== SceneMode.SCENE3D && frameState.scene3DOnly) ||\n    (!frameState.passes.render && !frameState.passes.pick)\n  ) {\n    return;\n  }\n\n  if (defined(this._error)) {\n    throw this._error;\n  }\n\n  //>>includeStart('debug', pragmas.debug);\n  if (defined(this.rtcCenter) && !frameState.scene3DOnly) {\n    throw new DeveloperError(\n      \"RTC rendering is only available for 3D only scenes.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  if (this._state === PrimitiveState.FAILED) {\n    return;\n  }\n\n  var context = frameState.context;\n  if (!defined(this._batchTable)) {\n    createBatchTable(this, context);\n  }\n  if (this._batchTable.attributes.length > 0) {\n    if (ContextLimits.maximumVertexTextureImageUnits === 0) {\n      throw new RuntimeError(\n        \"Vertex texture fetch support is required to render primitives with per-instance attributes. The maximum number of vertex texture image units must be greater than zero.\"\n      );\n    }\n    this._batchTable.update(frameState);\n  }\n\n  if (\n    this._state !== PrimitiveState.COMPLETE &&\n    this._state !== PrimitiveState.COMBINED\n  ) {\n    if (this.asynchronous) {\n      loadAsynchronous(this, frameState);\n    } else {\n      loadSynchronous(this, frameState);\n    }\n  }\n\n  if (this._state === PrimitiveState.COMBINED) {\n    updateBatchTableBoundingSpheres(this, frameState);\n    updateBatchTableOffsets(this, frameState);\n    createVertexArray(this, frameState);\n  }\n\n  if (!this.show || this._state !== PrimitiveState.COMPLETE) {\n    return;\n  }\n\n  if (!this._batchTableOffsetsUpdated) {\n    updateBatchTableOffsets(this, frameState);\n  }\n  if (this._recomputeBoundingSpheres) {\n    recomputeBoundingSpheres(this, frameState);\n  }\n\n  // Create or recreate render state and shader program if appearance/material changed\n  var appearance = this.appearance;\n  var material = appearance.material;\n  var createRS = false;\n  var createSP = false;\n\n  if (this._appearance !== appearance) {\n    this._appearance = appearance;\n    this._material = material;\n    createRS = true;\n    createSP = true;\n  } else if (this._material !== material) {\n    this._material = material;\n    createSP = true;\n  }\n\n  var depthFailAppearance = this.depthFailAppearance;\n  var depthFailMaterial = defined(depthFailAppearance)\n    ? depthFailAppearance.material\n    : undefined;\n\n  if (this._depthFailAppearance !== depthFailAppearance) {\n    this._depthFailAppearance = depthFailAppearance;\n    this._depthFailMaterial = depthFailMaterial;\n    createRS = true;\n    createSP = true;\n  } else if (this._depthFailMaterial !== depthFailMaterial) {\n    this._depthFailMaterial = depthFailMaterial;\n    createSP = true;\n  }\n\n  var translucent = this._appearance.isTranslucent();\n  if (this._translucent !== translucent) {\n    this._translucent = translucent;\n    createRS = true;\n  }\n\n  if (defined(this._material)) {\n    this._material.update(context);\n  }\n\n  var twoPasses = appearance.closed && translucent;\n\n  if (createRS) {\n    var rsFunc = defaultValue(\n      this._createRenderStatesFunction,\n      createRenderStates\n    );\n    rsFunc(this, context, appearance, twoPasses);\n  }\n\n  if (createSP) {\n    var spFunc = defaultValue(\n      this._createShaderProgramFunction,\n      createShaderProgram\n    );\n    spFunc(this, frameState, appearance);\n  }\n\n  if (createRS || createSP) {\n    var commandFunc = defaultValue(\n      this._createCommandsFunction,\n      createCommands\n    );\n    commandFunc(\n      this,\n      appearance,\n      material,\n      translucent,\n      twoPasses,\n      this._colorCommands,\n      this._pickCommands,\n      frameState\n    );\n  }\n\n  var updateAndQueueCommandsFunc = defaultValue(\n    this._updateAndQueueCommandsFunction,\n    updateAndQueueCommands\n  );\n  updateAndQueueCommandsFunc(\n    this,\n    frameState,\n    this._colorCommands,\n    this._pickCommands,\n    this.modelMatrix,\n    this.cull,\n    this.debugShowBoundingVolume,\n    twoPasses\n  );\n};\n\nvar offsetBoundingSphereScratch1 = new BoundingSphere();\nvar offsetBoundingSphereScratch2 = new BoundingSphere();\nfunction transformBoundingSphere(boundingSphere, offset, offsetAttribute) {\n  if (offsetAttribute === GeometryOffsetAttribute.TOP) {\n    var origBS = BoundingSphere.clone(\n      boundingSphere,\n      offsetBoundingSphereScratch1\n    );\n    var offsetBS = BoundingSphere.clone(\n      boundingSphere,\n      offsetBoundingSphereScratch2\n    );\n    offsetBS.center = Cartesian3.add(offsetBS.center, offset, offsetBS.center);\n    boundingSphere = BoundingSphere.union(origBS, offsetBS, boundingSphere);\n  } else if (offsetAttribute === GeometryOffsetAttribute.ALL) {\n    boundingSphere.center = Cartesian3.add(\n      boundingSphere.center,\n      offset,\n      boundingSphere.center\n    );\n  }\n\n  return boundingSphere;\n}\n\nfunction createGetFunction(batchTable, instanceIndex, attributeIndex) {\n  return function () {\n    var attributeValue = batchTable.getBatchedAttribute(\n      instanceIndex,\n      attributeIndex\n    );\n    var attribute = batchTable.attributes[attributeIndex];\n    var componentsPerAttribute = attribute.componentsPerAttribute;\n    var value = ComponentDatatype.createTypedArray(\n      attribute.componentDatatype,\n      componentsPerAttribute\n    );\n    if (defined(attributeValue.constructor.pack)) {\n      attributeValue.constructor.pack(attributeValue, value, 0);\n    } else {\n      value[0] = attributeValue;\n    }\n    return value;\n  };\n}\n\nfunction createSetFunction(\n  batchTable,\n  instanceIndex,\n  attributeIndex,\n  primitive,\n  name\n) {\n  return function (value) {\n    //>>includeStart('debug', pragmas.debug);\n    if (\n      !defined(value) ||\n      !defined(value.length) ||\n      value.length < 1 ||\n      value.length > 4\n    ) {\n      throw new DeveloperError(\n        \"value must be and array with length between 1 and 4.\"\n      );\n    }\n    //>>includeEnd('debug');\n    var attributeValue = getAttributeValue(value);\n    batchTable.setBatchedAttribute(\n      instanceIndex,\n      attributeIndex,\n      attributeValue\n    );\n    if (name === \"offset\") {\n      primitive._recomputeBoundingSpheres = true;\n      primitive._batchTableOffsetsUpdated = false;\n    }\n  };\n}\n\nvar offsetScratch = new Cartesian3();\n\nfunction createBoundingSphereProperties(primitive, properties, index) {\n  properties.boundingSphere = {\n    get: function () {\n      var boundingSphere = primitive._instanceBoundingSpheres[index];\n      if (defined(boundingSphere)) {\n        boundingSphere = boundingSphere.clone();\n        var modelMatrix = primitive.modelMatrix;\n        var offset = properties.offset;\n        if (defined(offset)) {\n          transformBoundingSphere(\n            boundingSphere,\n            Cartesian3.fromArray(offset.get(), 0, offsetScratch),\n            primitive._offsetInstanceExtend[index]\n          );\n        }\n        if (defined(modelMatrix)) {\n          boundingSphere = BoundingSphere.transform(\n            boundingSphere,\n            modelMatrix\n          );\n        }\n      }\n\n      return boundingSphere;\n    },\n  };\n  properties.boundingSphereCV = {\n    get: function () {\n      return primitive._instanceBoundingSpheresCV[index];\n    },\n  };\n}\n\nfunction createPickIdProperty(primitive, properties, index) {\n  properties.pickId = {\n    get: function () {\n      return primitive._pickIds[index];\n    },\n  };\n}\n\n/**\n * Returns the modifiable per-instance attributes for a {@link GeometryInstance}.\n *\n * @param {*} id The id of the {@link GeometryInstance}.\n * @returns {Object} The typed array in the attribute's format or undefined if the is no instance with id.\n *\n * @exception {DeveloperError} must call update before calling getGeometryInstanceAttributes.\n *\n * @example\n * var attributes = primitive.getGeometryInstanceAttributes('an id');\n * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);\n * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);\n * attributes.distanceDisplayCondition = Cesium.DistanceDisplayConditionGeometryInstanceAttribute.toValue(100.0, 10000.0);\n * attributes.offset = Cesium.OffsetGeometryInstanceAttribute.toValue(Cartesian3.IDENTITY);\n */\nPrimitive.prototype.getGeometryInstanceAttributes = function (id) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(id)) {\n    throw new DeveloperError(\"id is required\");\n  }\n  if (!defined(this._batchTable)) {\n    throw new DeveloperError(\n      \"must call update before calling getGeometryInstanceAttributes\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var index = -1;\n  var lastIndex = this._lastPerInstanceAttributeIndex;\n  var ids = this._instanceIds;\n  var length = ids.length;\n  for (var i = 0; i < length; ++i) {\n    var curIndex = (lastIndex + i) % length;\n    if (id === ids[curIndex]) {\n      index = curIndex;\n      break;\n    }\n  }\n\n  if (index === -1) {\n    return undefined;\n  }\n\n  var attributes = this._perInstanceAttributeCache[index];\n  if (defined(attributes)) {\n    return attributes;\n  }\n\n  var batchTable = this._batchTable;\n  var perInstanceAttributeIndices = this._batchTableAttributeIndices;\n  attributes = {};\n  var properties = {};\n\n  for (var name in perInstanceAttributeIndices) {\n    if (perInstanceAttributeIndices.hasOwnProperty(name)) {\n      var attributeIndex = perInstanceAttributeIndices[name];\n      properties[name] = {\n        get: createGetFunction(batchTable, index, attributeIndex),\n        set: createSetFunction(batchTable, index, attributeIndex, this, name),\n      };\n    }\n  }\n\n  createBoundingSphereProperties(this, properties, index);\n  createPickIdProperty(this, properties, index);\n  Object.defineProperties(attributes, properties);\n\n  this._lastPerInstanceAttributeIndex = index;\n  this._perInstanceAttributeCache[index] = attributes;\n  return attributes;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see Primitive#destroy\n */\nPrimitive.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n *\n * @example\n * e = e && e.destroy();\n *\n * @see Primitive#isDestroyed\n */\nPrimitive.prototype.destroy = function () {\n  var length;\n  var i;\n\n  this._sp = this._sp && this._sp.destroy();\n  this._spDepthFail = this._spDepthFail && this._spDepthFail.destroy();\n\n  var va = this._va;\n  length = va.length;\n  for (i = 0; i < length; ++i) {\n    va[i].destroy();\n  }\n  this._va = undefined;\n\n  var pickIds = this._pickIds;\n  length = pickIds.length;\n  for (i = 0; i < length; ++i) {\n    pickIds[i].destroy();\n  }\n  this._pickIds = undefined;\n\n  this._batchTable = this._batchTable && this._batchTable.destroy();\n\n  //These objects may be fairly large and reference other large objects (like Entities)\n  //We explicitly set them to undefined here so that the memory can be freed\n  //even if a reference to the destroyed Primitive has been kept around.\n  this._instanceIds = undefined;\n  this._perInstanceAttributeCache = undefined;\n  this._attributeLocations = undefined;\n\n  return destroyObject(this);\n};\n\nfunction setReady(primitive, frameState, state, error) {\n  primitive._error = error;\n  primitive._state = state;\n  frameState.afterRender.push(function () {\n    primitive._ready =\n      primitive._state === PrimitiveState.COMPLETE ||\n      primitive._state === PrimitiveState.FAILED;\n    if (!defined(error)) {\n      primitive._readyPromise.resolve(primitive);\n    } else {\n      primitive._readyPromise.reject(error);\n    }\n  });\n}\nexport default Primitive;\n"]},"metadata":{},"sourceType":"module"}