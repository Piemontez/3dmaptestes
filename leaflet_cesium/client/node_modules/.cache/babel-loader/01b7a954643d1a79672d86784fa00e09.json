{"ast":null,"code":"import arraySlice from \"../Core/arraySlice.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport getJsonFromTypedArray from \"../Core/getJsonFromTypedArray.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport when from \"../ThirdParty/when.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport Cesium3DTileBatchTable from \"./Cesium3DTileBatchTable.js\";\nimport Cesium3DTileFeatureTable from \"./Cesium3DTileFeatureTable.js\";\nimport DracoLoader from \"./DracoLoader.js\";\nimport getClipAndStyleCode from \"./getClipAndStyleCode.js\";\nimport getClippingFunction from \"./getClippingFunction.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\nimport StencilConstants from \"./StencilConstants.js\";\nvar DecodingState = {\n  NEEDS_DECODE: 0,\n  DECODING: 1,\n  READY: 2,\n  FAILED: 3\n};\n/**\n * Represents the contents of a\n * {@link https://github.com/CesiumGS/3d-tiles/tree/master/specification/TileFormats/PointCloud|Point Cloud}\n * tile. Used internally by {@link PointCloud3DTileContent} and {@link TimeDynamicPointCloud}.\n *\n * @alias PointCloud\n * @constructor\n *\n * @see PointCloud3DTileContent\n * @see TimeDynamicPointCloud\n *\n * @private\n */\n\nfunction PointCloud(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.arrayBuffer\", options.arrayBuffer); //>>includeEnd('debug');\n  // Hold onto the payload until the render resources are created\n\n  this._parsedContent = undefined;\n  this._drawCommand = undefined;\n  this._isTranslucent = false;\n  this._styleTranslucent = false;\n  this._constantColor = Color.clone(Color.DARKGRAY);\n  this._highlightColor = Color.clone(Color.WHITE);\n  this._pointSize = 1.0;\n  this._rtcCenter = undefined;\n  this._quantizedVolumeScale = undefined;\n  this._quantizedVolumeOffset = undefined; // These values are used to regenerate the shader when the style changes\n\n  this._styleableShaderAttributes = undefined;\n  this._isQuantized = false;\n  this._isOctEncoded16P = false;\n  this._isRGB565 = false;\n  this._hasColors = false;\n  this._hasNormals = false;\n  this._hasBatchIds = false; // Draco\n\n  this._decodingState = DecodingState.READY;\n  this._dequantizeInShader = true;\n  this._isQuantizedDraco = false;\n  this._isOctEncodedDraco = false;\n  this._quantizedRange = 0.0;\n  this._octEncodedRange = 0.0; // Use per-point normals to hide back-facing points.\n\n  this.backFaceCulling = false;\n  this._backFaceCulling = false; // Whether to enable normal shading\n\n  this.normalShading = true;\n  this._normalShading = true;\n  this._opaqueRenderState = undefined;\n  this._translucentRenderState = undefined;\n  this._mode = undefined;\n  this._ready = false;\n  this._readyPromise = when.defer();\n  this._pointsLength = 0;\n  this._geometryByteLength = 0;\n  this._vertexShaderLoaded = options.vertexShaderLoaded;\n  this._fragmentShaderLoaded = options.fragmentShaderLoaded;\n  this._uniformMapLoaded = options.uniformMapLoaded;\n  this._batchTableLoaded = options.batchTableLoaded;\n  this._pickIdLoaded = options.pickIdLoaded;\n  this._opaquePass = defaultValue(options.opaquePass, Pass.OPAQUE);\n  this._cull = defaultValue(options.cull, true);\n  this.style = undefined;\n  this._style = undefined;\n  this.styleDirty = false;\n  this.modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n  this._modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n  this.time = 0.0; // For styling\n\n  this.shadows = ShadowMode.ENABLED;\n  this._boundingSphere = undefined;\n  this.clippingPlanes = undefined;\n  this.isClipped = false;\n  this.clippingPlanesDirty = false; // If defined, use this matrix to position the clipping planes instead of the modelMatrix.\n  // This is so that when point clouds are part of a tileset they all get clipped relative\n  // to the root tile.\n\n  this.clippingPlanesOriginMatrix = undefined;\n  this.attenuation = false;\n  this._attenuation = false; // Options for geometric error based attenuation\n\n  this.geometricError = 0.0;\n  this.geometricErrorScale = 1.0;\n  this.maximumAttenuation = this._pointSize;\n  initialize(this, options);\n}\n\nObject.defineProperties(PointCloud.prototype, {\n  pointsLength: {\n    get: function () {\n      return this._pointsLength;\n    }\n  },\n  geometryByteLength: {\n    get: function () {\n      return this._geometryByteLength;\n    }\n  },\n  ready: {\n    get: function () {\n      return this._ready;\n    }\n  },\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    }\n  },\n  color: {\n    get: function () {\n      return Color.clone(this._highlightColor);\n    },\n    set: function (value) {\n      this._highlightColor = Color.clone(value, this._highlightColor);\n    }\n  },\n  boundingSphere: {\n    get: function () {\n      if (defined(this._drawCommand)) {\n        return this._drawCommand.boundingVolume;\n      }\n\n      return undefined;\n    },\n    set: function (value) {\n      this._boundingSphere = BoundingSphere.clone(value, this._boundingSphere);\n    }\n  }\n});\nvar sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;\n\nfunction initialize(pointCloud, options) {\n  var arrayBuffer = options.arrayBuffer;\n  var byteOffset = defaultValue(options.byteOffset, 0);\n  var uint8Array = new Uint8Array(arrayBuffer);\n  var view = new DataView(arrayBuffer);\n  byteOffset += sizeOfUint32; // Skip magic\n\n  var version = view.getUint32(byteOffset, true);\n\n  if (version !== 1) {\n    throw new RuntimeError(\"Only Point Cloud tile version 1 is supported.  Version \" + version + \" is not.\");\n  }\n\n  byteOffset += sizeOfUint32; // Skip byteLength\n\n  byteOffset += sizeOfUint32;\n  var featureTableJsonByteLength = view.getUint32(byteOffset, true);\n\n  if (featureTableJsonByteLength === 0) {\n    throw new RuntimeError(\"Feature table must have a byte length greater than zero\");\n  }\n\n  byteOffset += sizeOfUint32;\n  var featureTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  var batchTableJsonByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  var batchTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  var featureTableJson = getJsonFromTypedArray(uint8Array, byteOffset, featureTableJsonByteLength);\n  byteOffset += featureTableJsonByteLength;\n  var featureTableBinary = new Uint8Array(arrayBuffer, byteOffset, featureTableBinaryByteLength);\n  byteOffset += featureTableBinaryByteLength; // Get the batch table JSON and binary\n\n  var batchTableJson;\n  var batchTableBinary;\n\n  if (batchTableJsonByteLength > 0) {\n    // Has a batch table JSON\n    batchTableJson = getJsonFromTypedArray(uint8Array, byteOffset, batchTableJsonByteLength);\n    byteOffset += batchTableJsonByteLength;\n\n    if (batchTableBinaryByteLength > 0) {\n      // Has a batch table binary\n      batchTableBinary = new Uint8Array(arrayBuffer, byteOffset, batchTableBinaryByteLength);\n      byteOffset += batchTableBinaryByteLength;\n    }\n  }\n\n  var featureTable = new Cesium3DTileFeatureTable(featureTableJson, featureTableBinary);\n  var pointsLength = featureTable.getGlobalProperty(\"POINTS_LENGTH\");\n  featureTable.featuresLength = pointsLength;\n\n  if (!defined(pointsLength)) {\n    throw new RuntimeError(\"Feature table global property: POINTS_LENGTH must be defined\");\n  }\n\n  var rtcCenter = featureTable.getGlobalProperty(\"RTC_CENTER\", ComponentDatatype.FLOAT, 3);\n\n  if (defined(rtcCenter)) {\n    pointCloud._rtcCenter = Cartesian3.unpack(rtcCenter);\n  }\n\n  var positions;\n  var colors;\n  var normals;\n  var batchIds;\n  var hasPositions = false;\n  var hasColors = false;\n  var hasNormals = false;\n  var hasBatchIds = false;\n  var isQuantized = false;\n  var isTranslucent = false;\n  var isRGB565 = false;\n  var isOctEncoded16P = false;\n  var dracoBuffer;\n  var dracoFeatureTableProperties;\n  var dracoBatchTableProperties;\n  var featureTableDraco = defined(featureTableJson.extensions) ? featureTableJson.extensions[\"3DTILES_draco_point_compression\"] : undefined;\n  var batchTableDraco = defined(batchTableJson) && defined(batchTableJson.extensions) ? batchTableJson.extensions[\"3DTILES_draco_point_compression\"] : undefined;\n\n  if (defined(batchTableDraco)) {\n    dracoBatchTableProperties = batchTableDraco.properties;\n  }\n\n  if (defined(featureTableDraco)) {\n    dracoFeatureTableProperties = featureTableDraco.properties;\n    var dracoByteOffset = featureTableDraco.byteOffset;\n    var dracoByteLength = featureTableDraco.byteLength;\n\n    if (!defined(dracoFeatureTableProperties) || !defined(dracoByteOffset) || !defined(dracoByteLength)) {\n      throw new RuntimeError(\"Draco properties, byteOffset, and byteLength must be defined\");\n    }\n\n    dracoBuffer = arraySlice(featureTableBinary, dracoByteOffset, dracoByteOffset + dracoByteLength);\n    hasPositions = defined(dracoFeatureTableProperties.POSITION);\n    hasColors = defined(dracoFeatureTableProperties.RGB) || defined(dracoFeatureTableProperties.RGBA);\n    hasNormals = defined(dracoFeatureTableProperties.NORMAL);\n    hasBatchIds = defined(dracoFeatureTableProperties.BATCH_ID);\n    isTranslucent = defined(dracoFeatureTableProperties.RGBA);\n    pointCloud._decodingState = DecodingState.NEEDS_DECODE;\n  }\n\n  var draco;\n\n  if (defined(dracoBuffer)) {\n    draco = {\n      buffer: dracoBuffer,\n      featureTableProperties: dracoFeatureTableProperties,\n      batchTableProperties: dracoBatchTableProperties,\n      properties: combine(dracoFeatureTableProperties, dracoBatchTableProperties),\n      dequantizeInShader: pointCloud._dequantizeInShader\n    };\n  }\n\n  if (!hasPositions) {\n    if (defined(featureTableJson.POSITION)) {\n      positions = featureTable.getPropertyArray(\"POSITION\", ComponentDatatype.FLOAT, 3);\n      hasPositions = true;\n    } else if (defined(featureTableJson.POSITION_QUANTIZED)) {\n      positions = featureTable.getPropertyArray(\"POSITION_QUANTIZED\", ComponentDatatype.UNSIGNED_SHORT, 3);\n      isQuantized = true;\n      hasPositions = true;\n      var quantizedVolumeScale = featureTable.getGlobalProperty(\"QUANTIZED_VOLUME_SCALE\", ComponentDatatype.FLOAT, 3);\n\n      if (!defined(quantizedVolumeScale)) {\n        throw new RuntimeError(\"Global property: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.\");\n      }\n\n      pointCloud._quantizedVolumeScale = Cartesian3.unpack(quantizedVolumeScale);\n      pointCloud._quantizedRange = (1 << 16) - 1;\n      var quantizedVolumeOffset = featureTable.getGlobalProperty(\"QUANTIZED_VOLUME_OFFSET\", ComponentDatatype.FLOAT, 3);\n\n      if (!defined(quantizedVolumeOffset)) {\n        throw new RuntimeError(\"Global property: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.\");\n      }\n\n      pointCloud._quantizedVolumeOffset = Cartesian3.unpack(quantizedVolumeOffset);\n    }\n  }\n\n  if (!hasColors) {\n    if (defined(featureTableJson.RGBA)) {\n      colors = featureTable.getPropertyArray(\"RGBA\", ComponentDatatype.UNSIGNED_BYTE, 4);\n      isTranslucent = true;\n      hasColors = true;\n    } else if (defined(featureTableJson.RGB)) {\n      colors = featureTable.getPropertyArray(\"RGB\", ComponentDatatype.UNSIGNED_BYTE, 3);\n      hasColors = true;\n    } else if (defined(featureTableJson.RGB565)) {\n      colors = featureTable.getPropertyArray(\"RGB565\", ComponentDatatype.UNSIGNED_SHORT, 1);\n      isRGB565 = true;\n      hasColors = true;\n    }\n  }\n\n  if (!hasNormals) {\n    if (defined(featureTableJson.NORMAL)) {\n      normals = featureTable.getPropertyArray(\"NORMAL\", ComponentDatatype.FLOAT, 3);\n      hasNormals = true;\n    } else if (defined(featureTableJson.NORMAL_OCT16P)) {\n      normals = featureTable.getPropertyArray(\"NORMAL_OCT16P\", ComponentDatatype.UNSIGNED_BYTE, 2);\n      isOctEncoded16P = true;\n      hasNormals = true;\n    }\n  }\n\n  if (!hasBatchIds) {\n    if (defined(featureTableJson.BATCH_ID)) {\n      batchIds = featureTable.getPropertyArray(\"BATCH_ID\", ComponentDatatype.UNSIGNED_SHORT, 1);\n      hasBatchIds = true;\n    }\n  }\n\n  if (!hasPositions) {\n    throw new RuntimeError(\"Either POSITION or POSITION_QUANTIZED must be defined.\");\n  }\n\n  if (defined(featureTableJson.CONSTANT_RGBA)) {\n    var constantRGBA = featureTable.getGlobalProperty(\"CONSTANT_RGBA\", ComponentDatatype.UNSIGNED_BYTE, 4);\n    pointCloud._constantColor = Color.fromBytes(constantRGBA[0], constantRGBA[1], constantRGBA[2], constantRGBA[3], pointCloud._constantColor);\n  }\n\n  if (hasBatchIds) {\n    var batchLength = featureTable.getGlobalProperty(\"BATCH_LENGTH\");\n\n    if (!defined(batchLength)) {\n      throw new RuntimeError(\"Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.\");\n    }\n\n    if (defined(batchTableBinary)) {\n      // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed\n      batchTableBinary = new Uint8Array(batchTableBinary);\n    }\n\n    if (defined(pointCloud._batchTableLoaded)) {\n      pointCloud._batchTableLoaded(batchLength, batchTableJson, batchTableBinary);\n    }\n  } // If points are not batched and there are per-point properties, use these properties for styling purposes\n\n\n  var styleableProperties;\n\n  if (!hasBatchIds && defined(batchTableBinary)) {\n    styleableProperties = Cesium3DTileBatchTable.getBinaryProperties(pointsLength, batchTableJson, batchTableBinary);\n  }\n\n  pointCloud._parsedContent = {\n    positions: positions,\n    colors: colors,\n    normals: normals,\n    batchIds: batchIds,\n    styleableProperties: styleableProperties,\n    draco: draco\n  };\n  pointCloud._pointsLength = pointsLength;\n  pointCloud._isQuantized = isQuantized;\n  pointCloud._isOctEncoded16P = isOctEncoded16P;\n  pointCloud._isRGB565 = isRGB565;\n  pointCloud._isTranslucent = isTranslucent;\n  pointCloud._hasColors = hasColors;\n  pointCloud._hasNormals = hasNormals;\n  pointCloud._hasBatchIds = hasBatchIds;\n}\n\nvar scratchMin = new Cartesian3();\nvar scratchMax = new Cartesian3();\nvar scratchPosition = new Cartesian3();\nvar randomValues;\n\nfunction getRandomValues(samplesLength) {\n  // Use same random values across all runs\n  if (!defined(randomValues)) {\n    CesiumMath.setRandomNumberSeed(0);\n    randomValues = new Array(samplesLength);\n\n    for (var i = 0; i < samplesLength; ++i) {\n      randomValues[i] = CesiumMath.nextRandomNumber();\n    }\n  }\n\n  return randomValues;\n}\n\nfunction computeApproximateBoundingSphereFromPositions(positions) {\n  var maximumSamplesLength = 20;\n  var pointsLength = positions.length / 3;\n  var samplesLength = Math.min(pointsLength, maximumSamplesLength);\n  var randomValues = getRandomValues(maximumSamplesLength);\n  var maxValue = Number.MAX_VALUE;\n  var minValue = -Number.MAX_VALUE;\n  var min = Cartesian3.fromElements(maxValue, maxValue, maxValue, scratchMin);\n  var max = Cartesian3.fromElements(minValue, minValue, minValue, scratchMax);\n\n  for (var i = 0; i < samplesLength; ++i) {\n    var index = Math.floor(randomValues[i] * pointsLength);\n    var position = Cartesian3.unpack(positions, index * 3, scratchPosition);\n    Cartesian3.minimumByComponent(min, position, min);\n    Cartesian3.maximumByComponent(max, position, max);\n  }\n\n  var boundingSphere = BoundingSphere.fromCornerPoints(min, max);\n  boundingSphere.radius += CesiumMath.EPSILON2; // To avoid radius of zero\n\n  return boundingSphere;\n}\n\nfunction prepareVertexAttribute(typedArray, name) {\n  // WebGL does not support UNSIGNED_INT, INT, or DOUBLE vertex attributes. Convert these to FLOAT.\n  var componentDatatype = ComponentDatatype.fromTypedArray(typedArray);\n\n  if (componentDatatype === ComponentDatatype.INT || componentDatatype === ComponentDatatype.UNSIGNED_INT || componentDatatype === ComponentDatatype.DOUBLE) {\n    oneTimeWarning(\"Cast pnts property to floats\", 'Point cloud property \"' + name + '\" will be casted to a float array because INT, UNSIGNED_INT, and DOUBLE are not valid WebGL vertex attribute types. Some precision may be lost.');\n    return new Float32Array(typedArray);\n  }\n\n  return typedArray;\n}\n\nvar scratchPointSizeAndTimeAndGeometricErrorAndDepthMultiplier = new Cartesian4();\nvar scratchQuantizedVolumeScaleAndOctEncodedRange = new Cartesian4();\nvar scratchColor = new Color();\nvar positionLocation = 0;\nvar colorLocation = 1;\nvar normalLocation = 2;\nvar batchIdLocation = 3;\nvar numberOfAttributes = 4;\nvar scratchClippingPlanesMatrix = new Matrix4();\nvar scratchInverseTransposeClippingPlanesMatrix = new Matrix4();\n\nfunction createResources(pointCloud, frameState) {\n  var context = frameState.context;\n  var parsedContent = pointCloud._parsedContent;\n  var pointsLength = pointCloud._pointsLength;\n  var positions = parsedContent.positions;\n  var colors = parsedContent.colors;\n  var normals = parsedContent.normals;\n  var batchIds = parsedContent.batchIds;\n  var styleableProperties = parsedContent.styleableProperties;\n  var hasStyleableProperties = defined(styleableProperties);\n  var isQuantized = pointCloud._isQuantized;\n  var isQuantizedDraco = pointCloud._isQuantizedDraco;\n  var isOctEncoded16P = pointCloud._isOctEncoded16P;\n  var isOctEncodedDraco = pointCloud._isOctEncodedDraco;\n  var quantizedRange = pointCloud._quantizedRange;\n  var octEncodedRange = pointCloud._octEncodedRange;\n  var isRGB565 = pointCloud._isRGB565;\n  var isTranslucent = pointCloud._isTranslucent;\n  var hasColors = pointCloud._hasColors;\n  var hasNormals = pointCloud._hasNormals;\n  var hasBatchIds = pointCloud._hasBatchIds;\n  var componentsPerAttribute;\n  var componentDatatype;\n  var styleableVertexAttributes = [];\n  var styleableShaderAttributes = {};\n  pointCloud._styleableShaderAttributes = styleableShaderAttributes;\n\n  if (hasStyleableProperties) {\n    var attributeLocation = numberOfAttributes;\n\n    for (var name in styleableProperties) {\n      if (styleableProperties.hasOwnProperty(name)) {\n        var property = styleableProperties[name];\n        var typedArray = prepareVertexAttribute(property.typedArray, name);\n        componentsPerAttribute = property.componentCount;\n        componentDatatype = ComponentDatatype.fromTypedArray(typedArray);\n        var vertexBuffer = Buffer.createVertexBuffer({\n          context: context,\n          typedArray: typedArray,\n          usage: BufferUsage.STATIC_DRAW\n        });\n        pointCloud._geometryByteLength += vertexBuffer.sizeInBytes;\n        var vertexAttribute = {\n          index: attributeLocation,\n          vertexBuffer: vertexBuffer,\n          componentsPerAttribute: componentsPerAttribute,\n          componentDatatype: componentDatatype,\n          normalize: false,\n          offsetInBytes: 0,\n          strideInBytes: 0\n        };\n        styleableVertexAttributes.push(vertexAttribute);\n        styleableShaderAttributes[name] = {\n          location: attributeLocation,\n          componentCount: componentsPerAttribute\n        };\n        ++attributeLocation;\n      }\n    }\n  }\n\n  var positionsVertexBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: positions,\n    usage: BufferUsage.STATIC_DRAW\n  });\n  pointCloud._geometryByteLength += positionsVertexBuffer.sizeInBytes;\n  var colorsVertexBuffer;\n\n  if (hasColors) {\n    colorsVertexBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: colors,\n      usage: BufferUsage.STATIC_DRAW\n    });\n    pointCloud._geometryByteLength += colorsVertexBuffer.sizeInBytes;\n  }\n\n  var normalsVertexBuffer;\n\n  if (hasNormals) {\n    normalsVertexBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: normals,\n      usage: BufferUsage.STATIC_DRAW\n    });\n    pointCloud._geometryByteLength += normalsVertexBuffer.sizeInBytes;\n  }\n\n  var batchIdsVertexBuffer;\n\n  if (hasBatchIds) {\n    batchIds = prepareVertexAttribute(batchIds, \"batchIds\");\n    batchIdsVertexBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: batchIds,\n      usage: BufferUsage.STATIC_DRAW\n    });\n    pointCloud._geometryByteLength += batchIdsVertexBuffer.sizeInBytes;\n  }\n\n  var attributes = [];\n\n  if (isQuantized) {\n    componentDatatype = ComponentDatatype.UNSIGNED_SHORT;\n  } else if (isQuantizedDraco) {\n    componentDatatype = quantizedRange <= 255 ? ComponentDatatype.UNSIGNED_BYTE : ComponentDatatype.UNSIGNED_SHORT;\n  } else {\n    componentDatatype = ComponentDatatype.FLOAT;\n  }\n\n  attributes.push({\n    index: positionLocation,\n    vertexBuffer: positionsVertexBuffer,\n    componentsPerAttribute: 3,\n    componentDatatype: componentDatatype,\n    normalize: false,\n    offsetInBytes: 0,\n    strideInBytes: 0\n  });\n\n  if (pointCloud._cull) {\n    if (isQuantized || isQuantizedDraco) {\n      pointCloud._boundingSphere = BoundingSphere.fromCornerPoints(Cartesian3.ZERO, pointCloud._quantizedVolumeScale);\n    } else {\n      pointCloud._boundingSphere = computeApproximateBoundingSphereFromPositions(positions);\n    }\n  }\n\n  if (hasColors) {\n    if (isRGB565) {\n      attributes.push({\n        index: colorLocation,\n        vertexBuffer: colorsVertexBuffer,\n        componentsPerAttribute: 1,\n        componentDatatype: ComponentDatatype.UNSIGNED_SHORT,\n        normalize: false,\n        offsetInBytes: 0,\n        strideInBytes: 0\n      });\n    } else {\n      var colorComponentsPerAttribute = isTranslucent ? 4 : 3;\n      attributes.push({\n        index: colorLocation,\n        vertexBuffer: colorsVertexBuffer,\n        componentsPerAttribute: colorComponentsPerAttribute,\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        normalize: true,\n        offsetInBytes: 0,\n        strideInBytes: 0\n      });\n    }\n  }\n\n  if (hasNormals) {\n    if (isOctEncoded16P) {\n      componentsPerAttribute = 2;\n      componentDatatype = ComponentDatatype.UNSIGNED_BYTE;\n    } else if (isOctEncodedDraco) {\n      componentsPerAttribute = 2;\n      componentDatatype = octEncodedRange <= 255 ? ComponentDatatype.UNSIGNED_BYTE : ComponentDatatype.UNSIGNED_SHORT;\n    } else {\n      componentsPerAttribute = 3;\n      componentDatatype = ComponentDatatype.FLOAT;\n    }\n\n    attributes.push({\n      index: normalLocation,\n      vertexBuffer: normalsVertexBuffer,\n      componentsPerAttribute: componentsPerAttribute,\n      componentDatatype: componentDatatype,\n      normalize: false,\n      offsetInBytes: 0,\n      strideInBytes: 0\n    });\n  }\n\n  if (hasBatchIds) {\n    attributes.push({\n      index: batchIdLocation,\n      vertexBuffer: batchIdsVertexBuffer,\n      componentsPerAttribute: 1,\n      componentDatatype: ComponentDatatype.fromTypedArray(batchIds),\n      normalize: false,\n      offsetInBytes: 0,\n      strideInBytes: 0\n    });\n  }\n\n  if (hasStyleableProperties) {\n    attributes = attributes.concat(styleableVertexAttributes);\n  }\n\n  var vertexArray = new VertexArray({\n    context: context,\n    attributes: attributes\n  });\n  var opaqueRenderState = {\n    depthTest: {\n      enabled: true\n    }\n  };\n\n  if (pointCloud._opaquePass === Pass.CESIUM_3D_TILE) {\n    opaqueRenderState.stencilTest = StencilConstants.setCesium3DTileBit();\n    opaqueRenderState.stencilMask = StencilConstants.CESIUM_3D_TILE_MASK;\n  }\n\n  pointCloud._opaqueRenderState = RenderState.fromCache(opaqueRenderState);\n  pointCloud._translucentRenderState = RenderState.fromCache({\n    depthTest: {\n      enabled: true\n    },\n    depthMask: false,\n    blending: BlendingState.ALPHA_BLEND\n  });\n  pointCloud._drawCommand = new DrawCommand({\n    boundingVolume: new BoundingSphere(),\n    cull: pointCloud._cull,\n    modelMatrix: new Matrix4(),\n    primitiveType: PrimitiveType.POINTS,\n    vertexArray: vertexArray,\n    count: pointsLength,\n    shaderProgram: undefined,\n    // Updated in createShaders\n    uniformMap: undefined,\n    // Updated in createShaders\n    renderState: isTranslucent ? pointCloud._translucentRenderState : pointCloud._opaqueRenderState,\n    pass: isTranslucent ? Pass.TRANSLUCENT : pointCloud._opaquePass,\n    owner: pointCloud,\n    castShadows: false,\n    receiveShadows: false,\n    pickId: pointCloud._pickIdLoaded()\n  });\n}\n\nfunction createUniformMap(pointCloud, frameState) {\n  var context = frameState.context;\n  var isQuantized = pointCloud._isQuantized;\n  var isQuantizedDraco = pointCloud._isQuantizedDraco;\n  var isOctEncodedDraco = pointCloud._isOctEncodedDraco;\n  var uniformMap = {\n    u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier: function () {\n      var scratch = scratchPointSizeAndTimeAndGeometricErrorAndDepthMultiplier;\n      scratch.x = pointCloud._attenuation ? pointCloud.maximumAttenuation : pointCloud._pointSize;\n      scratch.x *= frameState.pixelRatio;\n      scratch.y = pointCloud.time;\n\n      if (pointCloud._attenuation) {\n        var frustum = frameState.camera.frustum;\n        var depthMultiplier; // Attenuation is maximumAttenuation in 2D/ortho\n\n        if (frameState.mode === SceneMode.SCENE2D || frustum instanceof OrthographicFrustum) {\n          depthMultiplier = Number.POSITIVE_INFINITY;\n        } else {\n          depthMultiplier = context.drawingBufferHeight / frameState.camera.frustum.sseDenominator;\n        }\n\n        scratch.z = pointCloud.geometricError * pointCloud.geometricErrorScale;\n        scratch.w = depthMultiplier;\n      }\n\n      return scratch;\n    },\n    u_highlightColor: function () {\n      return pointCloud._highlightColor;\n    },\n    u_constantColor: function () {\n      return pointCloud._constantColor;\n    },\n    u_clippingPlanes: function () {\n      var clippingPlanes = pointCloud.clippingPlanes;\n      var isClipped = pointCloud.isClipped;\n      return isClipped ? clippingPlanes.texture : context.defaultTexture;\n    },\n    u_clippingPlanesEdgeStyle: function () {\n      var clippingPlanes = pointCloud.clippingPlanes;\n\n      if (!defined(clippingPlanes)) {\n        return Color.TRANSPARENT;\n      }\n\n      var style = Color.clone(clippingPlanes.edgeColor, scratchColor);\n      style.alpha = clippingPlanes.edgeWidth;\n      return style;\n    },\n    u_clippingPlanesMatrix: function () {\n      var clippingPlanes = pointCloud.clippingPlanes;\n\n      if (!defined(clippingPlanes)) {\n        return Matrix4.IDENTITY;\n      }\n\n      var clippingPlanesOriginMatrix = defaultValue(pointCloud.clippingPlanesOriginMatrix, pointCloud._modelMatrix);\n      Matrix4.multiply(context.uniformState.view3D, clippingPlanesOriginMatrix, scratchClippingPlanesMatrix);\n      var transform = Matrix4.multiply(scratchClippingPlanesMatrix, clippingPlanes.modelMatrix, scratchClippingPlanesMatrix);\n      return Matrix4.inverseTranspose(transform, scratchInverseTransposeClippingPlanesMatrix);\n    }\n  };\n\n  if (isQuantized || isQuantizedDraco || isOctEncodedDraco) {\n    uniformMap = combine(uniformMap, {\n      u_quantizedVolumeScaleAndOctEncodedRange: function () {\n        var scratch = scratchQuantizedVolumeScaleAndOctEncodedRange;\n\n        if (defined(pointCloud._quantizedVolumeScale)) {\n          var scale = Cartesian3.clone(pointCloud._quantizedVolumeScale, scratch);\n          Cartesian3.divideByScalar(scale, pointCloud._quantizedRange, scratch);\n        }\n\n        scratch.w = pointCloud._octEncodedRange;\n        return scratch;\n      }\n    });\n  }\n\n  if (defined(pointCloud._uniformMapLoaded)) {\n    uniformMap = pointCloud._uniformMapLoaded(uniformMap);\n  }\n\n  pointCloud._drawCommand.uniformMap = uniformMap;\n}\n\nfunction getStyleablePropertyIds(source, propertyIds) {\n  // Get all the property IDs used by this style\n  var regex = /czm_3dtiles_property_(\\d+)/g;\n  var matches = regex.exec(source);\n\n  while (matches !== null) {\n    var id = parseInt(matches[1]);\n\n    if (propertyIds.indexOf(id) === -1) {\n      propertyIds.push(id);\n    }\n\n    matches = regex.exec(source);\n  }\n}\n\nfunction getBuiltinPropertyNames(source, propertyNames) {\n  // Get all the builtin property names used by this style\n  var regex = /czm_3dtiles_builtin_property_(\\w+)/g;\n  var matches = regex.exec(source);\n\n  while (matches !== null) {\n    var name = matches[1];\n\n    if (propertyNames.indexOf(name) === -1) {\n      propertyNames.push(name);\n    }\n\n    matches = regex.exec(source);\n  }\n}\n\nfunction getVertexAttribute(vertexArray, index) {\n  var numberOfAttributes = vertexArray.numberOfAttributes;\n\n  for (var i = 0; i < numberOfAttributes; ++i) {\n    var attribute = vertexArray.getAttribute(i);\n\n    if (attribute.index === index) {\n      return attribute;\n    }\n  }\n}\n\nvar builtinPropertyNameMap = {\n  POSITION: \"czm_3dtiles_builtin_property_POSITION\",\n  POSITION_ABSOLUTE: \"czm_3dtiles_builtin_property_POSITION_ABSOLUTE\",\n  COLOR: \"czm_3dtiles_builtin_property_COLOR\",\n  NORMAL: \"czm_3dtiles_builtin_property_NORMAL\"\n};\n\nfunction modifyStyleFunction(source) {\n  // Edit the function header to accept the point position, color, and normal\n  var functionHeader = \"(\" + \"vec3 czm_3dtiles_builtin_property_POSITION, \" + \"vec3 czm_3dtiles_builtin_property_POSITION_ABSOLUTE, \" + \"vec4 czm_3dtiles_builtin_property_COLOR, \" + \"vec3 czm_3dtiles_builtin_property_NORMAL\" + \")\";\n  return source.replace(\"()\", functionHeader);\n}\n\nfunction createShaders(pointCloud, frameState, style) {\n  var i;\n  var name;\n  var attribute;\n  var context = frameState.context;\n  var hasStyle = defined(style);\n  var isQuantized = pointCloud._isQuantized;\n  var isQuantizedDraco = pointCloud._isQuantizedDraco;\n  var isOctEncoded16P = pointCloud._isOctEncoded16P;\n  var isOctEncodedDraco = pointCloud._isOctEncodedDraco;\n  var isRGB565 = pointCloud._isRGB565;\n  var isTranslucent = pointCloud._isTranslucent;\n  var hasColors = pointCloud._hasColors;\n  var hasNormals = pointCloud._hasNormals;\n  var hasBatchIds = pointCloud._hasBatchIds;\n  var backFaceCulling = pointCloud._backFaceCulling;\n  var normalShading = pointCloud._normalShading;\n  var vertexArray = pointCloud._drawCommand.vertexArray;\n  var clippingPlanes = pointCloud.clippingPlanes;\n  var attenuation = pointCloud._attenuation;\n  var colorStyleFunction;\n  var showStyleFunction;\n  var pointSizeStyleFunction;\n  var styleTranslucent = isTranslucent;\n  var propertyNameMap = clone(builtinPropertyNameMap);\n  var propertyIdToAttributeMap = {};\n  var styleableShaderAttributes = pointCloud._styleableShaderAttributes;\n\n  for (name in styleableShaderAttributes) {\n    if (styleableShaderAttributes.hasOwnProperty(name)) {\n      attribute = styleableShaderAttributes[name];\n      propertyNameMap[name] = \"czm_3dtiles_property_\" + attribute.location;\n      propertyIdToAttributeMap[attribute.location] = attribute;\n    }\n  }\n\n  if (hasStyle) {\n    var shaderState = {\n      translucent: false\n    };\n    colorStyleFunction = style.getColorShaderFunction(\"getColorFromStyle\", propertyNameMap, shaderState);\n    showStyleFunction = style.getShowShaderFunction(\"getShowFromStyle\", propertyNameMap, shaderState);\n    pointSizeStyleFunction = style.getPointSizeShaderFunction(\"getPointSizeFromStyle\", propertyNameMap, shaderState);\n\n    if (defined(colorStyleFunction) && shaderState.translucent) {\n      styleTranslucent = true;\n    }\n  }\n\n  pointCloud._styleTranslucent = styleTranslucent;\n  var hasColorStyle = defined(colorStyleFunction);\n  var hasShowStyle = defined(showStyleFunction);\n  var hasPointSizeStyle = defined(pointSizeStyleFunction);\n  var hasClippedContent = pointCloud.isClipped; // Get the properties in use by the style\n\n  var styleablePropertyIds = [];\n  var builtinPropertyNames = [];\n\n  if (hasColorStyle) {\n    getStyleablePropertyIds(colorStyleFunction, styleablePropertyIds);\n    getBuiltinPropertyNames(colorStyleFunction, builtinPropertyNames);\n    colorStyleFunction = modifyStyleFunction(colorStyleFunction);\n  }\n\n  if (hasShowStyle) {\n    getStyleablePropertyIds(showStyleFunction, styleablePropertyIds);\n    getBuiltinPropertyNames(showStyleFunction, builtinPropertyNames);\n    showStyleFunction = modifyStyleFunction(showStyleFunction);\n  }\n\n  if (hasPointSizeStyle) {\n    getStyleablePropertyIds(pointSizeStyleFunction, styleablePropertyIds);\n    getBuiltinPropertyNames(pointSizeStyleFunction, builtinPropertyNames);\n    pointSizeStyleFunction = modifyStyleFunction(pointSizeStyleFunction);\n  }\n\n  var usesColorSemantic = builtinPropertyNames.indexOf(\"COLOR\") >= 0;\n  var usesNormalSemantic = builtinPropertyNames.indexOf(\"NORMAL\") >= 0;\n\n  if (usesNormalSemantic && !hasNormals) {\n    throw new RuntimeError(\"Style references the NORMAL semantic but the point cloud does not have normals\");\n  } // Disable vertex attributes that aren't used in the style, enable attributes that are\n\n\n  for (name in styleableShaderAttributes) {\n    if (styleableShaderAttributes.hasOwnProperty(name)) {\n      attribute = styleableShaderAttributes[name];\n      var enabled = styleablePropertyIds.indexOf(attribute.location) >= 0;\n      var vertexAttribute = getVertexAttribute(vertexArray, attribute.location);\n      vertexAttribute.enabled = enabled;\n    }\n  }\n\n  var usesColors = hasColors && (!hasColorStyle || usesColorSemantic);\n\n  if (hasColors) {\n    // Disable the color vertex attribute if the color style does not reference the color semantic\n    var colorVertexAttribute = getVertexAttribute(vertexArray, colorLocation);\n    colorVertexAttribute.enabled = usesColors;\n  }\n\n  var usesNormals = hasNormals && (normalShading || backFaceCulling || usesNormalSemantic);\n\n  if (hasNormals) {\n    // Disable the normal vertex attribute if normals are not used\n    var normalVertexAttribute = getVertexAttribute(vertexArray, normalLocation);\n    normalVertexAttribute.enabled = usesNormals;\n  }\n\n  var attributeLocations = {\n    a_position: positionLocation\n  };\n\n  if (usesColors) {\n    attributeLocations.a_color = colorLocation;\n  }\n\n  if (usesNormals) {\n    attributeLocations.a_normal = normalLocation;\n  }\n\n  if (hasBatchIds) {\n    attributeLocations.a_batchId = batchIdLocation;\n  }\n\n  var attributeDeclarations = \"\";\n  var length = styleablePropertyIds.length;\n\n  for (i = 0; i < length; ++i) {\n    var propertyId = styleablePropertyIds[i];\n    attribute = propertyIdToAttributeMap[propertyId];\n    var componentCount = attribute.componentCount;\n    var attributeName = \"czm_3dtiles_property_\" + propertyId;\n    var attributeType;\n\n    if (componentCount === 1) {\n      attributeType = \"float\";\n    } else {\n      attributeType = \"vec\" + componentCount;\n    }\n\n    attributeDeclarations += \"attribute \" + attributeType + \" \" + attributeName + \"; \\n\";\n    attributeLocations[attributeName] = attribute.location;\n  }\n\n  createUniformMap(pointCloud, frameState);\n  var vs = \"attribute vec3 a_position; \\n\" + \"varying vec4 v_color; \\n\" + \"uniform vec4 u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier; \\n\" + \"uniform vec4 u_constantColor; \\n\" + \"uniform vec4 u_highlightColor; \\n\";\n  vs += \"float u_pointSize; \\n\" + \"float u_time; \\n\";\n\n  if (attenuation) {\n    vs += \"float u_geometricError; \\n\" + \"float u_depthMultiplier; \\n\";\n  }\n\n  vs += attributeDeclarations;\n\n  if (usesColors) {\n    if (isTranslucent) {\n      vs += \"attribute vec4 a_color; \\n\";\n    } else if (isRGB565) {\n      vs += \"attribute float a_color; \\n\" + \"const float SHIFT_RIGHT_11 = 1.0 / 2048.0; \\n\" + \"const float SHIFT_RIGHT_5 = 1.0 / 32.0; \\n\" + \"const float SHIFT_LEFT_11 = 2048.0; \\n\" + \"const float SHIFT_LEFT_5 = 32.0; \\n\" + \"const float NORMALIZE_6 = 1.0 / 64.0; \\n\" + \"const float NORMALIZE_5 = 1.0 / 32.0; \\n\";\n    } else {\n      vs += \"attribute vec3 a_color; \\n\";\n    }\n  }\n\n  if (usesNormals) {\n    if (isOctEncoded16P || isOctEncodedDraco) {\n      vs += \"attribute vec2 a_normal; \\n\";\n    } else {\n      vs += \"attribute vec3 a_normal; \\n\";\n    }\n  }\n\n  if (hasBatchIds) {\n    vs += \"attribute float a_batchId; \\n\";\n  }\n\n  if (isQuantized || isQuantizedDraco || isOctEncodedDraco) {\n    vs += \"uniform vec4 u_quantizedVolumeScaleAndOctEncodedRange; \\n\";\n  }\n\n  if (hasColorStyle) {\n    vs += colorStyleFunction;\n  }\n\n  if (hasShowStyle) {\n    vs += showStyleFunction;\n  }\n\n  if (hasPointSizeStyle) {\n    vs += pointSizeStyleFunction;\n  }\n\n  vs += \"void main() \\n\" + \"{ \\n\" + \"    u_pointSize = u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier.x; \\n\" + \"    u_time = u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier.y; \\n\";\n\n  if (attenuation) {\n    vs += \"    u_geometricError = u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier.z; \\n\" + \"    u_depthMultiplier = u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier.w; \\n\";\n  }\n\n  if (usesColors) {\n    if (isTranslucent) {\n      vs += \"    vec4 color = a_color; \\n\";\n    } else if (isRGB565) {\n      vs += \"    float compressed = a_color; \\n\" + \"    float r = floor(compressed * SHIFT_RIGHT_11); \\n\" + \"    compressed -= r * SHIFT_LEFT_11; \\n\" + \"    float g = floor(compressed * SHIFT_RIGHT_5); \\n\" + \"    compressed -= g * SHIFT_LEFT_5; \\n\" + \"    float b = compressed; \\n\" + \"    vec3 rgb = vec3(r * NORMALIZE_5, g * NORMALIZE_6, b * NORMALIZE_5); \\n\" + \"    vec4 color = vec4(rgb, 1.0); \\n\";\n    } else {\n      vs += \"    vec4 color = vec4(a_color, 1.0); \\n\";\n    }\n  } else {\n    vs += \"    vec4 color = u_constantColor; \\n\";\n  }\n\n  if (isQuantized || isQuantizedDraco) {\n    vs += \"    vec3 position = a_position * u_quantizedVolumeScaleAndOctEncodedRange.xyz; \\n\";\n  } else {\n    vs += \"    vec3 position = a_position; \\n\";\n  }\n\n  vs += \"    vec3 position_absolute = vec3(czm_model * vec4(position, 1.0)); \\n\";\n\n  if (usesNormals) {\n    if (isOctEncoded16P) {\n      vs += \"    vec3 normal = czm_octDecode(a_normal); \\n\";\n    } else if (isOctEncodedDraco) {\n      // Draco oct-encoding decodes to zxy order\n      vs += \"    vec3 normal = czm_octDecode(a_normal, u_quantizedVolumeScaleAndOctEncodedRange.w).zxy; \\n\";\n    } else {\n      vs += \"    vec3 normal = a_normal; \\n\";\n    }\n\n    vs += \"    vec3 normalEC = czm_normal * normal; \\n\";\n  } else {\n    vs += \"    vec3 normal = vec3(1.0); \\n\";\n  }\n\n  if (hasColorStyle) {\n    vs += \"    color = getColorFromStyle(position, position_absolute, color, normal); \\n\";\n  }\n\n  if (hasShowStyle) {\n    vs += \"    float show = float(getShowFromStyle(position, position_absolute, color, normal)); \\n\";\n  }\n\n  if (hasPointSizeStyle) {\n    vs += \"    gl_PointSize = getPointSizeFromStyle(position, position_absolute, color, normal) * czm_pixelRatio; \\n\";\n  } else if (attenuation) {\n    vs += \"    vec4 positionEC = czm_modelView * vec4(position, 1.0); \\n\" + \"    float depth = -positionEC.z; \\n\" + // compute SSE for this point\n    \"    gl_PointSize = min((u_geometricError / depth) * u_depthMultiplier, u_pointSize); \\n\";\n  } else {\n    vs += \"    gl_PointSize = u_pointSize; \\n\";\n  }\n\n  vs += \"    color = color * u_highlightColor; \\n\";\n\n  if (usesNormals && normalShading) {\n    vs += \"    float diffuseStrength = czm_getLambertDiffuse(czm_lightDirectionEC, normalEC); \\n\" + \"    diffuseStrength = max(diffuseStrength, 0.4); \\n\" + // Apply some ambient lighting\n    \"    color.xyz *= diffuseStrength * czm_lightColor; \\n\";\n  }\n\n  vs += \"    v_color = color; \\n\" + \"    gl_Position = czm_modelViewProjection * vec4(position, 1.0); \\n\";\n\n  if (usesNormals && backFaceCulling) {\n    vs += \"    float visible = step(-normalEC.z, 0.0); \\n\" + \"    gl_Position *= visible; \\n\" + \"    gl_PointSize *= visible; \\n\";\n  }\n\n  if (hasShowStyle) {\n    vs += \"    gl_Position.w *= float(show); \\n\" + \"    gl_PointSize *= float(show); \\n\";\n  }\n\n  vs += \"} \\n\";\n  var fs = \"varying vec4 v_color; \\n\";\n\n  if (hasClippedContent) {\n    fs += \"uniform highp sampler2D u_clippingPlanes; \\n\" + \"uniform mat4 u_clippingPlanesMatrix; \\n\" + \"uniform vec4 u_clippingPlanesEdgeStyle; \\n\";\n    fs += \"\\n\";\n    fs += getClippingFunction(clippingPlanes, context);\n    fs += \"\\n\";\n  }\n\n  fs += \"void main() \\n\" + \"{ \\n\" + \"    gl_FragColor = czm_gammaCorrect(v_color); \\n\";\n\n  if (hasClippedContent) {\n    fs += getClipAndStyleCode(\"u_clippingPlanes\", \"u_clippingPlanesMatrix\", \"u_clippingPlanesEdgeStyle\");\n  }\n\n  fs += \"} \\n\";\n\n  if (defined(pointCloud._vertexShaderLoaded)) {\n    vs = pointCloud._vertexShaderLoaded(vs);\n  }\n\n  if (defined(pointCloud._fragmentShaderLoaded)) {\n    fs = pointCloud._fragmentShaderLoaded(fs);\n  }\n\n  var drawCommand = pointCloud._drawCommand;\n\n  if (defined(drawCommand.shaderProgram)) {\n    // Destroy the old shader\n    drawCommand.shaderProgram.destroy();\n  }\n\n  drawCommand.shaderProgram = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations\n  });\n\n  try {\n    // Check if the shader compiles correctly. If not there is likely a syntax error with the style.\n    drawCommand.shaderProgram._bind();\n  } catch (error) {\n    // Rephrase the error.\n    throw new RuntimeError(\"Error generating style shader: this may be caused by a type mismatch, index out-of-bounds, or other syntax error.\");\n  }\n}\n\nfunction decodeDraco(pointCloud, context) {\n  if (pointCloud._decodingState === DecodingState.READY) {\n    return false;\n  }\n\n  if (pointCloud._decodingState === DecodingState.NEEDS_DECODE) {\n    var parsedContent = pointCloud._parsedContent;\n    var draco = parsedContent.draco;\n    var decodePromise = DracoLoader.decodePointCloud(draco, context);\n\n    if (defined(decodePromise)) {\n      pointCloud._decodingState = DecodingState.DECODING;\n      decodePromise.then(function (result) {\n        pointCloud._decodingState = DecodingState.READY;\n        var decodedPositions = defined(result.POSITION) ? result.POSITION.array : undefined;\n        var decodedRgb = defined(result.RGB) ? result.RGB.array : undefined;\n        var decodedRgba = defined(result.RGBA) ? result.RGBA.array : undefined;\n        var decodedNormals = defined(result.NORMAL) ? result.NORMAL.array : undefined;\n        var decodedBatchIds = defined(result.BATCH_ID) ? result.BATCH_ID.array : undefined;\n        var isQuantizedDraco = defined(decodedPositions) && defined(result.POSITION.data.quantization);\n        var isOctEncodedDraco = defined(decodedNormals) && defined(result.NORMAL.data.quantization);\n\n        if (isQuantizedDraco) {\n          // Draco quantization range == quantized volume scale - size in meters of the quantized volume\n          // Internal quantized range is the range of values of the quantized data, e.g. 255 for 8-bit, 1023 for 10-bit, etc\n          var quantization = result.POSITION.data.quantization;\n          var range = quantization.range;\n          pointCloud._quantizedVolumeScale = Cartesian3.fromElements(range, range, range);\n          pointCloud._quantizedVolumeOffset = Cartesian3.unpack(quantization.minValues);\n          pointCloud._quantizedRange = (1 << quantization.quantizationBits) - 1.0;\n          pointCloud._isQuantizedDraco = true;\n        }\n\n        if (isOctEncodedDraco) {\n          pointCloud._octEncodedRange = (1 << result.NORMAL.data.quantization.quantizationBits) - 1.0;\n          pointCloud._isOctEncodedDraco = true;\n        }\n\n        var styleableProperties = parsedContent.styleableProperties;\n        var batchTableProperties = draco.batchTableProperties;\n\n        for (var name in batchTableProperties) {\n          if (batchTableProperties.hasOwnProperty(name)) {\n            var property = result[name];\n\n            if (!defined(styleableProperties)) {\n              styleableProperties = {};\n            }\n\n            styleableProperties[name] = {\n              typedArray: property.array,\n              componentCount: property.data.componentsPerAttribute\n            };\n          }\n        }\n\n        parsedContent.positions = defaultValue(decodedPositions, parsedContent.positions);\n        parsedContent.colors = defaultValue(defaultValue(decodedRgba, decodedRgb), parsedContent.colors);\n        parsedContent.normals = defaultValue(decodedNormals, parsedContent.normals);\n        parsedContent.batchIds = defaultValue(decodedBatchIds, parsedContent.batchIds);\n        parsedContent.styleableProperties = styleableProperties;\n      }).otherwise(function (error) {\n        pointCloud._decodingState = DecodingState.FAILED;\n\n        pointCloud._readyPromise.reject(error);\n      });\n    }\n  }\n\n  return true;\n}\n\nvar scratchComputedTranslation = new Cartesian4();\nvar scratchScale = new Cartesian3();\n\nPointCloud.prototype.update = function (frameState) {\n  var context = frameState.context;\n  var decoding = decodeDraco(this, context);\n\n  if (decoding) {\n    return;\n  }\n\n  var shadersDirty = false;\n  var modelMatrixDirty = !Matrix4.equals(this._modelMatrix, this.modelMatrix);\n\n  if (this._mode !== frameState.mode) {\n    this._mode = frameState.mode;\n    modelMatrixDirty = true;\n  }\n\n  if (!defined(this._drawCommand)) {\n    createResources(this, frameState);\n    modelMatrixDirty = true;\n    shadersDirty = true;\n    this._ready = true;\n\n    this._readyPromise.resolve(this);\n\n    this._parsedContent = undefined; // Unload\n  }\n\n  if (modelMatrixDirty) {\n    Matrix4.clone(this.modelMatrix, this._modelMatrix);\n    var modelMatrix = this._drawCommand.modelMatrix;\n    Matrix4.clone(this._modelMatrix, modelMatrix);\n\n    if (defined(this._rtcCenter)) {\n      Matrix4.multiplyByTranslation(modelMatrix, this._rtcCenter, modelMatrix);\n    }\n\n    if (defined(this._quantizedVolumeOffset)) {\n      Matrix4.multiplyByTranslation(modelMatrix, this._quantizedVolumeOffset, modelMatrix);\n    }\n\n    if (frameState.mode !== SceneMode.SCENE3D) {\n      var projection = frameState.mapProjection;\n      var translation = Matrix4.getColumn(modelMatrix, 3, scratchComputedTranslation);\n\n      if (!Cartesian4.equals(translation, Cartesian4.UNIT_W)) {\n        Transforms.basisTo2D(projection, modelMatrix, modelMatrix);\n      }\n    }\n\n    var boundingSphere = this._drawCommand.boundingVolume;\n    BoundingSphere.clone(this._boundingSphere, boundingSphere);\n\n    if (this._cull) {\n      var center = boundingSphere.center;\n      Matrix4.multiplyByPoint(modelMatrix, center, center);\n      var scale = Matrix4.getScale(modelMatrix, scratchScale);\n      boundingSphere.radius *= Cartesian3.maximumComponent(scale);\n    }\n  }\n\n  if (this.clippingPlanesDirty) {\n    this.clippingPlanesDirty = false;\n    shadersDirty = true;\n  }\n\n  if (this._attenuation !== this.attenuation) {\n    this._attenuation = this.attenuation;\n    shadersDirty = true;\n  }\n\n  if (this.backFaceCulling !== this._backFaceCulling) {\n    this._backFaceCulling = this.backFaceCulling;\n    shadersDirty = true;\n  }\n\n  if (this.normalShading !== this._normalShading) {\n    this._normalShading = this.normalShading;\n    shadersDirty = true;\n  }\n\n  if (this._style !== this.style || this.styleDirty) {\n    this._style = this.style;\n    this.styleDirty = false;\n    shadersDirty = true;\n  }\n\n  if (shadersDirty) {\n    createShaders(this, frameState, this._style);\n  }\n\n  this._drawCommand.castShadows = ShadowMode.castShadows(this.shadows);\n  this._drawCommand.receiveShadows = ShadowMode.receiveShadows(this.shadows); // Update the render state\n\n  var isTranslucent = this._highlightColor.alpha < 1.0 || this._constantColor.alpha < 1.0 || this._styleTranslucent;\n  this._drawCommand.renderState = isTranslucent ? this._translucentRenderState : this._opaqueRenderState;\n  this._drawCommand.pass = isTranslucent ? Pass.TRANSLUCENT : this._opaquePass;\n  var commandList = frameState.commandList;\n  var passes = frameState.passes;\n\n  if (passes.render || passes.pick) {\n    commandList.push(this._drawCommand);\n  }\n};\n\nPointCloud.prototype.isDestroyed = function () {\n  return false;\n};\n\nPointCloud.prototype.destroy = function () {\n  var command = this._drawCommand;\n\n  if (defined(command)) {\n    command.vertexArray = command.vertexArray && command.vertexArray.destroy();\n    command.shaderProgram = command.shaderProgram && command.shaderProgram.destroy();\n  }\n\n  return destroyObject(this);\n};\n\nexport default PointCloud;","map":{"version":3,"sources":["/home/usuario/davi/thalamus/wms/3dmaptestes/leaflet_cesium/client/node_modules/cesium/Source/Scene/PointCloud.js"],"names":["arraySlice","BoundingSphere","Cartesian3","Cartesian4","Check","clone","Color","combine","ComponentDatatype","defaultValue","defined","destroyObject","getJsonFromTypedArray","CesiumMath","Matrix4","oneTimeWarning","OrthographicFrustum","PrimitiveType","RuntimeError","Transforms","Buffer","BufferUsage","DrawCommand","Pass","RenderState","ShaderProgram","VertexArray","when","BlendingState","Cesium3DTileBatchTable","Cesium3DTileFeatureTable","DracoLoader","getClipAndStyleCode","getClippingFunction","SceneMode","ShadowMode","StencilConstants","DecodingState","NEEDS_DECODE","DECODING","READY","FAILED","PointCloud","options","typeOf","object","arrayBuffer","_parsedContent","undefined","_drawCommand","_isTranslucent","_styleTranslucent","_constantColor","DARKGRAY","_highlightColor","WHITE","_pointSize","_rtcCenter","_quantizedVolumeScale","_quantizedVolumeOffset","_styleableShaderAttributes","_isQuantized","_isOctEncoded16P","_isRGB565","_hasColors","_hasNormals","_hasBatchIds","_decodingState","_dequantizeInShader","_isQuantizedDraco","_isOctEncodedDraco","_quantizedRange","_octEncodedRange","backFaceCulling","_backFaceCulling","normalShading","_normalShading","_opaqueRenderState","_translucentRenderState","_mode","_ready","_readyPromise","defer","_pointsLength","_geometryByteLength","_vertexShaderLoaded","vertexShaderLoaded","_fragmentShaderLoaded","fragmentShaderLoaded","_uniformMapLoaded","uniformMapLoaded","_batchTableLoaded","batchTableLoaded","_pickIdLoaded","pickIdLoaded","_opaquePass","opaquePass","OPAQUE","_cull","cull","style","_style","styleDirty","modelMatrix","IDENTITY","_modelMatrix","time","shadows","ENABLED","_boundingSphere","clippingPlanes","isClipped","clippingPlanesDirty","clippingPlanesOriginMatrix","attenuation","_attenuation","geometricError","geometricErrorScale","maximumAttenuation","initialize","Object","defineProperties","prototype","pointsLength","get","geometryByteLength","ready","readyPromise","promise","color","set","value","boundingSphere","boundingVolume","sizeOfUint32","Uint32Array","BYTES_PER_ELEMENT","pointCloud","byteOffset","uint8Array","Uint8Array","view","DataView","version","getUint32","featureTableJsonByteLength","featureTableBinaryByteLength","batchTableJsonByteLength","batchTableBinaryByteLength","featureTableJson","featureTableBinary","batchTableJson","batchTableBinary","featureTable","getGlobalProperty","featuresLength","rtcCenter","FLOAT","unpack","positions","colors","normals","batchIds","hasPositions","hasColors","hasNormals","hasBatchIds","isQuantized","isTranslucent","isRGB565","isOctEncoded16P","dracoBuffer","dracoFeatureTableProperties","dracoBatchTableProperties","featureTableDraco","extensions","batchTableDraco","properties","dracoByteOffset","dracoByteLength","byteLength","POSITION","RGB","RGBA","NORMAL","BATCH_ID","draco","buffer","featureTableProperties","batchTableProperties","dequantizeInShader","getPropertyArray","POSITION_QUANTIZED","UNSIGNED_SHORT","quantizedVolumeScale","quantizedVolumeOffset","UNSIGNED_BYTE","RGB565","NORMAL_OCT16P","CONSTANT_RGBA","constantRGBA","fromBytes","batchLength","styleableProperties","getBinaryProperties","scratchMin","scratchMax","scratchPosition","randomValues","getRandomValues","samplesLength","setRandomNumberSeed","Array","i","nextRandomNumber","computeApproximateBoundingSphereFromPositions","maximumSamplesLength","length","Math","min","maxValue","Number","MAX_VALUE","minValue","fromElements","max","index","floor","position","minimumByComponent","maximumByComponent","fromCornerPoints","radius","EPSILON2","prepareVertexAttribute","typedArray","name","componentDatatype","fromTypedArray","INT","UNSIGNED_INT","DOUBLE","Float32Array","scratchPointSizeAndTimeAndGeometricErrorAndDepthMultiplier","scratchQuantizedVolumeScaleAndOctEncodedRange","scratchColor","positionLocation","colorLocation","normalLocation","batchIdLocation","numberOfAttributes","scratchClippingPlanesMatrix","scratchInverseTransposeClippingPlanesMatrix","createResources","frameState","context","parsedContent","hasStyleableProperties","isQuantizedDraco","isOctEncodedDraco","quantizedRange","octEncodedRange","componentsPerAttribute","styleableVertexAttributes","styleableShaderAttributes","attributeLocation","hasOwnProperty","property","componentCount","vertexBuffer","createVertexBuffer","usage","STATIC_DRAW","sizeInBytes","vertexAttribute","normalize","offsetInBytes","strideInBytes","push","location","positionsVertexBuffer","colorsVertexBuffer","normalsVertexBuffer","batchIdsVertexBuffer","attributes","ZERO","colorComponentsPerAttribute","concat","vertexArray","opaqueRenderState","depthTest","enabled","CESIUM_3D_TILE","stencilTest","setCesium3DTileBit","stencilMask","CESIUM_3D_TILE_MASK","fromCache","depthMask","blending","ALPHA_BLEND","primitiveType","POINTS","count","shaderProgram","uniformMap","renderState","pass","TRANSLUCENT","owner","castShadows","receiveShadows","pickId","createUniformMap","u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier","scratch","x","pixelRatio","y","frustum","camera","depthMultiplier","mode","SCENE2D","POSITIVE_INFINITY","drawingBufferHeight","sseDenominator","z","w","u_highlightColor","u_constantColor","u_clippingPlanes","texture","defaultTexture","u_clippingPlanesEdgeStyle","TRANSPARENT","edgeColor","alpha","edgeWidth","u_clippingPlanesMatrix","multiply","uniformState","view3D","transform","inverseTranspose","u_quantizedVolumeScaleAndOctEncodedRange","scale","divideByScalar","getStyleablePropertyIds","source","propertyIds","regex","matches","exec","id","parseInt","indexOf","getBuiltinPropertyNames","propertyNames","getVertexAttribute","attribute","getAttribute","builtinPropertyNameMap","POSITION_ABSOLUTE","COLOR","modifyStyleFunction","functionHeader","replace","createShaders","hasStyle","colorStyleFunction","showStyleFunction","pointSizeStyleFunction","styleTranslucent","propertyNameMap","propertyIdToAttributeMap","shaderState","translucent","getColorShaderFunction","getShowShaderFunction","getPointSizeShaderFunction","hasColorStyle","hasShowStyle","hasPointSizeStyle","hasClippedContent","styleablePropertyIds","builtinPropertyNames","usesColorSemantic","usesNormalSemantic","usesColors","colorVertexAttribute","usesNormals","normalVertexAttribute","attributeLocations","a_position","a_color","a_normal","a_batchId","attributeDeclarations","propertyId","attributeName","attributeType","vs","fs","drawCommand","destroy","vertexShaderSource","fragmentShaderSource","_bind","error","decodeDraco","decodePromise","decodePointCloud","then","result","decodedPositions","array","decodedRgb","decodedRgba","decodedNormals","decodedBatchIds","data","quantization","range","minValues","quantizationBits","otherwise","reject","scratchComputedTranslation","scratchScale","update","decoding","shadersDirty","modelMatrixDirty","equals","resolve","multiplyByTranslation","SCENE3D","projection","mapProjection","translation","getColumn","UNIT_W","basisTo2D","center","multiplyByPoint","getScale","maximumComponent","commandList","passes","render","pick","isDestroyed","command"],"mappings":"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","sourcesContent":["import arraySlice from \"../Core/arraySlice.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Check from \"../Core/Check.js\";\nimport clone from \"../Core/clone.js\";\nimport Color from \"../Core/Color.js\";\nimport combine from \"../Core/combine.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport getJsonFromTypedArray from \"../Core/getJsonFromTypedArray.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport oneTimeWarning from \"../Core/oneTimeWarning.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport Buffer from \"../Renderer/Buffer.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport when from \"../ThirdParty/when.js\";\nimport BlendingState from \"./BlendingState.js\";\nimport Cesium3DTileBatchTable from \"./Cesium3DTileBatchTable.js\";\nimport Cesium3DTileFeatureTable from \"./Cesium3DTileFeatureTable.js\";\nimport DracoLoader from \"./DracoLoader.js\";\nimport getClipAndStyleCode from \"./getClipAndStyleCode.js\";\nimport getClippingFunction from \"./getClippingFunction.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMode from \"./ShadowMode.js\";\nimport StencilConstants from \"./StencilConstants.js\";\n\nvar DecodingState = {\n  NEEDS_DECODE: 0,\n  DECODING: 1,\n  READY: 2,\n  FAILED: 3,\n};\n\n/**\n * Represents the contents of a\n * {@link https://github.com/CesiumGS/3d-tiles/tree/master/specification/TileFormats/PointCloud|Point Cloud}\n * tile. Used internally by {@link PointCloud3DTileContent} and {@link TimeDynamicPointCloud}.\n *\n * @alias PointCloud\n * @constructor\n *\n * @see PointCloud3DTileContent\n * @see TimeDynamicPointCloud\n *\n * @private\n */\nfunction PointCloud(options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"options\", options);\n  Check.typeOf.object(\"options.arrayBuffer\", options.arrayBuffer);\n  //>>includeEnd('debug');\n\n  // Hold onto the payload until the render resources are created\n  this._parsedContent = undefined;\n\n  this._drawCommand = undefined;\n  this._isTranslucent = false;\n  this._styleTranslucent = false;\n  this._constantColor = Color.clone(Color.DARKGRAY);\n  this._highlightColor = Color.clone(Color.WHITE);\n  this._pointSize = 1.0;\n\n  this._rtcCenter = undefined;\n  this._quantizedVolumeScale = undefined;\n  this._quantizedVolumeOffset = undefined;\n\n  // These values are used to regenerate the shader when the style changes\n  this._styleableShaderAttributes = undefined;\n  this._isQuantized = false;\n  this._isOctEncoded16P = false;\n  this._isRGB565 = false;\n  this._hasColors = false;\n  this._hasNormals = false;\n  this._hasBatchIds = false;\n\n  // Draco\n  this._decodingState = DecodingState.READY;\n  this._dequantizeInShader = true;\n  this._isQuantizedDraco = false;\n  this._isOctEncodedDraco = false;\n  this._quantizedRange = 0.0;\n  this._octEncodedRange = 0.0;\n\n  // Use per-point normals to hide back-facing points.\n  this.backFaceCulling = false;\n  this._backFaceCulling = false;\n\n  // Whether to enable normal shading\n  this.normalShading = true;\n  this._normalShading = true;\n\n  this._opaqueRenderState = undefined;\n  this._translucentRenderState = undefined;\n\n  this._mode = undefined;\n\n  this._ready = false;\n  this._readyPromise = when.defer();\n  this._pointsLength = 0;\n  this._geometryByteLength = 0;\n\n  this._vertexShaderLoaded = options.vertexShaderLoaded;\n  this._fragmentShaderLoaded = options.fragmentShaderLoaded;\n  this._uniformMapLoaded = options.uniformMapLoaded;\n  this._batchTableLoaded = options.batchTableLoaded;\n  this._pickIdLoaded = options.pickIdLoaded;\n  this._opaquePass = defaultValue(options.opaquePass, Pass.OPAQUE);\n  this._cull = defaultValue(options.cull, true);\n\n  this.style = undefined;\n  this._style = undefined;\n  this.styleDirty = false;\n\n  this.modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n  this._modelMatrix = Matrix4.clone(Matrix4.IDENTITY);\n\n  this.time = 0.0; // For styling\n  this.shadows = ShadowMode.ENABLED;\n  this._boundingSphere = undefined;\n\n  this.clippingPlanes = undefined;\n  this.isClipped = false;\n  this.clippingPlanesDirty = false;\n  // If defined, use this matrix to position the clipping planes instead of the modelMatrix.\n  // This is so that when point clouds are part of a tileset they all get clipped relative\n  // to the root tile.\n  this.clippingPlanesOriginMatrix = undefined;\n\n  this.attenuation = false;\n  this._attenuation = false;\n\n  // Options for geometric error based attenuation\n  this.geometricError = 0.0;\n  this.geometricErrorScale = 1.0;\n  this.maximumAttenuation = this._pointSize;\n\n  initialize(this, options);\n}\n\nObject.defineProperties(PointCloud.prototype, {\n  pointsLength: {\n    get: function () {\n      return this._pointsLength;\n    },\n  },\n\n  geometryByteLength: {\n    get: function () {\n      return this._geometryByteLength;\n    },\n  },\n\n  ready: {\n    get: function () {\n      return this._ready;\n    },\n  },\n\n  readyPromise: {\n    get: function () {\n      return this._readyPromise.promise;\n    },\n  },\n\n  color: {\n    get: function () {\n      return Color.clone(this._highlightColor);\n    },\n    set: function (value) {\n      this._highlightColor = Color.clone(value, this._highlightColor);\n    },\n  },\n\n  boundingSphere: {\n    get: function () {\n      if (defined(this._drawCommand)) {\n        return this._drawCommand.boundingVolume;\n      }\n      return undefined;\n    },\n    set: function (value) {\n      this._boundingSphere = BoundingSphere.clone(value, this._boundingSphere);\n    },\n  },\n});\n\nvar sizeOfUint32 = Uint32Array.BYTES_PER_ELEMENT;\n\nfunction initialize(pointCloud, options) {\n  var arrayBuffer = options.arrayBuffer;\n  var byteOffset = defaultValue(options.byteOffset, 0);\n\n  var uint8Array = new Uint8Array(arrayBuffer);\n  var view = new DataView(arrayBuffer);\n  byteOffset += sizeOfUint32; // Skip magic\n\n  var version = view.getUint32(byteOffset, true);\n  if (version !== 1) {\n    throw new RuntimeError(\n      \"Only Point Cloud tile version 1 is supported.  Version \" +\n        version +\n        \" is not.\"\n    );\n  }\n  byteOffset += sizeOfUint32;\n\n  // Skip byteLength\n  byteOffset += sizeOfUint32;\n\n  var featureTableJsonByteLength = view.getUint32(byteOffset, true);\n  if (featureTableJsonByteLength === 0) {\n    throw new RuntimeError(\n      \"Feature table must have a byte length greater than zero\"\n    );\n  }\n  byteOffset += sizeOfUint32;\n\n  var featureTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  var batchTableJsonByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n  var batchTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += sizeOfUint32;\n\n  var featureTableJson = getJsonFromTypedArray(\n    uint8Array,\n    byteOffset,\n    featureTableJsonByteLength\n  );\n  byteOffset += featureTableJsonByteLength;\n\n  var featureTableBinary = new Uint8Array(\n    arrayBuffer,\n    byteOffset,\n    featureTableBinaryByteLength\n  );\n  byteOffset += featureTableBinaryByteLength;\n\n  // Get the batch table JSON and binary\n  var batchTableJson;\n  var batchTableBinary;\n  if (batchTableJsonByteLength > 0) {\n    // Has a batch table JSON\n    batchTableJson = getJsonFromTypedArray(\n      uint8Array,\n      byteOffset,\n      batchTableJsonByteLength\n    );\n    byteOffset += batchTableJsonByteLength;\n\n    if (batchTableBinaryByteLength > 0) {\n      // Has a batch table binary\n      batchTableBinary = new Uint8Array(\n        arrayBuffer,\n        byteOffset,\n        batchTableBinaryByteLength\n      );\n      byteOffset += batchTableBinaryByteLength;\n    }\n  }\n\n  var featureTable = new Cesium3DTileFeatureTable(\n    featureTableJson,\n    featureTableBinary\n  );\n\n  var pointsLength = featureTable.getGlobalProperty(\"POINTS_LENGTH\");\n  featureTable.featuresLength = pointsLength;\n\n  if (!defined(pointsLength)) {\n    throw new RuntimeError(\n      \"Feature table global property: POINTS_LENGTH must be defined\"\n    );\n  }\n\n  var rtcCenter = featureTable.getGlobalProperty(\n    \"RTC_CENTER\",\n    ComponentDatatype.FLOAT,\n    3\n  );\n  if (defined(rtcCenter)) {\n    pointCloud._rtcCenter = Cartesian3.unpack(rtcCenter);\n  }\n\n  var positions;\n  var colors;\n  var normals;\n  var batchIds;\n\n  var hasPositions = false;\n  var hasColors = false;\n  var hasNormals = false;\n  var hasBatchIds = false;\n\n  var isQuantized = false;\n  var isTranslucent = false;\n  var isRGB565 = false;\n  var isOctEncoded16P = false;\n\n  var dracoBuffer;\n  var dracoFeatureTableProperties;\n  var dracoBatchTableProperties;\n\n  var featureTableDraco = defined(featureTableJson.extensions)\n    ? featureTableJson.extensions[\"3DTILES_draco_point_compression\"]\n    : undefined;\n  var batchTableDraco =\n    defined(batchTableJson) && defined(batchTableJson.extensions)\n      ? batchTableJson.extensions[\"3DTILES_draco_point_compression\"]\n      : undefined;\n\n  if (defined(batchTableDraco)) {\n    dracoBatchTableProperties = batchTableDraco.properties;\n  }\n\n  if (defined(featureTableDraco)) {\n    dracoFeatureTableProperties = featureTableDraco.properties;\n    var dracoByteOffset = featureTableDraco.byteOffset;\n    var dracoByteLength = featureTableDraco.byteLength;\n    if (\n      !defined(dracoFeatureTableProperties) ||\n      !defined(dracoByteOffset) ||\n      !defined(dracoByteLength)\n    ) {\n      throw new RuntimeError(\n        \"Draco properties, byteOffset, and byteLength must be defined\"\n      );\n    }\n    dracoBuffer = arraySlice(\n      featureTableBinary,\n      dracoByteOffset,\n      dracoByteOffset + dracoByteLength\n    );\n    hasPositions = defined(dracoFeatureTableProperties.POSITION);\n    hasColors =\n      defined(dracoFeatureTableProperties.RGB) ||\n      defined(dracoFeatureTableProperties.RGBA);\n    hasNormals = defined(dracoFeatureTableProperties.NORMAL);\n    hasBatchIds = defined(dracoFeatureTableProperties.BATCH_ID);\n    isTranslucent = defined(dracoFeatureTableProperties.RGBA);\n    pointCloud._decodingState = DecodingState.NEEDS_DECODE;\n  }\n\n  var draco;\n  if (defined(dracoBuffer)) {\n    draco = {\n      buffer: dracoBuffer,\n      featureTableProperties: dracoFeatureTableProperties,\n      batchTableProperties: dracoBatchTableProperties,\n      properties: combine(\n        dracoFeatureTableProperties,\n        dracoBatchTableProperties\n      ),\n      dequantizeInShader: pointCloud._dequantizeInShader,\n    };\n  }\n\n  if (!hasPositions) {\n    if (defined(featureTableJson.POSITION)) {\n      positions = featureTable.getPropertyArray(\n        \"POSITION\",\n        ComponentDatatype.FLOAT,\n        3\n      );\n      hasPositions = true;\n    } else if (defined(featureTableJson.POSITION_QUANTIZED)) {\n      positions = featureTable.getPropertyArray(\n        \"POSITION_QUANTIZED\",\n        ComponentDatatype.UNSIGNED_SHORT,\n        3\n      );\n      isQuantized = true;\n      hasPositions = true;\n\n      var quantizedVolumeScale = featureTable.getGlobalProperty(\n        \"QUANTIZED_VOLUME_SCALE\",\n        ComponentDatatype.FLOAT,\n        3\n      );\n      if (!defined(quantizedVolumeScale)) {\n        throw new RuntimeError(\n          \"Global property: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.\"\n        );\n      }\n      pointCloud._quantizedVolumeScale = Cartesian3.unpack(\n        quantizedVolumeScale\n      );\n      pointCloud._quantizedRange = (1 << 16) - 1;\n\n      var quantizedVolumeOffset = featureTable.getGlobalProperty(\n        \"QUANTIZED_VOLUME_OFFSET\",\n        ComponentDatatype.FLOAT,\n        3\n      );\n      if (!defined(quantizedVolumeOffset)) {\n        throw new RuntimeError(\n          \"Global property: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.\"\n        );\n      }\n      pointCloud._quantizedVolumeOffset = Cartesian3.unpack(\n        quantizedVolumeOffset\n      );\n    }\n  }\n\n  if (!hasColors) {\n    if (defined(featureTableJson.RGBA)) {\n      colors = featureTable.getPropertyArray(\n        \"RGBA\",\n        ComponentDatatype.UNSIGNED_BYTE,\n        4\n      );\n      isTranslucent = true;\n      hasColors = true;\n    } else if (defined(featureTableJson.RGB)) {\n      colors = featureTable.getPropertyArray(\n        \"RGB\",\n        ComponentDatatype.UNSIGNED_BYTE,\n        3\n      );\n      hasColors = true;\n    } else if (defined(featureTableJson.RGB565)) {\n      colors = featureTable.getPropertyArray(\n        \"RGB565\",\n        ComponentDatatype.UNSIGNED_SHORT,\n        1\n      );\n      isRGB565 = true;\n      hasColors = true;\n    }\n  }\n\n  if (!hasNormals) {\n    if (defined(featureTableJson.NORMAL)) {\n      normals = featureTable.getPropertyArray(\n        \"NORMAL\",\n        ComponentDatatype.FLOAT,\n        3\n      );\n      hasNormals = true;\n    } else if (defined(featureTableJson.NORMAL_OCT16P)) {\n      normals = featureTable.getPropertyArray(\n        \"NORMAL_OCT16P\",\n        ComponentDatatype.UNSIGNED_BYTE,\n        2\n      );\n      isOctEncoded16P = true;\n      hasNormals = true;\n    }\n  }\n\n  if (!hasBatchIds) {\n    if (defined(featureTableJson.BATCH_ID)) {\n      batchIds = featureTable.getPropertyArray(\n        \"BATCH_ID\",\n        ComponentDatatype.UNSIGNED_SHORT,\n        1\n      );\n      hasBatchIds = true;\n    }\n  }\n\n  if (!hasPositions) {\n    throw new RuntimeError(\n      \"Either POSITION or POSITION_QUANTIZED must be defined.\"\n    );\n  }\n\n  if (defined(featureTableJson.CONSTANT_RGBA)) {\n    var constantRGBA = featureTable.getGlobalProperty(\n      \"CONSTANT_RGBA\",\n      ComponentDatatype.UNSIGNED_BYTE,\n      4\n    );\n    pointCloud._constantColor = Color.fromBytes(\n      constantRGBA[0],\n      constantRGBA[1],\n      constantRGBA[2],\n      constantRGBA[3],\n      pointCloud._constantColor\n    );\n  }\n\n  if (hasBatchIds) {\n    var batchLength = featureTable.getGlobalProperty(\"BATCH_LENGTH\");\n    if (!defined(batchLength)) {\n      throw new RuntimeError(\n        \"Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.\"\n      );\n    }\n\n    if (defined(batchTableBinary)) {\n      // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed\n      batchTableBinary = new Uint8Array(batchTableBinary);\n    }\n\n    if (defined(pointCloud._batchTableLoaded)) {\n      pointCloud._batchTableLoaded(\n        batchLength,\n        batchTableJson,\n        batchTableBinary\n      );\n    }\n  }\n\n  // If points are not batched and there are per-point properties, use these properties for styling purposes\n  var styleableProperties;\n  if (!hasBatchIds && defined(batchTableBinary)) {\n    styleableProperties = Cesium3DTileBatchTable.getBinaryProperties(\n      pointsLength,\n      batchTableJson,\n      batchTableBinary\n    );\n  }\n\n  pointCloud._parsedContent = {\n    positions: positions,\n    colors: colors,\n    normals: normals,\n    batchIds: batchIds,\n    styleableProperties: styleableProperties,\n    draco: draco,\n  };\n  pointCloud._pointsLength = pointsLength;\n  pointCloud._isQuantized = isQuantized;\n  pointCloud._isOctEncoded16P = isOctEncoded16P;\n  pointCloud._isRGB565 = isRGB565;\n  pointCloud._isTranslucent = isTranslucent;\n  pointCloud._hasColors = hasColors;\n  pointCloud._hasNormals = hasNormals;\n  pointCloud._hasBatchIds = hasBatchIds;\n}\n\nvar scratchMin = new Cartesian3();\nvar scratchMax = new Cartesian3();\nvar scratchPosition = new Cartesian3();\nvar randomValues;\n\nfunction getRandomValues(samplesLength) {\n  // Use same random values across all runs\n  if (!defined(randomValues)) {\n    CesiumMath.setRandomNumberSeed(0);\n    randomValues = new Array(samplesLength);\n    for (var i = 0; i < samplesLength; ++i) {\n      randomValues[i] = CesiumMath.nextRandomNumber();\n    }\n  }\n  return randomValues;\n}\n\nfunction computeApproximateBoundingSphereFromPositions(positions) {\n  var maximumSamplesLength = 20;\n  var pointsLength = positions.length / 3;\n  var samplesLength = Math.min(pointsLength, maximumSamplesLength);\n  var randomValues = getRandomValues(maximumSamplesLength);\n  var maxValue = Number.MAX_VALUE;\n  var minValue = -Number.MAX_VALUE;\n  var min = Cartesian3.fromElements(maxValue, maxValue, maxValue, scratchMin);\n  var max = Cartesian3.fromElements(minValue, minValue, minValue, scratchMax);\n  for (var i = 0; i < samplesLength; ++i) {\n    var index = Math.floor(randomValues[i] * pointsLength);\n    var position = Cartesian3.unpack(positions, index * 3, scratchPosition);\n    Cartesian3.minimumByComponent(min, position, min);\n    Cartesian3.maximumByComponent(max, position, max);\n  }\n\n  var boundingSphere = BoundingSphere.fromCornerPoints(min, max);\n  boundingSphere.radius += CesiumMath.EPSILON2; // To avoid radius of zero\n  return boundingSphere;\n}\n\nfunction prepareVertexAttribute(typedArray, name) {\n  // WebGL does not support UNSIGNED_INT, INT, or DOUBLE vertex attributes. Convert these to FLOAT.\n  var componentDatatype = ComponentDatatype.fromTypedArray(typedArray);\n  if (\n    componentDatatype === ComponentDatatype.INT ||\n    componentDatatype === ComponentDatatype.UNSIGNED_INT ||\n    componentDatatype === ComponentDatatype.DOUBLE\n  ) {\n    oneTimeWarning(\n      \"Cast pnts property to floats\",\n      'Point cloud property \"' +\n        name +\n        '\" will be casted to a float array because INT, UNSIGNED_INT, and DOUBLE are not valid WebGL vertex attribute types. Some precision may be lost.'\n    );\n    return new Float32Array(typedArray);\n  }\n  return typedArray;\n}\n\nvar scratchPointSizeAndTimeAndGeometricErrorAndDepthMultiplier = new Cartesian4();\nvar scratchQuantizedVolumeScaleAndOctEncodedRange = new Cartesian4();\nvar scratchColor = new Color();\n\nvar positionLocation = 0;\nvar colorLocation = 1;\nvar normalLocation = 2;\nvar batchIdLocation = 3;\nvar numberOfAttributes = 4;\n\nvar scratchClippingPlanesMatrix = new Matrix4();\nvar scratchInverseTransposeClippingPlanesMatrix = new Matrix4();\n\nfunction createResources(pointCloud, frameState) {\n  var context = frameState.context;\n  var parsedContent = pointCloud._parsedContent;\n  var pointsLength = pointCloud._pointsLength;\n  var positions = parsedContent.positions;\n  var colors = parsedContent.colors;\n  var normals = parsedContent.normals;\n  var batchIds = parsedContent.batchIds;\n  var styleableProperties = parsedContent.styleableProperties;\n  var hasStyleableProperties = defined(styleableProperties);\n  var isQuantized = pointCloud._isQuantized;\n  var isQuantizedDraco = pointCloud._isQuantizedDraco;\n  var isOctEncoded16P = pointCloud._isOctEncoded16P;\n  var isOctEncodedDraco = pointCloud._isOctEncodedDraco;\n  var quantizedRange = pointCloud._quantizedRange;\n  var octEncodedRange = pointCloud._octEncodedRange;\n  var isRGB565 = pointCloud._isRGB565;\n  var isTranslucent = pointCloud._isTranslucent;\n  var hasColors = pointCloud._hasColors;\n  var hasNormals = pointCloud._hasNormals;\n  var hasBatchIds = pointCloud._hasBatchIds;\n\n  var componentsPerAttribute;\n  var componentDatatype;\n\n  var styleableVertexAttributes = [];\n  var styleableShaderAttributes = {};\n  pointCloud._styleableShaderAttributes = styleableShaderAttributes;\n\n  if (hasStyleableProperties) {\n    var attributeLocation = numberOfAttributes;\n\n    for (var name in styleableProperties) {\n      if (styleableProperties.hasOwnProperty(name)) {\n        var property = styleableProperties[name];\n        var typedArray = prepareVertexAttribute(property.typedArray, name);\n        componentsPerAttribute = property.componentCount;\n        componentDatatype = ComponentDatatype.fromTypedArray(typedArray);\n\n        var vertexBuffer = Buffer.createVertexBuffer({\n          context: context,\n          typedArray: typedArray,\n          usage: BufferUsage.STATIC_DRAW,\n        });\n\n        pointCloud._geometryByteLength += vertexBuffer.sizeInBytes;\n\n        var vertexAttribute = {\n          index: attributeLocation,\n          vertexBuffer: vertexBuffer,\n          componentsPerAttribute: componentsPerAttribute,\n          componentDatatype: componentDatatype,\n          normalize: false,\n          offsetInBytes: 0,\n          strideInBytes: 0,\n        };\n\n        styleableVertexAttributes.push(vertexAttribute);\n        styleableShaderAttributes[name] = {\n          location: attributeLocation,\n          componentCount: componentsPerAttribute,\n        };\n        ++attributeLocation;\n      }\n    }\n  }\n\n  var positionsVertexBuffer = Buffer.createVertexBuffer({\n    context: context,\n    typedArray: positions,\n    usage: BufferUsage.STATIC_DRAW,\n  });\n  pointCloud._geometryByteLength += positionsVertexBuffer.sizeInBytes;\n\n  var colorsVertexBuffer;\n  if (hasColors) {\n    colorsVertexBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: colors,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    pointCloud._geometryByteLength += colorsVertexBuffer.sizeInBytes;\n  }\n\n  var normalsVertexBuffer;\n  if (hasNormals) {\n    normalsVertexBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: normals,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    pointCloud._geometryByteLength += normalsVertexBuffer.sizeInBytes;\n  }\n\n  var batchIdsVertexBuffer;\n  if (hasBatchIds) {\n    batchIds = prepareVertexAttribute(batchIds, \"batchIds\");\n    batchIdsVertexBuffer = Buffer.createVertexBuffer({\n      context: context,\n      typedArray: batchIds,\n      usage: BufferUsage.STATIC_DRAW,\n    });\n    pointCloud._geometryByteLength += batchIdsVertexBuffer.sizeInBytes;\n  }\n\n  var attributes = [];\n\n  if (isQuantized) {\n    componentDatatype = ComponentDatatype.UNSIGNED_SHORT;\n  } else if (isQuantizedDraco) {\n    componentDatatype =\n      quantizedRange <= 255\n        ? ComponentDatatype.UNSIGNED_BYTE\n        : ComponentDatatype.UNSIGNED_SHORT;\n  } else {\n    componentDatatype = ComponentDatatype.FLOAT;\n  }\n\n  attributes.push({\n    index: positionLocation,\n    vertexBuffer: positionsVertexBuffer,\n    componentsPerAttribute: 3,\n    componentDatatype: componentDatatype,\n    normalize: false,\n    offsetInBytes: 0,\n    strideInBytes: 0,\n  });\n\n  if (pointCloud._cull) {\n    if (isQuantized || isQuantizedDraco) {\n      pointCloud._boundingSphere = BoundingSphere.fromCornerPoints(\n        Cartesian3.ZERO,\n        pointCloud._quantizedVolumeScale\n      );\n    } else {\n      pointCloud._boundingSphere = computeApproximateBoundingSphereFromPositions(\n        positions\n      );\n    }\n  }\n\n  if (hasColors) {\n    if (isRGB565) {\n      attributes.push({\n        index: colorLocation,\n        vertexBuffer: colorsVertexBuffer,\n        componentsPerAttribute: 1,\n        componentDatatype: ComponentDatatype.UNSIGNED_SHORT,\n        normalize: false,\n        offsetInBytes: 0,\n        strideInBytes: 0,\n      });\n    } else {\n      var colorComponentsPerAttribute = isTranslucent ? 4 : 3;\n      attributes.push({\n        index: colorLocation,\n        vertexBuffer: colorsVertexBuffer,\n        componentsPerAttribute: colorComponentsPerAttribute,\n        componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\n        normalize: true,\n        offsetInBytes: 0,\n        strideInBytes: 0,\n      });\n    }\n  }\n\n  if (hasNormals) {\n    if (isOctEncoded16P) {\n      componentsPerAttribute = 2;\n      componentDatatype = ComponentDatatype.UNSIGNED_BYTE;\n    } else if (isOctEncodedDraco) {\n      componentsPerAttribute = 2;\n      componentDatatype =\n        octEncodedRange <= 255\n          ? ComponentDatatype.UNSIGNED_BYTE\n          : ComponentDatatype.UNSIGNED_SHORT;\n    } else {\n      componentsPerAttribute = 3;\n      componentDatatype = ComponentDatatype.FLOAT;\n    }\n    attributes.push({\n      index: normalLocation,\n      vertexBuffer: normalsVertexBuffer,\n      componentsPerAttribute: componentsPerAttribute,\n      componentDatatype: componentDatatype,\n      normalize: false,\n      offsetInBytes: 0,\n      strideInBytes: 0,\n    });\n  }\n\n  if (hasBatchIds) {\n    attributes.push({\n      index: batchIdLocation,\n      vertexBuffer: batchIdsVertexBuffer,\n      componentsPerAttribute: 1,\n      componentDatatype: ComponentDatatype.fromTypedArray(batchIds),\n      normalize: false,\n      offsetInBytes: 0,\n      strideInBytes: 0,\n    });\n  }\n\n  if (hasStyleableProperties) {\n    attributes = attributes.concat(styleableVertexAttributes);\n  }\n\n  var vertexArray = new VertexArray({\n    context: context,\n    attributes: attributes,\n  });\n\n  var opaqueRenderState = {\n    depthTest: {\n      enabled: true,\n    },\n  };\n\n  if (pointCloud._opaquePass === Pass.CESIUM_3D_TILE) {\n    opaqueRenderState.stencilTest = StencilConstants.setCesium3DTileBit();\n    opaqueRenderState.stencilMask = StencilConstants.CESIUM_3D_TILE_MASK;\n  }\n\n  pointCloud._opaqueRenderState = RenderState.fromCache(opaqueRenderState);\n\n  pointCloud._translucentRenderState = RenderState.fromCache({\n    depthTest: {\n      enabled: true,\n    },\n    depthMask: false,\n    blending: BlendingState.ALPHA_BLEND,\n  });\n\n  pointCloud._drawCommand = new DrawCommand({\n    boundingVolume: new BoundingSphere(),\n    cull: pointCloud._cull,\n    modelMatrix: new Matrix4(),\n    primitiveType: PrimitiveType.POINTS,\n    vertexArray: vertexArray,\n    count: pointsLength,\n    shaderProgram: undefined, // Updated in createShaders\n    uniformMap: undefined, // Updated in createShaders\n    renderState: isTranslucent\n      ? pointCloud._translucentRenderState\n      : pointCloud._opaqueRenderState,\n    pass: isTranslucent ? Pass.TRANSLUCENT : pointCloud._opaquePass,\n    owner: pointCloud,\n    castShadows: false,\n    receiveShadows: false,\n    pickId: pointCloud._pickIdLoaded(),\n  });\n}\n\nfunction createUniformMap(pointCloud, frameState) {\n  var context = frameState.context;\n  var isQuantized = pointCloud._isQuantized;\n  var isQuantizedDraco = pointCloud._isQuantizedDraco;\n  var isOctEncodedDraco = pointCloud._isOctEncodedDraco;\n\n  var uniformMap = {\n    u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier: function () {\n      var scratch = scratchPointSizeAndTimeAndGeometricErrorAndDepthMultiplier;\n      scratch.x = pointCloud._attenuation\n        ? pointCloud.maximumAttenuation\n        : pointCloud._pointSize;\n      scratch.x *= frameState.pixelRatio;\n\n      scratch.y = pointCloud.time;\n\n      if (pointCloud._attenuation) {\n        var frustum = frameState.camera.frustum;\n        var depthMultiplier;\n        // Attenuation is maximumAttenuation in 2D/ortho\n        if (\n          frameState.mode === SceneMode.SCENE2D ||\n          frustum instanceof OrthographicFrustum\n        ) {\n          depthMultiplier = Number.POSITIVE_INFINITY;\n        } else {\n          depthMultiplier =\n            context.drawingBufferHeight /\n            frameState.camera.frustum.sseDenominator;\n        }\n\n        scratch.z = pointCloud.geometricError * pointCloud.geometricErrorScale;\n        scratch.w = depthMultiplier;\n      }\n\n      return scratch;\n    },\n    u_highlightColor: function () {\n      return pointCloud._highlightColor;\n    },\n    u_constantColor: function () {\n      return pointCloud._constantColor;\n    },\n    u_clippingPlanes: function () {\n      var clippingPlanes = pointCloud.clippingPlanes;\n      var isClipped = pointCloud.isClipped;\n      return isClipped ? clippingPlanes.texture : context.defaultTexture;\n    },\n    u_clippingPlanesEdgeStyle: function () {\n      var clippingPlanes = pointCloud.clippingPlanes;\n      if (!defined(clippingPlanes)) {\n        return Color.TRANSPARENT;\n      }\n\n      var style = Color.clone(clippingPlanes.edgeColor, scratchColor);\n      style.alpha = clippingPlanes.edgeWidth;\n      return style;\n    },\n    u_clippingPlanesMatrix: function () {\n      var clippingPlanes = pointCloud.clippingPlanes;\n      if (!defined(clippingPlanes)) {\n        return Matrix4.IDENTITY;\n      }\n\n      var clippingPlanesOriginMatrix = defaultValue(\n        pointCloud.clippingPlanesOriginMatrix,\n        pointCloud._modelMatrix\n      );\n      Matrix4.multiply(\n        context.uniformState.view3D,\n        clippingPlanesOriginMatrix,\n        scratchClippingPlanesMatrix\n      );\n      var transform = Matrix4.multiply(\n        scratchClippingPlanesMatrix,\n        clippingPlanes.modelMatrix,\n        scratchClippingPlanesMatrix\n      );\n\n      return Matrix4.inverseTranspose(\n        transform,\n        scratchInverseTransposeClippingPlanesMatrix\n      );\n    },\n  };\n\n  if (isQuantized || isQuantizedDraco || isOctEncodedDraco) {\n    uniformMap = combine(uniformMap, {\n      u_quantizedVolumeScaleAndOctEncodedRange: function () {\n        var scratch = scratchQuantizedVolumeScaleAndOctEncodedRange;\n        if (defined(pointCloud._quantizedVolumeScale)) {\n          var scale = Cartesian3.clone(\n            pointCloud._quantizedVolumeScale,\n            scratch\n          );\n          Cartesian3.divideByScalar(scale, pointCloud._quantizedRange, scratch);\n        }\n        scratch.w = pointCloud._octEncodedRange;\n        return scratch;\n      },\n    });\n  }\n\n  if (defined(pointCloud._uniformMapLoaded)) {\n    uniformMap = pointCloud._uniformMapLoaded(uniformMap);\n  }\n\n  pointCloud._drawCommand.uniformMap = uniformMap;\n}\n\nfunction getStyleablePropertyIds(source, propertyIds) {\n  // Get all the property IDs used by this style\n  var regex = /czm_3dtiles_property_(\\d+)/g;\n  var matches = regex.exec(source);\n  while (matches !== null) {\n    var id = parseInt(matches[1]);\n    if (propertyIds.indexOf(id) === -1) {\n      propertyIds.push(id);\n    }\n    matches = regex.exec(source);\n  }\n}\n\nfunction getBuiltinPropertyNames(source, propertyNames) {\n  // Get all the builtin property names used by this style\n  var regex = /czm_3dtiles_builtin_property_(\\w+)/g;\n  var matches = regex.exec(source);\n  while (matches !== null) {\n    var name = matches[1];\n    if (propertyNames.indexOf(name) === -1) {\n      propertyNames.push(name);\n    }\n    matches = regex.exec(source);\n  }\n}\n\nfunction getVertexAttribute(vertexArray, index) {\n  var numberOfAttributes = vertexArray.numberOfAttributes;\n  for (var i = 0; i < numberOfAttributes; ++i) {\n    var attribute = vertexArray.getAttribute(i);\n    if (attribute.index === index) {\n      return attribute;\n    }\n  }\n}\n\nvar builtinPropertyNameMap = {\n  POSITION: \"czm_3dtiles_builtin_property_POSITION\",\n  POSITION_ABSOLUTE: \"czm_3dtiles_builtin_property_POSITION_ABSOLUTE\",\n  COLOR: \"czm_3dtiles_builtin_property_COLOR\",\n  NORMAL: \"czm_3dtiles_builtin_property_NORMAL\",\n};\n\nfunction modifyStyleFunction(source) {\n  // Edit the function header to accept the point position, color, and normal\n  var functionHeader =\n    \"(\" +\n    \"vec3 czm_3dtiles_builtin_property_POSITION, \" +\n    \"vec3 czm_3dtiles_builtin_property_POSITION_ABSOLUTE, \" +\n    \"vec4 czm_3dtiles_builtin_property_COLOR, \" +\n    \"vec3 czm_3dtiles_builtin_property_NORMAL\" +\n    \")\";\n\n  return source.replace(\"()\", functionHeader);\n}\n\nfunction createShaders(pointCloud, frameState, style) {\n  var i;\n  var name;\n  var attribute;\n\n  var context = frameState.context;\n  var hasStyle = defined(style);\n  var isQuantized = pointCloud._isQuantized;\n  var isQuantizedDraco = pointCloud._isQuantizedDraco;\n  var isOctEncoded16P = pointCloud._isOctEncoded16P;\n  var isOctEncodedDraco = pointCloud._isOctEncodedDraco;\n  var isRGB565 = pointCloud._isRGB565;\n  var isTranslucent = pointCloud._isTranslucent;\n  var hasColors = pointCloud._hasColors;\n  var hasNormals = pointCloud._hasNormals;\n  var hasBatchIds = pointCloud._hasBatchIds;\n  var backFaceCulling = pointCloud._backFaceCulling;\n  var normalShading = pointCloud._normalShading;\n  var vertexArray = pointCloud._drawCommand.vertexArray;\n  var clippingPlanes = pointCloud.clippingPlanes;\n  var attenuation = pointCloud._attenuation;\n\n  var colorStyleFunction;\n  var showStyleFunction;\n  var pointSizeStyleFunction;\n  var styleTranslucent = isTranslucent;\n\n  var propertyNameMap = clone(builtinPropertyNameMap);\n  var propertyIdToAttributeMap = {};\n  var styleableShaderAttributes = pointCloud._styleableShaderAttributes;\n  for (name in styleableShaderAttributes) {\n    if (styleableShaderAttributes.hasOwnProperty(name)) {\n      attribute = styleableShaderAttributes[name];\n      propertyNameMap[name] = \"czm_3dtiles_property_\" + attribute.location;\n      propertyIdToAttributeMap[attribute.location] = attribute;\n    }\n  }\n\n  if (hasStyle) {\n    var shaderState = {\n      translucent: false,\n    };\n    colorStyleFunction = style.getColorShaderFunction(\n      \"getColorFromStyle\",\n      propertyNameMap,\n      shaderState\n    );\n    showStyleFunction = style.getShowShaderFunction(\n      \"getShowFromStyle\",\n      propertyNameMap,\n      shaderState\n    );\n    pointSizeStyleFunction = style.getPointSizeShaderFunction(\n      \"getPointSizeFromStyle\",\n      propertyNameMap,\n      shaderState\n    );\n    if (defined(colorStyleFunction) && shaderState.translucent) {\n      styleTranslucent = true;\n    }\n  }\n\n  pointCloud._styleTranslucent = styleTranslucent;\n\n  var hasColorStyle = defined(colorStyleFunction);\n  var hasShowStyle = defined(showStyleFunction);\n  var hasPointSizeStyle = defined(pointSizeStyleFunction);\n  var hasClippedContent = pointCloud.isClipped;\n\n  // Get the properties in use by the style\n  var styleablePropertyIds = [];\n  var builtinPropertyNames = [];\n\n  if (hasColorStyle) {\n    getStyleablePropertyIds(colorStyleFunction, styleablePropertyIds);\n    getBuiltinPropertyNames(colorStyleFunction, builtinPropertyNames);\n    colorStyleFunction = modifyStyleFunction(colorStyleFunction);\n  }\n  if (hasShowStyle) {\n    getStyleablePropertyIds(showStyleFunction, styleablePropertyIds);\n    getBuiltinPropertyNames(showStyleFunction, builtinPropertyNames);\n    showStyleFunction = modifyStyleFunction(showStyleFunction);\n  }\n  if (hasPointSizeStyle) {\n    getStyleablePropertyIds(pointSizeStyleFunction, styleablePropertyIds);\n    getBuiltinPropertyNames(pointSizeStyleFunction, builtinPropertyNames);\n    pointSizeStyleFunction = modifyStyleFunction(pointSizeStyleFunction);\n  }\n\n  var usesColorSemantic = builtinPropertyNames.indexOf(\"COLOR\") >= 0;\n  var usesNormalSemantic = builtinPropertyNames.indexOf(\"NORMAL\") >= 0;\n\n  if (usesNormalSemantic && !hasNormals) {\n    throw new RuntimeError(\n      \"Style references the NORMAL semantic but the point cloud does not have normals\"\n    );\n  }\n\n  // Disable vertex attributes that aren't used in the style, enable attributes that are\n  for (name in styleableShaderAttributes) {\n    if (styleableShaderAttributes.hasOwnProperty(name)) {\n      attribute = styleableShaderAttributes[name];\n      var enabled = styleablePropertyIds.indexOf(attribute.location) >= 0;\n      var vertexAttribute = getVertexAttribute(vertexArray, attribute.location);\n      vertexAttribute.enabled = enabled;\n    }\n  }\n\n  var usesColors = hasColors && (!hasColorStyle || usesColorSemantic);\n  if (hasColors) {\n    // Disable the color vertex attribute if the color style does not reference the color semantic\n    var colorVertexAttribute = getVertexAttribute(vertexArray, colorLocation);\n    colorVertexAttribute.enabled = usesColors;\n  }\n\n  var usesNormals =\n    hasNormals && (normalShading || backFaceCulling || usesNormalSemantic);\n  if (hasNormals) {\n    // Disable the normal vertex attribute if normals are not used\n    var normalVertexAttribute = getVertexAttribute(vertexArray, normalLocation);\n    normalVertexAttribute.enabled = usesNormals;\n  }\n\n  var attributeLocations = {\n    a_position: positionLocation,\n  };\n  if (usesColors) {\n    attributeLocations.a_color = colorLocation;\n  }\n  if (usesNormals) {\n    attributeLocations.a_normal = normalLocation;\n  }\n  if (hasBatchIds) {\n    attributeLocations.a_batchId = batchIdLocation;\n  }\n\n  var attributeDeclarations = \"\";\n\n  var length = styleablePropertyIds.length;\n  for (i = 0; i < length; ++i) {\n    var propertyId = styleablePropertyIds[i];\n    attribute = propertyIdToAttributeMap[propertyId];\n    var componentCount = attribute.componentCount;\n    var attributeName = \"czm_3dtiles_property_\" + propertyId;\n    var attributeType;\n    if (componentCount === 1) {\n      attributeType = \"float\";\n    } else {\n      attributeType = \"vec\" + componentCount;\n    }\n\n    attributeDeclarations +=\n      \"attribute \" + attributeType + \" \" + attributeName + \"; \\n\";\n    attributeLocations[attributeName] = attribute.location;\n  }\n\n  createUniformMap(pointCloud, frameState);\n\n  var vs =\n    \"attribute vec3 a_position; \\n\" +\n    \"varying vec4 v_color; \\n\" +\n    \"uniform vec4 u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier; \\n\" +\n    \"uniform vec4 u_constantColor; \\n\" +\n    \"uniform vec4 u_highlightColor; \\n\";\n  vs += \"float u_pointSize; \\n\" + \"float u_time; \\n\";\n\n  if (attenuation) {\n    vs += \"float u_geometricError; \\n\" + \"float u_depthMultiplier; \\n\";\n  }\n\n  vs += attributeDeclarations;\n\n  if (usesColors) {\n    if (isTranslucent) {\n      vs += \"attribute vec4 a_color; \\n\";\n    } else if (isRGB565) {\n      vs +=\n        \"attribute float a_color; \\n\" +\n        \"const float SHIFT_RIGHT_11 = 1.0 / 2048.0; \\n\" +\n        \"const float SHIFT_RIGHT_5 = 1.0 / 32.0; \\n\" +\n        \"const float SHIFT_LEFT_11 = 2048.0; \\n\" +\n        \"const float SHIFT_LEFT_5 = 32.0; \\n\" +\n        \"const float NORMALIZE_6 = 1.0 / 64.0; \\n\" +\n        \"const float NORMALIZE_5 = 1.0 / 32.0; \\n\";\n    } else {\n      vs += \"attribute vec3 a_color; \\n\";\n    }\n  }\n  if (usesNormals) {\n    if (isOctEncoded16P || isOctEncodedDraco) {\n      vs += \"attribute vec2 a_normal; \\n\";\n    } else {\n      vs += \"attribute vec3 a_normal; \\n\";\n    }\n  }\n\n  if (hasBatchIds) {\n    vs += \"attribute float a_batchId; \\n\";\n  }\n\n  if (isQuantized || isQuantizedDraco || isOctEncodedDraco) {\n    vs += \"uniform vec4 u_quantizedVolumeScaleAndOctEncodedRange; \\n\";\n  }\n\n  if (hasColorStyle) {\n    vs += colorStyleFunction;\n  }\n\n  if (hasShowStyle) {\n    vs += showStyleFunction;\n  }\n\n  if (hasPointSizeStyle) {\n    vs += pointSizeStyleFunction;\n  }\n\n  vs +=\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    u_pointSize = u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier.x; \\n\" +\n    \"    u_time = u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier.y; \\n\";\n\n  if (attenuation) {\n    vs +=\n      \"    u_geometricError = u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier.z; \\n\" +\n      \"    u_depthMultiplier = u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier.w; \\n\";\n  }\n\n  if (usesColors) {\n    if (isTranslucent) {\n      vs += \"    vec4 color = a_color; \\n\";\n    } else if (isRGB565) {\n      vs +=\n        \"    float compressed = a_color; \\n\" +\n        \"    float r = floor(compressed * SHIFT_RIGHT_11); \\n\" +\n        \"    compressed -= r * SHIFT_LEFT_11; \\n\" +\n        \"    float g = floor(compressed * SHIFT_RIGHT_5); \\n\" +\n        \"    compressed -= g * SHIFT_LEFT_5; \\n\" +\n        \"    float b = compressed; \\n\" +\n        \"    vec3 rgb = vec3(r * NORMALIZE_5, g * NORMALIZE_6, b * NORMALIZE_5); \\n\" +\n        \"    vec4 color = vec4(rgb, 1.0); \\n\";\n    } else {\n      vs += \"    vec4 color = vec4(a_color, 1.0); \\n\";\n    }\n  } else {\n    vs += \"    vec4 color = u_constantColor; \\n\";\n  }\n\n  if (isQuantized || isQuantizedDraco) {\n    vs +=\n      \"    vec3 position = a_position * u_quantizedVolumeScaleAndOctEncodedRange.xyz; \\n\";\n  } else {\n    vs += \"    vec3 position = a_position; \\n\";\n  }\n  vs +=\n    \"    vec3 position_absolute = vec3(czm_model * vec4(position, 1.0)); \\n\";\n\n  if (usesNormals) {\n    if (isOctEncoded16P) {\n      vs += \"    vec3 normal = czm_octDecode(a_normal); \\n\";\n    } else if (isOctEncodedDraco) {\n      // Draco oct-encoding decodes to zxy order\n      vs +=\n        \"    vec3 normal = czm_octDecode(a_normal, u_quantizedVolumeScaleAndOctEncodedRange.w).zxy; \\n\";\n    } else {\n      vs += \"    vec3 normal = a_normal; \\n\";\n    }\n    vs += \"    vec3 normalEC = czm_normal * normal; \\n\";\n  } else {\n    vs += \"    vec3 normal = vec3(1.0); \\n\";\n  }\n\n  if (hasColorStyle) {\n    vs +=\n      \"    color = getColorFromStyle(position, position_absolute, color, normal); \\n\";\n  }\n\n  if (hasShowStyle) {\n    vs +=\n      \"    float show = float(getShowFromStyle(position, position_absolute, color, normal)); \\n\";\n  }\n\n  if (hasPointSizeStyle) {\n    vs +=\n      \"    gl_PointSize = getPointSizeFromStyle(position, position_absolute, color, normal) * czm_pixelRatio; \\n\";\n  } else if (attenuation) {\n    vs +=\n      \"    vec4 positionEC = czm_modelView * vec4(position, 1.0); \\n\" +\n      \"    float depth = -positionEC.z; \\n\" +\n      // compute SSE for this point\n      \"    gl_PointSize = min((u_geometricError / depth) * u_depthMultiplier, u_pointSize); \\n\";\n  } else {\n    vs += \"    gl_PointSize = u_pointSize; \\n\";\n  }\n\n  vs += \"    color = color * u_highlightColor; \\n\";\n\n  if (usesNormals && normalShading) {\n    vs +=\n      \"    float diffuseStrength = czm_getLambertDiffuse(czm_lightDirectionEC, normalEC); \\n\" +\n      \"    diffuseStrength = max(diffuseStrength, 0.4); \\n\" + // Apply some ambient lighting\n      \"    color.xyz *= diffuseStrength * czm_lightColor; \\n\";\n  }\n\n  vs +=\n    \"    v_color = color; \\n\" +\n    \"    gl_Position = czm_modelViewProjection * vec4(position, 1.0); \\n\";\n\n  if (usesNormals && backFaceCulling) {\n    vs +=\n      \"    float visible = step(-normalEC.z, 0.0); \\n\" +\n      \"    gl_Position *= visible; \\n\" +\n      \"    gl_PointSize *= visible; \\n\";\n  }\n\n  if (hasShowStyle) {\n    vs +=\n      \"    gl_Position.w *= float(show); \\n\" +\n      \"    gl_PointSize *= float(show); \\n\";\n  }\n\n  vs += \"} \\n\";\n\n  var fs = \"varying vec4 v_color; \\n\";\n\n  if (hasClippedContent) {\n    fs +=\n      \"uniform highp sampler2D u_clippingPlanes; \\n\" +\n      \"uniform mat4 u_clippingPlanesMatrix; \\n\" +\n      \"uniform vec4 u_clippingPlanesEdgeStyle; \\n\";\n    fs += \"\\n\";\n    fs += getClippingFunction(clippingPlanes, context);\n    fs += \"\\n\";\n  }\n\n  fs +=\n    \"void main() \\n\" +\n    \"{ \\n\" +\n    \"    gl_FragColor = czm_gammaCorrect(v_color); \\n\";\n\n  if (hasClippedContent) {\n    fs += getClipAndStyleCode(\n      \"u_clippingPlanes\",\n      \"u_clippingPlanesMatrix\",\n      \"u_clippingPlanesEdgeStyle\"\n    );\n  }\n\n  fs += \"} \\n\";\n\n  if (defined(pointCloud._vertexShaderLoaded)) {\n    vs = pointCloud._vertexShaderLoaded(vs);\n  }\n\n  if (defined(pointCloud._fragmentShaderLoaded)) {\n    fs = pointCloud._fragmentShaderLoaded(fs);\n  }\n\n  var drawCommand = pointCloud._drawCommand;\n  if (defined(drawCommand.shaderProgram)) {\n    // Destroy the old shader\n    drawCommand.shaderProgram.destroy();\n  }\n  drawCommand.shaderProgram = ShaderProgram.fromCache({\n    context: context,\n    vertexShaderSource: vs,\n    fragmentShaderSource: fs,\n    attributeLocations: attributeLocations,\n  });\n\n  try {\n    // Check if the shader compiles correctly. If not there is likely a syntax error with the style.\n    drawCommand.shaderProgram._bind();\n  } catch (error) {\n    // Rephrase the error.\n    throw new RuntimeError(\n      \"Error generating style shader: this may be caused by a type mismatch, index out-of-bounds, or other syntax error.\"\n    );\n  }\n}\n\nfunction decodeDraco(pointCloud, context) {\n  if (pointCloud._decodingState === DecodingState.READY) {\n    return false;\n  }\n  if (pointCloud._decodingState === DecodingState.NEEDS_DECODE) {\n    var parsedContent = pointCloud._parsedContent;\n    var draco = parsedContent.draco;\n    var decodePromise = DracoLoader.decodePointCloud(draco, context);\n    if (defined(decodePromise)) {\n      pointCloud._decodingState = DecodingState.DECODING;\n      decodePromise\n        .then(function (result) {\n          pointCloud._decodingState = DecodingState.READY;\n          var decodedPositions = defined(result.POSITION)\n            ? result.POSITION.array\n            : undefined;\n          var decodedRgb = defined(result.RGB) ? result.RGB.array : undefined;\n          var decodedRgba = defined(result.RGBA)\n            ? result.RGBA.array\n            : undefined;\n          var decodedNormals = defined(result.NORMAL)\n            ? result.NORMAL.array\n            : undefined;\n          var decodedBatchIds = defined(result.BATCH_ID)\n            ? result.BATCH_ID.array\n            : undefined;\n          var isQuantizedDraco =\n            defined(decodedPositions) &&\n            defined(result.POSITION.data.quantization);\n          var isOctEncodedDraco =\n            defined(decodedNormals) && defined(result.NORMAL.data.quantization);\n          if (isQuantizedDraco) {\n            // Draco quantization range == quantized volume scale - size in meters of the quantized volume\n            // Internal quantized range is the range of values of the quantized data, e.g. 255 for 8-bit, 1023 for 10-bit, etc\n            var quantization = result.POSITION.data.quantization;\n            var range = quantization.range;\n            pointCloud._quantizedVolumeScale = Cartesian3.fromElements(\n              range,\n              range,\n              range\n            );\n            pointCloud._quantizedVolumeOffset = Cartesian3.unpack(\n              quantization.minValues\n            );\n            pointCloud._quantizedRange =\n              (1 << quantization.quantizationBits) - 1.0;\n            pointCloud._isQuantizedDraco = true;\n          }\n          if (isOctEncodedDraco) {\n            pointCloud._octEncodedRange =\n              (1 << result.NORMAL.data.quantization.quantizationBits) - 1.0;\n            pointCloud._isOctEncodedDraco = true;\n          }\n          var styleableProperties = parsedContent.styleableProperties;\n          var batchTableProperties = draco.batchTableProperties;\n          for (var name in batchTableProperties) {\n            if (batchTableProperties.hasOwnProperty(name)) {\n              var property = result[name];\n              if (!defined(styleableProperties)) {\n                styleableProperties = {};\n              }\n              styleableProperties[name] = {\n                typedArray: property.array,\n                componentCount: property.data.componentsPerAttribute,\n              };\n            }\n          }\n          parsedContent.positions = defaultValue(\n            decodedPositions,\n            parsedContent.positions\n          );\n          parsedContent.colors = defaultValue(\n            defaultValue(decodedRgba, decodedRgb),\n            parsedContent.colors\n          );\n          parsedContent.normals = defaultValue(\n            decodedNormals,\n            parsedContent.normals\n          );\n          parsedContent.batchIds = defaultValue(\n            decodedBatchIds,\n            parsedContent.batchIds\n          );\n          parsedContent.styleableProperties = styleableProperties;\n        })\n        .otherwise(function (error) {\n          pointCloud._decodingState = DecodingState.FAILED;\n          pointCloud._readyPromise.reject(error);\n        });\n    }\n  }\n  return true;\n}\n\nvar scratchComputedTranslation = new Cartesian4();\nvar scratchScale = new Cartesian3();\n\nPointCloud.prototype.update = function (frameState) {\n  var context = frameState.context;\n  var decoding = decodeDraco(this, context);\n  if (decoding) {\n    return;\n  }\n\n  var shadersDirty = false;\n  var modelMatrixDirty = !Matrix4.equals(this._modelMatrix, this.modelMatrix);\n\n  if (this._mode !== frameState.mode) {\n    this._mode = frameState.mode;\n    modelMatrixDirty = true;\n  }\n\n  if (!defined(this._drawCommand)) {\n    createResources(this, frameState);\n    modelMatrixDirty = true;\n    shadersDirty = true;\n    this._ready = true;\n    this._readyPromise.resolve(this);\n    this._parsedContent = undefined; // Unload\n  }\n\n  if (modelMatrixDirty) {\n    Matrix4.clone(this.modelMatrix, this._modelMatrix);\n    var modelMatrix = this._drawCommand.modelMatrix;\n    Matrix4.clone(this._modelMatrix, modelMatrix);\n\n    if (defined(this._rtcCenter)) {\n      Matrix4.multiplyByTranslation(modelMatrix, this._rtcCenter, modelMatrix);\n    }\n    if (defined(this._quantizedVolumeOffset)) {\n      Matrix4.multiplyByTranslation(\n        modelMatrix,\n        this._quantizedVolumeOffset,\n        modelMatrix\n      );\n    }\n\n    if (frameState.mode !== SceneMode.SCENE3D) {\n      var projection = frameState.mapProjection;\n      var translation = Matrix4.getColumn(\n        modelMatrix,\n        3,\n        scratchComputedTranslation\n      );\n      if (!Cartesian4.equals(translation, Cartesian4.UNIT_W)) {\n        Transforms.basisTo2D(projection, modelMatrix, modelMatrix);\n      }\n    }\n\n    var boundingSphere = this._drawCommand.boundingVolume;\n    BoundingSphere.clone(this._boundingSphere, boundingSphere);\n\n    if (this._cull) {\n      var center = boundingSphere.center;\n      Matrix4.multiplyByPoint(modelMatrix, center, center);\n      var scale = Matrix4.getScale(modelMatrix, scratchScale);\n      boundingSphere.radius *= Cartesian3.maximumComponent(scale);\n    }\n  }\n\n  if (this.clippingPlanesDirty) {\n    this.clippingPlanesDirty = false;\n    shadersDirty = true;\n  }\n\n  if (this._attenuation !== this.attenuation) {\n    this._attenuation = this.attenuation;\n    shadersDirty = true;\n  }\n\n  if (this.backFaceCulling !== this._backFaceCulling) {\n    this._backFaceCulling = this.backFaceCulling;\n    shadersDirty = true;\n  }\n\n  if (this.normalShading !== this._normalShading) {\n    this._normalShading = this.normalShading;\n    shadersDirty = true;\n  }\n\n  if (this._style !== this.style || this.styleDirty) {\n    this._style = this.style;\n    this.styleDirty = false;\n    shadersDirty = true;\n  }\n\n  if (shadersDirty) {\n    createShaders(this, frameState, this._style);\n  }\n\n  this._drawCommand.castShadows = ShadowMode.castShadows(this.shadows);\n  this._drawCommand.receiveShadows = ShadowMode.receiveShadows(this.shadows);\n\n  // Update the render state\n  var isTranslucent =\n    this._highlightColor.alpha < 1.0 ||\n    this._constantColor.alpha < 1.0 ||\n    this._styleTranslucent;\n  this._drawCommand.renderState = isTranslucent\n    ? this._translucentRenderState\n    : this._opaqueRenderState;\n  this._drawCommand.pass = isTranslucent ? Pass.TRANSLUCENT : this._opaquePass;\n\n  var commandList = frameState.commandList;\n\n  var passes = frameState.passes;\n  if (passes.render || passes.pick) {\n    commandList.push(this._drawCommand);\n  }\n};\n\nPointCloud.prototype.isDestroyed = function () {\n  return false;\n};\n\nPointCloud.prototype.destroy = function () {\n  var command = this._drawCommand;\n  if (defined(command)) {\n    command.vertexArray = command.vertexArray && command.vertexArray.destroy();\n    command.shaderProgram =\n      command.shaderProgram && command.shaderProgram.destroy();\n  }\n  return destroyObject(this);\n};\nexport default PointCloud;\n"]},"metadata":{},"sourceType":"module"}