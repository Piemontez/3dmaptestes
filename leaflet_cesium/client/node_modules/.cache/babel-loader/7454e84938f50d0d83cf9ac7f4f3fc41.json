{"ast":null,"code":"import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport EncodedCartesian3 from \"../Core/EncodedCartesian3.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport Simon1994PlanetaryPositions from \"../Core/Simon1994PlanetaryPositions.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport SceneMode from \"../Scene/SceneMode.js\";\nimport SunLight from \"../Scene/SunLight.js\";\n/**\n * @private\n * @constructor\n */\n\nfunction UniformState() {\n  /**\n   * @type {Texture}\n   */\n  this.globeDepthTexture = undefined;\n  /**\n   * @type {Number}\n   */\n\n  this.gamma = undefined;\n  this._viewport = new BoundingRectangle();\n  this._viewportCartesian4 = new Cartesian4();\n  this._viewportDirty = false;\n  this._viewportOrthographicMatrix = Matrix4.clone(Matrix4.IDENTITY);\n  this._viewportTransformation = Matrix4.clone(Matrix4.IDENTITY);\n  this._model = Matrix4.clone(Matrix4.IDENTITY);\n  this._view = Matrix4.clone(Matrix4.IDENTITY);\n  this._inverseView = Matrix4.clone(Matrix4.IDENTITY);\n  this._projection = Matrix4.clone(Matrix4.IDENTITY);\n  this._infiniteProjection = Matrix4.clone(Matrix4.IDENTITY);\n  this._entireFrustum = new Cartesian2();\n  this._currentFrustum = new Cartesian2();\n  this._frustumPlanes = new Cartesian4();\n  this._farDepthFromNearPlusOne = undefined;\n  this._log2FarDepthFromNearPlusOne = undefined;\n  this._oneOverLog2FarDepthFromNearPlusOne = undefined;\n  this._frameState = undefined;\n  this._temeToPseudoFixed = Matrix3.clone(Matrix4.IDENTITY); // Derived members\n\n  this._view3DDirty = true;\n  this._view3D = new Matrix4();\n  this._inverseView3DDirty = true;\n  this._inverseView3D = new Matrix4();\n  this._inverseModelDirty = true;\n  this._inverseModel = new Matrix4();\n  this._inverseTransposeModelDirty = true;\n  this._inverseTransposeModel = new Matrix3();\n  this._viewRotation = new Matrix3();\n  this._inverseViewRotation = new Matrix3();\n  this._viewRotation3D = new Matrix3();\n  this._inverseViewRotation3D = new Matrix3();\n  this._inverseProjectionDirty = true;\n  this._inverseProjection = new Matrix4();\n  this._modelViewDirty = true;\n  this._modelView = new Matrix4();\n  this._modelView3DDirty = true;\n  this._modelView3D = new Matrix4();\n  this._modelViewRelativeToEyeDirty = true;\n  this._modelViewRelativeToEye = new Matrix4();\n  this._inverseModelViewDirty = true;\n  this._inverseModelView = new Matrix4();\n  this._inverseModelView3DDirty = true;\n  this._inverseModelView3D = new Matrix4();\n  this._viewProjectionDirty = true;\n  this._viewProjection = new Matrix4();\n  this._inverseViewProjectionDirty = true;\n  this._inverseViewProjection = new Matrix4();\n  this._modelViewProjectionDirty = true;\n  this._modelViewProjection = new Matrix4();\n  this._inverseModelViewProjectionDirty = true;\n  this._inverseModelViewProjection = new Matrix4();\n  this._modelViewProjectionRelativeToEyeDirty = true;\n  this._modelViewProjectionRelativeToEye = new Matrix4();\n  this._modelViewInfiniteProjectionDirty = true;\n  this._modelViewInfiniteProjection = new Matrix4();\n  this._normalDirty = true;\n  this._normal = new Matrix3();\n  this._normal3DDirty = true;\n  this._normal3D = new Matrix3();\n  this._inverseNormalDirty = true;\n  this._inverseNormal = new Matrix3();\n  this._inverseNormal3DDirty = true;\n  this._inverseNormal3D = new Matrix3();\n  this._encodedCameraPositionMCDirty = true;\n  this._encodedCameraPositionMC = new EncodedCartesian3();\n  this._cameraPosition = new Cartesian3();\n  this._sunPositionWC = new Cartesian3();\n  this._sunPositionColumbusView = new Cartesian3();\n  this._sunDirectionWC = new Cartesian3();\n  this._sunDirectionEC = new Cartesian3();\n  this._moonDirectionEC = new Cartesian3();\n  this._lightDirectionWC = new Cartesian3();\n  this._lightDirectionEC = new Cartesian3();\n  this._lightColor = new Cartesian3();\n  this._lightColorHdr = new Cartesian3();\n  this._pass = undefined;\n  this._mode = undefined;\n  this._mapProjection = undefined;\n  this._ellipsoid = undefined;\n  this._cameraDirection = new Cartesian3();\n  this._cameraRight = new Cartesian3();\n  this._cameraUp = new Cartesian3();\n  this._frustum2DWidth = 0.0;\n  this._eyeHeight = 0.0;\n  this._eyeHeight2D = new Cartesian2();\n  this._pixelRatio = 1.0;\n  this._orthographicIn3D = false;\n  this._backgroundColor = new Color();\n  this._brdfLut = undefined;\n  this._environmentMap = undefined;\n  this._sphericalHarmonicCoefficients = undefined;\n  this._specularEnvironmentMaps = undefined;\n  this._specularEnvironmentMapsDimensions = new Cartesian2();\n  this._specularEnvironmentMapsMaximumLOD = undefined;\n  this._fogDensity = undefined;\n  this._invertClassificationColor = undefined;\n  this._imagerySplitPosition = 0.0;\n  this._pixelSizePerMeter = undefined;\n  this._geometricToleranceOverMeter = undefined;\n  this._minimumDisableDepthTestDistance = undefined;\n}\n\nObject.defineProperties(UniformState.prototype, {\n  /**\n   * @memberof UniformState.prototype\n   * @type {FrameState}\n   * @readonly\n   */\n  frameState: {\n    get: function () {\n      return this._frameState;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {BoundingRectangle}\n   */\n  viewport: {\n    get: function () {\n      return this._viewport;\n    },\n    set: function (viewport) {\n      if (!BoundingRectangle.equals(viewport, this._viewport)) {\n        BoundingRectangle.clone(viewport, this._viewport);\n        var v = this._viewport;\n        var vc = this._viewportCartesian4;\n        vc.x = v.x;\n        vc.y = v.y;\n        vc.z = v.width;\n        vc.w = v.height;\n        this._viewportDirty = true;\n      }\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @private\n   */\n  viewportCartesian4: {\n    get: function () {\n      return this._viewportCartesian4;\n    }\n  },\n  viewportOrthographic: {\n    get: function () {\n      cleanViewport(this);\n      return this._viewportOrthographicMatrix;\n    }\n  },\n  viewportTransformation: {\n    get: function () {\n      cleanViewport(this);\n      return this._viewportTransformation;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  model: {\n    get: function () {\n      return this._model;\n    },\n    set: function (matrix) {\n      Matrix4.clone(matrix, this._model);\n      this._modelView3DDirty = true;\n      this._inverseModelView3DDirty = true;\n      this._inverseModelDirty = true;\n      this._inverseTransposeModelDirty = true;\n      this._modelViewDirty = true;\n      this._inverseModelViewDirty = true;\n      this._modelViewRelativeToEyeDirty = true;\n      this._inverseModelViewDirty = true;\n      this._modelViewProjectionDirty = true;\n      this._inverseModelViewProjectionDirty = true;\n      this._modelViewProjectionRelativeToEyeDirty = true;\n      this._modelViewInfiniteProjectionDirty = true;\n      this._normalDirty = true;\n      this._inverseNormalDirty = true;\n      this._normal3DDirty = true;\n      this._inverseNormal3DDirty = true;\n      this._encodedCameraPositionMCDirty = true;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseModel: {\n    get: function () {\n      if (this._inverseModelDirty) {\n        this._inverseModelDirty = false;\n        Matrix4.inverse(this._model, this._inverseModel);\n      }\n\n      return this._inverseModel;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @private\n   */\n  inverseTransposeModel: {\n    get: function () {\n      var m = this._inverseTransposeModel;\n\n      if (this._inverseTransposeModelDirty) {\n        this._inverseTransposeModelDirty = false;\n        Matrix4.getMatrix3(this.inverseModel, m);\n        Matrix3.transpose(m, m);\n      }\n\n      return m;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  view: {\n    get: function () {\n      return this._view;\n    }\n  },\n\n  /**\n   * The 3D view matrix.  In 3D mode, this is identical to {@link UniformState#view},\n   * but in 2D and Columbus View it is a synthetic matrix based on the equivalent position\n   * of the camera in the 3D world.\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  view3D: {\n    get: function () {\n      updateView3D(this);\n      return this._view3D;\n    }\n  },\n\n  /**\n   * The 3x3 rotation matrix of the current view matrix ({@link UniformState#view}).\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  viewRotation: {\n    get: function () {\n      updateView3D(this);\n      return this._viewRotation;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  viewRotation3D: {\n    get: function () {\n      updateView3D(this);\n      return this._viewRotation3D;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseView: {\n    get: function () {\n      return this._inverseView;\n    }\n  },\n\n  /**\n   * the 4x4 inverse-view matrix that transforms from eye to 3D world coordinates.  In 3D mode, this is\n   * identical to {@link UniformState#inverseView}, but in 2D and Columbus View it is a synthetic matrix\n   * based on the equivalent position of the camera in the 3D world.\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseView3D: {\n    get: function () {\n      updateInverseView3D(this);\n      return this._inverseView3D;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  inverseViewRotation: {\n    get: function () {\n      return this._inverseViewRotation;\n    }\n  },\n\n  /**\n   * The 3x3 rotation matrix of the current 3D inverse-view matrix ({@link UniformState#inverseView3D}).\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  inverseViewRotation3D: {\n    get: function () {\n      updateInverseView3D(this);\n      return this._inverseViewRotation3D;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  projection: {\n    get: function () {\n      return this._projection;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseProjection: {\n    get: function () {\n      cleanInverseProjection(this);\n      return this._inverseProjection;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  infiniteProjection: {\n    get: function () {\n      return this._infiniteProjection;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelView: {\n    get: function () {\n      cleanModelView(this);\n      return this._modelView;\n    }\n  },\n\n  /**\n   * The 3D model-view matrix.  In 3D mode, this is equivalent to {@link UniformState#modelView}.  In 2D and\n   * Columbus View, however, it is a synthetic matrix based on the equivalent position of the camera in the 3D world.\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelView3D: {\n    get: function () {\n      cleanModelView3D(this);\n      return this._modelView3D;\n    }\n  },\n\n  /**\n   * Model-view relative to eye matrix.\n   *\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelViewRelativeToEye: {\n    get: function () {\n      cleanModelViewRelativeToEye(this);\n      return this._modelViewRelativeToEye;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseModelView: {\n    get: function () {\n      cleanInverseModelView(this);\n      return this._inverseModelView;\n    }\n  },\n\n  /**\n   * The inverse of the 3D model-view matrix.  In 3D mode, this is equivalent to {@link UniformState#inverseModelView}.\n   * In 2D and Columbus View, however, it is a synthetic matrix based on the equivalent position of the camera in the 3D world.\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseModelView3D: {\n    get: function () {\n      cleanInverseModelView3D(this);\n      return this._inverseModelView3D;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  viewProjection: {\n    get: function () {\n      cleanViewProjection(this);\n      return this._viewProjection;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseViewProjection: {\n    get: function () {\n      cleanInverseViewProjection(this);\n      return this._inverseViewProjection;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelViewProjection: {\n    get: function () {\n      cleanModelViewProjection(this);\n      return this._modelViewProjection;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseModelViewProjection: {\n    get: function () {\n      cleanInverseModelViewProjection(this);\n      return this._inverseModelViewProjection;\n    }\n  },\n\n  /**\n   * Model-view-projection relative to eye matrix.\n   *\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelViewProjectionRelativeToEye: {\n    get: function () {\n      cleanModelViewProjectionRelativeToEye(this);\n      return this._modelViewProjectionRelativeToEye;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelViewInfiniteProjection: {\n    get: function () {\n      cleanModelViewInfiniteProjection(this);\n      return this._modelViewInfiniteProjection;\n    }\n  },\n\n  /**\n   * A 3x3 normal transformation matrix that transforms normal vectors in model coordinates to\n   * eye coordinates.\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  normal: {\n    get: function () {\n      cleanNormal(this);\n      return this._normal;\n    }\n  },\n\n  /**\n   * A 3x3 normal transformation matrix that transforms normal vectors in 3D model\n   * coordinates to eye coordinates.  In 3D mode, this is identical to\n   * {@link UniformState#normal}, but in 2D and Columbus View it represents the normal transformation\n   * matrix as if the camera were at an equivalent location in 3D mode.\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  normal3D: {\n    get: function () {\n      cleanNormal3D(this);\n      return this._normal3D;\n    }\n  },\n\n  /**\n   * An inverse 3x3 normal transformation matrix that transforms normal vectors in model coordinates\n   * to eye coordinates.\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  inverseNormal: {\n    get: function () {\n      cleanInverseNormal(this);\n      return this._inverseNormal;\n    }\n  },\n\n  /**\n   * An inverse 3x3 normal transformation matrix that transforms normal vectors in eye coordinates\n   * to 3D model coordinates.  In 3D mode, this is identical to\n   * {@link UniformState#inverseNormal}, but in 2D and Columbus View it represents the normal transformation\n   * matrix as if the camera were at an equivalent location in 3D mode.\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  inverseNormal3D: {\n    get: function () {\n      cleanInverseNormal3D(this);\n      return this._inverseNormal3D;\n    }\n  },\n\n  /**\n   * The near distance (<code>x</code>) and the far distance (<code>y</code>) of the frustum defined by the camera.\n   * This is the largest possible frustum, not an individual frustum used for multi-frustum rendering.\n   * @memberof UniformState.prototype\n   * @type {Cartesian2}\n   */\n  entireFrustum: {\n    get: function () {\n      return this._entireFrustum;\n    }\n  },\n\n  /**\n   * The near distance (<code>x</code>) and the far distance (<code>y</code>) of the frustum defined by the camera.\n   * This is the individual frustum used for multi-frustum rendering.\n   * @memberof UniformState.prototype\n   * @type {Cartesian2}\n   */\n  currentFrustum: {\n    get: function () {\n      return this._currentFrustum;\n    }\n  },\n\n  /**\n   * The distances to the frustum planes. The top, bottom, left and right distances are\n   * the x, y, z, and w components, respectively.\n   * @memberof UniformState.prototype\n   * @type {Cartesian4}\n   */\n  frustumPlanes: {\n    get: function () {\n      return this._frustumPlanes;\n    }\n  },\n\n  /**\n   * The far plane's distance from the near plane, plus 1.0.\n   *\n   * @memberof UniformState.prototype\n   * @type {Number}\n   */\n  farDepthFromNearPlusOne: {\n    get: function () {\n      return this._farDepthFromNearPlusOne;\n    }\n  },\n\n  /**\n   * The log2 of {@link UniformState#farDepthFromNearPlusOne}.\n   *\n   * @memberof UniformState.prototype\n   * @type {Number}\n   */\n  log2FarDepthFromNearPlusOne: {\n    get: function () {\n      return this._log2FarDepthFromNearPlusOne;\n    }\n  },\n\n  /**\n   * 1.0 divided by {@link UniformState#log2FarDepthFromNearPlusOne}.\n   *\n   * @memberof UniformState.prototype\n   * @type {Number}\n   */\n  oneOverLog2FarDepthFromNearPlusOne: {\n    get: function () {\n      return this._oneOverLog2FarDepthFromNearPlusOne;\n    }\n  },\n\n  /**\n   * The height in meters of the eye (camera) above or below the ellipsoid.\n   * @memberof UniformState.prototype\n   * @type {Number}\n   */\n  eyeHeight: {\n    get: function () {\n      return this._eyeHeight;\n    }\n  },\n\n  /**\n   * The height (<code>x</code>) and the height squared (<code>y</code>)\n   * in meters of the eye (camera) above the 2D world plane. This uniform is only valid\n   * when the {@link SceneMode} is <code>SCENE2D</code>.\n   * @memberof UniformState.prototype\n   * @type {Cartesian2}\n   */\n  eyeHeight2D: {\n    get: function () {\n      return this._eyeHeight2D;\n    }\n  },\n\n  /**\n   * The sun position in 3D world coordinates at the current scene time.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  sunPositionWC: {\n    get: function () {\n      return this._sunPositionWC;\n    }\n  },\n\n  /**\n   * The sun position in 2D world coordinates at the current scene time.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  sunPositionColumbusView: {\n    get: function () {\n      return this._sunPositionColumbusView;\n    }\n  },\n\n  /**\n   * A normalized vector to the sun in 3D world coordinates at the current scene time.  Even in 2D or\n   * Columbus View mode, this returns the direction to the sun in the 3D scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  sunDirectionWC: {\n    get: function () {\n      return this._sunDirectionWC;\n    }\n  },\n\n  /**\n   * A normalized vector to the sun in eye coordinates at the current scene time.  In 3D mode, this\n   * returns the actual vector from the camera position to the sun position.  In 2D and Columbus View, it returns\n   * the vector from the equivalent 3D camera position to the position of the sun in the 3D scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  sunDirectionEC: {\n    get: function () {\n      return this._sunDirectionEC;\n    }\n  },\n\n  /**\n   * A normalized vector to the moon in eye coordinates at the current scene time.  In 3D mode, this\n   * returns the actual vector from the camera position to the moon position.  In 2D and Columbus View, it returns\n   * the vector from the equivalent 3D camera position to the position of the moon in the 3D scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  moonDirectionEC: {\n    get: function () {\n      return this._moonDirectionEC;\n    }\n  },\n\n  /**\n   * A normalized vector to the scene's light source in 3D world coordinates.  Even in 2D or\n   * Columbus View mode, this returns the direction to the light in the 3D scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  lightDirectionWC: {\n    get: function () {\n      return this._lightDirectionWC;\n    }\n  },\n\n  /**\n   * A normalized vector to the scene's light source in eye coordinates.  In 3D mode, this\n   * returns the actual vector from the camera position to the light.  In 2D and Columbus View, it returns\n   * the vector from the equivalent 3D camera position in the 3D scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  lightDirectionEC: {\n    get: function () {\n      return this._lightDirectionEC;\n    }\n  },\n\n  /**\n   * The color of light emitted by the scene's light source. This is equivalent to the light\n   * color multiplied by the light intensity limited to a maximum luminance of 1.0 suitable\n   * for non-HDR lighting.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  lightColor: {\n    get: function () {\n      return this._lightColor;\n    }\n  },\n\n  /**\n   * The high dynamic range color of light emitted by the scene's light source. This is equivalent to\n   * the light color multiplied by the light intensity suitable for HDR lighting.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  lightColorHdr: {\n    get: function () {\n      return this._lightColorHdr;\n    }\n  },\n\n  /**\n   * The high bits of the camera position.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  encodedCameraPositionMCHigh: {\n    get: function () {\n      cleanEncodedCameraPositionMC(this);\n      return this._encodedCameraPositionMC.high;\n    }\n  },\n\n  /**\n   * The low bits of the camera position.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  encodedCameraPositionMCLow: {\n    get: function () {\n      cleanEncodedCameraPositionMC(this);\n      return this._encodedCameraPositionMC.low;\n    }\n  },\n\n  /**\n   * A 3x3 matrix that transforms from True Equator Mean Equinox (TEME) axes to the\n   * pseudo-fixed axes at the Scene's current time.\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  temeToPseudoFixedMatrix: {\n    get: function () {\n      return this._temeToPseudoFixed;\n    }\n  },\n\n  /**\n   * Gets the scaling factor for transforming from the canvas\n   * pixel space to canvas coordinate space.\n   * @memberof UniformState.prototype\n   * @type {Number}\n   */\n  pixelRatio: {\n    get: function () {\n      return this._pixelRatio;\n    }\n  },\n\n  /**\n   * A scalar used to mix a color with the fog color based on the distance to the camera.\n   * @memberof UniformState.prototype\n   * @type {Number}\n   */\n  fogDensity: {\n    get: function () {\n      return this._fogDensity;\n    }\n  },\n\n  /**\n   * A scalar that represents the geometric tolerance per meter\n   * @memberof UniformState.prototype\n   * @type {Number}\n   */\n  geometricToleranceOverMeter: {\n    get: function () {\n      return this._geometricToleranceOverMeter;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Pass}\n   */\n  pass: {\n    get: function () {\n      return this._pass;\n    }\n  },\n\n  /**\n   * The current background color\n   * @memberof UniformState.prototype\n   * @type {Color}\n   */\n  backgroundColor: {\n    get: function () {\n      return this._backgroundColor;\n    }\n  },\n\n  /**\n   * The look up texture used to find the BRDF for a material\n   * @memberof UniformState.prototype\n   * @type {Texture}\n   */\n  brdfLut: {\n    get: function () {\n      return this._brdfLut;\n    }\n  },\n\n  /**\n   * The environment map of the scene\n   * @memberof UniformState.prototype\n   * @type {CubeMap}\n   */\n  environmentMap: {\n    get: function () {\n      return this._environmentMap;\n    }\n  },\n\n  /**\n   * The spherical harmonic coefficients of the scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3[]}\n   */\n  sphericalHarmonicCoefficients: {\n    get: function () {\n      return this._sphericalHarmonicCoefficients;\n    }\n  },\n\n  /**\n   * The specular environment map atlas of the scene.\n   * @memberof UniformState.prototype\n   * @type {Texture}\n   */\n  specularEnvironmentMaps: {\n    get: function () {\n      return this._specularEnvironmentMaps;\n    }\n  },\n\n  /**\n   * The dimensions of the specular environment map atlas of the scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian2}\n   */\n  specularEnvironmentMapsDimensions: {\n    get: function () {\n      return this._specularEnvironmentMapsDimensions;\n    }\n  },\n\n  /**\n   * The maximum level-of-detail of the specular environment map atlas of the scene.\n   * @memberof UniformState.prototype\n   * @type {Number}\n   */\n  specularEnvironmentMapsMaximumLOD: {\n    get: function () {\n      return this._specularEnvironmentMapsMaximumLOD;\n    }\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Number}\n   */\n  imagerySplitPosition: {\n    get: function () {\n      return this._imagerySplitPosition;\n    }\n  },\n\n  /**\n   * The distance from the camera at which to disable the depth test of billboards, labels and points\n   * to, for example, prevent clipping against terrain. When set to zero, the depth test should always\n   * be applied. When less than zero, the depth test should never be applied.\n   *\n   * @memberof UniformState.prototype\n   * @type {Number}\n   */\n  minimumDisableDepthTestDistance: {\n    get: function () {\n      return this._minimumDisableDepthTestDistance;\n    }\n  },\n\n  /**\n   * The highlight color of unclassified 3D Tiles.\n   *\n   * @memberof UniformState.prototype\n   * @type {Color}\n   */\n  invertClassificationColor: {\n    get: function () {\n      return this._invertClassificationColor;\n    }\n  },\n\n  /**\n   * Whether or not the current projection is orthographic in 3D.\n   *\n   * @memberOf UniformState.prototype\n   * @type {Boolean}\n   */\n  orthographicIn3D: {\n    get: function () {\n      return this._orthographicIn3D;\n    }\n  },\n\n  /**\n   * The current ellipsoid.\n   *\n   * @memberOf UniformState.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return defaultValue(this._ellipsoid, Ellipsoid.WGS84);\n    }\n  }\n});\n\nfunction setView(uniformState, matrix) {\n  Matrix4.clone(matrix, uniformState._view);\n  Matrix4.getMatrix3(matrix, uniformState._viewRotation);\n  uniformState._view3DDirty = true;\n  uniformState._inverseView3DDirty = true;\n  uniformState._modelViewDirty = true;\n  uniformState._modelView3DDirty = true;\n  uniformState._modelViewRelativeToEyeDirty = true;\n  uniformState._inverseModelViewDirty = true;\n  uniformState._inverseModelView3DDirty = true;\n  uniformState._viewProjectionDirty = true;\n  uniformState._inverseViewProjectionDirty = true;\n  uniformState._modelViewProjectionDirty = true;\n  uniformState._modelViewProjectionRelativeToEyeDirty = true;\n  uniformState._modelViewInfiniteProjectionDirty = true;\n  uniformState._normalDirty = true;\n  uniformState._inverseNormalDirty = true;\n  uniformState._normal3DDirty = true;\n  uniformState._inverseNormal3DDirty = true;\n}\n\nfunction setInverseView(uniformState, matrix) {\n  Matrix4.clone(matrix, uniformState._inverseView);\n  Matrix4.getMatrix3(matrix, uniformState._inverseViewRotation);\n}\n\nfunction setProjection(uniformState, matrix) {\n  Matrix4.clone(matrix, uniformState._projection);\n  uniformState._inverseProjectionDirty = true;\n  uniformState._viewProjectionDirty = true;\n  uniformState._inverseViewProjectionDirty = true;\n  uniformState._modelViewProjectionDirty = true;\n  uniformState._modelViewProjectionRelativeToEyeDirty = true;\n}\n\nfunction setInfiniteProjection(uniformState, matrix) {\n  Matrix4.clone(matrix, uniformState._infiniteProjection);\n  uniformState._modelViewInfiniteProjectionDirty = true;\n}\n\nfunction setCamera(uniformState, camera) {\n  Cartesian3.clone(camera.positionWC, uniformState._cameraPosition);\n  Cartesian3.clone(camera.directionWC, uniformState._cameraDirection);\n  Cartesian3.clone(camera.rightWC, uniformState._cameraRight);\n  Cartesian3.clone(camera.upWC, uniformState._cameraUp);\n  var positionCartographic = camera.positionCartographic;\n\n  if (!defined(positionCartographic)) {\n    uniformState._eyeHeight = -uniformState._ellipsoid.maximumRadius;\n  } else {\n    uniformState._eyeHeight = positionCartographic.height;\n  }\n\n  uniformState._encodedCameraPositionMCDirty = true;\n}\n\nvar transformMatrix = new Matrix3();\nvar sunCartographicScratch = new Cartographic();\n\nfunction setSunAndMoonDirections(uniformState, frameState) {\n  if (!defined(Transforms.computeIcrfToFixedMatrix(frameState.time, transformMatrix))) {\n    transformMatrix = Transforms.computeTemeToPseudoFixedMatrix(frameState.time, transformMatrix);\n  }\n\n  var position = Simon1994PlanetaryPositions.computeSunPositionInEarthInertialFrame(frameState.time, uniformState._sunPositionWC);\n  Matrix3.multiplyByVector(transformMatrix, position, position);\n  Cartesian3.normalize(position, uniformState._sunDirectionWC);\n  position = Matrix3.multiplyByVector(uniformState.viewRotation3D, position, uniformState._sunDirectionEC);\n  Cartesian3.normalize(position, position);\n  position = Simon1994PlanetaryPositions.computeMoonPositionInEarthInertialFrame(frameState.time, uniformState._moonDirectionEC);\n  Matrix3.multiplyByVector(transformMatrix, position, position);\n  Matrix3.multiplyByVector(uniformState.viewRotation3D, position, position);\n  Cartesian3.normalize(position, position);\n  var projection = frameState.mapProjection;\n  var ellipsoid = projection.ellipsoid;\n  var sunCartographic = ellipsoid.cartesianToCartographic(uniformState._sunPositionWC, sunCartographicScratch);\n  projection.project(sunCartographic, uniformState._sunPositionColumbusView);\n}\n/**\n * Synchronizes the frustum's state with the camera state.  This is called\n * by the {@link Scene} when rendering to ensure that automatic GLSL uniforms\n * are set to the right value.\n *\n * @param {Object} camera The camera to synchronize with.\n */\n\n\nUniformState.prototype.updateCamera = function (camera) {\n  setView(this, camera.viewMatrix);\n  setInverseView(this, camera.inverseViewMatrix);\n  setCamera(this, camera);\n  this._entireFrustum.x = camera.frustum.near;\n  this._entireFrustum.y = camera.frustum.far;\n  this.updateFrustum(camera.frustum);\n  this._orthographicIn3D = this._mode !== SceneMode.SCENE2D && camera.frustum instanceof OrthographicFrustum;\n};\n/**\n * Synchronizes the frustum's state with the uniform state.  This is called\n * by the {@link Scene} when rendering to ensure that automatic GLSL uniforms\n * are set to the right value.\n *\n * @param {Object} frustum The frustum to synchronize with.\n */\n\n\nUniformState.prototype.updateFrustum = function (frustum) {\n  setProjection(this, frustum.projectionMatrix);\n\n  if (defined(frustum.infiniteProjectionMatrix)) {\n    setInfiniteProjection(this, frustum.infiniteProjectionMatrix);\n  }\n\n  this._currentFrustum.x = frustum.near;\n  this._currentFrustum.y = frustum.far;\n  this._farDepthFromNearPlusOne = frustum.far - frustum.near + 1.0;\n  this._log2FarDepthFromNearPlusOne = CesiumMath.log2(this._farDepthFromNearPlusOne);\n  this._oneOverLog2FarDepthFromNearPlusOne = 1.0 / this._log2FarDepthFromNearPlusOne;\n\n  if (defined(frustum._offCenterFrustum)) {\n    frustum = frustum._offCenterFrustum;\n  }\n\n  this._frustumPlanes.x = frustum.top;\n  this._frustumPlanes.y = frustum.bottom;\n  this._frustumPlanes.z = frustum.left;\n  this._frustumPlanes.w = frustum.right;\n};\n\nUniformState.prototype.updatePass = function (pass) {\n  this._pass = pass;\n};\n\nvar EMPTY_ARRAY = [];\nvar defaultLight = new SunLight();\n/**\n * Synchronizes frame state with the uniform state.  This is called\n * by the {@link Scene} when rendering to ensure that automatic GLSL uniforms\n * are set to the right value.\n *\n * @param {FrameState} frameState The frameState to synchronize with.\n */\n\nUniformState.prototype.update = function (frameState) {\n  this._mode = frameState.mode;\n  this._mapProjection = frameState.mapProjection;\n  this._ellipsoid = frameState.mapProjection.ellipsoid;\n  this._pixelRatio = frameState.pixelRatio;\n  var camera = frameState.camera;\n  this.updateCamera(camera);\n\n  if (frameState.mode === SceneMode.SCENE2D) {\n    this._frustum2DWidth = camera.frustum.right - camera.frustum.left;\n    this._eyeHeight2D.x = this._frustum2DWidth * 0.5;\n    this._eyeHeight2D.y = this._eyeHeight2D.x * this._eyeHeight2D.x;\n  } else {\n    this._frustum2DWidth = 0.0;\n    this._eyeHeight2D.x = 0.0;\n    this._eyeHeight2D.y = 0.0;\n  }\n\n  setSunAndMoonDirections(this, frameState);\n  var light = defaultValue(frameState.light, defaultLight);\n\n  if (light instanceof SunLight) {\n    this._lightDirectionWC = Cartesian3.clone(this._sunDirectionWC, this._lightDirectionWC);\n    this._lightDirectionEC = Cartesian3.clone(this._sunDirectionEC, this._lightDirectionEC);\n  } else {\n    this._lightDirectionWC = Cartesian3.normalize(Cartesian3.negate(light.direction, this._lightDirectionWC), this._lightDirectionWC);\n    this._lightDirectionEC = Matrix3.multiplyByVector(this.viewRotation3D, this._lightDirectionWC, this._lightDirectionEC);\n  }\n\n  var lightColor = light.color;\n  var lightColorHdr = Cartesian3.fromElements(lightColor.red, lightColor.green, lightColor.blue, this._lightColorHdr);\n  lightColorHdr = Cartesian3.multiplyByScalar(lightColorHdr, light.intensity, lightColorHdr);\n  var maximumComponent = Cartesian3.maximumComponent(lightColorHdr);\n\n  if (maximumComponent > 1.0) {\n    Cartesian3.divideByScalar(lightColorHdr, maximumComponent, this._lightColor);\n  } else {\n    Cartesian3.clone(lightColorHdr, this._lightColor);\n  }\n\n  var brdfLutGenerator = frameState.brdfLutGenerator;\n  var brdfLut = defined(brdfLutGenerator) ? brdfLutGenerator.colorTexture : undefined;\n  this._brdfLut = brdfLut;\n  this._environmentMap = defaultValue(frameState.environmentMap, frameState.context.defaultCubeMap); // IE 11 doesn't optimize out uniforms that are #ifdef'd out. So undefined values for the spherical harmonic\n  // coefficients and specular environment map atlas dimensions cause a crash.\n\n  this._sphericalHarmonicCoefficients = defaultValue(frameState.sphericalHarmonicCoefficients, EMPTY_ARRAY);\n  this._specularEnvironmentMaps = frameState.specularEnvironmentMaps;\n  this._specularEnvironmentMapsMaximumLOD = frameState.specularEnvironmentMapsMaximumLOD;\n\n  if (defined(this._specularEnvironmentMaps)) {\n    Cartesian2.clone(this._specularEnvironmentMaps.dimensions, this._specularEnvironmentMapsDimensions);\n  }\n\n  this._fogDensity = frameState.fog.density;\n  this._invertClassificationColor = frameState.invertClassificationColor;\n  this._frameState = frameState;\n  this._temeToPseudoFixed = Transforms.computeTemeToPseudoFixedMatrix(frameState.time, this._temeToPseudoFixed); // Convert the relative imagerySplitPosition to absolute pixel coordinates\n\n  this._imagerySplitPosition = frameState.imagerySplitPosition * frameState.context.drawingBufferWidth;\n  var fov = camera.frustum.fov;\n  var viewport = this._viewport;\n  var pixelSizePerMeter;\n\n  if (defined(fov)) {\n    if (viewport.height > viewport.width) {\n      pixelSizePerMeter = Math.tan(0.5 * fov) * 2.0 / viewport.height;\n    } else {\n      pixelSizePerMeter = Math.tan(0.5 * fov) * 2.0 / viewport.width;\n    }\n  } else {\n    pixelSizePerMeter = 1.0 / Math.max(viewport.width, viewport.height);\n  }\n\n  this._geometricToleranceOverMeter = pixelSizePerMeter * frameState.maximumScreenSpaceError;\n  Color.clone(frameState.backgroundColor, this._backgroundColor);\n  this._minimumDisableDepthTestDistance = frameState.minimumDisableDepthTestDistance;\n  this._minimumDisableDepthTestDistance *= this._minimumDisableDepthTestDistance;\n\n  if (this._minimumDisableDepthTestDistance === Number.POSITIVE_INFINITY) {\n    this._minimumDisableDepthTestDistance = -1.0;\n  }\n};\n\nfunction cleanViewport(uniformState) {\n  if (uniformState._viewportDirty) {\n    var v = uniformState._viewport;\n    Matrix4.computeOrthographicOffCenter(v.x, v.x + v.width, v.y, v.y + v.height, 0.0, 1.0, uniformState._viewportOrthographicMatrix);\n    Matrix4.computeViewportTransformation(v, 0.0, 1.0, uniformState._viewportTransformation);\n    uniformState._viewportDirty = false;\n  }\n}\n\nfunction cleanInverseProjection(uniformState) {\n  if (uniformState._inverseProjectionDirty) {\n    uniformState._inverseProjectionDirty = false;\n\n    if (uniformState._mode !== SceneMode.SCENE2D && uniformState._mode !== SceneMode.MORPHING && !uniformState._orthographicIn3D) {\n      Matrix4.inverse(uniformState._projection, uniformState._inverseProjection);\n    } else {\n      Matrix4.clone(Matrix4.ZERO, uniformState._inverseProjection);\n    }\n  }\n} // Derived\n\n\nfunction cleanModelView(uniformState) {\n  if (uniformState._modelViewDirty) {\n    uniformState._modelViewDirty = false;\n    Matrix4.multiplyTransformation(uniformState._view, uniformState._model, uniformState._modelView);\n  }\n}\n\nfunction cleanModelView3D(uniformState) {\n  if (uniformState._modelView3DDirty) {\n    uniformState._modelView3DDirty = false;\n    Matrix4.multiplyTransformation(uniformState.view3D, uniformState._model, uniformState._modelView3D);\n  }\n}\n\nfunction cleanInverseModelView(uniformState) {\n  if (uniformState._inverseModelViewDirty) {\n    uniformState._inverseModelViewDirty = false;\n    Matrix4.inverse(uniformState.modelView, uniformState._inverseModelView);\n  }\n}\n\nfunction cleanInverseModelView3D(uniformState) {\n  if (uniformState._inverseModelView3DDirty) {\n    uniformState._inverseModelView3DDirty = false;\n    Matrix4.inverse(uniformState.modelView3D, uniformState._inverseModelView3D);\n  }\n}\n\nfunction cleanViewProjection(uniformState) {\n  if (uniformState._viewProjectionDirty) {\n    uniformState._viewProjectionDirty = false;\n    Matrix4.multiply(uniformState._projection, uniformState._view, uniformState._viewProjection);\n  }\n}\n\nfunction cleanInverseViewProjection(uniformState) {\n  if (uniformState._inverseViewProjectionDirty) {\n    uniformState._inverseViewProjectionDirty = false;\n    Matrix4.inverse(uniformState.viewProjection, uniformState._inverseViewProjection);\n  }\n}\n\nfunction cleanModelViewProjection(uniformState) {\n  if (uniformState._modelViewProjectionDirty) {\n    uniformState._modelViewProjectionDirty = false;\n    Matrix4.multiply(uniformState._projection, uniformState.modelView, uniformState._modelViewProjection);\n  }\n}\n\nfunction cleanModelViewRelativeToEye(uniformState) {\n  if (uniformState._modelViewRelativeToEyeDirty) {\n    uniformState._modelViewRelativeToEyeDirty = false;\n    var mv = uniformState.modelView;\n    var mvRte = uniformState._modelViewRelativeToEye;\n    mvRte[0] = mv[0];\n    mvRte[1] = mv[1];\n    mvRte[2] = mv[2];\n    mvRte[3] = mv[3];\n    mvRte[4] = mv[4];\n    mvRte[5] = mv[5];\n    mvRte[6] = mv[6];\n    mvRte[7] = mv[7];\n    mvRte[8] = mv[8];\n    mvRte[9] = mv[9];\n    mvRte[10] = mv[10];\n    mvRte[11] = mv[11];\n    mvRte[12] = 0.0;\n    mvRte[13] = 0.0;\n    mvRte[14] = 0.0;\n    mvRte[15] = mv[15];\n  }\n}\n\nfunction cleanInverseModelViewProjection(uniformState) {\n  if (uniformState._inverseModelViewProjectionDirty) {\n    uniformState._inverseModelViewProjectionDirty = false;\n    Matrix4.inverse(uniformState.modelViewProjection, uniformState._inverseModelViewProjection);\n  }\n}\n\nfunction cleanModelViewProjectionRelativeToEye(uniformState) {\n  if (uniformState._modelViewProjectionRelativeToEyeDirty) {\n    uniformState._modelViewProjectionRelativeToEyeDirty = false;\n    Matrix4.multiply(uniformState._projection, uniformState.modelViewRelativeToEye, uniformState._modelViewProjectionRelativeToEye);\n  }\n}\n\nfunction cleanModelViewInfiniteProjection(uniformState) {\n  if (uniformState._modelViewInfiniteProjectionDirty) {\n    uniformState._modelViewInfiniteProjectionDirty = false;\n    Matrix4.multiply(uniformState._infiniteProjection, uniformState.modelView, uniformState._modelViewInfiniteProjection);\n  }\n}\n\nfunction cleanNormal(uniformState) {\n  if (uniformState._normalDirty) {\n    uniformState._normalDirty = false;\n    var m = uniformState._normal;\n    Matrix4.getMatrix3(uniformState.inverseModelView, m);\n    Matrix3.getRotation(m, m);\n    Matrix3.transpose(m, m);\n  }\n}\n\nfunction cleanNormal3D(uniformState) {\n  if (uniformState._normal3DDirty) {\n    uniformState._normal3DDirty = false;\n    var m = uniformState._normal3D;\n    Matrix4.getMatrix3(uniformState.inverseModelView3D, m);\n    Matrix3.getRotation(m, m);\n    Matrix3.transpose(m, m);\n  }\n}\n\nfunction cleanInverseNormal(uniformState) {\n  if (uniformState._inverseNormalDirty) {\n    uniformState._inverseNormalDirty = false;\n    Matrix4.getMatrix3(uniformState.inverseModelView, uniformState._inverseNormal);\n    Matrix3.getRotation(uniformState._inverseNormal, uniformState._inverseNormal);\n  }\n}\n\nfunction cleanInverseNormal3D(uniformState) {\n  if (uniformState._inverseNormal3DDirty) {\n    uniformState._inverseNormal3DDirty = false;\n    Matrix4.getMatrix3(uniformState.inverseModelView3D, uniformState._inverseNormal3D);\n    Matrix3.getRotation(uniformState._inverseNormal3D, uniformState._inverseNormal3D);\n  }\n}\n\nvar cameraPositionMC = new Cartesian3();\n\nfunction cleanEncodedCameraPositionMC(uniformState) {\n  if (uniformState._encodedCameraPositionMCDirty) {\n    uniformState._encodedCameraPositionMCDirty = false;\n    Matrix4.multiplyByPoint(uniformState.inverseModel, uniformState._cameraPosition, cameraPositionMC);\n    EncodedCartesian3.fromCartesian(cameraPositionMC, uniformState._encodedCameraPositionMC);\n  }\n}\n\nvar view2Dto3DPScratch = new Cartesian3();\nvar view2Dto3DRScratch = new Cartesian3();\nvar view2Dto3DUScratch = new Cartesian3();\nvar view2Dto3DDScratch = new Cartesian3();\nvar view2Dto3DCartographicScratch = new Cartographic();\nvar view2Dto3DCartesian3Scratch = new Cartesian3();\nvar view2Dto3DMatrix4Scratch = new Matrix4();\n\nfunction view2Dto3D(position2D, direction2D, right2D, up2D, frustum2DWidth, mode, projection, result) {\n  // The camera position and directions are expressed in the 2D coordinate system where the Y axis is to the East,\n  // the Z axis is to the North, and the X axis is out of the map.  Express them instead in the ENU axes where\n  // X is to the East, Y is to the North, and Z is out of the local horizontal plane.\n  var p = view2Dto3DPScratch;\n  p.x = position2D.y;\n  p.y = position2D.z;\n  p.z = position2D.x;\n  var r = view2Dto3DRScratch;\n  r.x = right2D.y;\n  r.y = right2D.z;\n  r.z = right2D.x;\n  var u = view2Dto3DUScratch;\n  u.x = up2D.y;\n  u.y = up2D.z;\n  u.z = up2D.x;\n  var d = view2Dto3DDScratch;\n  d.x = direction2D.y;\n  d.y = direction2D.z;\n  d.z = direction2D.x; // In 2D, the camera height is always 12.7 million meters.\n  // The apparent height is equal to half the frustum width.\n\n  if (mode === SceneMode.SCENE2D) {\n    p.z = frustum2DWidth * 0.5;\n  } // Compute the equivalent camera position in the real (3D) world.\n  // In 2D and Columbus View, the camera can travel outside the projection, and when it does so\n  // there's not really any corresponding location in the real world.  So clamp the unprojected\n  // longitude and latitude to their valid ranges.\n\n\n  var cartographic = projection.unproject(p, view2Dto3DCartographicScratch);\n  cartographic.longitude = CesiumMath.clamp(cartographic.longitude, -Math.PI, Math.PI);\n  cartographic.latitude = CesiumMath.clamp(cartographic.latitude, -CesiumMath.PI_OVER_TWO, CesiumMath.PI_OVER_TWO);\n  var ellipsoid = projection.ellipsoid;\n  var position3D = ellipsoid.cartographicToCartesian(cartographic, view2Dto3DCartesian3Scratch); // Compute the rotation from the local ENU at the real world camera position to the fixed axes.\n\n  var enuToFixed = Transforms.eastNorthUpToFixedFrame(position3D, ellipsoid, view2Dto3DMatrix4Scratch); // Transform each camera direction to the fixed axes.\n\n  Matrix4.multiplyByPointAsVector(enuToFixed, r, r);\n  Matrix4.multiplyByPointAsVector(enuToFixed, u, u);\n  Matrix4.multiplyByPointAsVector(enuToFixed, d, d); // Compute the view matrix based on the new fixed-frame camera position and directions.\n\n  if (!defined(result)) {\n    result = new Matrix4();\n  }\n\n  result[0] = r.x;\n  result[1] = u.x;\n  result[2] = -d.x;\n  result[3] = 0.0;\n  result[4] = r.y;\n  result[5] = u.y;\n  result[6] = -d.y;\n  result[7] = 0.0;\n  result[8] = r.z;\n  result[9] = u.z;\n  result[10] = -d.z;\n  result[11] = 0.0;\n  result[12] = -Cartesian3.dot(r, position3D);\n  result[13] = -Cartesian3.dot(u, position3D);\n  result[14] = Cartesian3.dot(d, position3D);\n  result[15] = 1.0;\n  return result;\n}\n\nfunction updateView3D(that) {\n  if (that._view3DDirty) {\n    if (that._mode === SceneMode.SCENE3D) {\n      Matrix4.clone(that._view, that._view3D);\n    } else {\n      view2Dto3D(that._cameraPosition, that._cameraDirection, that._cameraRight, that._cameraUp, that._frustum2DWidth, that._mode, that._mapProjection, that._view3D);\n    }\n\n    Matrix4.getMatrix3(that._view3D, that._viewRotation3D);\n    that._view3DDirty = false;\n  }\n}\n\nfunction updateInverseView3D(that) {\n  if (that._inverseView3DDirty) {\n    Matrix4.inverseTransformation(that.view3D, that._inverseView3D);\n    Matrix4.getMatrix3(that._inverseView3D, that._inverseViewRotation3D);\n    that._inverseView3DDirty = false;\n  }\n}\n\nexport default UniformState;","map":{"version":3,"sources":["/home/usuario/davi/thalamus/wms/3dmaptestes/leaflet_cesium/client/node_modules/cesium/Source/Renderer/UniformState.js"],"names":["BoundingRectangle","Cartesian2","Cartesian3","Cartesian4","Cartographic","Color","defaultValue","defined","Ellipsoid","EncodedCartesian3","CesiumMath","Matrix3","Matrix4","OrthographicFrustum","Simon1994PlanetaryPositions","Transforms","SceneMode","SunLight","UniformState","globeDepthTexture","undefined","gamma","_viewport","_viewportCartesian4","_viewportDirty","_viewportOrthographicMatrix","clone","IDENTITY","_viewportTransformation","_model","_view","_inverseView","_projection","_infiniteProjection","_entireFrustum","_currentFrustum","_frustumPlanes","_farDepthFromNearPlusOne","_log2FarDepthFromNearPlusOne","_oneOverLog2FarDepthFromNearPlusOne","_frameState","_temeToPseudoFixed","_view3DDirty","_view3D","_inverseView3DDirty","_inverseView3D","_inverseModelDirty","_inverseModel","_inverseTransposeModelDirty","_inverseTransposeModel","_viewRotation","_inverseViewRotation","_viewRotation3D","_inverseViewRotation3D","_inverseProjectionDirty","_inverseProjection","_modelViewDirty","_modelView","_modelView3DDirty","_modelView3D","_modelViewRelativeToEyeDirty","_modelViewRelativeToEye","_inverseModelViewDirty","_inverseModelView","_inverseModelView3DDirty","_inverseModelView3D","_viewProjectionDirty","_viewProjection","_inverseViewProjectionDirty","_inverseViewProjection","_modelViewProjectionDirty","_modelViewProjection","_inverseModelViewProjectionDirty","_inverseModelViewProjection","_modelViewProjectionRelativeToEyeDirty","_modelViewProjectionRelativeToEye","_modelViewInfiniteProjectionDirty","_modelViewInfiniteProjection","_normalDirty","_normal","_normal3DDirty","_normal3D","_inverseNormalDirty","_inverseNormal","_inverseNormal3DDirty","_inverseNormal3D","_encodedCameraPositionMCDirty","_encodedCameraPositionMC","_cameraPosition","_sunPositionWC","_sunPositionColumbusView","_sunDirectionWC","_sunDirectionEC","_moonDirectionEC","_lightDirectionWC","_lightDirectionEC","_lightColor","_lightColorHdr","_pass","_mode","_mapProjection","_ellipsoid","_cameraDirection","_cameraRight","_cameraUp","_frustum2DWidth","_eyeHeight","_eyeHeight2D","_pixelRatio","_orthographicIn3D","_backgroundColor","_brdfLut","_environmentMap","_sphericalHarmonicCoefficients","_specularEnvironmentMaps","_specularEnvironmentMapsDimensions","_specularEnvironmentMapsMaximumLOD","_fogDensity","_invertClassificationColor","_imagerySplitPosition","_pixelSizePerMeter","_geometricToleranceOverMeter","_minimumDisableDepthTestDistance","Object","defineProperties","prototype","frameState","get","viewport","set","equals","v","vc","x","y","z","width","w","height","viewportCartesian4","viewportOrthographic","cleanViewport","viewportTransformation","model","matrix","inverseModel","inverse","inverseTransposeModel","m","getMatrix3","transpose","view","view3D","updateView3D","viewRotation","viewRotation3D","inverseView","inverseView3D","updateInverseView3D","inverseViewRotation","inverseViewRotation3D","projection","inverseProjection","cleanInverseProjection","infiniteProjection","modelView","cleanModelView","modelView3D","cleanModelView3D","modelViewRelativeToEye","cleanModelViewRelativeToEye","inverseModelView","cleanInverseModelView","inverseModelView3D","cleanInverseModelView3D","viewProjection","cleanViewProjection","inverseViewProjection","cleanInverseViewProjection","modelViewProjection","cleanModelViewProjection","inverseModelViewProjection","cleanInverseModelViewProjection","modelViewProjectionRelativeToEye","cleanModelViewProjectionRelativeToEye","modelViewInfiniteProjection","cleanModelViewInfiniteProjection","normal","cleanNormal","normal3D","cleanNormal3D","inverseNormal","cleanInverseNormal","inverseNormal3D","cleanInverseNormal3D","entireFrustum","currentFrustum","frustumPlanes","farDepthFromNearPlusOne","log2FarDepthFromNearPlusOne","oneOverLog2FarDepthFromNearPlusOne","eyeHeight","eyeHeight2D","sunPositionWC","sunPositionColumbusView","sunDirectionWC","sunDirectionEC","moonDirectionEC","lightDirectionWC","lightDirectionEC","lightColor","lightColorHdr","encodedCameraPositionMCHigh","cleanEncodedCameraPositionMC","high","encodedCameraPositionMCLow","low","temeToPseudoFixedMatrix","pixelRatio","fogDensity","geometricToleranceOverMeter","pass","backgroundColor","brdfLut","environmentMap","sphericalHarmonicCoefficients","specularEnvironmentMaps","specularEnvironmentMapsDimensions","specularEnvironmentMapsMaximumLOD","imagerySplitPosition","minimumDisableDepthTestDistance","invertClassificationColor","orthographicIn3D","ellipsoid","WGS84","setView","uniformState","setInverseView","setProjection","setInfiniteProjection","setCamera","camera","positionWC","directionWC","rightWC","upWC","positionCartographic","maximumRadius","transformMatrix","sunCartographicScratch","setSunAndMoonDirections","computeIcrfToFixedMatrix","time","computeTemeToPseudoFixedMatrix","position","computeSunPositionInEarthInertialFrame","multiplyByVector","normalize","computeMoonPositionInEarthInertialFrame","mapProjection","sunCartographic","cartesianToCartographic","project","updateCamera","viewMatrix","inverseViewMatrix","frustum","near","far","updateFrustum","SCENE2D","projectionMatrix","infiniteProjectionMatrix","log2","_offCenterFrustum","top","bottom","left","right","updatePass","EMPTY_ARRAY","defaultLight","update","mode","light","negate","direction","color","fromElements","red","green","blue","multiplyByScalar","intensity","maximumComponent","divideByScalar","brdfLutGenerator","colorTexture","context","defaultCubeMap","dimensions","fog","density","drawingBufferWidth","fov","pixelSizePerMeter","Math","tan","max","maximumScreenSpaceError","Number","POSITIVE_INFINITY","computeOrthographicOffCenter","computeViewportTransformation","MORPHING","ZERO","multiplyTransformation","multiply","mv","mvRte","getRotation","cameraPositionMC","multiplyByPoint","fromCartesian","view2Dto3DPScratch","view2Dto3DRScratch","view2Dto3DUScratch","view2Dto3DDScratch","view2Dto3DCartographicScratch","view2Dto3DCartesian3Scratch","view2Dto3DMatrix4Scratch","view2Dto3D","position2D","direction2D","right2D","up2D","frustum2DWidth","result","p","r","u","d","cartographic","unproject","longitude","clamp","PI","latitude","PI_OVER_TWO","position3D","cartographicToCartesian","enuToFixed","eastNorthUpToFixedFrame","multiplyByPointAsVector","dot","that","SCENE3D","inverseTransformation"],"mappings":"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","sourcesContent":["import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Color from \"../Core/Color.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport EncodedCartesian3 from \"../Core/EncodedCartesian3.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport Simon1994PlanetaryPositions from \"../Core/Simon1994PlanetaryPositions.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport SceneMode from \"../Scene/SceneMode.js\";\nimport SunLight from \"../Scene/SunLight.js\";\n\n/**\n * @private\n * @constructor\n */\nfunction UniformState() {\n  /**\n   * @type {Texture}\n   */\n  this.globeDepthTexture = undefined;\n  /**\n   * @type {Number}\n   */\n  this.gamma = undefined;\n\n  this._viewport = new BoundingRectangle();\n  this._viewportCartesian4 = new Cartesian4();\n  this._viewportDirty = false;\n  this._viewportOrthographicMatrix = Matrix4.clone(Matrix4.IDENTITY);\n  this._viewportTransformation = Matrix4.clone(Matrix4.IDENTITY);\n\n  this._model = Matrix4.clone(Matrix4.IDENTITY);\n  this._view = Matrix4.clone(Matrix4.IDENTITY);\n  this._inverseView = Matrix4.clone(Matrix4.IDENTITY);\n  this._projection = Matrix4.clone(Matrix4.IDENTITY);\n  this._infiniteProjection = Matrix4.clone(Matrix4.IDENTITY);\n  this._entireFrustum = new Cartesian2();\n  this._currentFrustum = new Cartesian2();\n  this._frustumPlanes = new Cartesian4();\n  this._farDepthFromNearPlusOne = undefined;\n  this._log2FarDepthFromNearPlusOne = undefined;\n  this._oneOverLog2FarDepthFromNearPlusOne = undefined;\n\n  this._frameState = undefined;\n  this._temeToPseudoFixed = Matrix3.clone(Matrix4.IDENTITY);\n\n  // Derived members\n  this._view3DDirty = true;\n  this._view3D = new Matrix4();\n\n  this._inverseView3DDirty = true;\n  this._inverseView3D = new Matrix4();\n\n  this._inverseModelDirty = true;\n  this._inverseModel = new Matrix4();\n\n  this._inverseTransposeModelDirty = true;\n  this._inverseTransposeModel = new Matrix3();\n\n  this._viewRotation = new Matrix3();\n  this._inverseViewRotation = new Matrix3();\n\n  this._viewRotation3D = new Matrix3();\n  this._inverseViewRotation3D = new Matrix3();\n\n  this._inverseProjectionDirty = true;\n  this._inverseProjection = new Matrix4();\n\n  this._modelViewDirty = true;\n  this._modelView = new Matrix4();\n\n  this._modelView3DDirty = true;\n  this._modelView3D = new Matrix4();\n\n  this._modelViewRelativeToEyeDirty = true;\n  this._modelViewRelativeToEye = new Matrix4();\n\n  this._inverseModelViewDirty = true;\n  this._inverseModelView = new Matrix4();\n\n  this._inverseModelView3DDirty = true;\n  this._inverseModelView3D = new Matrix4();\n\n  this._viewProjectionDirty = true;\n  this._viewProjection = new Matrix4();\n\n  this._inverseViewProjectionDirty = true;\n  this._inverseViewProjection = new Matrix4();\n\n  this._modelViewProjectionDirty = true;\n  this._modelViewProjection = new Matrix4();\n\n  this._inverseModelViewProjectionDirty = true;\n  this._inverseModelViewProjection = new Matrix4();\n\n  this._modelViewProjectionRelativeToEyeDirty = true;\n  this._modelViewProjectionRelativeToEye = new Matrix4();\n\n  this._modelViewInfiniteProjectionDirty = true;\n  this._modelViewInfiniteProjection = new Matrix4();\n\n  this._normalDirty = true;\n  this._normal = new Matrix3();\n\n  this._normal3DDirty = true;\n  this._normal3D = new Matrix3();\n\n  this._inverseNormalDirty = true;\n  this._inverseNormal = new Matrix3();\n\n  this._inverseNormal3DDirty = true;\n  this._inverseNormal3D = new Matrix3();\n\n  this._encodedCameraPositionMCDirty = true;\n  this._encodedCameraPositionMC = new EncodedCartesian3();\n  this._cameraPosition = new Cartesian3();\n\n  this._sunPositionWC = new Cartesian3();\n  this._sunPositionColumbusView = new Cartesian3();\n  this._sunDirectionWC = new Cartesian3();\n  this._sunDirectionEC = new Cartesian3();\n  this._moonDirectionEC = new Cartesian3();\n\n  this._lightDirectionWC = new Cartesian3();\n  this._lightDirectionEC = new Cartesian3();\n  this._lightColor = new Cartesian3();\n  this._lightColorHdr = new Cartesian3();\n\n  this._pass = undefined;\n  this._mode = undefined;\n  this._mapProjection = undefined;\n  this._ellipsoid = undefined;\n  this._cameraDirection = new Cartesian3();\n  this._cameraRight = new Cartesian3();\n  this._cameraUp = new Cartesian3();\n  this._frustum2DWidth = 0.0;\n  this._eyeHeight = 0.0;\n  this._eyeHeight2D = new Cartesian2();\n  this._pixelRatio = 1.0;\n  this._orthographicIn3D = false;\n  this._backgroundColor = new Color();\n\n  this._brdfLut = undefined;\n  this._environmentMap = undefined;\n\n  this._sphericalHarmonicCoefficients = undefined;\n  this._specularEnvironmentMaps = undefined;\n  this._specularEnvironmentMapsDimensions = new Cartesian2();\n  this._specularEnvironmentMapsMaximumLOD = undefined;\n\n  this._fogDensity = undefined;\n\n  this._invertClassificationColor = undefined;\n\n  this._imagerySplitPosition = 0.0;\n  this._pixelSizePerMeter = undefined;\n  this._geometricToleranceOverMeter = undefined;\n\n  this._minimumDisableDepthTestDistance = undefined;\n}\n\nObject.defineProperties(UniformState.prototype, {\n  /**\n   * @memberof UniformState.prototype\n   * @type {FrameState}\n   * @readonly\n   */\n  frameState: {\n    get: function () {\n      return this._frameState;\n    },\n  },\n  /**\n   * @memberof UniformState.prototype\n   * @type {BoundingRectangle}\n   */\n  viewport: {\n    get: function () {\n      return this._viewport;\n    },\n    set: function (viewport) {\n      if (!BoundingRectangle.equals(viewport, this._viewport)) {\n        BoundingRectangle.clone(viewport, this._viewport);\n\n        var v = this._viewport;\n        var vc = this._viewportCartesian4;\n        vc.x = v.x;\n        vc.y = v.y;\n        vc.z = v.width;\n        vc.w = v.height;\n\n        this._viewportDirty = true;\n      }\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @private\n   */\n  viewportCartesian4: {\n    get: function () {\n      return this._viewportCartesian4;\n    },\n  },\n\n  viewportOrthographic: {\n    get: function () {\n      cleanViewport(this);\n      return this._viewportOrthographicMatrix;\n    },\n  },\n\n  viewportTransformation: {\n    get: function () {\n      cleanViewport(this);\n      return this._viewportTransformation;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  model: {\n    get: function () {\n      return this._model;\n    },\n    set: function (matrix) {\n      Matrix4.clone(matrix, this._model);\n\n      this._modelView3DDirty = true;\n      this._inverseModelView3DDirty = true;\n      this._inverseModelDirty = true;\n      this._inverseTransposeModelDirty = true;\n      this._modelViewDirty = true;\n      this._inverseModelViewDirty = true;\n      this._modelViewRelativeToEyeDirty = true;\n      this._inverseModelViewDirty = true;\n      this._modelViewProjectionDirty = true;\n      this._inverseModelViewProjectionDirty = true;\n      this._modelViewProjectionRelativeToEyeDirty = true;\n      this._modelViewInfiniteProjectionDirty = true;\n      this._normalDirty = true;\n      this._inverseNormalDirty = true;\n      this._normal3DDirty = true;\n      this._inverseNormal3DDirty = true;\n      this._encodedCameraPositionMCDirty = true;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseModel: {\n    get: function () {\n      if (this._inverseModelDirty) {\n        this._inverseModelDirty = false;\n\n        Matrix4.inverse(this._model, this._inverseModel);\n      }\n\n      return this._inverseModel;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @private\n   */\n  inverseTransposeModel: {\n    get: function () {\n      var m = this._inverseTransposeModel;\n      if (this._inverseTransposeModelDirty) {\n        this._inverseTransposeModelDirty = false;\n\n        Matrix4.getMatrix3(this.inverseModel, m);\n        Matrix3.transpose(m, m);\n      }\n\n      return m;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  view: {\n    get: function () {\n      return this._view;\n    },\n  },\n\n  /**\n   * The 3D view matrix.  In 3D mode, this is identical to {@link UniformState#view},\n   * but in 2D and Columbus View it is a synthetic matrix based on the equivalent position\n   * of the camera in the 3D world.\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  view3D: {\n    get: function () {\n      updateView3D(this);\n      return this._view3D;\n    },\n  },\n\n  /**\n   * The 3x3 rotation matrix of the current view matrix ({@link UniformState#view}).\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  viewRotation: {\n    get: function () {\n      updateView3D(this);\n      return this._viewRotation;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  viewRotation3D: {\n    get: function () {\n      updateView3D(this);\n      return this._viewRotation3D;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseView: {\n    get: function () {\n      return this._inverseView;\n    },\n  },\n\n  /**\n   * the 4x4 inverse-view matrix that transforms from eye to 3D world coordinates.  In 3D mode, this is\n   * identical to {@link UniformState#inverseView}, but in 2D and Columbus View it is a synthetic matrix\n   * based on the equivalent position of the camera in the 3D world.\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseView3D: {\n    get: function () {\n      updateInverseView3D(this);\n      return this._inverseView3D;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  inverseViewRotation: {\n    get: function () {\n      return this._inverseViewRotation;\n    },\n  },\n\n  /**\n   * The 3x3 rotation matrix of the current 3D inverse-view matrix ({@link UniformState#inverseView3D}).\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  inverseViewRotation3D: {\n    get: function () {\n      updateInverseView3D(this);\n      return this._inverseViewRotation3D;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  projection: {\n    get: function () {\n      return this._projection;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseProjection: {\n    get: function () {\n      cleanInverseProjection(this);\n      return this._inverseProjection;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  infiniteProjection: {\n    get: function () {\n      return this._infiniteProjection;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelView: {\n    get: function () {\n      cleanModelView(this);\n      return this._modelView;\n    },\n  },\n\n  /**\n   * The 3D model-view matrix.  In 3D mode, this is equivalent to {@link UniformState#modelView}.  In 2D and\n   * Columbus View, however, it is a synthetic matrix based on the equivalent position of the camera in the 3D world.\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelView3D: {\n    get: function () {\n      cleanModelView3D(this);\n      return this._modelView3D;\n    },\n  },\n\n  /**\n   * Model-view relative to eye matrix.\n   *\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelViewRelativeToEye: {\n    get: function () {\n      cleanModelViewRelativeToEye(this);\n      return this._modelViewRelativeToEye;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseModelView: {\n    get: function () {\n      cleanInverseModelView(this);\n      return this._inverseModelView;\n    },\n  },\n\n  /**\n   * The inverse of the 3D model-view matrix.  In 3D mode, this is equivalent to {@link UniformState#inverseModelView}.\n   * In 2D and Columbus View, however, it is a synthetic matrix based on the equivalent position of the camera in the 3D world.\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseModelView3D: {\n    get: function () {\n      cleanInverseModelView3D(this);\n      return this._inverseModelView3D;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  viewProjection: {\n    get: function () {\n      cleanViewProjection(this);\n      return this._viewProjection;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseViewProjection: {\n    get: function () {\n      cleanInverseViewProjection(this);\n      return this._inverseViewProjection;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelViewProjection: {\n    get: function () {\n      cleanModelViewProjection(this);\n      return this._modelViewProjection;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  inverseModelViewProjection: {\n    get: function () {\n      cleanInverseModelViewProjection(this);\n      return this._inverseModelViewProjection;\n    },\n  },\n\n  /**\n   * Model-view-projection relative to eye matrix.\n   *\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelViewProjectionRelativeToEye: {\n    get: function () {\n      cleanModelViewProjectionRelativeToEye(this);\n      return this._modelViewProjectionRelativeToEye;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Matrix4}\n   */\n  modelViewInfiniteProjection: {\n    get: function () {\n      cleanModelViewInfiniteProjection(this);\n      return this._modelViewInfiniteProjection;\n    },\n  },\n\n  /**\n   * A 3x3 normal transformation matrix that transforms normal vectors in model coordinates to\n   * eye coordinates.\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  normal: {\n    get: function () {\n      cleanNormal(this);\n      return this._normal;\n    },\n  },\n\n  /**\n   * A 3x3 normal transformation matrix that transforms normal vectors in 3D model\n   * coordinates to eye coordinates.  In 3D mode, this is identical to\n   * {@link UniformState#normal}, but in 2D and Columbus View it represents the normal transformation\n   * matrix as if the camera were at an equivalent location in 3D mode.\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  normal3D: {\n    get: function () {\n      cleanNormal3D(this);\n      return this._normal3D;\n    },\n  },\n\n  /**\n   * An inverse 3x3 normal transformation matrix that transforms normal vectors in model coordinates\n   * to eye coordinates.\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  inverseNormal: {\n    get: function () {\n      cleanInverseNormal(this);\n      return this._inverseNormal;\n    },\n  },\n\n  /**\n   * An inverse 3x3 normal transformation matrix that transforms normal vectors in eye coordinates\n   * to 3D model coordinates.  In 3D mode, this is identical to\n   * {@link UniformState#inverseNormal}, but in 2D and Columbus View it represents the normal transformation\n   * matrix as if the camera were at an equivalent location in 3D mode.\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  inverseNormal3D: {\n    get: function () {\n      cleanInverseNormal3D(this);\n      return this._inverseNormal3D;\n    },\n  },\n\n  /**\n   * The near distance (<code>x</code>) and the far distance (<code>y</code>) of the frustum defined by the camera.\n   * This is the largest possible frustum, not an individual frustum used for multi-frustum rendering.\n   * @memberof UniformState.prototype\n   * @type {Cartesian2}\n   */\n  entireFrustum: {\n    get: function () {\n      return this._entireFrustum;\n    },\n  },\n\n  /**\n   * The near distance (<code>x</code>) and the far distance (<code>y</code>) of the frustum defined by the camera.\n   * This is the individual frustum used for multi-frustum rendering.\n   * @memberof UniformState.prototype\n   * @type {Cartesian2}\n   */\n  currentFrustum: {\n    get: function () {\n      return this._currentFrustum;\n    },\n  },\n\n  /**\n   * The distances to the frustum planes. The top, bottom, left and right distances are\n   * the x, y, z, and w components, respectively.\n   * @memberof UniformState.prototype\n   * @type {Cartesian4}\n   */\n  frustumPlanes: {\n    get: function () {\n      return this._frustumPlanes;\n    },\n  },\n\n  /**\n   * The far plane's distance from the near plane, plus 1.0.\n   *\n   * @memberof UniformState.prototype\n   * @type {Number}\n   */\n  farDepthFromNearPlusOne: {\n    get: function () {\n      return this._farDepthFromNearPlusOne;\n    },\n  },\n\n  /**\n   * The log2 of {@link UniformState#farDepthFromNearPlusOne}.\n   *\n   * @memberof UniformState.prototype\n   * @type {Number}\n   */\n  log2FarDepthFromNearPlusOne: {\n    get: function () {\n      return this._log2FarDepthFromNearPlusOne;\n    },\n  },\n\n  /**\n   * 1.0 divided by {@link UniformState#log2FarDepthFromNearPlusOne}.\n   *\n   * @memberof UniformState.prototype\n   * @type {Number}\n   */\n  oneOverLog2FarDepthFromNearPlusOne: {\n    get: function () {\n      return this._oneOverLog2FarDepthFromNearPlusOne;\n    },\n  },\n\n  /**\n   * The height in meters of the eye (camera) above or below the ellipsoid.\n   * @memberof UniformState.prototype\n   * @type {Number}\n   */\n  eyeHeight: {\n    get: function () {\n      return this._eyeHeight;\n    },\n  },\n\n  /**\n   * The height (<code>x</code>) and the height squared (<code>y</code>)\n   * in meters of the eye (camera) above the 2D world plane. This uniform is only valid\n   * when the {@link SceneMode} is <code>SCENE2D</code>.\n   * @memberof UniformState.prototype\n   * @type {Cartesian2}\n   */\n  eyeHeight2D: {\n    get: function () {\n      return this._eyeHeight2D;\n    },\n  },\n\n  /**\n   * The sun position in 3D world coordinates at the current scene time.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  sunPositionWC: {\n    get: function () {\n      return this._sunPositionWC;\n    },\n  },\n\n  /**\n   * The sun position in 2D world coordinates at the current scene time.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  sunPositionColumbusView: {\n    get: function () {\n      return this._sunPositionColumbusView;\n    },\n  },\n\n  /**\n   * A normalized vector to the sun in 3D world coordinates at the current scene time.  Even in 2D or\n   * Columbus View mode, this returns the direction to the sun in the 3D scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  sunDirectionWC: {\n    get: function () {\n      return this._sunDirectionWC;\n    },\n  },\n\n  /**\n   * A normalized vector to the sun in eye coordinates at the current scene time.  In 3D mode, this\n   * returns the actual vector from the camera position to the sun position.  In 2D and Columbus View, it returns\n   * the vector from the equivalent 3D camera position to the position of the sun in the 3D scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  sunDirectionEC: {\n    get: function () {\n      return this._sunDirectionEC;\n    },\n  },\n\n  /**\n   * A normalized vector to the moon in eye coordinates at the current scene time.  In 3D mode, this\n   * returns the actual vector from the camera position to the moon position.  In 2D and Columbus View, it returns\n   * the vector from the equivalent 3D camera position to the position of the moon in the 3D scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  moonDirectionEC: {\n    get: function () {\n      return this._moonDirectionEC;\n    },\n  },\n\n  /**\n   * A normalized vector to the scene's light source in 3D world coordinates.  Even in 2D or\n   * Columbus View mode, this returns the direction to the light in the 3D scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  lightDirectionWC: {\n    get: function () {\n      return this._lightDirectionWC;\n    },\n  },\n\n  /**\n   * A normalized vector to the scene's light source in eye coordinates.  In 3D mode, this\n   * returns the actual vector from the camera position to the light.  In 2D and Columbus View, it returns\n   * the vector from the equivalent 3D camera position in the 3D scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  lightDirectionEC: {\n    get: function () {\n      return this._lightDirectionEC;\n    },\n  },\n\n  /**\n   * The color of light emitted by the scene's light source. This is equivalent to the light\n   * color multiplied by the light intensity limited to a maximum luminance of 1.0 suitable\n   * for non-HDR lighting.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  lightColor: {\n    get: function () {\n      return this._lightColor;\n    },\n  },\n\n  /**\n   * The high dynamic range color of light emitted by the scene's light source. This is equivalent to\n   * the light color multiplied by the light intensity suitable for HDR lighting.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  lightColorHdr: {\n    get: function () {\n      return this._lightColorHdr;\n    },\n  },\n\n  /**\n   * The high bits of the camera position.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  encodedCameraPositionMCHigh: {\n    get: function () {\n      cleanEncodedCameraPositionMC(this);\n      return this._encodedCameraPositionMC.high;\n    },\n  },\n\n  /**\n   * The low bits of the camera position.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3}\n   */\n  encodedCameraPositionMCLow: {\n    get: function () {\n      cleanEncodedCameraPositionMC(this);\n      return this._encodedCameraPositionMC.low;\n    },\n  },\n\n  /**\n   * A 3x3 matrix that transforms from True Equator Mean Equinox (TEME) axes to the\n   * pseudo-fixed axes at the Scene's current time.\n   * @memberof UniformState.prototype\n   * @type {Matrix3}\n   */\n  temeToPseudoFixedMatrix: {\n    get: function () {\n      return this._temeToPseudoFixed;\n    },\n  },\n\n  /**\n   * Gets the scaling factor for transforming from the canvas\n   * pixel space to canvas coordinate space.\n   * @memberof UniformState.prototype\n   * @type {Number}\n   */\n  pixelRatio: {\n    get: function () {\n      return this._pixelRatio;\n    },\n  },\n\n  /**\n   * A scalar used to mix a color with the fog color based on the distance to the camera.\n   * @memberof UniformState.prototype\n   * @type {Number}\n   */\n  fogDensity: {\n    get: function () {\n      return this._fogDensity;\n    },\n  },\n\n  /**\n   * A scalar that represents the geometric tolerance per meter\n   * @memberof UniformState.prototype\n   * @type {Number}\n   */\n  geometricToleranceOverMeter: {\n    get: function () {\n      return this._geometricToleranceOverMeter;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Pass}\n   */\n  pass: {\n    get: function () {\n      return this._pass;\n    },\n  },\n\n  /**\n   * The current background color\n   * @memberof UniformState.prototype\n   * @type {Color}\n   */\n  backgroundColor: {\n    get: function () {\n      return this._backgroundColor;\n    },\n  },\n\n  /**\n   * The look up texture used to find the BRDF for a material\n   * @memberof UniformState.prototype\n   * @type {Texture}\n   */\n  brdfLut: {\n    get: function () {\n      return this._brdfLut;\n    },\n  },\n\n  /**\n   * The environment map of the scene\n   * @memberof UniformState.prototype\n   * @type {CubeMap}\n   */\n  environmentMap: {\n    get: function () {\n      return this._environmentMap;\n    },\n  },\n\n  /**\n   * The spherical harmonic coefficients of the scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian3[]}\n   */\n  sphericalHarmonicCoefficients: {\n    get: function () {\n      return this._sphericalHarmonicCoefficients;\n    },\n  },\n\n  /**\n   * The specular environment map atlas of the scene.\n   * @memberof UniformState.prototype\n   * @type {Texture}\n   */\n  specularEnvironmentMaps: {\n    get: function () {\n      return this._specularEnvironmentMaps;\n    },\n  },\n\n  /**\n   * The dimensions of the specular environment map atlas of the scene.\n   * @memberof UniformState.prototype\n   * @type {Cartesian2}\n   */\n  specularEnvironmentMapsDimensions: {\n    get: function () {\n      return this._specularEnvironmentMapsDimensions;\n    },\n  },\n\n  /**\n   * The maximum level-of-detail of the specular environment map atlas of the scene.\n   * @memberof UniformState.prototype\n   * @type {Number}\n   */\n  specularEnvironmentMapsMaximumLOD: {\n    get: function () {\n      return this._specularEnvironmentMapsMaximumLOD;\n    },\n  },\n\n  /**\n   * @memberof UniformState.prototype\n   * @type {Number}\n   */\n  imagerySplitPosition: {\n    get: function () {\n      return this._imagerySplitPosition;\n    },\n  },\n\n  /**\n   * The distance from the camera at which to disable the depth test of billboards, labels and points\n   * to, for example, prevent clipping against terrain. When set to zero, the depth test should always\n   * be applied. When less than zero, the depth test should never be applied.\n   *\n   * @memberof UniformState.prototype\n   * @type {Number}\n   */\n  minimumDisableDepthTestDistance: {\n    get: function () {\n      return this._minimumDisableDepthTestDistance;\n    },\n  },\n\n  /**\n   * The highlight color of unclassified 3D Tiles.\n   *\n   * @memberof UniformState.prototype\n   * @type {Color}\n   */\n  invertClassificationColor: {\n    get: function () {\n      return this._invertClassificationColor;\n    },\n  },\n\n  /**\n   * Whether or not the current projection is orthographic in 3D.\n   *\n   * @memberOf UniformState.prototype\n   * @type {Boolean}\n   */\n  orthographicIn3D: {\n    get: function () {\n      return this._orthographicIn3D;\n    },\n  },\n\n  /**\n   * The current ellipsoid.\n   *\n   * @memberOf UniformState.prototype\n   * @type {Ellipsoid}\n   */\n  ellipsoid: {\n    get: function () {\n      return defaultValue(this._ellipsoid, Ellipsoid.WGS84);\n    },\n  },\n});\n\nfunction setView(uniformState, matrix) {\n  Matrix4.clone(matrix, uniformState._view);\n  Matrix4.getMatrix3(matrix, uniformState._viewRotation);\n\n  uniformState._view3DDirty = true;\n  uniformState._inverseView3DDirty = true;\n  uniformState._modelViewDirty = true;\n  uniformState._modelView3DDirty = true;\n  uniformState._modelViewRelativeToEyeDirty = true;\n  uniformState._inverseModelViewDirty = true;\n  uniformState._inverseModelView3DDirty = true;\n  uniformState._viewProjectionDirty = true;\n  uniformState._inverseViewProjectionDirty = true;\n  uniformState._modelViewProjectionDirty = true;\n  uniformState._modelViewProjectionRelativeToEyeDirty = true;\n  uniformState._modelViewInfiniteProjectionDirty = true;\n  uniformState._normalDirty = true;\n  uniformState._inverseNormalDirty = true;\n  uniformState._normal3DDirty = true;\n  uniformState._inverseNormal3DDirty = true;\n}\n\nfunction setInverseView(uniformState, matrix) {\n  Matrix4.clone(matrix, uniformState._inverseView);\n  Matrix4.getMatrix3(matrix, uniformState._inverseViewRotation);\n}\n\nfunction setProjection(uniformState, matrix) {\n  Matrix4.clone(matrix, uniformState._projection);\n\n  uniformState._inverseProjectionDirty = true;\n  uniformState._viewProjectionDirty = true;\n  uniformState._inverseViewProjectionDirty = true;\n  uniformState._modelViewProjectionDirty = true;\n  uniformState._modelViewProjectionRelativeToEyeDirty = true;\n}\n\nfunction setInfiniteProjection(uniformState, matrix) {\n  Matrix4.clone(matrix, uniformState._infiniteProjection);\n\n  uniformState._modelViewInfiniteProjectionDirty = true;\n}\n\nfunction setCamera(uniformState, camera) {\n  Cartesian3.clone(camera.positionWC, uniformState._cameraPosition);\n  Cartesian3.clone(camera.directionWC, uniformState._cameraDirection);\n  Cartesian3.clone(camera.rightWC, uniformState._cameraRight);\n  Cartesian3.clone(camera.upWC, uniformState._cameraUp);\n\n  var positionCartographic = camera.positionCartographic;\n  if (!defined(positionCartographic)) {\n    uniformState._eyeHeight = -uniformState._ellipsoid.maximumRadius;\n  } else {\n    uniformState._eyeHeight = positionCartographic.height;\n  }\n\n  uniformState._encodedCameraPositionMCDirty = true;\n}\n\nvar transformMatrix = new Matrix3();\nvar sunCartographicScratch = new Cartographic();\nfunction setSunAndMoonDirections(uniformState, frameState) {\n  if (\n    !defined(\n      Transforms.computeIcrfToFixedMatrix(frameState.time, transformMatrix)\n    )\n  ) {\n    transformMatrix = Transforms.computeTemeToPseudoFixedMatrix(\n      frameState.time,\n      transformMatrix\n    );\n  }\n\n  var position = Simon1994PlanetaryPositions.computeSunPositionInEarthInertialFrame(\n    frameState.time,\n    uniformState._sunPositionWC\n  );\n  Matrix3.multiplyByVector(transformMatrix, position, position);\n\n  Cartesian3.normalize(position, uniformState._sunDirectionWC);\n\n  position = Matrix3.multiplyByVector(\n    uniformState.viewRotation3D,\n    position,\n    uniformState._sunDirectionEC\n  );\n  Cartesian3.normalize(position, position);\n\n  position = Simon1994PlanetaryPositions.computeMoonPositionInEarthInertialFrame(\n    frameState.time,\n    uniformState._moonDirectionEC\n  );\n  Matrix3.multiplyByVector(transformMatrix, position, position);\n  Matrix3.multiplyByVector(uniformState.viewRotation3D, position, position);\n  Cartesian3.normalize(position, position);\n\n  var projection = frameState.mapProjection;\n  var ellipsoid = projection.ellipsoid;\n  var sunCartographic = ellipsoid.cartesianToCartographic(\n    uniformState._sunPositionWC,\n    sunCartographicScratch\n  );\n  projection.project(sunCartographic, uniformState._sunPositionColumbusView);\n}\n\n/**\n * Synchronizes the frustum's state with the camera state.  This is called\n * by the {@link Scene} when rendering to ensure that automatic GLSL uniforms\n * are set to the right value.\n *\n * @param {Object} camera The camera to synchronize with.\n */\nUniformState.prototype.updateCamera = function (camera) {\n  setView(this, camera.viewMatrix);\n  setInverseView(this, camera.inverseViewMatrix);\n  setCamera(this, camera);\n\n  this._entireFrustum.x = camera.frustum.near;\n  this._entireFrustum.y = camera.frustum.far;\n  this.updateFrustum(camera.frustum);\n\n  this._orthographicIn3D =\n    this._mode !== SceneMode.SCENE2D &&\n    camera.frustum instanceof OrthographicFrustum;\n};\n\n/**\n * Synchronizes the frustum's state with the uniform state.  This is called\n * by the {@link Scene} when rendering to ensure that automatic GLSL uniforms\n * are set to the right value.\n *\n * @param {Object} frustum The frustum to synchronize with.\n */\nUniformState.prototype.updateFrustum = function (frustum) {\n  setProjection(this, frustum.projectionMatrix);\n  if (defined(frustum.infiniteProjectionMatrix)) {\n    setInfiniteProjection(this, frustum.infiniteProjectionMatrix);\n  }\n  this._currentFrustum.x = frustum.near;\n  this._currentFrustum.y = frustum.far;\n\n  this._farDepthFromNearPlusOne = frustum.far - frustum.near + 1.0;\n  this._log2FarDepthFromNearPlusOne = CesiumMath.log2(\n    this._farDepthFromNearPlusOne\n  );\n  this._oneOverLog2FarDepthFromNearPlusOne =\n    1.0 / this._log2FarDepthFromNearPlusOne;\n\n  if (defined(frustum._offCenterFrustum)) {\n    frustum = frustum._offCenterFrustum;\n  }\n\n  this._frustumPlanes.x = frustum.top;\n  this._frustumPlanes.y = frustum.bottom;\n  this._frustumPlanes.z = frustum.left;\n  this._frustumPlanes.w = frustum.right;\n};\n\nUniformState.prototype.updatePass = function (pass) {\n  this._pass = pass;\n};\n\nvar EMPTY_ARRAY = [];\nvar defaultLight = new SunLight();\n\n/**\n * Synchronizes frame state with the uniform state.  This is called\n * by the {@link Scene} when rendering to ensure that automatic GLSL uniforms\n * are set to the right value.\n *\n * @param {FrameState} frameState The frameState to synchronize with.\n */\nUniformState.prototype.update = function (frameState) {\n  this._mode = frameState.mode;\n  this._mapProjection = frameState.mapProjection;\n  this._ellipsoid = frameState.mapProjection.ellipsoid;\n  this._pixelRatio = frameState.pixelRatio;\n\n  var camera = frameState.camera;\n  this.updateCamera(camera);\n\n  if (frameState.mode === SceneMode.SCENE2D) {\n    this._frustum2DWidth = camera.frustum.right - camera.frustum.left;\n    this._eyeHeight2D.x = this._frustum2DWidth * 0.5;\n    this._eyeHeight2D.y = this._eyeHeight2D.x * this._eyeHeight2D.x;\n  } else {\n    this._frustum2DWidth = 0.0;\n    this._eyeHeight2D.x = 0.0;\n    this._eyeHeight2D.y = 0.0;\n  }\n\n  setSunAndMoonDirections(this, frameState);\n\n  var light = defaultValue(frameState.light, defaultLight);\n  if (light instanceof SunLight) {\n    this._lightDirectionWC = Cartesian3.clone(\n      this._sunDirectionWC,\n      this._lightDirectionWC\n    );\n    this._lightDirectionEC = Cartesian3.clone(\n      this._sunDirectionEC,\n      this._lightDirectionEC\n    );\n  } else {\n    this._lightDirectionWC = Cartesian3.normalize(\n      Cartesian3.negate(light.direction, this._lightDirectionWC),\n      this._lightDirectionWC\n    );\n    this._lightDirectionEC = Matrix3.multiplyByVector(\n      this.viewRotation3D,\n      this._lightDirectionWC,\n      this._lightDirectionEC\n    );\n  }\n\n  var lightColor = light.color;\n  var lightColorHdr = Cartesian3.fromElements(\n    lightColor.red,\n    lightColor.green,\n    lightColor.blue,\n    this._lightColorHdr\n  );\n  lightColorHdr = Cartesian3.multiplyByScalar(\n    lightColorHdr,\n    light.intensity,\n    lightColorHdr\n  );\n  var maximumComponent = Cartesian3.maximumComponent(lightColorHdr);\n  if (maximumComponent > 1.0) {\n    Cartesian3.divideByScalar(\n      lightColorHdr,\n      maximumComponent,\n      this._lightColor\n    );\n  } else {\n    Cartesian3.clone(lightColorHdr, this._lightColor);\n  }\n\n  var brdfLutGenerator = frameState.brdfLutGenerator;\n  var brdfLut = defined(brdfLutGenerator)\n    ? brdfLutGenerator.colorTexture\n    : undefined;\n  this._brdfLut = brdfLut;\n\n  this._environmentMap = defaultValue(\n    frameState.environmentMap,\n    frameState.context.defaultCubeMap\n  );\n\n  // IE 11 doesn't optimize out uniforms that are #ifdef'd out. So undefined values for the spherical harmonic\n  // coefficients and specular environment map atlas dimensions cause a crash.\n  this._sphericalHarmonicCoefficients = defaultValue(\n    frameState.sphericalHarmonicCoefficients,\n    EMPTY_ARRAY\n  );\n  this._specularEnvironmentMaps = frameState.specularEnvironmentMaps;\n  this._specularEnvironmentMapsMaximumLOD =\n    frameState.specularEnvironmentMapsMaximumLOD;\n\n  if (defined(this._specularEnvironmentMaps)) {\n    Cartesian2.clone(\n      this._specularEnvironmentMaps.dimensions,\n      this._specularEnvironmentMapsDimensions\n    );\n  }\n\n  this._fogDensity = frameState.fog.density;\n\n  this._invertClassificationColor = frameState.invertClassificationColor;\n\n  this._frameState = frameState;\n  this._temeToPseudoFixed = Transforms.computeTemeToPseudoFixedMatrix(\n    frameState.time,\n    this._temeToPseudoFixed\n  );\n\n  // Convert the relative imagerySplitPosition to absolute pixel coordinates\n  this._imagerySplitPosition =\n    frameState.imagerySplitPosition * frameState.context.drawingBufferWidth;\n  var fov = camera.frustum.fov;\n  var viewport = this._viewport;\n  var pixelSizePerMeter;\n  if (defined(fov)) {\n    if (viewport.height > viewport.width) {\n      pixelSizePerMeter = (Math.tan(0.5 * fov) * 2.0) / viewport.height;\n    } else {\n      pixelSizePerMeter = (Math.tan(0.5 * fov) * 2.0) / viewport.width;\n    }\n  } else {\n    pixelSizePerMeter = 1.0 / Math.max(viewport.width, viewport.height);\n  }\n\n  this._geometricToleranceOverMeter =\n    pixelSizePerMeter * frameState.maximumScreenSpaceError;\n  Color.clone(frameState.backgroundColor, this._backgroundColor);\n\n  this._minimumDisableDepthTestDistance =\n    frameState.minimumDisableDepthTestDistance;\n  this._minimumDisableDepthTestDistance *= this._minimumDisableDepthTestDistance;\n  if (this._minimumDisableDepthTestDistance === Number.POSITIVE_INFINITY) {\n    this._minimumDisableDepthTestDistance = -1.0;\n  }\n};\n\nfunction cleanViewport(uniformState) {\n  if (uniformState._viewportDirty) {\n    var v = uniformState._viewport;\n    Matrix4.computeOrthographicOffCenter(\n      v.x,\n      v.x + v.width,\n      v.y,\n      v.y + v.height,\n      0.0,\n      1.0,\n      uniformState._viewportOrthographicMatrix\n    );\n    Matrix4.computeViewportTransformation(\n      v,\n      0.0,\n      1.0,\n      uniformState._viewportTransformation\n    );\n    uniformState._viewportDirty = false;\n  }\n}\n\nfunction cleanInverseProjection(uniformState) {\n  if (uniformState._inverseProjectionDirty) {\n    uniformState._inverseProjectionDirty = false;\n\n    if (\n      uniformState._mode !== SceneMode.SCENE2D &&\n      uniformState._mode !== SceneMode.MORPHING &&\n      !uniformState._orthographicIn3D\n    ) {\n      Matrix4.inverse(\n        uniformState._projection,\n        uniformState._inverseProjection\n      );\n    } else {\n      Matrix4.clone(Matrix4.ZERO, uniformState._inverseProjection);\n    }\n  }\n}\n\n// Derived\nfunction cleanModelView(uniformState) {\n  if (uniformState._modelViewDirty) {\n    uniformState._modelViewDirty = false;\n\n    Matrix4.multiplyTransformation(\n      uniformState._view,\n      uniformState._model,\n      uniformState._modelView\n    );\n  }\n}\n\nfunction cleanModelView3D(uniformState) {\n  if (uniformState._modelView3DDirty) {\n    uniformState._modelView3DDirty = false;\n\n    Matrix4.multiplyTransformation(\n      uniformState.view3D,\n      uniformState._model,\n      uniformState._modelView3D\n    );\n  }\n}\n\nfunction cleanInverseModelView(uniformState) {\n  if (uniformState._inverseModelViewDirty) {\n    uniformState._inverseModelViewDirty = false;\n\n    Matrix4.inverse(uniformState.modelView, uniformState._inverseModelView);\n  }\n}\n\nfunction cleanInverseModelView3D(uniformState) {\n  if (uniformState._inverseModelView3DDirty) {\n    uniformState._inverseModelView3DDirty = false;\n\n    Matrix4.inverse(uniformState.modelView3D, uniformState._inverseModelView3D);\n  }\n}\n\nfunction cleanViewProjection(uniformState) {\n  if (uniformState._viewProjectionDirty) {\n    uniformState._viewProjectionDirty = false;\n\n    Matrix4.multiply(\n      uniformState._projection,\n      uniformState._view,\n      uniformState._viewProjection\n    );\n  }\n}\n\nfunction cleanInverseViewProjection(uniformState) {\n  if (uniformState._inverseViewProjectionDirty) {\n    uniformState._inverseViewProjectionDirty = false;\n\n    Matrix4.inverse(\n      uniformState.viewProjection,\n      uniformState._inverseViewProjection\n    );\n  }\n}\n\nfunction cleanModelViewProjection(uniformState) {\n  if (uniformState._modelViewProjectionDirty) {\n    uniformState._modelViewProjectionDirty = false;\n\n    Matrix4.multiply(\n      uniformState._projection,\n      uniformState.modelView,\n      uniformState._modelViewProjection\n    );\n  }\n}\n\nfunction cleanModelViewRelativeToEye(uniformState) {\n  if (uniformState._modelViewRelativeToEyeDirty) {\n    uniformState._modelViewRelativeToEyeDirty = false;\n\n    var mv = uniformState.modelView;\n    var mvRte = uniformState._modelViewRelativeToEye;\n    mvRte[0] = mv[0];\n    mvRte[1] = mv[1];\n    mvRte[2] = mv[2];\n    mvRte[3] = mv[3];\n    mvRte[4] = mv[4];\n    mvRte[5] = mv[5];\n    mvRte[6] = mv[6];\n    mvRte[7] = mv[7];\n    mvRte[8] = mv[8];\n    mvRte[9] = mv[9];\n    mvRte[10] = mv[10];\n    mvRte[11] = mv[11];\n    mvRte[12] = 0.0;\n    mvRte[13] = 0.0;\n    mvRte[14] = 0.0;\n    mvRte[15] = mv[15];\n  }\n}\n\nfunction cleanInverseModelViewProjection(uniformState) {\n  if (uniformState._inverseModelViewProjectionDirty) {\n    uniformState._inverseModelViewProjectionDirty = false;\n\n    Matrix4.inverse(\n      uniformState.modelViewProjection,\n      uniformState._inverseModelViewProjection\n    );\n  }\n}\n\nfunction cleanModelViewProjectionRelativeToEye(uniformState) {\n  if (uniformState._modelViewProjectionRelativeToEyeDirty) {\n    uniformState._modelViewProjectionRelativeToEyeDirty = false;\n\n    Matrix4.multiply(\n      uniformState._projection,\n      uniformState.modelViewRelativeToEye,\n      uniformState._modelViewProjectionRelativeToEye\n    );\n  }\n}\n\nfunction cleanModelViewInfiniteProjection(uniformState) {\n  if (uniformState._modelViewInfiniteProjectionDirty) {\n    uniformState._modelViewInfiniteProjectionDirty = false;\n\n    Matrix4.multiply(\n      uniformState._infiniteProjection,\n      uniformState.modelView,\n      uniformState._modelViewInfiniteProjection\n    );\n  }\n}\n\nfunction cleanNormal(uniformState) {\n  if (uniformState._normalDirty) {\n    uniformState._normalDirty = false;\n\n    var m = uniformState._normal;\n    Matrix4.getMatrix3(uniformState.inverseModelView, m);\n    Matrix3.getRotation(m, m);\n    Matrix3.transpose(m, m);\n  }\n}\n\nfunction cleanNormal3D(uniformState) {\n  if (uniformState._normal3DDirty) {\n    uniformState._normal3DDirty = false;\n\n    var m = uniformState._normal3D;\n    Matrix4.getMatrix3(uniformState.inverseModelView3D, m);\n    Matrix3.getRotation(m, m);\n    Matrix3.transpose(m, m);\n  }\n}\n\nfunction cleanInverseNormal(uniformState) {\n  if (uniformState._inverseNormalDirty) {\n    uniformState._inverseNormalDirty = false;\n    Matrix4.getMatrix3(\n      uniformState.inverseModelView,\n      uniformState._inverseNormal\n    );\n    Matrix3.getRotation(\n      uniformState._inverseNormal,\n      uniformState._inverseNormal\n    );\n  }\n}\n\nfunction cleanInverseNormal3D(uniformState) {\n  if (uniformState._inverseNormal3DDirty) {\n    uniformState._inverseNormal3DDirty = false;\n    Matrix4.getMatrix3(\n      uniformState.inverseModelView3D,\n      uniformState._inverseNormal3D\n    );\n    Matrix3.getRotation(\n      uniformState._inverseNormal3D,\n      uniformState._inverseNormal3D\n    );\n  }\n}\n\nvar cameraPositionMC = new Cartesian3();\n\nfunction cleanEncodedCameraPositionMC(uniformState) {\n  if (uniformState._encodedCameraPositionMCDirty) {\n    uniformState._encodedCameraPositionMCDirty = false;\n\n    Matrix4.multiplyByPoint(\n      uniformState.inverseModel,\n      uniformState._cameraPosition,\n      cameraPositionMC\n    );\n    EncodedCartesian3.fromCartesian(\n      cameraPositionMC,\n      uniformState._encodedCameraPositionMC\n    );\n  }\n}\n\nvar view2Dto3DPScratch = new Cartesian3();\nvar view2Dto3DRScratch = new Cartesian3();\nvar view2Dto3DUScratch = new Cartesian3();\nvar view2Dto3DDScratch = new Cartesian3();\nvar view2Dto3DCartographicScratch = new Cartographic();\nvar view2Dto3DCartesian3Scratch = new Cartesian3();\nvar view2Dto3DMatrix4Scratch = new Matrix4();\n\nfunction view2Dto3D(\n  position2D,\n  direction2D,\n  right2D,\n  up2D,\n  frustum2DWidth,\n  mode,\n  projection,\n  result\n) {\n  // The camera position and directions are expressed in the 2D coordinate system where the Y axis is to the East,\n  // the Z axis is to the North, and the X axis is out of the map.  Express them instead in the ENU axes where\n  // X is to the East, Y is to the North, and Z is out of the local horizontal plane.\n  var p = view2Dto3DPScratch;\n  p.x = position2D.y;\n  p.y = position2D.z;\n  p.z = position2D.x;\n\n  var r = view2Dto3DRScratch;\n  r.x = right2D.y;\n  r.y = right2D.z;\n  r.z = right2D.x;\n\n  var u = view2Dto3DUScratch;\n  u.x = up2D.y;\n  u.y = up2D.z;\n  u.z = up2D.x;\n\n  var d = view2Dto3DDScratch;\n  d.x = direction2D.y;\n  d.y = direction2D.z;\n  d.z = direction2D.x;\n\n  // In 2D, the camera height is always 12.7 million meters.\n  // The apparent height is equal to half the frustum width.\n  if (mode === SceneMode.SCENE2D) {\n    p.z = frustum2DWidth * 0.5;\n  }\n\n  // Compute the equivalent camera position in the real (3D) world.\n  // In 2D and Columbus View, the camera can travel outside the projection, and when it does so\n  // there's not really any corresponding location in the real world.  So clamp the unprojected\n  // longitude and latitude to their valid ranges.\n  var cartographic = projection.unproject(p, view2Dto3DCartographicScratch);\n  cartographic.longitude = CesiumMath.clamp(\n    cartographic.longitude,\n    -Math.PI,\n    Math.PI\n  );\n  cartographic.latitude = CesiumMath.clamp(\n    cartographic.latitude,\n    -CesiumMath.PI_OVER_TWO,\n    CesiumMath.PI_OVER_TWO\n  );\n  var ellipsoid = projection.ellipsoid;\n  var position3D = ellipsoid.cartographicToCartesian(\n    cartographic,\n    view2Dto3DCartesian3Scratch\n  );\n\n  // Compute the rotation from the local ENU at the real world camera position to the fixed axes.\n  var enuToFixed = Transforms.eastNorthUpToFixedFrame(\n    position3D,\n    ellipsoid,\n    view2Dto3DMatrix4Scratch\n  );\n\n  // Transform each camera direction to the fixed axes.\n  Matrix4.multiplyByPointAsVector(enuToFixed, r, r);\n  Matrix4.multiplyByPointAsVector(enuToFixed, u, u);\n  Matrix4.multiplyByPointAsVector(enuToFixed, d, d);\n\n  // Compute the view matrix based on the new fixed-frame camera position and directions.\n  if (!defined(result)) {\n    result = new Matrix4();\n  }\n\n  result[0] = r.x;\n  result[1] = u.x;\n  result[2] = -d.x;\n  result[3] = 0.0;\n  result[4] = r.y;\n  result[5] = u.y;\n  result[6] = -d.y;\n  result[7] = 0.0;\n  result[8] = r.z;\n  result[9] = u.z;\n  result[10] = -d.z;\n  result[11] = 0.0;\n  result[12] = -Cartesian3.dot(r, position3D);\n  result[13] = -Cartesian3.dot(u, position3D);\n  result[14] = Cartesian3.dot(d, position3D);\n  result[15] = 1.0;\n\n  return result;\n}\n\nfunction updateView3D(that) {\n  if (that._view3DDirty) {\n    if (that._mode === SceneMode.SCENE3D) {\n      Matrix4.clone(that._view, that._view3D);\n    } else {\n      view2Dto3D(\n        that._cameraPosition,\n        that._cameraDirection,\n        that._cameraRight,\n        that._cameraUp,\n        that._frustum2DWidth,\n        that._mode,\n        that._mapProjection,\n        that._view3D\n      );\n    }\n    Matrix4.getMatrix3(that._view3D, that._viewRotation3D);\n    that._view3DDirty = false;\n  }\n}\n\nfunction updateInverseView3D(that) {\n  if (that._inverseView3DDirty) {\n    Matrix4.inverseTransformation(that.view3D, that._inverseView3D);\n    Matrix4.getMatrix3(that._inverseView3D, that._inverseViewRotation3D);\n    that._inverseView3DDirty = false;\n  }\n}\nexport default UniformState;\n"]},"metadata":{},"sourceType":"module"}