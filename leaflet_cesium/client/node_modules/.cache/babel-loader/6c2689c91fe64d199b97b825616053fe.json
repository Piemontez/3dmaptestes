{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defined from \"../Core/defined.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport Geometry from \"../Core/Geometry.js\";\nimport GeometryAttribute from \"../Core/GeometryAttribute.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport DepthPlaneFS from \"../Shaders/DepthPlaneFS.js\";\nimport DepthPlaneVS from \"../Shaders/DepthPlaneVS.js\";\nimport SceneMode from \"./SceneMode.js\";\n/**\n * @private\n */\n\nfunction DepthPlane() {\n  this._rs = undefined;\n  this._sp = undefined;\n  this._va = undefined;\n  this._command = undefined;\n  this._mode = undefined;\n  this._useLogDepth = false;\n}\n\nvar depthQuadScratch = FeatureDetection.supportsTypedArrays() ? new Float32Array(12) : [];\nvar scratchCartesian1 = new Cartesian3();\nvar scratchCartesian2 = new Cartesian3();\nvar scratchCartesian3 = new Cartesian3();\nvar scratchCartesian4 = new Cartesian3();\nvar scratchCartesian5 = new Cartesian3();\n\nfunction computeDepthQuad(ellipsoid, frameState) {\n  var radii = ellipsoid.radii;\n  var camera = frameState.camera;\n  var center, eastOffset, northOffset;\n\n  if (camera.frustum instanceof OrthographicFrustum) {\n    center = Cartesian3.ZERO;\n    eastOffset = camera.rightWC;\n    northOffset = camera.upWC;\n  } else {\n    var p = camera.positionWC; // Find the corresponding position in the scaled space of the ellipsoid.\n\n    var q = Cartesian3.multiplyComponents(ellipsoid.oneOverRadii, p, scratchCartesian1);\n    var qUnit = Cartesian3.normalize(q, scratchCartesian2); // Determine the east and north directions at q.\n\n    var eUnit = Cartesian3.normalize(Cartesian3.cross(Cartesian3.UNIT_Z, q, scratchCartesian3), scratchCartesian3);\n    var nUnit = Cartesian3.normalize(Cartesian3.cross(qUnit, eUnit, scratchCartesian4), scratchCartesian4);\n    var qMagnitude = Cartesian3.magnitude(q); // Determine the radius of the 'limb' of the ellipsoid.\n\n    var wMagnitude = Math.sqrt(qMagnitude * qMagnitude - 1.0); // Compute the center and offsets.\n\n    center = Cartesian3.multiplyByScalar(qUnit, 1.0 / qMagnitude, scratchCartesian1);\n    var scalar = wMagnitude / qMagnitude;\n    eastOffset = Cartesian3.multiplyByScalar(eUnit, scalar, scratchCartesian2);\n    northOffset = Cartesian3.multiplyByScalar(nUnit, scalar, scratchCartesian3);\n  } // A conservative measure for the longitudes would be to use the min/max longitudes of the bounding frustum.\n\n\n  var upperLeft = Cartesian3.add(center, northOffset, scratchCartesian5);\n  Cartesian3.subtract(upperLeft, eastOffset, upperLeft);\n  Cartesian3.multiplyComponents(radii, upperLeft, upperLeft);\n  Cartesian3.pack(upperLeft, depthQuadScratch, 0);\n  var lowerLeft = Cartesian3.subtract(center, northOffset, scratchCartesian5);\n  Cartesian3.subtract(lowerLeft, eastOffset, lowerLeft);\n  Cartesian3.multiplyComponents(radii, lowerLeft, lowerLeft);\n  Cartesian3.pack(lowerLeft, depthQuadScratch, 3);\n  var upperRight = Cartesian3.add(center, northOffset, scratchCartesian5);\n  Cartesian3.add(upperRight, eastOffset, upperRight);\n  Cartesian3.multiplyComponents(radii, upperRight, upperRight);\n  Cartesian3.pack(upperRight, depthQuadScratch, 6);\n  var lowerRight = Cartesian3.subtract(center, northOffset, scratchCartesian5);\n  Cartesian3.add(lowerRight, eastOffset, lowerRight);\n  Cartesian3.multiplyComponents(radii, lowerRight, lowerRight);\n  Cartesian3.pack(lowerRight, depthQuadScratch, 9);\n  return depthQuadScratch;\n}\n\nDepthPlane.prototype.update = function (frameState) {\n  this._mode = frameState.mode;\n\n  if (frameState.mode !== SceneMode.SCENE3D) {\n    return;\n  }\n\n  var context = frameState.context;\n  var ellipsoid = frameState.mapProjection.ellipsoid;\n  var useLogDepth = frameState.useLogDepth;\n\n  if (!defined(this._command)) {\n    this._rs = RenderState.fromCache({\n      // Write depth, not color\n      cull: {\n        enabled: true\n      },\n      depthTest: {\n        enabled: true\n      },\n      colorMask: {\n        red: false,\n        green: false,\n        blue: false,\n        alpha: false\n      }\n    });\n    this._command = new DrawCommand({\n      renderState: this._rs,\n      boundingVolume: new BoundingSphere(Cartesian3.ZERO, ellipsoid.maximumRadius),\n      pass: Pass.OPAQUE,\n      owner: this\n    });\n  }\n\n  if (!defined(this._sp) || this._useLogDepth !== useLogDepth) {\n    this._useLogDepth = useLogDepth;\n    var vs = new ShaderSource({\n      sources: [DepthPlaneVS]\n    });\n    var fs = new ShaderSource({\n      sources: [DepthPlaneFS]\n    });\n\n    if (useLogDepth) {\n      var extension = \"#ifdef GL_EXT_frag_depth \\n\" + \"#extension GL_EXT_frag_depth : enable \\n\" + \"#endif \\n\\n\";\n      fs.sources.push(extension);\n      fs.defines.push(\"LOG_DEPTH\");\n      vs.defines.push(\"LOG_DEPTH\");\n    }\n\n    this._sp = ShaderProgram.replaceCache({\n      shaderProgram: this._sp,\n      context: context,\n      vertexShaderSource: vs,\n      fragmentShaderSource: fs,\n      attributeLocations: {\n        position: 0\n      }\n    });\n    this._command.shaderProgram = this._sp;\n  } // update depth plane\n\n\n  var depthQuad = computeDepthQuad(ellipsoid, frameState); // depth plane\n\n  if (!defined(this._va)) {\n    var geometry = new Geometry({\n      attributes: {\n        position: new GeometryAttribute({\n          componentDatatype: ComponentDatatype.FLOAT,\n          componentsPerAttribute: 3,\n          values: depthQuad\n        })\n      },\n      indices: [0, 1, 2, 2, 1, 3],\n      primitiveType: PrimitiveType.TRIANGLES\n    });\n    this._va = VertexArray.fromGeometry({\n      context: context,\n      geometry: geometry,\n      attributeLocations: {\n        position: 0\n      },\n      bufferUsage: BufferUsage.DYNAMIC_DRAW\n    });\n    this._command.vertexArray = this._va;\n  } else {\n    this._va.getAttribute(0).vertexBuffer.copyFromArrayView(depthQuad);\n  }\n};\n\nDepthPlane.prototype.execute = function (context, passState) {\n  if (this._mode === SceneMode.SCENE3D) {\n    this._command.execute(context, passState);\n  }\n};\n\nDepthPlane.prototype.isDestroyed = function () {\n  return false;\n};\n\nDepthPlane.prototype.destroy = function () {\n  this._sp = this._sp && this._sp.destroy();\n  this._va = this._va && this._va.destroy();\n};\n\nexport default DepthPlane;","map":{"version":3,"sources":["/home/usuario/davi/thalamus/wms/3dmaptestes/leaflet_cesium/client/node_modules/cesium/Source/Scene/DepthPlane.js"],"names":["BoundingSphere","Cartesian3","ComponentDatatype","defined","FeatureDetection","Geometry","GeometryAttribute","OrthographicFrustum","PrimitiveType","BufferUsage","DrawCommand","Pass","RenderState","ShaderProgram","ShaderSource","VertexArray","DepthPlaneFS","DepthPlaneVS","SceneMode","DepthPlane","_rs","undefined","_sp","_va","_command","_mode","_useLogDepth","depthQuadScratch","supportsTypedArrays","Float32Array","scratchCartesian1","scratchCartesian2","scratchCartesian3","scratchCartesian4","scratchCartesian5","computeDepthQuad","ellipsoid","frameState","radii","camera","center","eastOffset","northOffset","frustum","ZERO","rightWC","upWC","p","positionWC","q","multiplyComponents","oneOverRadii","qUnit","normalize","eUnit","cross","UNIT_Z","nUnit","qMagnitude","magnitude","wMagnitude","Math","sqrt","multiplyByScalar","scalar","upperLeft","add","subtract","pack","lowerLeft","upperRight","lowerRight","prototype","update","mode","SCENE3D","context","mapProjection","useLogDepth","fromCache","cull","enabled","depthTest","colorMask","red","green","blue","alpha","renderState","boundingVolume","maximumRadius","pass","OPAQUE","owner","vs","sources","fs","extension","push","defines","replaceCache","shaderProgram","vertexShaderSource","fragmentShaderSource","attributeLocations","position","depthQuad","geometry","attributes","componentDatatype","FLOAT","componentsPerAttribute","values","indices","primitiveType","TRIANGLES","fromGeometry","bufferUsage","DYNAMIC_DRAW","vertexArray","getAttribute","vertexBuffer","copyFromArrayView","execute","passState","isDestroyed","destroy"],"mappings":"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","sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport ComponentDatatype from \"../Core/ComponentDatatype.js\";\nimport defined from \"../Core/defined.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport Geometry from \"../Core/Geometry.js\";\nimport GeometryAttribute from \"../Core/GeometryAttribute.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport PrimitiveType from \"../Core/PrimitiveType.js\";\nimport BufferUsage from \"../Renderer/BufferUsage.js\";\nimport DrawCommand from \"../Renderer/DrawCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport RenderState from \"../Renderer/RenderState.js\";\nimport ShaderProgram from \"../Renderer/ShaderProgram.js\";\nimport ShaderSource from \"../Renderer/ShaderSource.js\";\nimport VertexArray from \"../Renderer/VertexArray.js\";\nimport DepthPlaneFS from \"../Shaders/DepthPlaneFS.js\";\nimport DepthPlaneVS from \"../Shaders/DepthPlaneVS.js\";\nimport SceneMode from \"./SceneMode.js\";\n\n/**\n * @private\n */\nfunction DepthPlane() {\n  this._rs = undefined;\n  this._sp = undefined;\n  this._va = undefined;\n  this._command = undefined;\n  this._mode = undefined;\n  this._useLogDepth = false;\n}\n\nvar depthQuadScratch = FeatureDetection.supportsTypedArrays()\n  ? new Float32Array(12)\n  : [];\nvar scratchCartesian1 = new Cartesian3();\nvar scratchCartesian2 = new Cartesian3();\nvar scratchCartesian3 = new Cartesian3();\nvar scratchCartesian4 = new Cartesian3();\nvar scratchCartesian5 = new Cartesian3();\n\nfunction computeDepthQuad(ellipsoid, frameState) {\n  var radii = ellipsoid.radii;\n  var camera = frameState.camera;\n  var center, eastOffset, northOffset;\n\n  if (camera.frustum instanceof OrthographicFrustum) {\n    center = Cartesian3.ZERO;\n    eastOffset = camera.rightWC;\n    northOffset = camera.upWC;\n  } else {\n    var p = camera.positionWC;\n\n    // Find the corresponding position in the scaled space of the ellipsoid.\n    var q = Cartesian3.multiplyComponents(\n      ellipsoid.oneOverRadii,\n      p,\n      scratchCartesian1\n    );\n\n    var qUnit = Cartesian3.normalize(q, scratchCartesian2);\n\n    // Determine the east and north directions at q.\n    var eUnit = Cartesian3.normalize(\n      Cartesian3.cross(Cartesian3.UNIT_Z, q, scratchCartesian3),\n      scratchCartesian3\n    );\n    var nUnit = Cartesian3.normalize(\n      Cartesian3.cross(qUnit, eUnit, scratchCartesian4),\n      scratchCartesian4\n    );\n\n    var qMagnitude = Cartesian3.magnitude(q);\n\n    // Determine the radius of the 'limb' of the ellipsoid.\n    var wMagnitude = Math.sqrt(qMagnitude * qMagnitude - 1.0);\n\n    // Compute the center and offsets.\n    center = Cartesian3.multiplyByScalar(\n      qUnit,\n      1.0 / qMagnitude,\n      scratchCartesian1\n    );\n    var scalar = wMagnitude / qMagnitude;\n    eastOffset = Cartesian3.multiplyByScalar(eUnit, scalar, scratchCartesian2);\n    northOffset = Cartesian3.multiplyByScalar(nUnit, scalar, scratchCartesian3);\n  }\n\n  // A conservative measure for the longitudes would be to use the min/max longitudes of the bounding frustum.\n  var upperLeft = Cartesian3.add(center, northOffset, scratchCartesian5);\n  Cartesian3.subtract(upperLeft, eastOffset, upperLeft);\n  Cartesian3.multiplyComponents(radii, upperLeft, upperLeft);\n  Cartesian3.pack(upperLeft, depthQuadScratch, 0);\n\n  var lowerLeft = Cartesian3.subtract(center, northOffset, scratchCartesian5);\n  Cartesian3.subtract(lowerLeft, eastOffset, lowerLeft);\n  Cartesian3.multiplyComponents(radii, lowerLeft, lowerLeft);\n  Cartesian3.pack(lowerLeft, depthQuadScratch, 3);\n\n  var upperRight = Cartesian3.add(center, northOffset, scratchCartesian5);\n  Cartesian3.add(upperRight, eastOffset, upperRight);\n  Cartesian3.multiplyComponents(radii, upperRight, upperRight);\n  Cartesian3.pack(upperRight, depthQuadScratch, 6);\n\n  var lowerRight = Cartesian3.subtract(center, northOffset, scratchCartesian5);\n  Cartesian3.add(lowerRight, eastOffset, lowerRight);\n  Cartesian3.multiplyComponents(radii, lowerRight, lowerRight);\n  Cartesian3.pack(lowerRight, depthQuadScratch, 9);\n\n  return depthQuadScratch;\n}\n\nDepthPlane.prototype.update = function (frameState) {\n  this._mode = frameState.mode;\n  if (frameState.mode !== SceneMode.SCENE3D) {\n    return;\n  }\n\n  var context = frameState.context;\n  var ellipsoid = frameState.mapProjection.ellipsoid;\n  var useLogDepth = frameState.useLogDepth;\n\n  if (!defined(this._command)) {\n    this._rs = RenderState.fromCache({\n      // Write depth, not color\n      cull: {\n        enabled: true,\n      },\n      depthTest: {\n        enabled: true,\n      },\n      colorMask: {\n        red: false,\n        green: false,\n        blue: false,\n        alpha: false,\n      },\n    });\n\n    this._command = new DrawCommand({\n      renderState: this._rs,\n      boundingVolume: new BoundingSphere(\n        Cartesian3.ZERO,\n        ellipsoid.maximumRadius\n      ),\n      pass: Pass.OPAQUE,\n      owner: this,\n    });\n  }\n\n  if (!defined(this._sp) || this._useLogDepth !== useLogDepth) {\n    this._useLogDepth = useLogDepth;\n\n    var vs = new ShaderSource({\n      sources: [DepthPlaneVS],\n    });\n    var fs = new ShaderSource({\n      sources: [DepthPlaneFS],\n    });\n    if (useLogDepth) {\n      var extension =\n        \"#ifdef GL_EXT_frag_depth \\n\" +\n        \"#extension GL_EXT_frag_depth : enable \\n\" +\n        \"#endif \\n\\n\";\n\n      fs.sources.push(extension);\n      fs.defines.push(\"LOG_DEPTH\");\n      vs.defines.push(\"LOG_DEPTH\");\n    }\n\n    this._sp = ShaderProgram.replaceCache({\n      shaderProgram: this._sp,\n      context: context,\n      vertexShaderSource: vs,\n      fragmentShaderSource: fs,\n      attributeLocations: {\n        position: 0,\n      },\n    });\n\n    this._command.shaderProgram = this._sp;\n  }\n\n  // update depth plane\n  var depthQuad = computeDepthQuad(ellipsoid, frameState);\n\n  // depth plane\n  if (!defined(this._va)) {\n    var geometry = new Geometry({\n      attributes: {\n        position: new GeometryAttribute({\n          componentDatatype: ComponentDatatype.FLOAT,\n          componentsPerAttribute: 3,\n          values: depthQuad,\n        }),\n      },\n      indices: [0, 1, 2, 2, 1, 3],\n      primitiveType: PrimitiveType.TRIANGLES,\n    });\n\n    this._va = VertexArray.fromGeometry({\n      context: context,\n      geometry: geometry,\n      attributeLocations: {\n        position: 0,\n      },\n      bufferUsage: BufferUsage.DYNAMIC_DRAW,\n    });\n\n    this._command.vertexArray = this._va;\n  } else {\n    this._va.getAttribute(0).vertexBuffer.copyFromArrayView(depthQuad);\n  }\n};\n\nDepthPlane.prototype.execute = function (context, passState) {\n  if (this._mode === SceneMode.SCENE3D) {\n    this._command.execute(context, passState);\n  }\n};\n\nDepthPlane.prototype.isDestroyed = function () {\n  return false;\n};\n\nDepthPlane.prototype.destroy = function () {\n  this._sp = this._sp && this._sp.destroy();\n  this._va = this._va && this._va.destroy();\n};\nexport default DepthPlane;\n"]},"metadata":{},"sourceType":"module"}