{"ast":null,"code":"import addPipelineExtras from './addPipelineExtras.js';\nimport removeExtensionsUsed from './removeExtensionsUsed.js';\nimport defaultValue from '../../Core/defaultValue.js';\nimport defined from '../../Core/defined.js';\nimport getJsonFromTypedArray from '../../Core/getJsonFromTypedArray.js';\nimport getMagic from '../../Core/getMagic.js';\nimport RuntimeError from '../../Core/RuntimeError.js';\nvar sizeOfUint32 = 4;\n/**\n * Convert a binary glTF to glTF.\n *\n * The returned glTF has pipeline extras included. The embedded binary data is stored in gltf.buffers[0].extras._pipeline.source.\n *\n * @param {Buffer} glb The glb data to parse.\n * @returns {Object} A javascript object containing a glTF asset with pipeline extras included.\n *\n * @private\n */\n\nfunction parseGlb(glb) {\n  // Check that the magic string is present\n  var magic = getMagic(glb);\n\n  if (magic !== 'glTF') {\n    throw new RuntimeError('File is not valid binary glTF');\n  }\n\n  var header = readHeader(glb, 0, 5);\n  var version = header[1];\n\n  if (version !== 1 && version !== 2) {\n    throw new RuntimeError('Binary glTF version is not 1 or 2');\n  }\n\n  if (version === 1) {\n    return parseGlbVersion1(glb, header);\n  }\n\n  return parseGlbVersion2(glb, header);\n}\n\nfunction readHeader(glb, byteOffset, count) {\n  var dataView = new DataView(glb.buffer);\n  var header = new Array(count);\n\n  for (var i = 0; i < count; ++i) {\n    header[i] = dataView.getUint32(glb.byteOffset + byteOffset + i * sizeOfUint32, true);\n  }\n\n  return header;\n}\n\nfunction parseGlbVersion1(glb, header) {\n  var length = header[2];\n  var contentLength = header[3];\n  var contentFormat = header[4]; // Check that the content format is 0, indicating that it is JSON\n\n  if (contentFormat !== 0) {\n    throw new RuntimeError('Binary glTF scene format is not JSON');\n  }\n\n  var jsonStart = 20;\n  var binaryStart = jsonStart + contentLength;\n  var gltf = getJsonFromTypedArray(glb, jsonStart, contentLength);\n  addPipelineExtras(gltf);\n  var binaryBuffer = glb.subarray(binaryStart, length);\n  var buffers = gltf.buffers;\n\n  if (defined(buffers) && Object.keys(buffers).length > 0) {\n    // In some older models, the binary glTF buffer is named KHR_binary_glTF\n    var binaryGltfBuffer = defaultValue(buffers.binary_glTF, buffers.KHR_binary_glTF);\n\n    if (defined(binaryGltfBuffer)) {\n      binaryGltfBuffer.extras._pipeline.source = binaryBuffer;\n    }\n  } // Remove the KHR_binary_glTF extension\n\n\n  removeExtensionsUsed(gltf, 'KHR_binary_glTF');\n  return gltf;\n}\n\nfunction parseGlbVersion2(glb, header) {\n  var length = header[2];\n  var byteOffset = 12;\n  var gltf;\n  var binaryBuffer;\n\n  while (byteOffset < length) {\n    var chunkHeader = readHeader(glb, byteOffset, 2);\n    var chunkLength = chunkHeader[0];\n    var chunkType = chunkHeader[1];\n    byteOffset += 8;\n    var chunkBuffer = glb.subarray(byteOffset, byteOffset + chunkLength);\n    byteOffset += chunkLength; // Load JSON chunk\n\n    if (chunkType === 0x4E4F534A) {\n      gltf = getJsonFromTypedArray(chunkBuffer);\n      addPipelineExtras(gltf);\n    } // Load Binary chunk\n    else if (chunkType === 0x004E4942) {\n        binaryBuffer = chunkBuffer;\n      }\n  }\n\n  if (defined(gltf) && defined(binaryBuffer)) {\n    var buffers = gltf.buffers;\n\n    if (defined(buffers) && buffers.length > 0) {\n      var buffer = buffers[0];\n      buffer.extras._pipeline.source = binaryBuffer;\n    }\n  }\n\n  return gltf;\n}\n\nexport default parseGlb;","map":{"version":3,"sources":["/home/usuario/davi/thalamus/wms/3dmaptestes/leaflet_cesium/client/node_modules/cesium/Source/ThirdParty/GltfPipeline/parseGlb.js"],"names":["addPipelineExtras","removeExtensionsUsed","defaultValue","defined","getJsonFromTypedArray","getMagic","RuntimeError","sizeOfUint32","parseGlb","glb","magic","header","readHeader","version","parseGlbVersion1","parseGlbVersion2","byteOffset","count","dataView","DataView","buffer","Array","i","getUint32","length","contentLength","contentFormat","jsonStart","binaryStart","gltf","binaryBuffer","subarray","buffers","Object","keys","binaryGltfBuffer","binary_glTF","KHR_binary_glTF","extras","_pipeline","source","chunkHeader","chunkLength","chunkType","chunkBuffer"],"mappings":"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","sourcesContent":["import addPipelineExtras from './addPipelineExtras.js'\nimport removeExtensionsUsed from './removeExtensionsUsed.js'\nimport defaultValue from '../../Core/defaultValue.js'\nimport defined from '../../Core/defined.js'\nimport getJsonFromTypedArray from '../../Core/getJsonFromTypedArray.js'\nimport getMagic from '../../Core/getMagic.js'\nimport RuntimeError from '../../Core/RuntimeError.js'\n\n    var sizeOfUint32 = 4;\n\n    /**\n     * Convert a binary glTF to glTF.\n     *\n     * The returned glTF has pipeline extras included. The embedded binary data is stored in gltf.buffers[0].extras._pipeline.source.\n     *\n     * @param {Buffer} glb The glb data to parse.\n     * @returns {Object} A javascript object containing a glTF asset with pipeline extras included.\n     *\n     * @private\n     */\n    function parseGlb(glb) {\n        // Check that the magic string is present\n        var magic = getMagic(glb);\n        if (magic !== 'glTF') {\n            throw new RuntimeError('File is not valid binary glTF');\n        }\n\n        var header = readHeader(glb, 0, 5);\n        var version = header[1];\n        if (version !== 1 && version !== 2) {\n            throw new RuntimeError('Binary glTF version is not 1 or 2');\n        }\n\n        if (version === 1) {\n            return parseGlbVersion1(glb, header);\n        }\n\n        return parseGlbVersion2(glb, header);\n    }\n\n    function readHeader(glb, byteOffset, count) {\n        var dataView = new DataView(glb.buffer);\n        var header = new Array(count);\n        for (var i = 0; i < count; ++i) {\n            header[i] = dataView.getUint32(glb.byteOffset + byteOffset + i * sizeOfUint32, true);\n        }\n        return header;\n    }\n\n    function parseGlbVersion1(glb, header) {\n        var length = header[2];\n        var contentLength = header[3];\n        var contentFormat = header[4];\n\n        // Check that the content format is 0, indicating that it is JSON\n        if (contentFormat !== 0) {\n            throw new RuntimeError('Binary glTF scene format is not JSON');\n        }\n\n        var jsonStart = 20;\n        var binaryStart = jsonStart + contentLength;\n\n        var gltf = getJsonFromTypedArray(glb, jsonStart, contentLength);\n        addPipelineExtras(gltf);\n\n        var binaryBuffer = glb.subarray(binaryStart, length);\n\n        var buffers = gltf.buffers;\n        if (defined(buffers) && Object.keys(buffers).length > 0) {\n            // In some older models, the binary glTF buffer is named KHR_binary_glTF\n            var binaryGltfBuffer = defaultValue(buffers.binary_glTF, buffers.KHR_binary_glTF);\n            if (defined(binaryGltfBuffer)) {\n                binaryGltfBuffer.extras._pipeline.source = binaryBuffer;\n            }\n        }\n        // Remove the KHR_binary_glTF extension\n        removeExtensionsUsed(gltf, 'KHR_binary_glTF');\n        return gltf;\n    }\n\n    function parseGlbVersion2(glb, header) {\n        var length = header[2];\n        var byteOffset = 12;\n        var gltf;\n        var binaryBuffer;\n        while (byteOffset < length) {\n            var chunkHeader = readHeader(glb, byteOffset, 2);\n            var chunkLength = chunkHeader[0];\n            var chunkType = chunkHeader[1];\n            byteOffset += 8;\n            var chunkBuffer = glb.subarray(byteOffset, byteOffset + chunkLength);\n            byteOffset += chunkLength;\n            // Load JSON chunk\n            if (chunkType === 0x4E4F534A) {\n                gltf = getJsonFromTypedArray(chunkBuffer);\n                addPipelineExtras(gltf);\n            }\n            // Load Binary chunk\n            else if (chunkType === 0x004E4942) {\n                binaryBuffer = chunkBuffer;\n            }\n        }\n        if (defined(gltf) && defined(binaryBuffer)) {\n            var buffers = gltf.buffers;\n            if (defined(buffers) && buffers.length > 0) {\n                var buffer = buffers[0];\n                buffer.extras._pipeline.source = binaryBuffer;\n            }\n        }\n        return gltf;\n    }\n\n    export default parseGlb;\n"]},"metadata":{},"sourceType":"module"}