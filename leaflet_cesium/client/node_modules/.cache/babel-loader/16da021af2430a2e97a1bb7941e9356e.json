{"ast":null,"code":"import AttributeCompression from \"../Core/AttributeCompression.js\";\nimport binarySearch from \"../Core/binarySearch.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport HeightmapTerrainData from \"../Core/HeightmapTerrainData.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport Queue from \"../Core/Queue.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport TerrainEncoding from \"../Core/TerrainEncoding.js\";\nimport TerrainMesh from \"../Core/TerrainMesh.js\";\nimport TileEdge from \"../Core/TileEdge.js\";\nimport WebMercatorProjection from \"../Core/WebMercatorProjection.js\";\nimport GlobeSurfaceTile from \"./GlobeSurfaceTile.js\";\nimport TileSelectionResult from \"./TileSelectionResult.js\";\n\nfunction TerrainFillMesh(tile) {\n  this.tile = tile;\n  this.frameLastUpdated = undefined;\n  this.westMeshes = []; // north to south (CCW)\n\n  this.westTiles = [];\n  this.southMeshes = []; // west to east (CCW)\n\n  this.southTiles = [];\n  this.eastMeshes = []; // south to north (CCW)\n\n  this.eastTiles = [];\n  this.northMeshes = []; // east to west (CCW)\n\n  this.northTiles = [];\n  this.southwestMesh = undefined;\n  this.southwestTile = undefined;\n  this.southeastMesh = undefined;\n  this.southeastTile = undefined;\n  this.northwestMesh = undefined;\n  this.northwestTile = undefined;\n  this.northeastMesh = undefined;\n  this.northeastTile = undefined;\n  this.changedThisFrame = true;\n  this.visitedFrame = undefined;\n  this.enqueuedFrame = undefined;\n  this.mesh = undefined;\n  this.vertexArray = undefined;\n  this.waterMaskTexture = undefined;\n  this.waterMaskTranslationAndScale = new Cartesian4();\n}\n\nTerrainFillMesh.prototype.update = function (tileProvider, frameState, vertexArraysToDestroy) {\n  if (this.changedThisFrame) {\n    createFillMesh(tileProvider, frameState, this.tile, vertexArraysToDestroy);\n    this.changedThisFrame = false;\n  }\n};\n\nTerrainFillMesh.prototype.destroy = function (vertexArraysToDestroy) {\n  if (defined(this.vertexArray)) {\n    if (defined(vertexArraysToDestroy)) {\n      vertexArraysToDestroy.push(this.vertexArray);\n    } else {\n      GlobeSurfaceTile._freeVertexArray(this.vertexArray, vertexArraysToDestroy);\n    }\n\n    this.vertexArray = undefined;\n  }\n\n  if (defined(this.waterMaskTexture)) {\n    --this.waterMaskTexture.referenceCount;\n\n    if (this.waterMaskTexture.referenceCount === 0) {\n      this.waterMaskTexture.destroy();\n    }\n\n    this.waterMaskTexture = undefined;\n  }\n\n  return undefined;\n};\n\nvar traversalQueueScratch = new Queue();\n\nTerrainFillMesh.updateFillTiles = function (tileProvider, renderedTiles, frameState, vertexArraysToDestroy) {\n  // We want our fill tiles to look natural, which means they should align perfectly with\n  // adjacent loaded tiles, and their edges that are not adjacent to loaded tiles should have\n  // sensible heights (e.g. the average of the heights of loaded edges). Some fill tiles may\n  // be adjacent only to other fill tiles, and in that case heights should be assigned fanning\n  // outward from the loaded tiles so that there are no sudden changes in height.\n  // We do this with a breadth-first traversal of the rendered tiles, starting with the loaded\n  // ones. Graph nodes are tiles and graph edges connect to other rendered tiles that are spatially adjacent\n  // to those tiles. As we visit each node, we propagate tile edges to adjacent tiles. If there's no data\n  // for a tile edge,  we create an edge with an average height and then propagate it. If an edge is partially defined\n  // (e.g. an edge is adjacent to multiple more-detailed tiles and only some of them are loaded), we\n  // fill in the rest of the edge with the same height.\n  var quadtree = tileProvider._quadtree;\n  var levelZeroTiles = quadtree._levelZeroTiles;\n  var lastSelectionFrameNumber = quadtree._lastSelectionFrameNumber;\n  var traversalQueue = traversalQueueScratch;\n  traversalQueue.clear(); // Add the tiles with real geometry to the traversal queue.\n\n  for (var i = 0; i < renderedTiles.length; ++i) {\n    var renderedTile = renderedTiles[i];\n\n    if (defined(renderedTile.data.vertexArray)) {\n      traversalQueue.enqueue(renderedTiles[i]);\n    }\n  }\n\n  var tile = traversalQueue.dequeue();\n\n  while (tile !== undefined) {\n    var tileToWest = tile.findTileToWest(levelZeroTiles);\n    var tileToSouth = tile.findTileToSouth(levelZeroTiles);\n    var tileToEast = tile.findTileToEast(levelZeroTiles);\n    var tileToNorth = tile.findTileToNorth(levelZeroTiles);\n    visitRenderedTiles(tileProvider, frameState, tile, tileToWest, lastSelectionFrameNumber, TileEdge.EAST, false, traversalQueue, vertexArraysToDestroy);\n    visitRenderedTiles(tileProvider, frameState, tile, tileToSouth, lastSelectionFrameNumber, TileEdge.NORTH, false, traversalQueue, vertexArraysToDestroy);\n    visitRenderedTiles(tileProvider, frameState, tile, tileToEast, lastSelectionFrameNumber, TileEdge.WEST, false, traversalQueue, vertexArraysToDestroy);\n    visitRenderedTiles(tileProvider, frameState, tile, tileToNorth, lastSelectionFrameNumber, TileEdge.SOUTH, false, traversalQueue, vertexArraysToDestroy);\n    var tileToNorthwest = tileToWest.findTileToNorth(levelZeroTiles);\n    var tileToSouthwest = tileToWest.findTileToSouth(levelZeroTiles);\n    var tileToNortheast = tileToEast.findTileToNorth(levelZeroTiles);\n    var tileToSoutheast = tileToEast.findTileToSouth(levelZeroTiles);\n    visitRenderedTiles(tileProvider, frameState, tile, tileToNorthwest, lastSelectionFrameNumber, TileEdge.SOUTHEAST, false, traversalQueue, vertexArraysToDestroy);\n    visitRenderedTiles(tileProvider, frameState, tile, tileToNortheast, lastSelectionFrameNumber, TileEdge.SOUTHWEST, false, traversalQueue, vertexArraysToDestroy);\n    visitRenderedTiles(tileProvider, frameState, tile, tileToSouthwest, lastSelectionFrameNumber, TileEdge.NORTHEAST, false, traversalQueue, vertexArraysToDestroy);\n    visitRenderedTiles(tileProvider, frameState, tile, tileToSoutheast, lastSelectionFrameNumber, TileEdge.NORTHWEST, false, traversalQueue, vertexArraysToDestroy);\n    tile = traversalQueue.dequeue();\n  }\n};\n\nfunction visitRenderedTiles(tileProvider, frameState, sourceTile, startTile, currentFrameNumber, tileEdge, downOnly, traversalQueue, vertexArraysToDestroy) {\n  if (startTile === undefined) {\n    // There are no tiles North or South of the poles.\n    return;\n  }\n\n  var tile = startTile;\n\n  while (tile && (tile._lastSelectionResultFrame !== currentFrameNumber || TileSelectionResult.wasKicked(tile._lastSelectionResult) || TileSelectionResult.originalResult(tile._lastSelectionResult) === TileSelectionResult.CULLED)) {\n    // This tile wasn't visited or it was visited and then kicked, so walk up to find the closest ancestor that was rendered.\n    // We also walk up if the tile was culled, because if siblings were kicked an ancestor may have been rendered.\n    if (downOnly) {\n      return;\n    }\n\n    var parent = tile.parent;\n\n    if (tileEdge >= TileEdge.NORTHWEST && parent !== undefined) {\n      // When we're looking for a corner, verify that the parent tile is still relevant.\n      // That is, the parent and child must share the corner in question.\n      switch (tileEdge) {\n        case TileEdge.NORTHWEST:\n          tile = tile === parent.northwestChild ? parent : undefined;\n          break;\n\n        case TileEdge.NORTHEAST:\n          tile = tile === parent.northeastChild ? parent : undefined;\n          break;\n\n        case TileEdge.SOUTHWEST:\n          tile = tile === parent.southwestChild ? parent : undefined;\n          break;\n\n        case TileEdge.SOUTHEAST:\n          tile = tile === parent.southeastChild ? parent : undefined;\n          break;\n      }\n    } else {\n      tile = parent;\n    }\n  }\n\n  if (tile === undefined) {\n    return;\n  }\n\n  if (tile._lastSelectionResult === TileSelectionResult.RENDERED) {\n    if (defined(tile.data.vertexArray)) {\n      // No further processing necessary for renderable tiles.\n      return;\n    }\n\n    visitTile(tileProvider, frameState, sourceTile, tile, tileEdge, currentFrameNumber, traversalQueue, vertexArraysToDestroy);\n    return;\n  }\n\n  if (TileSelectionResult.originalResult(startTile._lastSelectionResult) === TileSelectionResult.CULLED) {\n    return;\n  } // This tile was refined, so find rendered children, if any.\n  // Visit the tiles in counter-clockwise order.\n\n\n  switch (tileEdge) {\n    case TileEdge.WEST:\n      visitRenderedTiles(tileProvider, frameState, sourceTile, startTile.northwestChild, currentFrameNumber, tileEdge, true, traversalQueue, vertexArraysToDestroy);\n      visitRenderedTiles(tileProvider, frameState, sourceTile, startTile.southwestChild, currentFrameNumber, tileEdge, true, traversalQueue, vertexArraysToDestroy);\n      break;\n\n    case TileEdge.EAST:\n      visitRenderedTiles(tileProvider, frameState, sourceTile, startTile.southeastChild, currentFrameNumber, tileEdge, true, traversalQueue, vertexArraysToDestroy);\n      visitRenderedTiles(tileProvider, frameState, sourceTile, startTile.northeastChild, currentFrameNumber, tileEdge, true, traversalQueue, vertexArraysToDestroy);\n      break;\n\n    case TileEdge.SOUTH:\n      visitRenderedTiles(tileProvider, frameState, sourceTile, startTile.southwestChild, currentFrameNumber, tileEdge, true, traversalQueue, vertexArraysToDestroy);\n      visitRenderedTiles(tileProvider, frameState, sourceTile, startTile.southeastChild, currentFrameNumber, tileEdge, true, traversalQueue, vertexArraysToDestroy);\n      break;\n\n    case TileEdge.NORTH:\n      visitRenderedTiles(tileProvider, frameState, sourceTile, startTile.northeastChild, currentFrameNumber, tileEdge, true, traversalQueue, vertexArraysToDestroy);\n      visitRenderedTiles(tileProvider, frameState, sourceTile, startTile.northwestChild, currentFrameNumber, tileEdge, true, traversalQueue, vertexArraysToDestroy);\n      break;\n\n    case TileEdge.NORTHWEST:\n      visitRenderedTiles(tileProvider, frameState, sourceTile, startTile.northwestChild, currentFrameNumber, tileEdge, true, traversalQueue, vertexArraysToDestroy);\n      break;\n\n    case TileEdge.NORTHEAST:\n      visitRenderedTiles(tileProvider, frameState, sourceTile, startTile.northeastChild, currentFrameNumber, tileEdge, true, traversalQueue, vertexArraysToDestroy);\n      break;\n\n    case TileEdge.SOUTHWEST:\n      visitRenderedTiles(tileProvider, frameState, sourceTile, startTile.southwestChild, currentFrameNumber, tileEdge, true, traversalQueue, vertexArraysToDestroy);\n      break;\n\n    case TileEdge.SOUTHEAST:\n      visitRenderedTiles(tileProvider, frameState, sourceTile, startTile.southeastChild, currentFrameNumber, tileEdge, true, traversalQueue, vertexArraysToDestroy);\n      break;\n\n    default:\n      throw new DeveloperError(\"Invalid edge\");\n  }\n}\n\nfunction visitTile(tileProvider, frameState, sourceTile, destinationTile, tileEdge, frameNumber, traversalQueue, vertexArraysToDestroy) {\n  var destinationSurfaceTile = destinationTile.data;\n\n  if (destinationSurfaceTile.fill === undefined) {\n    destinationSurfaceTile.fill = new TerrainFillMesh(destinationTile);\n  } else if (destinationSurfaceTile.fill.visitedFrame === frameNumber) {\n    // Don't propagate edges to tiles that have already been visited this frame.\n    return;\n  }\n\n  if (destinationSurfaceTile.fill.enqueuedFrame !== frameNumber) {\n    // First time visiting this tile this frame, add it to the traversal queue.\n    destinationSurfaceTile.fill.enqueuedFrame = frameNumber;\n    destinationSurfaceTile.fill.changedThisFrame = false;\n    traversalQueue.enqueue(destinationTile);\n  }\n\n  propagateEdge(tileProvider, frameState, sourceTile, destinationTile, tileEdge, vertexArraysToDestroy);\n}\n\nfunction propagateEdge(tileProvider, frameState, sourceTile, destinationTile, tileEdge, vertexArraysToDestroy) {\n  var destinationFill = destinationTile.data.fill;\n  var sourceMesh;\n  var sourceFill = sourceTile.data.fill;\n\n  if (defined(sourceFill)) {\n    sourceFill.visitedFrame = frameState.frameNumber; // Source is a fill, create/update it if necessary.\n\n    if (sourceFill.changedThisFrame) {\n      createFillMesh(tileProvider, frameState, sourceTile, vertexArraysToDestroy);\n      sourceFill.changedThisFrame = false;\n    }\n\n    sourceMesh = sourceTile.data.fill.mesh;\n  } else {\n    sourceMesh = sourceTile.data.mesh;\n  }\n\n  var edgeMeshes;\n  var edgeTiles;\n\n  switch (tileEdge) {\n    case TileEdge.WEST:\n      edgeMeshes = destinationFill.westMeshes;\n      edgeTiles = destinationFill.westTiles;\n      break;\n\n    case TileEdge.SOUTH:\n      edgeMeshes = destinationFill.southMeshes;\n      edgeTiles = destinationFill.southTiles;\n      break;\n\n    case TileEdge.EAST:\n      edgeMeshes = destinationFill.eastMeshes;\n      edgeTiles = destinationFill.eastTiles;\n      break;\n\n    case TileEdge.NORTH:\n      edgeMeshes = destinationFill.northMeshes;\n      edgeTiles = destinationFill.northTiles;\n      break;\n    // Corners are simpler.\n\n    case TileEdge.NORTHWEST:\n      destinationFill.changedThisFrame = destinationFill.changedThisFrame || destinationFill.northwestMesh !== sourceMesh;\n      destinationFill.northwestMesh = sourceMesh;\n      destinationFill.northwestTile = sourceTile;\n      return;\n\n    case TileEdge.NORTHEAST:\n      destinationFill.changedThisFrame = destinationFill.changedThisFrame || destinationFill.northeastMesh !== sourceMesh;\n      destinationFill.northeastMesh = sourceMesh;\n      destinationFill.northeastTile = sourceTile;\n      return;\n\n    case TileEdge.SOUTHWEST:\n      destinationFill.changedThisFrame = destinationFill.changedThisFrame || destinationFill.southwestMesh !== sourceMesh;\n      destinationFill.southwestMesh = sourceMesh;\n      destinationFill.southwestTile = sourceTile;\n      return;\n\n    case TileEdge.SOUTHEAST:\n      destinationFill.changedThisFrame = destinationFill.changedThisFrame || destinationFill.southeastMesh !== sourceMesh;\n      destinationFill.southeastMesh = sourceMesh;\n      destinationFill.southeastTile = sourceTile;\n      return;\n  }\n\n  if (sourceTile.level <= destinationTile.level) {\n    // Source edge completely spans the destination edge.\n    destinationFill.changedThisFrame = destinationFill.changedThisFrame || edgeMeshes[0] !== sourceMesh || edgeMeshes.length !== 1;\n    edgeMeshes[0] = sourceMesh;\n    edgeTiles[0] = sourceTile;\n    edgeMeshes.length = 1;\n    edgeTiles.length = 1;\n    return;\n  } // Source edge is a subset of the destination edge.\n  // Figure out the range of meshes we're replacing.\n\n\n  var startIndex, endIndex, existingTile, existingRectangle;\n  var sourceRectangle = sourceTile.rectangle;\n  var epsilon;\n  var destinationRectangle = destinationTile.rectangle;\n\n  switch (tileEdge) {\n    case TileEdge.WEST:\n      epsilon = (destinationRectangle.north - destinationRectangle.south) * CesiumMath.EPSILON5;\n\n      for (startIndex = 0; startIndex < edgeTiles.length; ++startIndex) {\n        existingTile = edgeTiles[startIndex];\n        existingRectangle = existingTile.rectangle;\n\n        if (CesiumMath.greaterThan(sourceRectangle.north, existingRectangle.south, epsilon)) {\n          break;\n        }\n      }\n\n      for (endIndex = startIndex; endIndex < edgeTiles.length; ++endIndex) {\n        existingTile = edgeTiles[endIndex];\n        existingRectangle = existingTile.rectangle;\n\n        if (CesiumMath.greaterThanOrEquals(sourceRectangle.south, existingRectangle.north, epsilon)) {\n          break;\n        }\n      }\n\n      break;\n\n    case TileEdge.SOUTH:\n      epsilon = (destinationRectangle.east - destinationRectangle.west) * CesiumMath.EPSILON5;\n\n      for (startIndex = 0; startIndex < edgeTiles.length; ++startIndex) {\n        existingTile = edgeTiles[startIndex];\n        existingRectangle = existingTile.rectangle;\n\n        if (CesiumMath.lessThan(sourceRectangle.west, existingRectangle.east, epsilon)) {\n          break;\n        }\n      }\n\n      for (endIndex = startIndex; endIndex < edgeTiles.length; ++endIndex) {\n        existingTile = edgeTiles[endIndex];\n        existingRectangle = existingTile.rectangle;\n\n        if (CesiumMath.lessThanOrEquals(sourceRectangle.east, existingRectangle.west, epsilon)) {\n          break;\n        }\n      }\n\n      break;\n\n    case TileEdge.EAST:\n      epsilon = (destinationRectangle.north - destinationRectangle.south) * CesiumMath.EPSILON5;\n\n      for (startIndex = 0; startIndex < edgeTiles.length; ++startIndex) {\n        existingTile = edgeTiles[startIndex];\n        existingRectangle = existingTile.rectangle;\n\n        if (CesiumMath.lessThan(sourceRectangle.south, existingRectangle.north, epsilon)) {\n          break;\n        }\n      }\n\n      for (endIndex = startIndex; endIndex < edgeTiles.length; ++endIndex) {\n        existingTile = edgeTiles[endIndex];\n        existingRectangle = existingTile.rectangle;\n\n        if (CesiumMath.lessThanOrEquals(sourceRectangle.north, existingRectangle.south, epsilon)) {\n          break;\n        }\n      }\n\n      break;\n\n    case TileEdge.NORTH:\n      epsilon = (destinationRectangle.east - destinationRectangle.west) * CesiumMath.EPSILON5;\n\n      for (startIndex = 0; startIndex < edgeTiles.length; ++startIndex) {\n        existingTile = edgeTiles[startIndex];\n        existingRectangle = existingTile.rectangle;\n\n        if (CesiumMath.greaterThan(sourceRectangle.east, existingRectangle.west, epsilon)) {\n          break;\n        }\n      }\n\n      for (endIndex = startIndex; endIndex < edgeTiles.length; ++endIndex) {\n        existingTile = edgeTiles[endIndex];\n        existingRectangle = existingTile.rectangle;\n\n        if (CesiumMath.greaterThanOrEquals(sourceRectangle.west, existingRectangle.east, epsilon)) {\n          break;\n        }\n      }\n\n      break;\n  }\n\n  if (endIndex - startIndex === 1) {\n    destinationFill.changedThisFrame = destinationFill.changedThisFrame || edgeMeshes[startIndex] !== sourceMesh;\n    edgeMeshes[startIndex] = sourceMesh;\n    edgeTiles[startIndex] = sourceTile;\n  } else {\n    destinationFill.changedThisFrame = true;\n    edgeMeshes.splice(startIndex, endIndex - startIndex, sourceMesh);\n    edgeTiles.splice(startIndex, endIndex - startIndex, sourceTile);\n  }\n}\n\nvar cartographicScratch = new Cartographic();\nvar centerCartographicScratch = new Cartographic();\nvar cartesianScratch = new Cartesian3();\nvar normalScratch = new Cartesian3();\nvar octEncodedNormalScratch = new Cartesian2();\nvar uvScratch2 = new Cartesian2();\nvar uvScratch = new Cartesian2();\n\nfunction HeightAndNormal() {\n  this.height = 0.0;\n  this.encodedNormal = new Cartesian2();\n}\n\nfunction fillMissingCorner(fill, ellipsoid, u, v, corner, adjacentCorner1, adjacentCorner2, oppositeCorner, vertex) {\n  if (defined(corner)) {\n    return corner;\n  }\n\n  var height;\n\n  if (defined(adjacentCorner1) && defined(adjacentCorner2)) {\n    height = (adjacentCorner1.height + adjacentCorner2.height) * 0.5;\n  } else if (defined(adjacentCorner1)) {\n    height = adjacentCorner1.height;\n  } else if (defined(adjacentCorner2)) {\n    height = adjacentCorner2.height;\n  } else if (defined(oppositeCorner)) {\n    height = oppositeCorner.height;\n  } else {\n    var surfaceTile = fill.tile.data;\n    var tileBoundingRegion = surfaceTile.tileBoundingRegion;\n    var minimumHeight = 0.0;\n    var maximumHeight = 0.0;\n\n    if (defined(tileBoundingRegion)) {\n      minimumHeight = tileBoundingRegion.minimumHeight;\n      maximumHeight = tileBoundingRegion.maximumHeight;\n    }\n\n    height = (minimumHeight + maximumHeight) * 0.5;\n  }\n\n  getVertexWithHeightAtCorner(fill, ellipsoid, u, v, height, vertex);\n  return vertex;\n}\n\nvar heightRangeScratch = {\n  minimumHeight: 0.0,\n  maximumHeight: 0.0\n};\nvar swVertexScratch = new HeightAndNormal();\nvar seVertexScratch = new HeightAndNormal();\nvar nwVertexScratch = new HeightAndNormal();\nvar neVertexScratch = new HeightAndNormal();\nvar heightmapBuffer = typeof Uint8Array !== \"undefined\" ? new Uint8Array(9 * 9) : undefined;\nvar scratchCreateMeshSyncOptions = {\n  tilingScheme: undefined,\n  x: 0,\n  y: 0,\n  level: 0,\n  exaggeration: 1.0\n};\n\nfunction createFillMesh(tileProvider, frameState, tile, vertexArraysToDestroy) {\n  GlobeSurfaceTile.initialize(tile, tileProvider.terrainProvider, tileProvider._imageryLayers);\n  var surfaceTile = tile.data;\n  var fill = surfaceTile.fill;\n  var rectangle = tile.rectangle;\n  var ellipsoid = tile.tilingScheme.ellipsoid;\n  var nwCorner = getCorner(fill, ellipsoid, 0.0, 1.0, fill.northwestTile, fill.northwestMesh, fill.northTiles, fill.northMeshes, fill.westTiles, fill.westMeshes, nwVertexScratch);\n  var swCorner = getCorner(fill, ellipsoid, 0.0, 0.0, fill.southwestTile, fill.southwestMesh, fill.westTiles, fill.westMeshes, fill.southTiles, fill.southMeshes, swVertexScratch);\n  var seCorner = getCorner(fill, ellipsoid, 1.0, 0.0, fill.southeastTile, fill.southeastMesh, fill.southTiles, fill.southMeshes, fill.eastTiles, fill.eastMeshes, seVertexScratch);\n  var neCorner = getCorner(fill, ellipsoid, 1.0, 1.0, fill.northeastTile, fill.northeastMesh, fill.eastTiles, fill.eastMeshes, fill.northTiles, fill.northMeshes, neVertexScratch);\n  nwCorner = fillMissingCorner(fill, ellipsoid, 0.0, 1.0, nwCorner, swCorner, neCorner, seCorner, nwVertexScratch);\n  swCorner = fillMissingCorner(fill, ellipsoid, 0.0, 0.0, swCorner, nwCorner, seCorner, neCorner, swVertexScratch);\n  seCorner = fillMissingCorner(fill, ellipsoid, 1.0, 1.0, seCorner, swCorner, neCorner, nwCorner, seVertexScratch);\n  neCorner = fillMissingCorner(fill, ellipsoid, 1.0, 1.0, neCorner, seCorner, nwCorner, swCorner, neVertexScratch);\n  var southwestHeight = swCorner.height;\n  var southeastHeight = seCorner.height;\n  var northwestHeight = nwCorner.height;\n  var northeastHeight = neCorner.height;\n  var minimumHeight = Math.min(southwestHeight, southeastHeight, northwestHeight, northeastHeight);\n  var maximumHeight = Math.max(southwestHeight, southeastHeight, northwestHeight, northeastHeight);\n  var middleHeight = (minimumHeight + maximumHeight) * 0.5;\n  var i;\n  var len; // For low-detail tiles, our usual fill tile approach will create tiles that\n  // look really blocky because they don't have enough vertices to account for the\n  // Earth's curvature. But the height range will also typically be well within\n  // the allowed geometric error for those levels. So fill such tiles with a\n  // constant-height heightmap.\n\n  var geometricError = tileProvider.getLevelMaximumGeometricError(tile.level);\n  var minCutThroughRadius = ellipsoid.maximumRadius - geometricError;\n  var maxTileWidth = Math.acos(minCutThroughRadius / ellipsoid.maximumRadius) * 4.0; // When the tile width is greater than maxTileWidth as computed above, the error\n  // of a normal fill tile from globe curvature alone will exceed the allowed geometric\n  // error. Terrain won't change that much. However, we can allow more error than that.\n  // A little blockiness during load is acceptable. For the WGS84 ellipsoid and\n  // standard geometric error setup, the value here will have us use a heightmap\n  // at levels 1, 2, and 3.\n\n  maxTileWidth *= 1.5;\n\n  if (rectangle.width > maxTileWidth && maximumHeight - minimumHeight <= geometricError) {\n    var terrainData = new HeightmapTerrainData({\n      width: 9,\n      height: 9,\n      buffer: heightmapBuffer,\n      structure: {\n        // Use the maximum as the constant height so that this tile's skirt\n        // covers any cracks with adjacent tiles.\n        heightOffset: maximumHeight\n      }\n    });\n    var createMeshSyncOptions = scratchCreateMeshSyncOptions;\n    createMeshSyncOptions.tilingScheme = tile.tilingScheme;\n    createMeshSyncOptions.x = tile.x;\n    createMeshSyncOptions.y = tile.y;\n    createMeshSyncOptions.level = tile.level;\n    fill.mesh = terrainData._createMeshSync(createMeshSyncOptions);\n  } else {\n    var encoding = new TerrainEncoding(undefined, undefined, undefined, undefined, true, true);\n    var centerCartographic = centerCartographicScratch;\n    centerCartographic.longitude = (rectangle.east + rectangle.west) * 0.5;\n    centerCartographic.latitude = (rectangle.north + rectangle.south) * 0.5;\n    centerCartographic.height = middleHeight;\n    encoding.center = ellipsoid.cartographicToCartesian(centerCartographic, encoding.center); // At _most_, we have vertices for the 4 corners, plus 1 center, plus every adjacent edge vertex.\n    // In reality there will be less most of the time, but close enough; better\n    // to overestimate than to re-allocate/copy/traverse the vertices twice.\n    // Also, we'll often be able to squeeze the index data into the extra space in the buffer.\n\n    var maxVertexCount = 5;\n    var meshes;\n    meshes = fill.westMeshes;\n\n    for (i = 0, len = meshes.length; i < len; ++i) {\n      maxVertexCount += meshes[i].eastIndicesNorthToSouth.length;\n    }\n\n    meshes = fill.southMeshes;\n\n    for (i = 0, len = meshes.length; i < len; ++i) {\n      maxVertexCount += meshes[i].northIndicesWestToEast.length;\n    }\n\n    meshes = fill.eastMeshes;\n\n    for (i = 0, len = meshes.length; i < len; ++i) {\n      maxVertexCount += meshes[i].westIndicesSouthToNorth.length;\n    }\n\n    meshes = fill.northMeshes;\n\n    for (i = 0, len = meshes.length; i < len; ++i) {\n      maxVertexCount += meshes[i].southIndicesEastToWest.length;\n    }\n\n    var heightRange = heightRangeScratch;\n    heightRange.minimumHeight = minimumHeight;\n    heightRange.maximumHeight = maximumHeight;\n    var stride = encoding.getStride();\n    var typedArray = new Float32Array(maxVertexCount * stride);\n    var nextIndex = 0;\n    var northwestIndex = nextIndex;\n    nextIndex = addVertexWithComputedPosition(ellipsoid, rectangle, encoding, typedArray, nextIndex, 0.0, 1.0, nwCorner.height, nwCorner.encodedNormal, 1.0, heightRange);\n    nextIndex = addEdge(fill, ellipsoid, encoding, typedArray, nextIndex, fill.westTiles, fill.westMeshes, TileEdge.EAST, heightRange);\n    var southwestIndex = nextIndex;\n    nextIndex = addVertexWithComputedPosition(ellipsoid, rectangle, encoding, typedArray, nextIndex, 0.0, 0.0, swCorner.height, swCorner.encodedNormal, 0.0, heightRange);\n    nextIndex = addEdge(fill, ellipsoid, encoding, typedArray, nextIndex, fill.southTiles, fill.southMeshes, TileEdge.NORTH, heightRange);\n    var southeastIndex = nextIndex;\n    nextIndex = addVertexWithComputedPosition(ellipsoid, rectangle, encoding, typedArray, nextIndex, 1.0, 0.0, seCorner.height, seCorner.encodedNormal, 0.0, heightRange);\n    nextIndex = addEdge(fill, ellipsoid, encoding, typedArray, nextIndex, fill.eastTiles, fill.eastMeshes, TileEdge.WEST, heightRange);\n    var northeastIndex = nextIndex;\n    nextIndex = addVertexWithComputedPosition(ellipsoid, rectangle, encoding, typedArray, nextIndex, 1.0, 1.0, neCorner.height, neCorner.encodedNormal, 1.0, heightRange);\n    nextIndex = addEdge(fill, ellipsoid, encoding, typedArray, nextIndex, fill.northTiles, fill.northMeshes, TileEdge.SOUTH, heightRange);\n    minimumHeight = heightRange.minimumHeight;\n    maximumHeight = heightRange.maximumHeight;\n    var obb = OrientedBoundingBox.fromRectangle(rectangle, minimumHeight, maximumHeight, tile.tilingScheme.ellipsoid); // Add a single vertex at the center of the tile.\n\n    var southMercatorY = WebMercatorProjection.geodeticLatitudeToMercatorAngle(rectangle.south);\n    var oneOverMercatorHeight = 1.0 / (WebMercatorProjection.geodeticLatitudeToMercatorAngle(rectangle.north) - southMercatorY);\n    var centerWebMercatorT = (WebMercatorProjection.geodeticLatitudeToMercatorAngle(centerCartographic.latitude) - southMercatorY) * oneOverMercatorHeight;\n    ellipsoid.geodeticSurfaceNormalCartographic(cartographicScratch, normalScratch);\n    var centerEncodedNormal = AttributeCompression.octEncode(normalScratch, octEncodedNormalScratch);\n    var centerIndex = nextIndex;\n    encoding.encode(typedArray, nextIndex * stride, obb.center, Cartesian2.fromElements(0.5, 0.5, uvScratch), middleHeight, centerEncodedNormal, centerWebMercatorT);\n    ++nextIndex;\n    var vertexCount = nextIndex;\n    var bytesPerIndex = vertexCount < 256 ? 1 : 2;\n    var indexCount = (vertexCount - 1) * 3; // one triangle per edge vertex\n\n    var indexDataBytes = indexCount * bytesPerIndex;\n    var availableBytesInBuffer = (typedArray.length - vertexCount * stride) * Float32Array.BYTES_PER_ELEMENT;\n    var indices;\n\n    if (availableBytesInBuffer >= indexDataBytes) {\n      // Store the index data in the same buffer as the vertex data.\n      var startIndex = vertexCount * stride * Float32Array.BYTES_PER_ELEMENT;\n      indices = vertexCount < 256 ? new Uint8Array(typedArray.buffer, startIndex, indexCount) : new Uint16Array(typedArray.buffer, startIndex, indexCount);\n    } else {\n      // Allocate a new buffer for the index data.\n      indices = vertexCount < 256 ? new Uint8Array(indexCount) : new Uint16Array(indexCount);\n    }\n\n    typedArray = new Float32Array(typedArray.buffer, 0, vertexCount * stride);\n    var indexOut = 0;\n\n    for (i = 0; i < vertexCount - 2; ++i) {\n      indices[indexOut++] = centerIndex;\n      indices[indexOut++] = i;\n      indices[indexOut++] = i + 1;\n    }\n\n    indices[indexOut++] = centerIndex;\n    indices[indexOut++] = i;\n    indices[indexOut++] = 0;\n    var westIndicesSouthToNorth = [];\n\n    for (i = southwestIndex; i >= northwestIndex; --i) {\n      westIndicesSouthToNorth.push(i);\n    }\n\n    var southIndicesEastToWest = [];\n\n    for (i = southeastIndex; i >= southwestIndex; --i) {\n      southIndicesEastToWest.push(i);\n    }\n\n    var eastIndicesNorthToSouth = [];\n\n    for (i = northeastIndex; i >= southeastIndex; --i) {\n      eastIndicesNorthToSouth.push(i);\n    }\n\n    var northIndicesWestToEast = [];\n    northIndicesWestToEast.push(0);\n\n    for (i = centerIndex - 1; i >= northeastIndex; --i) {\n      northIndicesWestToEast.push(i);\n    }\n\n    fill.mesh = new TerrainMesh(encoding.center, typedArray, indices, indexCount, vertexCount, minimumHeight, maximumHeight, BoundingSphere.fromOrientedBoundingBox(obb), computeOccludeePoint(tileProvider, obb.center, rectangle, minimumHeight, maximumHeight), encoding.getStride(), obb, encoding, frameState.terrainExaggeration, westIndicesSouthToNorth, southIndicesEastToWest, eastIndicesNorthToSouth, northIndicesWestToEast);\n  }\n\n  var context = frameState.context;\n\n  if (defined(fill.vertexArray)) {\n    if (defined(vertexArraysToDestroy)) {\n      vertexArraysToDestroy.push(fill.vertexArray);\n    } else {\n      GlobeSurfaceTile._freeVertexArray(fill.vertexArray);\n    }\n  }\n\n  fill.vertexArray = GlobeSurfaceTile._createVertexArrayForMesh(context, fill.mesh);\n  surfaceTile.processImagery(tile, tileProvider.terrainProvider, frameState, true);\n  var oldTexture = fill.waterMaskTexture;\n  fill.waterMaskTexture = undefined;\n\n  if (tileProvider.terrainProvider.hasWaterMask) {\n    var waterSourceTile = surfaceTile._findAncestorTileWithTerrainData(tile);\n\n    if (defined(waterSourceTile) && defined(waterSourceTile.data.waterMaskTexture)) {\n      fill.waterMaskTexture = waterSourceTile.data.waterMaskTexture;\n      ++fill.waterMaskTexture.referenceCount;\n\n      surfaceTile._computeWaterMaskTranslationAndScale(tile, waterSourceTile, fill.waterMaskTranslationAndScale);\n    }\n  }\n\n  if (defined(oldTexture)) {\n    --oldTexture.referenceCount;\n\n    if (oldTexture.referenceCount === 0) {\n      oldTexture.destroy();\n    }\n  }\n}\n\nfunction addVertexWithComputedPosition(ellipsoid, rectangle, encoding, buffer, index, u, v, height, encodedNormal, webMercatorT, heightRange) {\n  var cartographic = cartographicScratch;\n  cartographic.longitude = CesiumMath.lerp(rectangle.west, rectangle.east, u);\n  cartographic.latitude = CesiumMath.lerp(rectangle.south, rectangle.north, v);\n  cartographic.height = height;\n  var position = ellipsoid.cartographicToCartesian(cartographic, cartesianScratch);\n  var uv = uvScratch2;\n  uv.x = u;\n  uv.y = v;\n  encoding.encode(buffer, index * encoding.getStride(), position, uv, height, encodedNormal, webMercatorT);\n  heightRange.minimumHeight = Math.min(heightRange.minimumHeight, height);\n  heightRange.maximumHeight = Math.max(heightRange.maximumHeight, height);\n  return index + 1;\n}\n\nvar sourceRectangleScratch = new Rectangle();\n\nfunction transformTextureCoordinates(sourceTile, targetTile, coordinates, result) {\n  var sourceRectangle = sourceTile.rectangle;\n  var targetRectangle = targetTile.rectangle; // Handle transforming across the anti-meridian.\n\n  if (targetTile.x === 0 && coordinates.x === 1.0 && sourceTile.x === sourceTile.tilingScheme.getNumberOfXTilesAtLevel(sourceTile.level) - 1) {\n    sourceRectangle = Rectangle.clone(sourceTile.rectangle, sourceRectangleScratch);\n    sourceRectangle.west -= CesiumMath.TWO_PI;\n    sourceRectangle.east -= CesiumMath.TWO_PI;\n  } else if (sourceTile.x === 0 && coordinates.x === 0.0 && targetTile.x === targetTile.tilingScheme.getNumberOfXTilesAtLevel(targetTile.level) - 1) {\n    sourceRectangle = Rectangle.clone(sourceTile.rectangle, sourceRectangleScratch);\n    sourceRectangle.west += CesiumMath.TWO_PI;\n    sourceRectangle.east += CesiumMath.TWO_PI;\n  }\n\n  var sourceWidth = sourceRectangle.east - sourceRectangle.west;\n  var umin = (targetRectangle.west - sourceRectangle.west) / sourceWidth;\n  var umax = (targetRectangle.east - sourceRectangle.west) / sourceWidth;\n  var sourceHeight = sourceRectangle.north - sourceRectangle.south;\n  var vmin = (targetRectangle.south - sourceRectangle.south) / sourceHeight;\n  var vmax = (targetRectangle.north - sourceRectangle.south) / sourceHeight;\n  var u = (coordinates.x - umin) / (umax - umin);\n  var v = (coordinates.y - vmin) / (vmax - vmin); // Ensure that coordinates very near the corners are at the corners.\n\n  if (Math.abs(u) < Math.EPSILON5) {\n    u = 0.0;\n  } else if (Math.abs(u - 1.0) < Math.EPSILON5) {\n    u = 1.0;\n  }\n\n  if (Math.abs(v) < Math.EPSILON5) {\n    v = 0.0;\n  } else if (Math.abs(v - 1.0) < Math.EPSILON5) {\n    v = 1.0;\n  }\n\n  result.x = u;\n  result.y = v;\n  return result;\n}\n\nvar encodedNormalScratch = new Cartesian2();\n\nfunction getVertexFromTileAtCorner(sourceMesh, sourceIndex, u, v, vertex) {\n  var sourceEncoding = sourceMesh.encoding;\n  var sourceVertices = sourceMesh.vertices;\n  vertex.height = sourceEncoding.decodeHeight(sourceVertices, sourceIndex);\n\n  if (sourceEncoding.hasVertexNormals) {\n    sourceEncoding.getOctEncodedNormal(sourceVertices, sourceIndex, vertex.encodedNormal);\n  } else {\n    var normal = vertex.encodedNormal;\n    normal.x = 0.0;\n    normal.y = 0.0;\n  }\n}\n\nvar encodedNormalScratch2 = new Cartesian2();\nvar cartesianScratch2 = new Cartesian3();\n\nfunction getInterpolatedVertexAtCorner(ellipsoid, sourceTile, targetTile, sourceMesh, previousIndex, nextIndex, u, v, interpolateU, vertex) {\n  var sourceEncoding = sourceMesh.encoding;\n  var sourceVertices = sourceMesh.vertices;\n  var previousUv = transformTextureCoordinates(sourceTile, targetTile, sourceEncoding.decodeTextureCoordinates(sourceVertices, previousIndex, uvScratch), uvScratch);\n  var nextUv = transformTextureCoordinates(sourceTile, targetTile, sourceEncoding.decodeTextureCoordinates(sourceVertices, nextIndex, uvScratch2), uvScratch2);\n  var ratio;\n\n  if (interpolateU) {\n    ratio = (u - previousUv.x) / (nextUv.x - previousUv.x);\n  } else {\n    ratio = (v - previousUv.y) / (nextUv.y - previousUv.y);\n  }\n\n  var height1 = sourceEncoding.decodeHeight(sourceVertices, previousIndex);\n  var height2 = sourceEncoding.decodeHeight(sourceVertices, nextIndex);\n  var targetRectangle = targetTile.rectangle;\n  cartographicScratch.longitude = CesiumMath.lerp(targetRectangle.west, targetRectangle.east, u);\n  cartographicScratch.latitude = CesiumMath.lerp(targetRectangle.south, targetRectangle.north, v);\n  vertex.height = cartographicScratch.height = CesiumMath.lerp(height1, height2, ratio);\n  var normal;\n\n  if (sourceEncoding.hasVertexNormals) {\n    var encodedNormal1 = sourceEncoding.getOctEncodedNormal(sourceVertices, previousIndex, encodedNormalScratch);\n    var encodedNormal2 = sourceEncoding.getOctEncodedNormal(sourceVertices, nextIndex, encodedNormalScratch2);\n    var normal1 = AttributeCompression.octDecode(encodedNormal1.x, encodedNormal1.y, cartesianScratch);\n    var normal2 = AttributeCompression.octDecode(encodedNormal2.x, encodedNormal2.y, cartesianScratch2);\n    normal = Cartesian3.lerp(normal1, normal2, ratio, cartesianScratch);\n    Cartesian3.normalize(normal, normal);\n    AttributeCompression.octEncode(normal, vertex.encodedNormal);\n  } else {\n    normal = ellipsoid.geodeticSurfaceNormalCartographic(cartographicScratch, cartesianScratch);\n    AttributeCompression.octEncode(normal, vertex.encodedNormal);\n  }\n}\n\nfunction getVertexWithHeightAtCorner(terrainFillMesh, ellipsoid, u, v, height, vertex) {\n  vertex.height = height;\n  var normal = ellipsoid.geodeticSurfaceNormalCartographic(cartographicScratch, cartesianScratch);\n  AttributeCompression.octEncode(normal, vertex.encodedNormal);\n}\n\nfunction getCorner(terrainFillMesh, ellipsoid, u, v, cornerTile, cornerMesh, previousEdgeTiles, previousEdgeMeshes, nextEdgeTiles, nextEdgeMeshes, vertex) {\n  var gotCorner = getCornerFromEdge(terrainFillMesh, ellipsoid, previousEdgeMeshes, previousEdgeTiles, false, u, v, vertex) || getCornerFromEdge(terrainFillMesh, ellipsoid, nextEdgeMeshes, nextEdgeTiles, true, u, v, vertex);\n\n  if (gotCorner) {\n    return vertex;\n  }\n\n  var vertexIndex;\n\n  if (meshIsUsable(cornerTile, cornerMesh)) {\n    // Corner mesh is valid, copy its corner vertex to this mesh.\n    if (u === 0.0) {\n      if (v === 0.0) {\n        // southwest destination, northeast source\n        vertexIndex = cornerMesh.eastIndicesNorthToSouth[0];\n      } else {\n        // northwest destination, southeast source\n        vertexIndex = cornerMesh.southIndicesEastToWest[0];\n      }\n    } else if (v === 0.0) {\n      // southeast destination, northwest source\n      vertexIndex = cornerMesh.northIndicesWestToEast[0];\n    } else {\n      // northeast destination, southwest source\n      vertexIndex = cornerMesh.westIndicesSouthToNorth[0];\n    }\n\n    getVertexFromTileAtCorner(cornerMesh, vertexIndex, u, v, vertex);\n    return vertex;\n  } // There is no precise vertex available from the corner or from either adjacent edge.\n  // This is either because there are no tiles at all at the edges and corner, or\n  // because the tiles at the edge are higher-level-number and don't extend all the way\n  // to the corner.\n  // Try to grab a height from the adjacent edges.\n\n\n  var height;\n\n  if (u === 0.0) {\n    if (v === 0.0) {\n      // southwest\n      height = getClosestHeightToCorner(terrainFillMesh.westMeshes, terrainFillMesh.westTiles, TileEdge.EAST, terrainFillMesh.southMeshes, terrainFillMesh.southTiles, TileEdge.NORTH, u, v);\n    } else {\n      // northwest\n      height = getClosestHeightToCorner(terrainFillMesh.northMeshes, terrainFillMesh.northTiles, TileEdge.SOUTH, terrainFillMesh.westMeshes, terrainFillMesh.westTiles, TileEdge.EAST, u, v);\n    }\n  } else if (v === 0.0) {\n    // southeast\n    height = getClosestHeightToCorner(terrainFillMesh.southMeshes, terrainFillMesh.southTiles, TileEdge.NORTH, terrainFillMesh.eastMeshes, terrainFillMesh.eastTiles, TileEdge.WEST, u, v);\n  } else {\n    // northeast\n    height = getClosestHeightToCorner(terrainFillMesh.eastMeshes, terrainFillMesh.eastTiles, TileEdge.WEST, terrainFillMesh.northMeshes, terrainFillMesh.northTiles, TileEdge.SOUTH, u, v);\n  }\n\n  if (defined(height)) {\n    getVertexWithHeightAtCorner(terrainFillMesh, ellipsoid, u, v, height, vertex);\n    return vertex;\n  } // No heights available that are closer than the adjacent corners.\n\n\n  return undefined;\n}\n\nfunction getClosestHeightToCorner(previousMeshes, previousTiles, previousEdge, nextMeshes, nextTiles, nextEdge, u, v) {\n  var height1 = getNearestHeightOnEdge(previousMeshes, previousTiles, false, previousEdge, u, v);\n  var height2 = getNearestHeightOnEdge(nextMeshes, nextTiles, true, nextEdge, u, v);\n\n  if (defined(height1) && defined(height2)) {\n    // It would be slightly better to do a weighted average of the two heights\n    // based on their distance from the corner, but it shouldn't matter much in practice.\n    return (height1 + height2) * 0.5;\n  } else if (defined(height1)) {\n    return height1;\n  }\n\n  return height2;\n}\n\nfunction addEdge(terrainFillMesh, ellipsoid, encoding, typedArray, nextIndex, edgeTiles, edgeMeshes, tileEdge, heightRange) {\n  for (var i = 0; i < edgeTiles.length; ++i) {\n    nextIndex = addEdgeMesh(terrainFillMesh, ellipsoid, encoding, typedArray, nextIndex, edgeTiles[i], edgeMeshes[i], tileEdge, heightRange);\n  }\n\n  return nextIndex;\n}\n\nfunction addEdgeMesh(terrainFillMesh, ellipsoid, encoding, typedArray, nextIndex, edgeTile, edgeMesh, tileEdge, heightRange) {\n  // Handle copying edges across the anti-meridian.\n  var sourceRectangle = edgeTile.rectangle;\n\n  if (tileEdge === TileEdge.EAST && terrainFillMesh.tile.x === 0) {\n    sourceRectangle = Rectangle.clone(edgeTile.rectangle, sourceRectangleScratch);\n    sourceRectangle.west -= CesiumMath.TWO_PI;\n    sourceRectangle.east -= CesiumMath.TWO_PI;\n  } else if (tileEdge === TileEdge.WEST && edgeTile.x === 0) {\n    sourceRectangle = Rectangle.clone(edgeTile.rectangle, sourceRectangleScratch);\n    sourceRectangle.west += CesiumMath.TWO_PI;\n    sourceRectangle.east += CesiumMath.TWO_PI;\n  }\n\n  var targetRectangle = terrainFillMesh.tile.rectangle;\n  var lastU;\n  var lastV;\n\n  if (nextIndex > 0) {\n    encoding.decodeTextureCoordinates(typedArray, nextIndex - 1, uvScratch);\n    lastU = uvScratch.x;\n    lastV = uvScratch.y;\n  }\n\n  var indices;\n  var compareU;\n\n  switch (tileEdge) {\n    case TileEdge.WEST:\n      indices = edgeMesh.westIndicesSouthToNorth;\n      compareU = false;\n      break;\n\n    case TileEdge.NORTH:\n      indices = edgeMesh.northIndicesWestToEast;\n      compareU = true;\n      break;\n\n    case TileEdge.EAST:\n      indices = edgeMesh.eastIndicesNorthToSouth;\n      compareU = false;\n      break;\n\n    case TileEdge.SOUTH:\n      indices = edgeMesh.southIndicesEastToWest;\n      compareU = true;\n      break;\n  }\n\n  var sourceTile = edgeTile;\n  var targetTile = terrainFillMesh.tile;\n  var sourceEncoding = edgeMesh.encoding;\n  var sourceVertices = edgeMesh.vertices;\n  var targetStride = encoding.getStride();\n  var southMercatorY;\n  var oneOverMercatorHeight;\n\n  if (sourceEncoding.hasWebMercatorT) {\n    southMercatorY = WebMercatorProjection.geodeticLatitudeToMercatorAngle(targetRectangle.south);\n    oneOverMercatorHeight = 1.0 / (WebMercatorProjection.geodeticLatitudeToMercatorAngle(targetRectangle.north) - southMercatorY);\n  }\n\n  for (var i = 0; i < indices.length; ++i) {\n    var index = indices[i];\n    var uv = sourceEncoding.decodeTextureCoordinates(sourceVertices, index, uvScratch);\n    transformTextureCoordinates(sourceTile, targetTile, uv, uv);\n    var u = uv.x;\n    var v = uv.y;\n    var uOrV = compareU ? u : v;\n\n    if (uOrV < 0.0 || uOrV > 1.0) {\n      // Vertex is outside the target tile - skip it.\n      continue;\n    }\n\n    if (Math.abs(u - lastU) < CesiumMath.EPSILON5 && Math.abs(v - lastV) < CesiumMath.EPSILON5) {\n      // Vertex is very close to the previous one - skip it.\n      continue;\n    }\n\n    var nearlyEdgeU = Math.abs(u) < CesiumMath.EPSILON5 || Math.abs(u - 1.0) < CesiumMath.EPSILON5;\n    var nearlyEdgeV = Math.abs(v) < CesiumMath.EPSILON5 || Math.abs(v - 1.0) < CesiumMath.EPSILON5;\n\n    if (nearlyEdgeU && nearlyEdgeV) {\n      // Corner vertex - skip it.\n      continue;\n    }\n\n    var position = sourceEncoding.decodePosition(sourceVertices, index, cartesianScratch);\n    var height = sourceEncoding.decodeHeight(sourceVertices, index);\n    var normal;\n\n    if (sourceEncoding.hasVertexNormals) {\n      normal = sourceEncoding.getOctEncodedNormal(sourceVertices, index, octEncodedNormalScratch);\n    } else {\n      normal = octEncodedNormalScratch;\n      normal.x = 0.0;\n      normal.y = 0.0;\n    }\n\n    var webMercatorT = v;\n\n    if (sourceEncoding.hasWebMercatorT) {\n      var latitude = CesiumMath.lerp(targetRectangle.south, targetRectangle.north, v);\n      webMercatorT = (WebMercatorProjection.geodeticLatitudeToMercatorAngle(latitude) - southMercatorY) * oneOverMercatorHeight;\n    }\n\n    encoding.encode(typedArray, nextIndex * targetStride, position, uv, height, normal, webMercatorT);\n    heightRange.minimumHeight = Math.min(heightRange.minimumHeight, height);\n    heightRange.maximumHeight = Math.max(heightRange.maximumHeight, height);\n    ++nextIndex;\n  }\n\n  return nextIndex;\n}\n\nfunction getNearestHeightOnEdge(meshes, tiles, isNext, edge, u, v) {\n  var meshStart;\n  var meshEnd;\n  var meshStep;\n\n  if (isNext) {\n    meshStart = 0;\n    meshEnd = meshes.length;\n    meshStep = 1;\n  } else {\n    meshStart = meshes.length - 1;\n    meshEnd = -1;\n    meshStep = -1;\n  }\n\n  for (var meshIndex = meshStart; meshIndex !== meshEnd; meshIndex += meshStep) {\n    var mesh = meshes[meshIndex];\n    var tile = tiles[meshIndex];\n\n    if (!meshIsUsable(tile, mesh)) {\n      continue;\n    }\n\n    var indices;\n\n    switch (edge) {\n      case TileEdge.WEST:\n        indices = mesh.westIndicesSouthToNorth;\n        break;\n\n      case TileEdge.SOUTH:\n        indices = mesh.southIndicesEastToWest;\n        break;\n\n      case TileEdge.EAST:\n        indices = mesh.eastIndicesNorthToSouth;\n        break;\n\n      case TileEdge.NORTH:\n        indices = mesh.northIndicesWestToEast;\n        break;\n    }\n\n    var index = indices[isNext ? 0 : indices.length - 1];\n\n    if (defined(index)) {\n      return mesh.encoding.decodeHeight(mesh.vertices, index);\n    }\n  }\n\n  return undefined;\n}\n\nfunction meshIsUsable(tile, mesh) {\n  return defined(mesh) && (!defined(tile.data.fill) || !tile.data.fill.changedThisFrame);\n}\n\nfunction getCornerFromEdge(terrainFillMesh, ellipsoid, edgeMeshes, edgeTiles, isNext, u, v, vertex) {\n  var edgeVertices;\n  var compareU;\n  var increasing;\n  var vertexIndexIndex;\n  var vertexIndex;\n  var sourceTile = edgeTiles[isNext ? 0 : edgeMeshes.length - 1];\n  var sourceMesh = edgeMeshes[isNext ? 0 : edgeMeshes.length - 1];\n\n  if (meshIsUsable(sourceTile, sourceMesh)) {\n    // Previous mesh is valid, but we don't know yet if it covers this corner.\n    if (u === 0.0) {\n      if (v === 0.0) {\n        // southwest\n        edgeVertices = isNext ? sourceMesh.northIndicesWestToEast : sourceMesh.eastIndicesNorthToSouth;\n        compareU = isNext;\n        increasing = isNext;\n      } else {\n        // northwest\n        edgeVertices = isNext ? sourceMesh.eastIndicesNorthToSouth : sourceMesh.southIndicesEastToWest;\n        compareU = !isNext;\n        increasing = false;\n      }\n    } else if (v === 0.0) {\n      // southeast\n      edgeVertices = isNext ? sourceMesh.westIndicesSouthToNorth : sourceMesh.northIndicesWestToEast;\n      compareU = !isNext;\n      increasing = true;\n    } else {\n      // northeast\n      edgeVertices = isNext ? sourceMesh.southIndicesEastToWest : sourceMesh.westIndicesSouthToNorth;\n      compareU = isNext;\n      increasing = !isNext;\n    }\n\n    if (edgeVertices.length > 0) {\n      // The vertex we want will very often be the first/last vertex so check that first.\n      vertexIndexIndex = isNext ? 0 : edgeVertices.length - 1;\n      vertexIndex = edgeVertices[vertexIndexIndex];\n      sourceMesh.encoding.decodeTextureCoordinates(sourceMesh.vertices, vertexIndex, uvScratch);\n      var targetUv = transformTextureCoordinates(sourceTile, terrainFillMesh.tile, uvScratch, uvScratch);\n\n      if (targetUv.x === u && targetUv.y === v) {\n        // Vertex is good!\n        getVertexFromTileAtCorner(sourceMesh, vertexIndex, u, v, vertex);\n        return true;\n      } // The last vertex is not the one we need, try binary searching for the right one.\n\n\n      vertexIndexIndex = binarySearch(edgeVertices, compareU ? u : v, function (vertexIndex, textureCoordinate) {\n        sourceMesh.encoding.decodeTextureCoordinates(sourceMesh.vertices, vertexIndex, uvScratch);\n        var targetUv = transformTextureCoordinates(sourceTile, terrainFillMesh.tile, uvScratch, uvScratch);\n\n        if (increasing) {\n          if (compareU) {\n            return targetUv.x - u;\n          }\n\n          return targetUv.y - v;\n        } else if (compareU) {\n          return u - targetUv.x;\n        }\n\n        return v - targetUv.y;\n      });\n\n      if (vertexIndexIndex < 0) {\n        vertexIndexIndex = ~vertexIndexIndex;\n\n        if (vertexIndexIndex > 0 && vertexIndexIndex < edgeVertices.length) {\n          // The corner falls between two vertices, so interpolate between them.\n          getInterpolatedVertexAtCorner(ellipsoid, sourceTile, terrainFillMesh.tile, sourceMesh, edgeVertices[vertexIndexIndex - 1], edgeVertices[vertexIndexIndex], u, v, compareU, vertex);\n          return true;\n        }\n      } else {\n        // Found a vertex that fits in the corner exactly.\n        getVertexFromTileAtCorner(sourceMesh, edgeVertices[vertexIndexIndex], u, v, vertex);\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nvar cornerPositionsScratch = [new Cartesian3(), new Cartesian3(), new Cartesian3(), new Cartesian3()];\n\nfunction computeOccludeePoint(tileProvider, center, rectangle, minimumHeight, maximumHeight, result) {\n  var ellipsoidalOccluder = tileProvider.quadtree._occluders.ellipsoid;\n  var ellipsoid = ellipsoidalOccluder.ellipsoid;\n  var cornerPositions = cornerPositionsScratch;\n  Cartesian3.fromRadians(rectangle.west, rectangle.south, maximumHeight, ellipsoid, cornerPositions[0]);\n  Cartesian3.fromRadians(rectangle.east, rectangle.south, maximumHeight, ellipsoid, cornerPositions[1]);\n  Cartesian3.fromRadians(rectangle.west, rectangle.north, maximumHeight, ellipsoid, cornerPositions[2]);\n  Cartesian3.fromRadians(rectangle.east, rectangle.north, maximumHeight, ellipsoid, cornerPositions[3]);\n  return ellipsoidalOccluder.computeHorizonCullingPointPossiblyUnderEllipsoid(center, cornerPositions, minimumHeight, result);\n}\n\nexport default TerrainFillMesh;","map":{"version":3,"sources":["/home/usuario/davi/thalamus/wms/3dmaptestes/leaflet_cesium/client/node_modules/cesium/Source/Scene/TerrainFillMesh.js"],"names":["AttributeCompression","binarySearch","BoundingSphere","Cartesian2","Cartesian3","Cartesian4","Cartographic","defined","DeveloperError","HeightmapTerrainData","CesiumMath","OrientedBoundingBox","Queue","Rectangle","TerrainEncoding","TerrainMesh","TileEdge","WebMercatorProjection","GlobeSurfaceTile","TileSelectionResult","TerrainFillMesh","tile","frameLastUpdated","undefined","westMeshes","westTiles","southMeshes","southTiles","eastMeshes","eastTiles","northMeshes","northTiles","southwestMesh","southwestTile","southeastMesh","southeastTile","northwestMesh","northwestTile","northeastMesh","northeastTile","changedThisFrame","visitedFrame","enqueuedFrame","mesh","vertexArray","waterMaskTexture","waterMaskTranslationAndScale","prototype","update","tileProvider","frameState","vertexArraysToDestroy","createFillMesh","destroy","push","_freeVertexArray","referenceCount","traversalQueueScratch","updateFillTiles","renderedTiles","quadtree","_quadtree","levelZeroTiles","_levelZeroTiles","lastSelectionFrameNumber","_lastSelectionFrameNumber","traversalQueue","clear","i","length","renderedTile","data","enqueue","dequeue","tileToWest","findTileToWest","tileToSouth","findTileToSouth","tileToEast","findTileToEast","tileToNorth","findTileToNorth","visitRenderedTiles","EAST","NORTH","WEST","SOUTH","tileToNorthwest","tileToSouthwest","tileToNortheast","tileToSoutheast","SOUTHEAST","SOUTHWEST","NORTHEAST","NORTHWEST","sourceTile","startTile","currentFrameNumber","tileEdge","downOnly","_lastSelectionResultFrame","wasKicked","_lastSelectionResult","originalResult","CULLED","parent","northwestChild","northeastChild","southwestChild","southeastChild","RENDERED","visitTile","destinationTile","frameNumber","destinationSurfaceTile","fill","propagateEdge","destinationFill","sourceMesh","sourceFill","edgeMeshes","edgeTiles","level","startIndex","endIndex","existingTile","existingRectangle","sourceRectangle","rectangle","epsilon","destinationRectangle","north","south","EPSILON5","greaterThan","greaterThanOrEquals","east","west","lessThan","lessThanOrEquals","splice","cartographicScratch","centerCartographicScratch","cartesianScratch","normalScratch","octEncodedNormalScratch","uvScratch2","uvScratch","HeightAndNormal","height","encodedNormal","fillMissingCorner","ellipsoid","u","v","corner","adjacentCorner1","adjacentCorner2","oppositeCorner","vertex","surfaceTile","tileBoundingRegion","minimumHeight","maximumHeight","getVertexWithHeightAtCorner","heightRangeScratch","swVertexScratch","seVertexScratch","nwVertexScratch","neVertexScratch","heightmapBuffer","Uint8Array","scratchCreateMeshSyncOptions","tilingScheme","x","y","exaggeration","initialize","terrainProvider","_imageryLayers","nwCorner","getCorner","swCorner","seCorner","neCorner","southwestHeight","southeastHeight","northwestHeight","northeastHeight","Math","min","max","middleHeight","len","geometricError","getLevelMaximumGeometricError","minCutThroughRadius","maximumRadius","maxTileWidth","acos","width","terrainData","buffer","structure","heightOffset","createMeshSyncOptions","_createMeshSync","encoding","centerCartographic","longitude","latitude","center","cartographicToCartesian","maxVertexCount","meshes","eastIndicesNorthToSouth","northIndicesWestToEast","westIndicesSouthToNorth","southIndicesEastToWest","heightRange","stride","getStride","typedArray","Float32Array","nextIndex","northwestIndex","addVertexWithComputedPosition","addEdge","southwestIndex","southeastIndex","northeastIndex","obb","fromRectangle","southMercatorY","geodeticLatitudeToMercatorAngle","oneOverMercatorHeight","centerWebMercatorT","geodeticSurfaceNormalCartographic","centerEncodedNormal","octEncode","centerIndex","encode","fromElements","vertexCount","bytesPerIndex","indexCount","indexDataBytes","availableBytesInBuffer","BYTES_PER_ELEMENT","indices","Uint16Array","indexOut","fromOrientedBoundingBox","computeOccludeePoint","terrainExaggeration","context","_createVertexArrayForMesh","processImagery","oldTexture","hasWaterMask","waterSourceTile","_findAncestorTileWithTerrainData","_computeWaterMaskTranslationAndScale","index","webMercatorT","cartographic","lerp","position","uv","sourceRectangleScratch","transformTextureCoordinates","targetTile","coordinates","result","targetRectangle","getNumberOfXTilesAtLevel","clone","TWO_PI","sourceWidth","umin","umax","sourceHeight","vmin","vmax","abs","encodedNormalScratch","getVertexFromTileAtCorner","sourceIndex","sourceEncoding","sourceVertices","vertices","decodeHeight","hasVertexNormals","getOctEncodedNormal","normal","encodedNormalScratch2","cartesianScratch2","getInterpolatedVertexAtCorner","previousIndex","interpolateU","previousUv","decodeTextureCoordinates","nextUv","ratio","height1","height2","encodedNormal1","encodedNormal2","normal1","octDecode","normal2","normalize","terrainFillMesh","cornerTile","cornerMesh","previousEdgeTiles","previousEdgeMeshes","nextEdgeTiles","nextEdgeMeshes","gotCorner","getCornerFromEdge","vertexIndex","meshIsUsable","getClosestHeightToCorner","previousMeshes","previousTiles","previousEdge","nextMeshes","nextTiles","nextEdge","getNearestHeightOnEdge","addEdgeMesh","edgeTile","edgeMesh","lastU","lastV","compareU","targetStride","hasWebMercatorT","uOrV","nearlyEdgeU","nearlyEdgeV","decodePosition","tiles","isNext","edge","meshStart","meshEnd","meshStep","meshIndex","edgeVertices","increasing","vertexIndexIndex","targetUv","textureCoordinate","cornerPositionsScratch","ellipsoidalOccluder","_occluders","cornerPositions","fromRadians","computeHorizonCullingPointPossiblyUnderEllipsoid"],"mappings":"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","sourcesContent":["import AttributeCompression from \"../Core/AttributeCompression.js\";\nimport binarySearch from \"../Core/binarySearch.js\";\nimport BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport HeightmapTerrainData from \"../Core/HeightmapTerrainData.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport OrientedBoundingBox from \"../Core/OrientedBoundingBox.js\";\nimport Queue from \"../Core/Queue.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport TerrainEncoding from \"../Core/TerrainEncoding.js\";\nimport TerrainMesh from \"../Core/TerrainMesh.js\";\nimport TileEdge from \"../Core/TileEdge.js\";\nimport WebMercatorProjection from \"../Core/WebMercatorProjection.js\";\nimport GlobeSurfaceTile from \"./GlobeSurfaceTile.js\";\nimport TileSelectionResult from \"./TileSelectionResult.js\";\n\nfunction TerrainFillMesh(tile) {\n  this.tile = tile;\n  this.frameLastUpdated = undefined;\n  this.westMeshes = []; // north to south (CCW)\n  this.westTiles = [];\n  this.southMeshes = []; // west to east (CCW)\n  this.southTiles = [];\n  this.eastMeshes = []; // south to north (CCW)\n  this.eastTiles = [];\n  this.northMeshes = []; // east to west (CCW)\n  this.northTiles = [];\n  this.southwestMesh = undefined;\n  this.southwestTile = undefined;\n  this.southeastMesh = undefined;\n  this.southeastTile = undefined;\n  this.northwestMesh = undefined;\n  this.northwestTile = undefined;\n  this.northeastMesh = undefined;\n  this.northeastTile = undefined;\n  this.changedThisFrame = true;\n  this.visitedFrame = undefined;\n  this.enqueuedFrame = undefined;\n  this.mesh = undefined;\n  this.vertexArray = undefined;\n  this.waterMaskTexture = undefined;\n  this.waterMaskTranslationAndScale = new Cartesian4();\n}\n\nTerrainFillMesh.prototype.update = function (\n  tileProvider,\n  frameState,\n  vertexArraysToDestroy\n) {\n  if (this.changedThisFrame) {\n    createFillMesh(tileProvider, frameState, this.tile, vertexArraysToDestroy);\n    this.changedThisFrame = false;\n  }\n};\n\nTerrainFillMesh.prototype.destroy = function (vertexArraysToDestroy) {\n  if (defined(this.vertexArray)) {\n    if (defined(vertexArraysToDestroy)) {\n      vertexArraysToDestroy.push(this.vertexArray);\n    } else {\n      GlobeSurfaceTile._freeVertexArray(\n        this.vertexArray,\n        vertexArraysToDestroy\n      );\n    }\n    this.vertexArray = undefined;\n  }\n\n  if (defined(this.waterMaskTexture)) {\n    --this.waterMaskTexture.referenceCount;\n    if (this.waterMaskTexture.referenceCount === 0) {\n      this.waterMaskTexture.destroy();\n    }\n    this.waterMaskTexture = undefined;\n  }\n\n  return undefined;\n};\n\nvar traversalQueueScratch = new Queue();\n\nTerrainFillMesh.updateFillTiles = function (\n  tileProvider,\n  renderedTiles,\n  frameState,\n  vertexArraysToDestroy\n) {\n  // We want our fill tiles to look natural, which means they should align perfectly with\n  // adjacent loaded tiles, and their edges that are not adjacent to loaded tiles should have\n  // sensible heights (e.g. the average of the heights of loaded edges). Some fill tiles may\n  // be adjacent only to other fill tiles, and in that case heights should be assigned fanning\n  // outward from the loaded tiles so that there are no sudden changes in height.\n\n  // We do this with a breadth-first traversal of the rendered tiles, starting with the loaded\n  // ones. Graph nodes are tiles and graph edges connect to other rendered tiles that are spatially adjacent\n  // to those tiles. As we visit each node, we propagate tile edges to adjacent tiles. If there's no data\n  // for a tile edge,  we create an edge with an average height and then propagate it. If an edge is partially defined\n  // (e.g. an edge is adjacent to multiple more-detailed tiles and only some of them are loaded), we\n  // fill in the rest of the edge with the same height.\n  var quadtree = tileProvider._quadtree;\n  var levelZeroTiles = quadtree._levelZeroTiles;\n  var lastSelectionFrameNumber = quadtree._lastSelectionFrameNumber;\n\n  var traversalQueue = traversalQueueScratch;\n  traversalQueue.clear();\n\n  // Add the tiles with real geometry to the traversal queue.\n  for (var i = 0; i < renderedTiles.length; ++i) {\n    var renderedTile = renderedTiles[i];\n    if (defined(renderedTile.data.vertexArray)) {\n      traversalQueue.enqueue(renderedTiles[i]);\n    }\n  }\n\n  var tile = traversalQueue.dequeue();\n\n  while (tile !== undefined) {\n    var tileToWest = tile.findTileToWest(levelZeroTiles);\n    var tileToSouth = tile.findTileToSouth(levelZeroTiles);\n    var tileToEast = tile.findTileToEast(levelZeroTiles);\n    var tileToNorth = tile.findTileToNorth(levelZeroTiles);\n    visitRenderedTiles(\n      tileProvider,\n      frameState,\n      tile,\n      tileToWest,\n      lastSelectionFrameNumber,\n      TileEdge.EAST,\n      false,\n      traversalQueue,\n      vertexArraysToDestroy\n    );\n    visitRenderedTiles(\n      tileProvider,\n      frameState,\n      tile,\n      tileToSouth,\n      lastSelectionFrameNumber,\n      TileEdge.NORTH,\n      false,\n      traversalQueue,\n      vertexArraysToDestroy\n    );\n    visitRenderedTiles(\n      tileProvider,\n      frameState,\n      tile,\n      tileToEast,\n      lastSelectionFrameNumber,\n      TileEdge.WEST,\n      false,\n      traversalQueue,\n      vertexArraysToDestroy\n    );\n    visitRenderedTiles(\n      tileProvider,\n      frameState,\n      tile,\n      tileToNorth,\n      lastSelectionFrameNumber,\n      TileEdge.SOUTH,\n      false,\n      traversalQueue,\n      vertexArraysToDestroy\n    );\n\n    var tileToNorthwest = tileToWest.findTileToNorth(levelZeroTiles);\n    var tileToSouthwest = tileToWest.findTileToSouth(levelZeroTiles);\n    var tileToNortheast = tileToEast.findTileToNorth(levelZeroTiles);\n    var tileToSoutheast = tileToEast.findTileToSouth(levelZeroTiles);\n    visitRenderedTiles(\n      tileProvider,\n      frameState,\n      tile,\n      tileToNorthwest,\n      lastSelectionFrameNumber,\n      TileEdge.SOUTHEAST,\n      false,\n      traversalQueue,\n      vertexArraysToDestroy\n    );\n    visitRenderedTiles(\n      tileProvider,\n      frameState,\n      tile,\n      tileToNortheast,\n      lastSelectionFrameNumber,\n      TileEdge.SOUTHWEST,\n      false,\n      traversalQueue,\n      vertexArraysToDestroy\n    );\n    visitRenderedTiles(\n      tileProvider,\n      frameState,\n      tile,\n      tileToSouthwest,\n      lastSelectionFrameNumber,\n      TileEdge.NORTHEAST,\n      false,\n      traversalQueue,\n      vertexArraysToDestroy\n    );\n    visitRenderedTiles(\n      tileProvider,\n      frameState,\n      tile,\n      tileToSoutheast,\n      lastSelectionFrameNumber,\n      TileEdge.NORTHWEST,\n      false,\n      traversalQueue,\n      vertexArraysToDestroy\n    );\n\n    tile = traversalQueue.dequeue();\n  }\n};\n\nfunction visitRenderedTiles(\n  tileProvider,\n  frameState,\n  sourceTile,\n  startTile,\n  currentFrameNumber,\n  tileEdge,\n  downOnly,\n  traversalQueue,\n  vertexArraysToDestroy\n) {\n  if (startTile === undefined) {\n    // There are no tiles North or South of the poles.\n    return;\n  }\n\n  var tile = startTile;\n  while (\n    tile &&\n    (tile._lastSelectionResultFrame !== currentFrameNumber ||\n      TileSelectionResult.wasKicked(tile._lastSelectionResult) ||\n      TileSelectionResult.originalResult(tile._lastSelectionResult) ===\n        TileSelectionResult.CULLED)\n  ) {\n    // This tile wasn't visited or it was visited and then kicked, so walk up to find the closest ancestor that was rendered.\n    // We also walk up if the tile was culled, because if siblings were kicked an ancestor may have been rendered.\n    if (downOnly) {\n      return;\n    }\n\n    var parent = tile.parent;\n    if (tileEdge >= TileEdge.NORTHWEST && parent !== undefined) {\n      // When we're looking for a corner, verify that the parent tile is still relevant.\n      // That is, the parent and child must share the corner in question.\n      switch (tileEdge) {\n        case TileEdge.NORTHWEST:\n          tile = tile === parent.northwestChild ? parent : undefined;\n          break;\n        case TileEdge.NORTHEAST:\n          tile = tile === parent.northeastChild ? parent : undefined;\n          break;\n        case TileEdge.SOUTHWEST:\n          tile = tile === parent.southwestChild ? parent : undefined;\n          break;\n        case TileEdge.SOUTHEAST:\n          tile = tile === parent.southeastChild ? parent : undefined;\n          break;\n      }\n    } else {\n      tile = parent;\n    }\n  }\n\n  if (tile === undefined) {\n    return;\n  }\n\n  if (tile._lastSelectionResult === TileSelectionResult.RENDERED) {\n    if (defined(tile.data.vertexArray)) {\n      // No further processing necessary for renderable tiles.\n      return;\n    }\n    visitTile(\n      tileProvider,\n      frameState,\n      sourceTile,\n      tile,\n      tileEdge,\n      currentFrameNumber,\n      traversalQueue,\n      vertexArraysToDestroy\n    );\n    return;\n  }\n\n  if (\n    TileSelectionResult.originalResult(startTile._lastSelectionResult) ===\n    TileSelectionResult.CULLED\n  ) {\n    return;\n  }\n\n  // This tile was refined, so find rendered children, if any.\n  // Visit the tiles in counter-clockwise order.\n  switch (tileEdge) {\n    case TileEdge.WEST:\n      visitRenderedTiles(\n        tileProvider,\n        frameState,\n        sourceTile,\n        startTile.northwestChild,\n        currentFrameNumber,\n        tileEdge,\n        true,\n        traversalQueue,\n        vertexArraysToDestroy\n      );\n      visitRenderedTiles(\n        tileProvider,\n        frameState,\n        sourceTile,\n        startTile.southwestChild,\n        currentFrameNumber,\n        tileEdge,\n        true,\n        traversalQueue,\n        vertexArraysToDestroy\n      );\n      break;\n    case TileEdge.EAST:\n      visitRenderedTiles(\n        tileProvider,\n        frameState,\n        sourceTile,\n        startTile.southeastChild,\n        currentFrameNumber,\n        tileEdge,\n        true,\n        traversalQueue,\n        vertexArraysToDestroy\n      );\n      visitRenderedTiles(\n        tileProvider,\n        frameState,\n        sourceTile,\n        startTile.northeastChild,\n        currentFrameNumber,\n        tileEdge,\n        true,\n        traversalQueue,\n        vertexArraysToDestroy\n      );\n      break;\n    case TileEdge.SOUTH:\n      visitRenderedTiles(\n        tileProvider,\n        frameState,\n        sourceTile,\n        startTile.southwestChild,\n        currentFrameNumber,\n        tileEdge,\n        true,\n        traversalQueue,\n        vertexArraysToDestroy\n      );\n      visitRenderedTiles(\n        tileProvider,\n        frameState,\n        sourceTile,\n        startTile.southeastChild,\n        currentFrameNumber,\n        tileEdge,\n        true,\n        traversalQueue,\n        vertexArraysToDestroy\n      );\n      break;\n    case TileEdge.NORTH:\n      visitRenderedTiles(\n        tileProvider,\n        frameState,\n        sourceTile,\n        startTile.northeastChild,\n        currentFrameNumber,\n        tileEdge,\n        true,\n        traversalQueue,\n        vertexArraysToDestroy\n      );\n      visitRenderedTiles(\n        tileProvider,\n        frameState,\n        sourceTile,\n        startTile.northwestChild,\n        currentFrameNumber,\n        tileEdge,\n        true,\n        traversalQueue,\n        vertexArraysToDestroy\n      );\n      break;\n    case TileEdge.NORTHWEST:\n      visitRenderedTiles(\n        tileProvider,\n        frameState,\n        sourceTile,\n        startTile.northwestChild,\n        currentFrameNumber,\n        tileEdge,\n        true,\n        traversalQueue,\n        vertexArraysToDestroy\n      );\n      break;\n    case TileEdge.NORTHEAST:\n      visitRenderedTiles(\n        tileProvider,\n        frameState,\n        sourceTile,\n        startTile.northeastChild,\n        currentFrameNumber,\n        tileEdge,\n        true,\n        traversalQueue,\n        vertexArraysToDestroy\n      );\n      break;\n    case TileEdge.SOUTHWEST:\n      visitRenderedTiles(\n        tileProvider,\n        frameState,\n        sourceTile,\n        startTile.southwestChild,\n        currentFrameNumber,\n        tileEdge,\n        true,\n        traversalQueue,\n        vertexArraysToDestroy\n      );\n      break;\n    case TileEdge.SOUTHEAST:\n      visitRenderedTiles(\n        tileProvider,\n        frameState,\n        sourceTile,\n        startTile.southeastChild,\n        currentFrameNumber,\n        tileEdge,\n        true,\n        traversalQueue,\n        vertexArraysToDestroy\n      );\n      break;\n    default:\n      throw new DeveloperError(\"Invalid edge\");\n  }\n}\n\nfunction visitTile(\n  tileProvider,\n  frameState,\n  sourceTile,\n  destinationTile,\n  tileEdge,\n  frameNumber,\n  traversalQueue,\n  vertexArraysToDestroy\n) {\n  var destinationSurfaceTile = destinationTile.data;\n\n  if (destinationSurfaceTile.fill === undefined) {\n    destinationSurfaceTile.fill = new TerrainFillMesh(destinationTile);\n  } else if (destinationSurfaceTile.fill.visitedFrame === frameNumber) {\n    // Don't propagate edges to tiles that have already been visited this frame.\n    return;\n  }\n\n  if (destinationSurfaceTile.fill.enqueuedFrame !== frameNumber) {\n    // First time visiting this tile this frame, add it to the traversal queue.\n    destinationSurfaceTile.fill.enqueuedFrame = frameNumber;\n    destinationSurfaceTile.fill.changedThisFrame = false;\n    traversalQueue.enqueue(destinationTile);\n  }\n\n  propagateEdge(\n    tileProvider,\n    frameState,\n    sourceTile,\n    destinationTile,\n    tileEdge,\n    vertexArraysToDestroy\n  );\n}\n\nfunction propagateEdge(\n  tileProvider,\n  frameState,\n  sourceTile,\n  destinationTile,\n  tileEdge,\n  vertexArraysToDestroy\n) {\n  var destinationFill = destinationTile.data.fill;\n\n  var sourceMesh;\n  var sourceFill = sourceTile.data.fill;\n  if (defined(sourceFill)) {\n    sourceFill.visitedFrame = frameState.frameNumber;\n\n    // Source is a fill, create/update it if necessary.\n    if (sourceFill.changedThisFrame) {\n      createFillMesh(\n        tileProvider,\n        frameState,\n        sourceTile,\n        vertexArraysToDestroy\n      );\n      sourceFill.changedThisFrame = false;\n    }\n    sourceMesh = sourceTile.data.fill.mesh;\n  } else {\n    sourceMesh = sourceTile.data.mesh;\n  }\n\n  var edgeMeshes;\n  var edgeTiles;\n\n  switch (tileEdge) {\n    case TileEdge.WEST:\n      edgeMeshes = destinationFill.westMeshes;\n      edgeTiles = destinationFill.westTiles;\n      break;\n    case TileEdge.SOUTH:\n      edgeMeshes = destinationFill.southMeshes;\n      edgeTiles = destinationFill.southTiles;\n      break;\n    case TileEdge.EAST:\n      edgeMeshes = destinationFill.eastMeshes;\n      edgeTiles = destinationFill.eastTiles;\n      break;\n    case TileEdge.NORTH:\n      edgeMeshes = destinationFill.northMeshes;\n      edgeTiles = destinationFill.northTiles;\n      break;\n    // Corners are simpler.\n    case TileEdge.NORTHWEST:\n      destinationFill.changedThisFrame =\n        destinationFill.changedThisFrame ||\n        destinationFill.northwestMesh !== sourceMesh;\n      destinationFill.northwestMesh = sourceMesh;\n      destinationFill.northwestTile = sourceTile;\n      return;\n    case TileEdge.NORTHEAST:\n      destinationFill.changedThisFrame =\n        destinationFill.changedThisFrame ||\n        destinationFill.northeastMesh !== sourceMesh;\n      destinationFill.northeastMesh = sourceMesh;\n      destinationFill.northeastTile = sourceTile;\n      return;\n    case TileEdge.SOUTHWEST:\n      destinationFill.changedThisFrame =\n        destinationFill.changedThisFrame ||\n        destinationFill.southwestMesh !== sourceMesh;\n      destinationFill.southwestMesh = sourceMesh;\n      destinationFill.southwestTile = sourceTile;\n      return;\n    case TileEdge.SOUTHEAST:\n      destinationFill.changedThisFrame =\n        destinationFill.changedThisFrame ||\n        destinationFill.southeastMesh !== sourceMesh;\n      destinationFill.southeastMesh = sourceMesh;\n      destinationFill.southeastTile = sourceTile;\n      return;\n  }\n\n  if (sourceTile.level <= destinationTile.level) {\n    // Source edge completely spans the destination edge.\n    destinationFill.changedThisFrame =\n      destinationFill.changedThisFrame ||\n      edgeMeshes[0] !== sourceMesh ||\n      edgeMeshes.length !== 1;\n    edgeMeshes[0] = sourceMesh;\n    edgeTiles[0] = sourceTile;\n    edgeMeshes.length = 1;\n    edgeTiles.length = 1;\n    return;\n  }\n\n  // Source edge is a subset of the destination edge.\n  // Figure out the range of meshes we're replacing.\n  var startIndex, endIndex, existingTile, existingRectangle;\n  var sourceRectangle = sourceTile.rectangle;\n\n  var epsilon;\n  var destinationRectangle = destinationTile.rectangle;\n\n  switch (tileEdge) {\n    case TileEdge.WEST:\n      epsilon =\n        (destinationRectangle.north - destinationRectangle.south) *\n        CesiumMath.EPSILON5;\n\n      for (startIndex = 0; startIndex < edgeTiles.length; ++startIndex) {\n        existingTile = edgeTiles[startIndex];\n        existingRectangle = existingTile.rectangle;\n        if (\n          CesiumMath.greaterThan(\n            sourceRectangle.north,\n            existingRectangle.south,\n            epsilon\n          )\n        ) {\n          break;\n        }\n      }\n      for (endIndex = startIndex; endIndex < edgeTiles.length; ++endIndex) {\n        existingTile = edgeTiles[endIndex];\n        existingRectangle = existingTile.rectangle;\n        if (\n          CesiumMath.greaterThanOrEquals(\n            sourceRectangle.south,\n            existingRectangle.north,\n            epsilon\n          )\n        ) {\n          break;\n        }\n      }\n      break;\n    case TileEdge.SOUTH:\n      epsilon =\n        (destinationRectangle.east - destinationRectangle.west) *\n        CesiumMath.EPSILON5;\n\n      for (startIndex = 0; startIndex < edgeTiles.length; ++startIndex) {\n        existingTile = edgeTiles[startIndex];\n        existingRectangle = existingTile.rectangle;\n        if (\n          CesiumMath.lessThan(\n            sourceRectangle.west,\n            existingRectangle.east,\n            epsilon\n          )\n        ) {\n          break;\n        }\n      }\n      for (endIndex = startIndex; endIndex < edgeTiles.length; ++endIndex) {\n        existingTile = edgeTiles[endIndex];\n        existingRectangle = existingTile.rectangle;\n        if (\n          CesiumMath.lessThanOrEquals(\n            sourceRectangle.east,\n            existingRectangle.west,\n            epsilon\n          )\n        ) {\n          break;\n        }\n      }\n      break;\n    case TileEdge.EAST:\n      epsilon =\n        (destinationRectangle.north - destinationRectangle.south) *\n        CesiumMath.EPSILON5;\n\n      for (startIndex = 0; startIndex < edgeTiles.length; ++startIndex) {\n        existingTile = edgeTiles[startIndex];\n        existingRectangle = existingTile.rectangle;\n        if (\n          CesiumMath.lessThan(\n            sourceRectangle.south,\n            existingRectangle.north,\n            epsilon\n          )\n        ) {\n          break;\n        }\n      }\n      for (endIndex = startIndex; endIndex < edgeTiles.length; ++endIndex) {\n        existingTile = edgeTiles[endIndex];\n        existingRectangle = existingTile.rectangle;\n        if (\n          CesiumMath.lessThanOrEquals(\n            sourceRectangle.north,\n            existingRectangle.south,\n            epsilon\n          )\n        ) {\n          break;\n        }\n      }\n      break;\n    case TileEdge.NORTH:\n      epsilon =\n        (destinationRectangle.east - destinationRectangle.west) *\n        CesiumMath.EPSILON5;\n\n      for (startIndex = 0; startIndex < edgeTiles.length; ++startIndex) {\n        existingTile = edgeTiles[startIndex];\n        existingRectangle = existingTile.rectangle;\n        if (\n          CesiumMath.greaterThan(\n            sourceRectangle.east,\n            existingRectangle.west,\n            epsilon\n          )\n        ) {\n          break;\n        }\n      }\n      for (endIndex = startIndex; endIndex < edgeTiles.length; ++endIndex) {\n        existingTile = edgeTiles[endIndex];\n        existingRectangle = existingTile.rectangle;\n        if (\n          CesiumMath.greaterThanOrEquals(\n            sourceRectangle.west,\n            existingRectangle.east,\n            epsilon\n          )\n        ) {\n          break;\n        }\n      }\n      break;\n  }\n\n  if (endIndex - startIndex === 1) {\n    destinationFill.changedThisFrame =\n      destinationFill.changedThisFrame || edgeMeshes[startIndex] !== sourceMesh;\n    edgeMeshes[startIndex] = sourceMesh;\n    edgeTiles[startIndex] = sourceTile;\n  } else {\n    destinationFill.changedThisFrame = true;\n    edgeMeshes.splice(startIndex, endIndex - startIndex, sourceMesh);\n    edgeTiles.splice(startIndex, endIndex - startIndex, sourceTile);\n  }\n}\n\nvar cartographicScratch = new Cartographic();\nvar centerCartographicScratch = new Cartographic();\nvar cartesianScratch = new Cartesian3();\nvar normalScratch = new Cartesian3();\nvar octEncodedNormalScratch = new Cartesian2();\nvar uvScratch2 = new Cartesian2();\nvar uvScratch = new Cartesian2();\n\nfunction HeightAndNormal() {\n  this.height = 0.0;\n  this.encodedNormal = new Cartesian2();\n}\n\nfunction fillMissingCorner(\n  fill,\n  ellipsoid,\n  u,\n  v,\n  corner,\n  adjacentCorner1,\n  adjacentCorner2,\n  oppositeCorner,\n  vertex\n) {\n  if (defined(corner)) {\n    return corner;\n  }\n\n  var height;\n\n  if (defined(adjacentCorner1) && defined(adjacentCorner2)) {\n    height = (adjacentCorner1.height + adjacentCorner2.height) * 0.5;\n  } else if (defined(adjacentCorner1)) {\n    height = adjacentCorner1.height;\n  } else if (defined(adjacentCorner2)) {\n    height = adjacentCorner2.height;\n  } else if (defined(oppositeCorner)) {\n    height = oppositeCorner.height;\n  } else {\n    var surfaceTile = fill.tile.data;\n    var tileBoundingRegion = surfaceTile.tileBoundingRegion;\n    var minimumHeight = 0.0;\n    var maximumHeight = 0.0;\n    if (defined(tileBoundingRegion)) {\n      minimumHeight = tileBoundingRegion.minimumHeight;\n      maximumHeight = tileBoundingRegion.maximumHeight;\n    }\n    height = (minimumHeight + maximumHeight) * 0.5;\n  }\n\n  getVertexWithHeightAtCorner(fill, ellipsoid, u, v, height, vertex);\n  return vertex;\n}\n\nvar heightRangeScratch = {\n  minimumHeight: 0.0,\n  maximumHeight: 0.0,\n};\n\nvar swVertexScratch = new HeightAndNormal();\nvar seVertexScratch = new HeightAndNormal();\nvar nwVertexScratch = new HeightAndNormal();\nvar neVertexScratch = new HeightAndNormal();\nvar heightmapBuffer =\n  typeof Uint8Array !== \"undefined\" ? new Uint8Array(9 * 9) : undefined;\n\nvar scratchCreateMeshSyncOptions = {\n  tilingScheme: undefined,\n  x: 0,\n  y: 0,\n  level: 0,\n  exaggeration: 1.0,\n};\nfunction createFillMesh(tileProvider, frameState, tile, vertexArraysToDestroy) {\n  GlobeSurfaceTile.initialize(\n    tile,\n    tileProvider.terrainProvider,\n    tileProvider._imageryLayers\n  );\n\n  var surfaceTile = tile.data;\n  var fill = surfaceTile.fill;\n  var rectangle = tile.rectangle;\n\n  var ellipsoid = tile.tilingScheme.ellipsoid;\n\n  var nwCorner = getCorner(\n    fill,\n    ellipsoid,\n    0.0,\n    1.0,\n    fill.northwestTile,\n    fill.northwestMesh,\n    fill.northTiles,\n    fill.northMeshes,\n    fill.westTiles,\n    fill.westMeshes,\n    nwVertexScratch\n  );\n  var swCorner = getCorner(\n    fill,\n    ellipsoid,\n    0.0,\n    0.0,\n    fill.southwestTile,\n    fill.southwestMesh,\n    fill.westTiles,\n    fill.westMeshes,\n    fill.southTiles,\n    fill.southMeshes,\n    swVertexScratch\n  );\n  var seCorner = getCorner(\n    fill,\n    ellipsoid,\n    1.0,\n    0.0,\n    fill.southeastTile,\n    fill.southeastMesh,\n    fill.southTiles,\n    fill.southMeshes,\n    fill.eastTiles,\n    fill.eastMeshes,\n    seVertexScratch\n  );\n  var neCorner = getCorner(\n    fill,\n    ellipsoid,\n    1.0,\n    1.0,\n    fill.northeastTile,\n    fill.northeastMesh,\n    fill.eastTiles,\n    fill.eastMeshes,\n    fill.northTiles,\n    fill.northMeshes,\n    neVertexScratch\n  );\n\n  nwCorner = fillMissingCorner(\n    fill,\n    ellipsoid,\n    0.0,\n    1.0,\n    nwCorner,\n    swCorner,\n    neCorner,\n    seCorner,\n    nwVertexScratch\n  );\n  swCorner = fillMissingCorner(\n    fill,\n    ellipsoid,\n    0.0,\n    0.0,\n    swCorner,\n    nwCorner,\n    seCorner,\n    neCorner,\n    swVertexScratch\n  );\n  seCorner = fillMissingCorner(\n    fill,\n    ellipsoid,\n    1.0,\n    1.0,\n    seCorner,\n    swCorner,\n    neCorner,\n    nwCorner,\n    seVertexScratch\n  );\n  neCorner = fillMissingCorner(\n    fill,\n    ellipsoid,\n    1.0,\n    1.0,\n    neCorner,\n    seCorner,\n    nwCorner,\n    swCorner,\n    neVertexScratch\n  );\n\n  var southwestHeight = swCorner.height;\n  var southeastHeight = seCorner.height;\n  var northwestHeight = nwCorner.height;\n  var northeastHeight = neCorner.height;\n\n  var minimumHeight = Math.min(\n    southwestHeight,\n    southeastHeight,\n    northwestHeight,\n    northeastHeight\n  );\n  var maximumHeight = Math.max(\n    southwestHeight,\n    southeastHeight,\n    northwestHeight,\n    northeastHeight\n  );\n\n  var middleHeight = (minimumHeight + maximumHeight) * 0.5;\n\n  var i;\n  var len;\n\n  // For low-detail tiles, our usual fill tile approach will create tiles that\n  // look really blocky because they don't have enough vertices to account for the\n  // Earth's curvature. But the height range will also typically be well within\n  // the allowed geometric error for those levels. So fill such tiles with a\n  // constant-height heightmap.\n  var geometricError = tileProvider.getLevelMaximumGeometricError(tile.level);\n  var minCutThroughRadius = ellipsoid.maximumRadius - geometricError;\n  var maxTileWidth =\n    Math.acos(minCutThroughRadius / ellipsoid.maximumRadius) * 4.0;\n\n  // When the tile width is greater than maxTileWidth as computed above, the error\n  // of a normal fill tile from globe curvature alone will exceed the allowed geometric\n  // error. Terrain won't change that much. However, we can allow more error than that.\n  // A little blockiness during load is acceptable. For the WGS84 ellipsoid and\n  // standard geometric error setup, the value here will have us use a heightmap\n  // at levels 1, 2, and 3.\n  maxTileWidth *= 1.5;\n\n  if (\n    rectangle.width > maxTileWidth &&\n    maximumHeight - minimumHeight <= geometricError\n  ) {\n    var terrainData = new HeightmapTerrainData({\n      width: 9,\n      height: 9,\n      buffer: heightmapBuffer,\n      structure: {\n        // Use the maximum as the constant height so that this tile's skirt\n        // covers any cracks with adjacent tiles.\n        heightOffset: maximumHeight,\n      },\n    });\n\n    var createMeshSyncOptions = scratchCreateMeshSyncOptions;\n    createMeshSyncOptions.tilingScheme = tile.tilingScheme;\n    createMeshSyncOptions.x = tile.x;\n    createMeshSyncOptions.y = tile.y;\n    createMeshSyncOptions.level = tile.level;\n\n    fill.mesh = terrainData._createMeshSync(createMeshSyncOptions);\n  } else {\n    var encoding = new TerrainEncoding(\n      undefined,\n      undefined,\n      undefined,\n      undefined,\n      true,\n      true\n    );\n\n    var centerCartographic = centerCartographicScratch;\n    centerCartographic.longitude = (rectangle.east + rectangle.west) * 0.5;\n    centerCartographic.latitude = (rectangle.north + rectangle.south) * 0.5;\n    centerCartographic.height = middleHeight;\n    encoding.center = ellipsoid.cartographicToCartesian(\n      centerCartographic,\n      encoding.center\n    );\n\n    // At _most_, we have vertices for the 4 corners, plus 1 center, plus every adjacent edge vertex.\n    // In reality there will be less most of the time, but close enough; better\n    // to overestimate than to re-allocate/copy/traverse the vertices twice.\n    // Also, we'll often be able to squeeze the index data into the extra space in the buffer.\n    var maxVertexCount = 5;\n    var meshes;\n\n    meshes = fill.westMeshes;\n    for (i = 0, len = meshes.length; i < len; ++i) {\n      maxVertexCount += meshes[i].eastIndicesNorthToSouth.length;\n    }\n\n    meshes = fill.southMeshes;\n    for (i = 0, len = meshes.length; i < len; ++i) {\n      maxVertexCount += meshes[i].northIndicesWestToEast.length;\n    }\n\n    meshes = fill.eastMeshes;\n    for (i = 0, len = meshes.length; i < len; ++i) {\n      maxVertexCount += meshes[i].westIndicesSouthToNorth.length;\n    }\n\n    meshes = fill.northMeshes;\n    for (i = 0, len = meshes.length; i < len; ++i) {\n      maxVertexCount += meshes[i].southIndicesEastToWest.length;\n    }\n\n    var heightRange = heightRangeScratch;\n    heightRange.minimumHeight = minimumHeight;\n    heightRange.maximumHeight = maximumHeight;\n\n    var stride = encoding.getStride();\n    var typedArray = new Float32Array(maxVertexCount * stride);\n\n    var nextIndex = 0;\n    var northwestIndex = nextIndex;\n    nextIndex = addVertexWithComputedPosition(\n      ellipsoid,\n      rectangle,\n      encoding,\n      typedArray,\n      nextIndex,\n      0.0,\n      1.0,\n      nwCorner.height,\n      nwCorner.encodedNormal,\n      1.0,\n      heightRange\n    );\n    nextIndex = addEdge(\n      fill,\n      ellipsoid,\n      encoding,\n      typedArray,\n      nextIndex,\n      fill.westTiles,\n      fill.westMeshes,\n      TileEdge.EAST,\n      heightRange\n    );\n    var southwestIndex = nextIndex;\n    nextIndex = addVertexWithComputedPosition(\n      ellipsoid,\n      rectangle,\n      encoding,\n      typedArray,\n      nextIndex,\n      0.0,\n      0.0,\n      swCorner.height,\n      swCorner.encodedNormal,\n      0.0,\n      heightRange\n    );\n    nextIndex = addEdge(\n      fill,\n      ellipsoid,\n      encoding,\n      typedArray,\n      nextIndex,\n      fill.southTiles,\n      fill.southMeshes,\n      TileEdge.NORTH,\n      heightRange\n    );\n    var southeastIndex = nextIndex;\n    nextIndex = addVertexWithComputedPosition(\n      ellipsoid,\n      rectangle,\n      encoding,\n      typedArray,\n      nextIndex,\n      1.0,\n      0.0,\n      seCorner.height,\n      seCorner.encodedNormal,\n      0.0,\n      heightRange\n    );\n    nextIndex = addEdge(\n      fill,\n      ellipsoid,\n      encoding,\n      typedArray,\n      nextIndex,\n      fill.eastTiles,\n      fill.eastMeshes,\n      TileEdge.WEST,\n      heightRange\n    );\n    var northeastIndex = nextIndex;\n    nextIndex = addVertexWithComputedPosition(\n      ellipsoid,\n      rectangle,\n      encoding,\n      typedArray,\n      nextIndex,\n      1.0,\n      1.0,\n      neCorner.height,\n      neCorner.encodedNormal,\n      1.0,\n      heightRange\n    );\n    nextIndex = addEdge(\n      fill,\n      ellipsoid,\n      encoding,\n      typedArray,\n      nextIndex,\n      fill.northTiles,\n      fill.northMeshes,\n      TileEdge.SOUTH,\n      heightRange\n    );\n\n    minimumHeight = heightRange.minimumHeight;\n    maximumHeight = heightRange.maximumHeight;\n\n    var obb = OrientedBoundingBox.fromRectangle(\n      rectangle,\n      minimumHeight,\n      maximumHeight,\n      tile.tilingScheme.ellipsoid\n    );\n\n    // Add a single vertex at the center of the tile.\n    var southMercatorY = WebMercatorProjection.geodeticLatitudeToMercatorAngle(\n      rectangle.south\n    );\n    var oneOverMercatorHeight =\n      1.0 /\n      (WebMercatorProjection.geodeticLatitudeToMercatorAngle(rectangle.north) -\n        southMercatorY);\n    var centerWebMercatorT =\n      (WebMercatorProjection.geodeticLatitudeToMercatorAngle(\n        centerCartographic.latitude\n      ) -\n        southMercatorY) *\n      oneOverMercatorHeight;\n\n    ellipsoid.geodeticSurfaceNormalCartographic(\n      cartographicScratch,\n      normalScratch\n    );\n    var centerEncodedNormal = AttributeCompression.octEncode(\n      normalScratch,\n      octEncodedNormalScratch\n    );\n\n    var centerIndex = nextIndex;\n    encoding.encode(\n      typedArray,\n      nextIndex * stride,\n      obb.center,\n      Cartesian2.fromElements(0.5, 0.5, uvScratch),\n      middleHeight,\n      centerEncodedNormal,\n      centerWebMercatorT\n    );\n    ++nextIndex;\n\n    var vertexCount = nextIndex;\n\n    var bytesPerIndex = vertexCount < 256 ? 1 : 2;\n    var indexCount = (vertexCount - 1) * 3; // one triangle per edge vertex\n    var indexDataBytes = indexCount * bytesPerIndex;\n    var availableBytesInBuffer =\n      (typedArray.length - vertexCount * stride) *\n      Float32Array.BYTES_PER_ELEMENT;\n\n    var indices;\n    if (availableBytesInBuffer >= indexDataBytes) {\n      // Store the index data in the same buffer as the vertex data.\n      var startIndex = vertexCount * stride * Float32Array.BYTES_PER_ELEMENT;\n      indices =\n        vertexCount < 256\n          ? new Uint8Array(typedArray.buffer, startIndex, indexCount)\n          : new Uint16Array(typedArray.buffer, startIndex, indexCount);\n    } else {\n      // Allocate a new buffer for the index data.\n      indices =\n        vertexCount < 256\n          ? new Uint8Array(indexCount)\n          : new Uint16Array(indexCount);\n    }\n\n    typedArray = new Float32Array(typedArray.buffer, 0, vertexCount * stride);\n\n    var indexOut = 0;\n    for (i = 0; i < vertexCount - 2; ++i) {\n      indices[indexOut++] = centerIndex;\n      indices[indexOut++] = i;\n      indices[indexOut++] = i + 1;\n    }\n\n    indices[indexOut++] = centerIndex;\n    indices[indexOut++] = i;\n    indices[indexOut++] = 0;\n\n    var westIndicesSouthToNorth = [];\n    for (i = southwestIndex; i >= northwestIndex; --i) {\n      westIndicesSouthToNorth.push(i);\n    }\n\n    var southIndicesEastToWest = [];\n    for (i = southeastIndex; i >= southwestIndex; --i) {\n      southIndicesEastToWest.push(i);\n    }\n\n    var eastIndicesNorthToSouth = [];\n    for (i = northeastIndex; i >= southeastIndex; --i) {\n      eastIndicesNorthToSouth.push(i);\n    }\n\n    var northIndicesWestToEast = [];\n    northIndicesWestToEast.push(0);\n    for (i = centerIndex - 1; i >= northeastIndex; --i) {\n      northIndicesWestToEast.push(i);\n    }\n\n    fill.mesh = new TerrainMesh(\n      encoding.center,\n      typedArray,\n      indices,\n      indexCount,\n      vertexCount,\n      minimumHeight,\n      maximumHeight,\n      BoundingSphere.fromOrientedBoundingBox(obb),\n      computeOccludeePoint(\n        tileProvider,\n        obb.center,\n        rectangle,\n        minimumHeight,\n        maximumHeight\n      ),\n      encoding.getStride(),\n      obb,\n      encoding,\n      frameState.terrainExaggeration,\n      westIndicesSouthToNorth,\n      southIndicesEastToWest,\n      eastIndicesNorthToSouth,\n      northIndicesWestToEast\n    );\n  }\n\n  var context = frameState.context;\n\n  if (defined(fill.vertexArray)) {\n    if (defined(vertexArraysToDestroy)) {\n      vertexArraysToDestroy.push(fill.vertexArray);\n    } else {\n      GlobeSurfaceTile._freeVertexArray(fill.vertexArray);\n    }\n  }\n\n  fill.vertexArray = GlobeSurfaceTile._createVertexArrayForMesh(\n    context,\n    fill.mesh\n  );\n  surfaceTile.processImagery(\n    tile,\n    tileProvider.terrainProvider,\n    frameState,\n    true\n  );\n\n  var oldTexture = fill.waterMaskTexture;\n  fill.waterMaskTexture = undefined;\n\n  if (tileProvider.terrainProvider.hasWaterMask) {\n    var waterSourceTile = surfaceTile._findAncestorTileWithTerrainData(tile);\n    if (\n      defined(waterSourceTile) &&\n      defined(waterSourceTile.data.waterMaskTexture)\n    ) {\n      fill.waterMaskTexture = waterSourceTile.data.waterMaskTexture;\n      ++fill.waterMaskTexture.referenceCount;\n      surfaceTile._computeWaterMaskTranslationAndScale(\n        tile,\n        waterSourceTile,\n        fill.waterMaskTranslationAndScale\n      );\n    }\n  }\n\n  if (defined(oldTexture)) {\n    --oldTexture.referenceCount;\n    if (oldTexture.referenceCount === 0) {\n      oldTexture.destroy();\n    }\n  }\n}\n\nfunction addVertexWithComputedPosition(\n  ellipsoid,\n  rectangle,\n  encoding,\n  buffer,\n  index,\n  u,\n  v,\n  height,\n  encodedNormal,\n  webMercatorT,\n  heightRange\n) {\n  var cartographic = cartographicScratch;\n  cartographic.longitude = CesiumMath.lerp(rectangle.west, rectangle.east, u);\n  cartographic.latitude = CesiumMath.lerp(rectangle.south, rectangle.north, v);\n  cartographic.height = height;\n  var position = ellipsoid.cartographicToCartesian(\n    cartographic,\n    cartesianScratch\n  );\n\n  var uv = uvScratch2;\n  uv.x = u;\n  uv.y = v;\n\n  encoding.encode(\n    buffer,\n    index * encoding.getStride(),\n    position,\n    uv,\n    height,\n    encodedNormal,\n    webMercatorT\n  );\n\n  heightRange.minimumHeight = Math.min(heightRange.minimumHeight, height);\n  heightRange.maximumHeight = Math.max(heightRange.maximumHeight, height);\n\n  return index + 1;\n}\n\nvar sourceRectangleScratch = new Rectangle();\n\nfunction transformTextureCoordinates(\n  sourceTile,\n  targetTile,\n  coordinates,\n  result\n) {\n  var sourceRectangle = sourceTile.rectangle;\n  var targetRectangle = targetTile.rectangle;\n\n  // Handle transforming across the anti-meridian.\n  if (\n    targetTile.x === 0 &&\n    coordinates.x === 1.0 &&\n    sourceTile.x ===\n      sourceTile.tilingScheme.getNumberOfXTilesAtLevel(sourceTile.level) - 1\n  ) {\n    sourceRectangle = Rectangle.clone(\n      sourceTile.rectangle,\n      sourceRectangleScratch\n    );\n    sourceRectangle.west -= CesiumMath.TWO_PI;\n    sourceRectangle.east -= CesiumMath.TWO_PI;\n  } else if (\n    sourceTile.x === 0 &&\n    coordinates.x === 0.0 &&\n    targetTile.x ===\n      targetTile.tilingScheme.getNumberOfXTilesAtLevel(targetTile.level) - 1\n  ) {\n    sourceRectangle = Rectangle.clone(\n      sourceTile.rectangle,\n      sourceRectangleScratch\n    );\n    sourceRectangle.west += CesiumMath.TWO_PI;\n    sourceRectangle.east += CesiumMath.TWO_PI;\n  }\n\n  var sourceWidth = sourceRectangle.east - sourceRectangle.west;\n  var umin = (targetRectangle.west - sourceRectangle.west) / sourceWidth;\n  var umax = (targetRectangle.east - sourceRectangle.west) / sourceWidth;\n\n  var sourceHeight = sourceRectangle.north - sourceRectangle.south;\n  var vmin = (targetRectangle.south - sourceRectangle.south) / sourceHeight;\n  var vmax = (targetRectangle.north - sourceRectangle.south) / sourceHeight;\n\n  var u = (coordinates.x - umin) / (umax - umin);\n  var v = (coordinates.y - vmin) / (vmax - vmin);\n\n  // Ensure that coordinates very near the corners are at the corners.\n  if (Math.abs(u) < Math.EPSILON5) {\n    u = 0.0;\n  } else if (Math.abs(u - 1.0) < Math.EPSILON5) {\n    u = 1.0;\n  }\n\n  if (Math.abs(v) < Math.EPSILON5) {\n    v = 0.0;\n  } else if (Math.abs(v - 1.0) < Math.EPSILON5) {\n    v = 1.0;\n  }\n\n  result.x = u;\n  result.y = v;\n  return result;\n}\n\nvar encodedNormalScratch = new Cartesian2();\n\nfunction getVertexFromTileAtCorner(sourceMesh, sourceIndex, u, v, vertex) {\n  var sourceEncoding = sourceMesh.encoding;\n  var sourceVertices = sourceMesh.vertices;\n\n  vertex.height = sourceEncoding.decodeHeight(sourceVertices, sourceIndex);\n\n  if (sourceEncoding.hasVertexNormals) {\n    sourceEncoding.getOctEncodedNormal(\n      sourceVertices,\n      sourceIndex,\n      vertex.encodedNormal\n    );\n  } else {\n    var normal = vertex.encodedNormal;\n    normal.x = 0.0;\n    normal.y = 0.0;\n  }\n}\n\nvar encodedNormalScratch2 = new Cartesian2();\nvar cartesianScratch2 = new Cartesian3();\n\nfunction getInterpolatedVertexAtCorner(\n  ellipsoid,\n  sourceTile,\n  targetTile,\n  sourceMesh,\n  previousIndex,\n  nextIndex,\n  u,\n  v,\n  interpolateU,\n  vertex\n) {\n  var sourceEncoding = sourceMesh.encoding;\n  var sourceVertices = sourceMesh.vertices;\n\n  var previousUv = transformTextureCoordinates(\n    sourceTile,\n    targetTile,\n    sourceEncoding.decodeTextureCoordinates(\n      sourceVertices,\n      previousIndex,\n      uvScratch\n    ),\n    uvScratch\n  );\n  var nextUv = transformTextureCoordinates(\n    sourceTile,\n    targetTile,\n    sourceEncoding.decodeTextureCoordinates(\n      sourceVertices,\n      nextIndex,\n      uvScratch2\n    ),\n    uvScratch2\n  );\n\n  var ratio;\n  if (interpolateU) {\n    ratio = (u - previousUv.x) / (nextUv.x - previousUv.x);\n  } else {\n    ratio = (v - previousUv.y) / (nextUv.y - previousUv.y);\n  }\n\n  var height1 = sourceEncoding.decodeHeight(sourceVertices, previousIndex);\n  var height2 = sourceEncoding.decodeHeight(sourceVertices, nextIndex);\n\n  var targetRectangle = targetTile.rectangle;\n  cartographicScratch.longitude = CesiumMath.lerp(\n    targetRectangle.west,\n    targetRectangle.east,\n    u\n  );\n  cartographicScratch.latitude = CesiumMath.lerp(\n    targetRectangle.south,\n    targetRectangle.north,\n    v\n  );\n  vertex.height = cartographicScratch.height = CesiumMath.lerp(\n    height1,\n    height2,\n    ratio\n  );\n\n  var normal;\n  if (sourceEncoding.hasVertexNormals) {\n    var encodedNormal1 = sourceEncoding.getOctEncodedNormal(\n      sourceVertices,\n      previousIndex,\n      encodedNormalScratch\n    );\n    var encodedNormal2 = sourceEncoding.getOctEncodedNormal(\n      sourceVertices,\n      nextIndex,\n      encodedNormalScratch2\n    );\n    var normal1 = AttributeCompression.octDecode(\n      encodedNormal1.x,\n      encodedNormal1.y,\n      cartesianScratch\n    );\n    var normal2 = AttributeCompression.octDecode(\n      encodedNormal2.x,\n      encodedNormal2.y,\n      cartesianScratch2\n    );\n    normal = Cartesian3.lerp(normal1, normal2, ratio, cartesianScratch);\n    Cartesian3.normalize(normal, normal);\n    AttributeCompression.octEncode(normal, vertex.encodedNormal);\n  } else {\n    normal = ellipsoid.geodeticSurfaceNormalCartographic(\n      cartographicScratch,\n      cartesianScratch\n    );\n    AttributeCompression.octEncode(normal, vertex.encodedNormal);\n  }\n}\n\nfunction getVertexWithHeightAtCorner(\n  terrainFillMesh,\n  ellipsoid,\n  u,\n  v,\n  height,\n  vertex\n) {\n  vertex.height = height;\n  var normal = ellipsoid.geodeticSurfaceNormalCartographic(\n    cartographicScratch,\n    cartesianScratch\n  );\n  AttributeCompression.octEncode(normal, vertex.encodedNormal);\n}\n\nfunction getCorner(\n  terrainFillMesh,\n  ellipsoid,\n  u,\n  v,\n  cornerTile,\n  cornerMesh,\n  previousEdgeTiles,\n  previousEdgeMeshes,\n  nextEdgeTiles,\n  nextEdgeMeshes,\n  vertex\n) {\n  var gotCorner =\n    getCornerFromEdge(\n      terrainFillMesh,\n      ellipsoid,\n      previousEdgeMeshes,\n      previousEdgeTiles,\n      false,\n      u,\n      v,\n      vertex\n    ) ||\n    getCornerFromEdge(\n      terrainFillMesh,\n      ellipsoid,\n      nextEdgeMeshes,\n      nextEdgeTiles,\n      true,\n      u,\n      v,\n      vertex\n    );\n  if (gotCorner) {\n    return vertex;\n  }\n\n  var vertexIndex;\n\n  if (meshIsUsable(cornerTile, cornerMesh)) {\n    // Corner mesh is valid, copy its corner vertex to this mesh.\n    if (u === 0.0) {\n      if (v === 0.0) {\n        // southwest destination, northeast source\n        vertexIndex = cornerMesh.eastIndicesNorthToSouth[0];\n      } else {\n        // northwest destination, southeast source\n        vertexIndex = cornerMesh.southIndicesEastToWest[0];\n      }\n    } else if (v === 0.0) {\n      // southeast destination, northwest source\n      vertexIndex = cornerMesh.northIndicesWestToEast[0];\n    } else {\n      // northeast destination, southwest source\n      vertexIndex = cornerMesh.westIndicesSouthToNorth[0];\n    }\n    getVertexFromTileAtCorner(cornerMesh, vertexIndex, u, v, vertex);\n    return vertex;\n  }\n\n  // There is no precise vertex available from the corner or from either adjacent edge.\n  // This is either because there are no tiles at all at the edges and corner, or\n  // because the tiles at the edge are higher-level-number and don't extend all the way\n  // to the corner.\n  // Try to grab a height from the adjacent edges.\n  var height;\n  if (u === 0.0) {\n    if (v === 0.0) {\n      // southwest\n      height = getClosestHeightToCorner(\n        terrainFillMesh.westMeshes,\n        terrainFillMesh.westTiles,\n        TileEdge.EAST,\n        terrainFillMesh.southMeshes,\n        terrainFillMesh.southTiles,\n        TileEdge.NORTH,\n        u,\n        v\n      );\n    } else {\n      // northwest\n      height = getClosestHeightToCorner(\n        terrainFillMesh.northMeshes,\n        terrainFillMesh.northTiles,\n        TileEdge.SOUTH,\n        terrainFillMesh.westMeshes,\n        terrainFillMesh.westTiles,\n        TileEdge.EAST,\n        u,\n        v\n      );\n    }\n  } else if (v === 0.0) {\n    // southeast\n    height = getClosestHeightToCorner(\n      terrainFillMesh.southMeshes,\n      terrainFillMesh.southTiles,\n      TileEdge.NORTH,\n      terrainFillMesh.eastMeshes,\n      terrainFillMesh.eastTiles,\n      TileEdge.WEST,\n      u,\n      v\n    );\n  } else {\n    // northeast\n    height = getClosestHeightToCorner(\n      terrainFillMesh.eastMeshes,\n      terrainFillMesh.eastTiles,\n      TileEdge.WEST,\n      terrainFillMesh.northMeshes,\n      terrainFillMesh.northTiles,\n      TileEdge.SOUTH,\n      u,\n      v\n    );\n  }\n\n  if (defined(height)) {\n    getVertexWithHeightAtCorner(\n      terrainFillMesh,\n      ellipsoid,\n      u,\n      v,\n      height,\n      vertex\n    );\n    return vertex;\n  }\n\n  // No heights available that are closer than the adjacent corners.\n  return undefined;\n}\n\nfunction getClosestHeightToCorner(\n  previousMeshes,\n  previousTiles,\n  previousEdge,\n  nextMeshes,\n  nextTiles,\n  nextEdge,\n  u,\n  v\n) {\n  var height1 = getNearestHeightOnEdge(\n    previousMeshes,\n    previousTiles,\n    false,\n    previousEdge,\n    u,\n    v\n  );\n  var height2 = getNearestHeightOnEdge(\n    nextMeshes,\n    nextTiles,\n    true,\n    nextEdge,\n    u,\n    v\n  );\n  if (defined(height1) && defined(height2)) {\n    // It would be slightly better to do a weighted average of the two heights\n    // based on their distance from the corner, but it shouldn't matter much in practice.\n    return (height1 + height2) * 0.5;\n  } else if (defined(height1)) {\n    return height1;\n  }\n  return height2;\n}\n\nfunction addEdge(\n  terrainFillMesh,\n  ellipsoid,\n  encoding,\n  typedArray,\n  nextIndex,\n  edgeTiles,\n  edgeMeshes,\n  tileEdge,\n  heightRange\n) {\n  for (var i = 0; i < edgeTiles.length; ++i) {\n    nextIndex = addEdgeMesh(\n      terrainFillMesh,\n      ellipsoid,\n      encoding,\n      typedArray,\n      nextIndex,\n      edgeTiles[i],\n      edgeMeshes[i],\n      tileEdge,\n      heightRange\n    );\n  }\n  return nextIndex;\n}\n\nfunction addEdgeMesh(\n  terrainFillMesh,\n  ellipsoid,\n  encoding,\n  typedArray,\n  nextIndex,\n  edgeTile,\n  edgeMesh,\n  tileEdge,\n  heightRange\n) {\n  // Handle copying edges across the anti-meridian.\n  var sourceRectangle = edgeTile.rectangle;\n  if (tileEdge === TileEdge.EAST && terrainFillMesh.tile.x === 0) {\n    sourceRectangle = Rectangle.clone(\n      edgeTile.rectangle,\n      sourceRectangleScratch\n    );\n    sourceRectangle.west -= CesiumMath.TWO_PI;\n    sourceRectangle.east -= CesiumMath.TWO_PI;\n  } else if (tileEdge === TileEdge.WEST && edgeTile.x === 0) {\n    sourceRectangle = Rectangle.clone(\n      edgeTile.rectangle,\n      sourceRectangleScratch\n    );\n    sourceRectangle.west += CesiumMath.TWO_PI;\n    sourceRectangle.east += CesiumMath.TWO_PI;\n  }\n\n  var targetRectangle = terrainFillMesh.tile.rectangle;\n\n  var lastU;\n  var lastV;\n\n  if (nextIndex > 0) {\n    encoding.decodeTextureCoordinates(typedArray, nextIndex - 1, uvScratch);\n    lastU = uvScratch.x;\n    lastV = uvScratch.y;\n  }\n\n  var indices;\n  var compareU;\n\n  switch (tileEdge) {\n    case TileEdge.WEST:\n      indices = edgeMesh.westIndicesSouthToNorth;\n      compareU = false;\n      break;\n    case TileEdge.NORTH:\n      indices = edgeMesh.northIndicesWestToEast;\n      compareU = true;\n      break;\n    case TileEdge.EAST:\n      indices = edgeMesh.eastIndicesNorthToSouth;\n      compareU = false;\n      break;\n    case TileEdge.SOUTH:\n      indices = edgeMesh.southIndicesEastToWest;\n      compareU = true;\n      break;\n  }\n\n  var sourceTile = edgeTile;\n  var targetTile = terrainFillMesh.tile;\n  var sourceEncoding = edgeMesh.encoding;\n  var sourceVertices = edgeMesh.vertices;\n  var targetStride = encoding.getStride();\n\n  var southMercatorY;\n  var oneOverMercatorHeight;\n  if (sourceEncoding.hasWebMercatorT) {\n    southMercatorY = WebMercatorProjection.geodeticLatitudeToMercatorAngle(\n      targetRectangle.south\n    );\n    oneOverMercatorHeight =\n      1.0 /\n      (WebMercatorProjection.geodeticLatitudeToMercatorAngle(\n        targetRectangle.north\n      ) -\n        southMercatorY);\n  }\n\n  for (var i = 0; i < indices.length; ++i) {\n    var index = indices[i];\n\n    var uv = sourceEncoding.decodeTextureCoordinates(\n      sourceVertices,\n      index,\n      uvScratch\n    );\n    transformTextureCoordinates(sourceTile, targetTile, uv, uv);\n    var u = uv.x;\n    var v = uv.y;\n    var uOrV = compareU ? u : v;\n\n    if (uOrV < 0.0 || uOrV > 1.0) {\n      // Vertex is outside the target tile - skip it.\n      continue;\n    }\n\n    if (\n      Math.abs(u - lastU) < CesiumMath.EPSILON5 &&\n      Math.abs(v - lastV) < CesiumMath.EPSILON5\n    ) {\n      // Vertex is very close to the previous one - skip it.\n      continue;\n    }\n\n    var nearlyEdgeU =\n      Math.abs(u) < CesiumMath.EPSILON5 ||\n      Math.abs(u - 1.0) < CesiumMath.EPSILON5;\n    var nearlyEdgeV =\n      Math.abs(v) < CesiumMath.EPSILON5 ||\n      Math.abs(v - 1.0) < CesiumMath.EPSILON5;\n\n    if (nearlyEdgeU && nearlyEdgeV) {\n      // Corner vertex - skip it.\n      continue;\n    }\n\n    var position = sourceEncoding.decodePosition(\n      sourceVertices,\n      index,\n      cartesianScratch\n    );\n    var height = sourceEncoding.decodeHeight(sourceVertices, index);\n\n    var normal;\n    if (sourceEncoding.hasVertexNormals) {\n      normal = sourceEncoding.getOctEncodedNormal(\n        sourceVertices,\n        index,\n        octEncodedNormalScratch\n      );\n    } else {\n      normal = octEncodedNormalScratch;\n      normal.x = 0.0;\n      normal.y = 0.0;\n    }\n\n    var webMercatorT = v;\n    if (sourceEncoding.hasWebMercatorT) {\n      var latitude = CesiumMath.lerp(\n        targetRectangle.south,\n        targetRectangle.north,\n        v\n      );\n      webMercatorT =\n        (WebMercatorProjection.geodeticLatitudeToMercatorAngle(latitude) -\n          southMercatorY) *\n        oneOverMercatorHeight;\n    }\n\n    encoding.encode(\n      typedArray,\n      nextIndex * targetStride,\n      position,\n      uv,\n      height,\n      normal,\n      webMercatorT\n    );\n\n    heightRange.minimumHeight = Math.min(heightRange.minimumHeight, height);\n    heightRange.maximumHeight = Math.max(heightRange.maximumHeight, height);\n\n    ++nextIndex;\n  }\n\n  return nextIndex;\n}\n\nfunction getNearestHeightOnEdge(meshes, tiles, isNext, edge, u, v) {\n  var meshStart;\n  var meshEnd;\n  var meshStep;\n\n  if (isNext) {\n    meshStart = 0;\n    meshEnd = meshes.length;\n    meshStep = 1;\n  } else {\n    meshStart = meshes.length - 1;\n    meshEnd = -1;\n    meshStep = -1;\n  }\n\n  for (\n    var meshIndex = meshStart;\n    meshIndex !== meshEnd;\n    meshIndex += meshStep\n  ) {\n    var mesh = meshes[meshIndex];\n    var tile = tiles[meshIndex];\n    if (!meshIsUsable(tile, mesh)) {\n      continue;\n    }\n\n    var indices;\n    switch (edge) {\n      case TileEdge.WEST:\n        indices = mesh.westIndicesSouthToNorth;\n        break;\n      case TileEdge.SOUTH:\n        indices = mesh.southIndicesEastToWest;\n        break;\n      case TileEdge.EAST:\n        indices = mesh.eastIndicesNorthToSouth;\n        break;\n      case TileEdge.NORTH:\n        indices = mesh.northIndicesWestToEast;\n        break;\n    }\n\n    var index = indices[isNext ? 0 : indices.length - 1];\n    if (defined(index)) {\n      return mesh.encoding.decodeHeight(mesh.vertices, index);\n    }\n  }\n\n  return undefined;\n}\n\nfunction meshIsUsable(tile, mesh) {\n  return (\n    defined(mesh) &&\n    (!defined(tile.data.fill) || !tile.data.fill.changedThisFrame)\n  );\n}\n\nfunction getCornerFromEdge(\n  terrainFillMesh,\n  ellipsoid,\n  edgeMeshes,\n  edgeTiles,\n  isNext,\n  u,\n  v,\n  vertex\n) {\n  var edgeVertices;\n  var compareU;\n  var increasing;\n  var vertexIndexIndex;\n  var vertexIndex;\n  var sourceTile = edgeTiles[isNext ? 0 : edgeMeshes.length - 1];\n  var sourceMesh = edgeMeshes[isNext ? 0 : edgeMeshes.length - 1];\n\n  if (meshIsUsable(sourceTile, sourceMesh)) {\n    // Previous mesh is valid, but we don't know yet if it covers this corner.\n    if (u === 0.0) {\n      if (v === 0.0) {\n        // southwest\n        edgeVertices = isNext\n          ? sourceMesh.northIndicesWestToEast\n          : sourceMesh.eastIndicesNorthToSouth;\n        compareU = isNext;\n        increasing = isNext;\n      } else {\n        // northwest\n        edgeVertices = isNext\n          ? sourceMesh.eastIndicesNorthToSouth\n          : sourceMesh.southIndicesEastToWest;\n        compareU = !isNext;\n        increasing = false;\n      }\n    } else if (v === 0.0) {\n      // southeast\n      edgeVertices = isNext\n        ? sourceMesh.westIndicesSouthToNorth\n        : sourceMesh.northIndicesWestToEast;\n      compareU = !isNext;\n      increasing = true;\n    } else {\n      // northeast\n      edgeVertices = isNext\n        ? sourceMesh.southIndicesEastToWest\n        : sourceMesh.westIndicesSouthToNorth;\n      compareU = isNext;\n      increasing = !isNext;\n    }\n\n    if (edgeVertices.length > 0) {\n      // The vertex we want will very often be the first/last vertex so check that first.\n      vertexIndexIndex = isNext ? 0 : edgeVertices.length - 1;\n      vertexIndex = edgeVertices[vertexIndexIndex];\n      sourceMesh.encoding.decodeTextureCoordinates(\n        sourceMesh.vertices,\n        vertexIndex,\n        uvScratch\n      );\n      var targetUv = transformTextureCoordinates(\n        sourceTile,\n        terrainFillMesh.tile,\n        uvScratch,\n        uvScratch\n      );\n      if (targetUv.x === u && targetUv.y === v) {\n        // Vertex is good!\n        getVertexFromTileAtCorner(sourceMesh, vertexIndex, u, v, vertex);\n        return true;\n      }\n\n      // The last vertex is not the one we need, try binary searching for the right one.\n      vertexIndexIndex = binarySearch(edgeVertices, compareU ? u : v, function (\n        vertexIndex,\n        textureCoordinate\n      ) {\n        sourceMesh.encoding.decodeTextureCoordinates(\n          sourceMesh.vertices,\n          vertexIndex,\n          uvScratch\n        );\n        var targetUv = transformTextureCoordinates(\n          sourceTile,\n          terrainFillMesh.tile,\n          uvScratch,\n          uvScratch\n        );\n        if (increasing) {\n          if (compareU) {\n            return targetUv.x - u;\n          }\n          return targetUv.y - v;\n        } else if (compareU) {\n          return u - targetUv.x;\n        }\n        return v - targetUv.y;\n      });\n\n      if (vertexIndexIndex < 0) {\n        vertexIndexIndex = ~vertexIndexIndex;\n\n        if (vertexIndexIndex > 0 && vertexIndexIndex < edgeVertices.length) {\n          // The corner falls between two vertices, so interpolate between them.\n          getInterpolatedVertexAtCorner(\n            ellipsoid,\n            sourceTile,\n            terrainFillMesh.tile,\n            sourceMesh,\n            edgeVertices[vertexIndexIndex - 1],\n            edgeVertices[vertexIndexIndex],\n            u,\n            v,\n            compareU,\n            vertex\n          );\n          return true;\n        }\n      } else {\n        // Found a vertex that fits in the corner exactly.\n        getVertexFromTileAtCorner(\n          sourceMesh,\n          edgeVertices[vertexIndexIndex],\n          u,\n          v,\n          vertex\n        );\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nvar cornerPositionsScratch = [\n  new Cartesian3(),\n  new Cartesian3(),\n  new Cartesian3(),\n  new Cartesian3(),\n];\n\nfunction computeOccludeePoint(\n  tileProvider,\n  center,\n  rectangle,\n  minimumHeight,\n  maximumHeight,\n  result\n) {\n  var ellipsoidalOccluder = tileProvider.quadtree._occluders.ellipsoid;\n  var ellipsoid = ellipsoidalOccluder.ellipsoid;\n\n  var cornerPositions = cornerPositionsScratch;\n  Cartesian3.fromRadians(\n    rectangle.west,\n    rectangle.south,\n    maximumHeight,\n    ellipsoid,\n    cornerPositions[0]\n  );\n  Cartesian3.fromRadians(\n    rectangle.east,\n    rectangle.south,\n    maximumHeight,\n    ellipsoid,\n    cornerPositions[1]\n  );\n  Cartesian3.fromRadians(\n    rectangle.west,\n    rectangle.north,\n    maximumHeight,\n    ellipsoid,\n    cornerPositions[2]\n  );\n  Cartesian3.fromRadians(\n    rectangle.east,\n    rectangle.north,\n    maximumHeight,\n    ellipsoid,\n    cornerPositions[3]\n  );\n\n  return ellipsoidalOccluder.computeHorizonCullingPointPossiblyUnderEllipsoid(\n    center,\n    cornerPositions,\n    minimumHeight,\n    result\n  );\n}\nexport default TerrainFillMesh;\n"]},"metadata":{},"sourceType":"module"}