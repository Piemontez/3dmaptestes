{"ast":null,"code":"import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EasingFunction from \"../Core/EasingFunction.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport EllipsoidGeodesic from \"../Core/EllipsoidGeodesic.js\";\nimport Event from \"../Core/Event.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport HeadingPitchRange from \"../Core/HeadingPitchRange.js\";\nimport HeadingPitchRoll from \"../Core/HeadingPitchRoll.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport IntersectionTests from \"../Core/IntersectionTests.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport OrthographicOffCenterFrustum from \"../Core/OrthographicOffCenterFrustum.js\";\nimport PerspectiveFrustum from \"../Core/PerspectiveFrustum.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport Ray from \"../Core/Ray.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport CameraFlightPath from \"./CameraFlightPath.js\";\nimport MapMode2D from \"./MapMode2D.js\";\nimport SceneMode from \"./SceneMode.js\";\n/**\n * The camera is defined by a position, orientation, and view frustum.\n * <br /><br />\n * The orientation forms an orthonormal basis with a view, up and right = view x up unit vectors.\n * <br /><br />\n * The viewing frustum is defined by 6 planes.\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\n * define the unit vector normal to the plane, and the w component is the distance of the\n * plane from the origin/camera position.\n *\n * @alias Camera\n *\n * @constructor\n *\n * @param {Scene} scene The scene.\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Camera.html|Cesium Sandcastle Camera Demo}\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Camera%20Tutorial.html|Cesium Sandcastle Camera Tutorial Example}\n * @demo {@link https://cesium.com/docs/tutorials/camera/|Camera Tutorial}\n *\n * @example\n * // Create a camera looking down the negative z-axis, positioned at the origin,\n * // with a field of view of 60 degrees, and 1:1 aspect ratio.\n * var camera = new Cesium.Camera(scene);\n * camera.position = new Cesium.Cartesian3();\n * camera.direction = Cesium.Cartesian3.negate(Cesium.Cartesian3.UNIT_Z, new Cesium.Cartesian3());\n * camera.up = Cesium.Cartesian3.clone(Cesium.Cartesian3.UNIT_Y);\n * camera.frustum.fov = Cesium.Math.PI_OVER_THREE;\n * camera.frustum.near = 1.0;\n * camera.frustum.far = 2.0;\n */\n\nfunction Camera(scene) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  } //>>includeEnd('debug');\n\n\n  this._scene = scene;\n  this._transform = Matrix4.clone(Matrix4.IDENTITY);\n  this._invTransform = Matrix4.clone(Matrix4.IDENTITY);\n  this._actualTransform = Matrix4.clone(Matrix4.IDENTITY);\n  this._actualInvTransform = Matrix4.clone(Matrix4.IDENTITY);\n  this._transformChanged = false;\n  /**\n   * The position of the camera.\n   *\n   * @type {Cartesian3}\n   */\n\n  this.position = new Cartesian3();\n  this._position = new Cartesian3();\n  this._positionWC = new Cartesian3();\n  this._positionCartographic = new Cartographic();\n  this._oldPositionWC = undefined;\n  /**\n   * The position delta magnitude.\n   *\n   * @private\n   */\n\n  this.positionWCDeltaMagnitude = 0.0;\n  /**\n   * The position delta magnitude last frame.\n   *\n   * @private\n   */\n\n  this.positionWCDeltaMagnitudeLastFrame = 0.0;\n  /**\n   * How long in seconds since the camera has stopped moving\n   *\n   * @private\n   */\n\n  this.timeSinceMoved = 0.0;\n  this._lastMovedTimestamp = 0.0;\n  /**\n   * The view direction of the camera.\n   *\n   * @type {Cartesian3}\n   */\n\n  this.direction = new Cartesian3();\n  this._direction = new Cartesian3();\n  this._directionWC = new Cartesian3();\n  /**\n   * The up direction of the camera.\n   *\n   * @type {Cartesian3}\n   */\n\n  this.up = new Cartesian3();\n  this._up = new Cartesian3();\n  this._upWC = new Cartesian3();\n  /**\n   * The right direction of the camera.\n   *\n   * @type {Cartesian3}\n   */\n\n  this.right = new Cartesian3();\n  this._right = new Cartesian3();\n  this._rightWC = new Cartesian3();\n  /**\n   * The region of space in view.\n   *\n   * @type {PerspectiveFrustum|PerspectiveOffCenterFrustum|OrthographicFrustum}\n   * @default PerspectiveFrustum()\n   *\n   * @see PerspectiveFrustum\n   * @see PerspectiveOffCenterFrustum\n   * @see OrthographicFrustum\n   */\n\n  this.frustum = new PerspectiveFrustum();\n  this.frustum.aspectRatio = scene.drawingBufferWidth / scene.drawingBufferHeight;\n  this.frustum.fov = CesiumMath.toRadians(60.0);\n  /**\n   * The default amount to move the camera when an argument is not\n   * provided to the move methods.\n   * @type {Number}\n   * @default 100000.0;\n   */\n\n  this.defaultMoveAmount = 100000.0;\n  /**\n   * The default amount to rotate the camera when an argument is not\n   * provided to the look methods.\n   * @type {Number}\n   * @default Math.PI / 60.0\n   */\n\n  this.defaultLookAmount = Math.PI / 60.0;\n  /**\n   * The default amount to rotate the camera when an argument is not\n   * provided to the rotate methods.\n   * @type {Number}\n   * @default Math.PI / 3600.0\n   */\n\n  this.defaultRotateAmount = Math.PI / 3600.0;\n  /**\n   * The default amount to move the camera when an argument is not\n   * provided to the zoom methods.\n   * @type {Number}\n   * @default 100000.0;\n   */\n\n  this.defaultZoomAmount = 100000.0;\n  /**\n   * If set, the camera will not be able to rotate past this axis in either direction.\n   * @type {Cartesian3}\n   * @default undefined\n   */\n\n  this.constrainedAxis = undefined;\n  /**\n   * The factor multiplied by the the map size used to determine where to clamp the camera position\n   * when zooming out from the surface. The default is 1.5. Only valid for 2D and the map is rotatable.\n   * @type {Number}\n   * @default 1.5\n   */\n\n  this.maximumZoomFactor = 1.5;\n  this._moveStart = new Event();\n  this._moveEnd = new Event();\n  this._changed = new Event();\n  this._changedPosition = undefined;\n  this._changedDirection = undefined;\n  this._changedFrustum = undefined;\n  /**\n   * The amount the camera has to change before the <code>changed</code> event is raised. The value is a percentage in the [0, 1] range.\n   * @type {number}\n   * @default 0.5\n   */\n\n  this.percentageChanged = 0.5;\n  this._viewMatrix = new Matrix4();\n  this._invViewMatrix = new Matrix4();\n  updateViewMatrix(this);\n  this._mode = SceneMode.SCENE3D;\n  this._modeChanged = true;\n  var projection = scene.mapProjection;\n  this._projection = projection;\n  this._maxCoord = projection.project(new Cartographic(Math.PI, CesiumMath.PI_OVER_TWO));\n  this._max2Dfrustum = undefined; // set default view\n\n  rectangleCameraPosition3D(this, Camera.DEFAULT_VIEW_RECTANGLE, this.position, true);\n  var mag = Cartesian3.magnitude(this.position);\n  mag += mag * Camera.DEFAULT_VIEW_FACTOR;\n  Cartesian3.normalize(this.position, this.position);\n  Cartesian3.multiplyByScalar(this.position, mag, this.position);\n}\n/**\n * @private\n */\n\n\nCamera.TRANSFORM_2D = new Matrix4(0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n/**\n * @private\n */\n\nCamera.TRANSFORM_2D_INVERSE = Matrix4.inverseTransformation(Camera.TRANSFORM_2D, new Matrix4());\n/**\n * The default rectangle the camera will view on creation.\n * @type Rectangle\n */\n\nCamera.DEFAULT_VIEW_RECTANGLE = Rectangle.fromDegrees(-95.0, -20.0, -70.0, 90.0);\n/**\n * A scalar to multiply to the camera position and add it back after setting the camera to view the rectangle.\n * A value of zero means the camera will view the entire {@link Camera#DEFAULT_VIEW_RECTANGLE}, a value greater than zero\n * will move it further away from the extent, and a value less than zero will move it close to the extent.\n * @type Number\n */\n\nCamera.DEFAULT_VIEW_FACTOR = 0.5;\n/**\n * The default heading/pitch/range that is used when the camera flies to a location that contains a bounding sphere.\n * @type HeadingPitchRange\n */\n\nCamera.DEFAULT_OFFSET = new HeadingPitchRange(0.0, -CesiumMath.PI_OVER_FOUR, 0.0);\n\nfunction updateViewMatrix(camera) {\n  Matrix4.computeView(camera._position, camera._direction, camera._up, camera._right, camera._viewMatrix);\n  Matrix4.multiply(camera._viewMatrix, camera._actualInvTransform, camera._viewMatrix);\n  Matrix4.inverseTransformation(camera._viewMatrix, camera._invViewMatrix);\n}\n\nfunction updateCameraDeltas(camera) {\n  if (!defined(camera._oldPositionWC)) {\n    camera._oldPositionWC = Cartesian3.clone(camera.positionWC, camera._oldPositionWC);\n  } else {\n    camera.positionWCDeltaMagnitudeLastFrame = camera.positionWCDeltaMagnitude;\n    var delta = Cartesian3.subtract(camera.positionWC, camera._oldPositionWC, camera._oldPositionWC);\n    camera.positionWCDeltaMagnitude = Cartesian3.magnitude(delta);\n    camera._oldPositionWC = Cartesian3.clone(camera.positionWC, camera._oldPositionWC); // Update move timers\n\n    if (camera.positionWCDeltaMagnitude > 0.0) {\n      camera.timeSinceMoved = 0.0;\n      camera._lastMovedTimestamp = getTimestamp();\n    } else {\n      camera.timeSinceMoved = Math.max(getTimestamp() - camera._lastMovedTimestamp, 0.0) / 1000.0;\n    }\n  }\n}\n/**\n * Checks if there's a camera flight with preload for this camera.\n *\n * @returns {Boolean} Whether or not this camera has a current flight with a valid preloadFlightCamera in scene.\n *\n * @private\n *\n */\n\n\nCamera.prototype.canPreloadFlight = function () {\n  return defined(this._currentFlight) && this._mode !== SceneMode.SCENE2D;\n};\n\nCamera.prototype._updateCameraChanged = function () {\n  var camera = this;\n  updateCameraDeltas(camera);\n\n  if (camera._changed.numberOfListeners === 0) {\n    return;\n  }\n\n  var percentageChanged = camera.percentageChanged;\n\n  if (camera._mode === SceneMode.SCENE2D) {\n    if (!defined(camera._changedFrustum)) {\n      camera._changedPosition = Cartesian3.clone(camera.position, camera._changedPosition);\n      camera._changedFrustum = camera.frustum.clone();\n      return;\n    }\n\n    var position = camera.position;\n    var lastPosition = camera._changedPosition;\n    var frustum = camera.frustum;\n    var lastFrustum = camera._changedFrustum;\n    var x0 = position.x + frustum.left;\n    var x1 = position.x + frustum.right;\n    var x2 = lastPosition.x + lastFrustum.left;\n    var x3 = lastPosition.x + lastFrustum.right;\n    var y0 = position.y + frustum.bottom;\n    var y1 = position.y + frustum.top;\n    var y2 = lastPosition.y + lastFrustum.bottom;\n    var y3 = lastPosition.y + lastFrustum.top;\n    var leftX = Math.max(x0, x2);\n    var rightX = Math.min(x1, x3);\n    var bottomY = Math.max(y0, y2);\n    var topY = Math.min(y1, y3);\n    var areaPercentage;\n\n    if (leftX >= rightX || bottomY >= y1) {\n      areaPercentage = 1.0;\n    } else {\n      var areaRef = lastFrustum;\n\n      if (x0 < x2 && x1 > x3 && y0 < y2 && y1 > y3) {\n        areaRef = frustum;\n      }\n\n      areaPercentage = 1.0 - (rightX - leftX) * (topY - bottomY) / ((areaRef.right - areaRef.left) * (areaRef.top - areaRef.bottom));\n    }\n\n    if (areaPercentage > percentageChanged) {\n      camera._changed.raiseEvent(areaPercentage);\n\n      camera._changedPosition = Cartesian3.clone(camera.position, camera._changedPosition);\n      camera._changedFrustum = camera.frustum.clone(camera._changedFrustum);\n    }\n\n    return;\n  }\n\n  if (!defined(camera._changedDirection)) {\n    camera._changedPosition = Cartesian3.clone(camera.positionWC, camera._changedPosition);\n    camera._changedDirection = Cartesian3.clone(camera.directionWC, camera._changedDirection);\n    return;\n  }\n\n  var dirAngle = CesiumMath.acosClamped(Cartesian3.dot(camera.directionWC, camera._changedDirection));\n  var dirPercentage;\n\n  if (defined(camera.frustum.fovy)) {\n    dirPercentage = dirAngle / (camera.frustum.fovy * 0.5);\n  } else {\n    dirPercentage = dirAngle;\n  }\n\n  var distance = Cartesian3.distance(camera.positionWC, camera._changedPosition);\n  var heightPercentage = distance / camera.positionCartographic.height;\n\n  if (dirPercentage > percentageChanged || heightPercentage > percentageChanged) {\n    camera._changed.raiseEvent(Math.max(dirPercentage, heightPercentage));\n\n    camera._changedPosition = Cartesian3.clone(camera.positionWC, camera._changedPosition);\n    camera._changedDirection = Cartesian3.clone(camera.directionWC, camera._changedDirection);\n  }\n};\n\nfunction convertTransformForColumbusView(camera) {\n  Transforms.basisTo2D(camera._projection, camera._transform, camera._actualTransform);\n}\n\nvar scratchCartographic = new Cartographic();\nvar scratchCartesian3Projection = new Cartesian3();\nvar scratchCartesian3 = new Cartesian3();\nvar scratchCartesian4Origin = new Cartesian4();\nvar scratchCartesian4NewOrigin = new Cartesian4();\nvar scratchCartesian4NewXAxis = new Cartesian4();\nvar scratchCartesian4NewYAxis = new Cartesian4();\nvar scratchCartesian4NewZAxis = new Cartesian4();\n\nfunction convertTransformFor2D(camera) {\n  var projection = camera._projection;\n  var ellipsoid = projection.ellipsoid;\n  var origin = Matrix4.getColumn(camera._transform, 3, scratchCartesian4Origin);\n  var cartographic = ellipsoid.cartesianToCartographic(origin, scratchCartographic);\n  var projectedPosition = projection.project(cartographic, scratchCartesian3Projection);\n  var newOrigin = scratchCartesian4NewOrigin;\n  newOrigin.x = projectedPosition.z;\n  newOrigin.y = projectedPosition.x;\n  newOrigin.z = projectedPosition.y;\n  newOrigin.w = 1.0;\n  var newZAxis = Cartesian4.clone(Cartesian4.UNIT_X, scratchCartesian4NewZAxis);\n  var xAxis = Cartesian4.add(Matrix4.getColumn(camera._transform, 0, scratchCartesian3), origin, scratchCartesian3);\n  ellipsoid.cartesianToCartographic(xAxis, cartographic);\n  projection.project(cartographic, projectedPosition);\n  var newXAxis = scratchCartesian4NewXAxis;\n  newXAxis.x = projectedPosition.z;\n  newXAxis.y = projectedPosition.x;\n  newXAxis.z = projectedPosition.y;\n  newXAxis.w = 0.0;\n  Cartesian3.subtract(newXAxis, newOrigin, newXAxis);\n  newXAxis.x = 0.0;\n  var newYAxis = scratchCartesian4NewYAxis;\n\n  if (Cartesian3.magnitudeSquared(newXAxis) > CesiumMath.EPSILON10) {\n    Cartesian3.cross(newZAxis, newXAxis, newYAxis);\n  } else {\n    var yAxis = Cartesian4.add(Matrix4.getColumn(camera._transform, 1, scratchCartesian3), origin, scratchCartesian3);\n    ellipsoid.cartesianToCartographic(yAxis, cartographic);\n    projection.project(cartographic, projectedPosition);\n    newYAxis.x = projectedPosition.z;\n    newYAxis.y = projectedPosition.x;\n    newYAxis.z = projectedPosition.y;\n    newYAxis.w = 0.0;\n    Cartesian3.subtract(newYAxis, newOrigin, newYAxis);\n    newYAxis.x = 0.0;\n\n    if (Cartesian3.magnitudeSquared(newYAxis) < CesiumMath.EPSILON10) {\n      Cartesian4.clone(Cartesian4.UNIT_Y, newXAxis);\n      Cartesian4.clone(Cartesian4.UNIT_Z, newYAxis);\n    }\n  }\n\n  Cartesian3.cross(newYAxis, newZAxis, newXAxis);\n  Cartesian3.normalize(newXAxis, newXAxis);\n  Cartesian3.cross(newZAxis, newXAxis, newYAxis);\n  Cartesian3.normalize(newYAxis, newYAxis);\n  Matrix4.setColumn(camera._actualTransform, 0, newXAxis, camera._actualTransform);\n  Matrix4.setColumn(camera._actualTransform, 1, newYAxis, camera._actualTransform);\n  Matrix4.setColumn(camera._actualTransform, 2, newZAxis, camera._actualTransform);\n  Matrix4.setColumn(camera._actualTransform, 3, newOrigin, camera._actualTransform);\n}\n\nvar scratchCartesian = new Cartesian3();\n\nfunction updateMembers(camera) {\n  var mode = camera._mode;\n  var heightChanged = false;\n  var height = 0.0;\n\n  if (mode === SceneMode.SCENE2D) {\n    height = camera.frustum.right - camera.frustum.left;\n    heightChanged = height !== camera._positionCartographic.height;\n  }\n\n  var position = camera._position;\n  var positionChanged = !Cartesian3.equals(position, camera.position) || heightChanged;\n\n  if (positionChanged) {\n    position = Cartesian3.clone(camera.position, camera._position);\n  }\n\n  var direction = camera._direction;\n  var directionChanged = !Cartesian3.equals(direction, camera.direction);\n\n  if (directionChanged) {\n    Cartesian3.normalize(camera.direction, camera.direction);\n    direction = Cartesian3.clone(camera.direction, camera._direction);\n  }\n\n  var up = camera._up;\n  var upChanged = !Cartesian3.equals(up, camera.up);\n\n  if (upChanged) {\n    Cartesian3.normalize(camera.up, camera.up);\n    up = Cartesian3.clone(camera.up, camera._up);\n  }\n\n  var right = camera._right;\n  var rightChanged = !Cartesian3.equals(right, camera.right);\n\n  if (rightChanged) {\n    Cartesian3.normalize(camera.right, camera.right);\n    right = Cartesian3.clone(camera.right, camera._right);\n  }\n\n  var transformChanged = camera._transformChanged || camera._modeChanged;\n  camera._transformChanged = false;\n\n  if (transformChanged) {\n    Matrix4.inverseTransformation(camera._transform, camera._invTransform);\n\n    if (camera._mode === SceneMode.COLUMBUS_VIEW || camera._mode === SceneMode.SCENE2D) {\n      if (Matrix4.equals(Matrix4.IDENTITY, camera._transform)) {\n        Matrix4.clone(Camera.TRANSFORM_2D, camera._actualTransform);\n      } else if (camera._mode === SceneMode.COLUMBUS_VIEW) {\n        convertTransformForColumbusView(camera);\n      } else {\n        convertTransformFor2D(camera);\n      }\n    } else {\n      Matrix4.clone(camera._transform, camera._actualTransform);\n    }\n\n    Matrix4.inverseTransformation(camera._actualTransform, camera._actualInvTransform);\n    camera._modeChanged = false;\n  }\n\n  var transform = camera._actualTransform;\n\n  if (positionChanged || transformChanged) {\n    camera._positionWC = Matrix4.multiplyByPoint(transform, position, camera._positionWC); // Compute the Cartographic position of the camera.\n\n    if (mode === SceneMode.SCENE3D || mode === SceneMode.MORPHING) {\n      camera._positionCartographic = camera._projection.ellipsoid.cartesianToCartographic(camera._positionWC, camera._positionCartographic);\n    } else {\n      // The camera position is expressed in the 2D coordinate system where the Y axis is to the East,\n      // the Z axis is to the North, and the X axis is out of the map.  Express them instead in the ENU axes where\n      // X is to the East, Y is to the North, and Z is out of the local horizontal plane.\n      var positionENU = scratchCartesian;\n      positionENU.x = camera._positionWC.y;\n      positionENU.y = camera._positionWC.z;\n      positionENU.z = camera._positionWC.x; // In 2D, the camera height is always 12.7 million meters.\n      // The apparent height is equal to half the frustum width.\n\n      if (mode === SceneMode.SCENE2D) {\n        positionENU.z = height;\n      }\n\n      camera._projection.unproject(positionENU, camera._positionCartographic);\n    }\n  }\n\n  if (directionChanged || upChanged || rightChanged) {\n    var det = Cartesian3.dot(direction, Cartesian3.cross(up, right, scratchCartesian));\n\n    if (Math.abs(1.0 - det) > CesiumMath.EPSILON2) {\n      //orthonormalize axes\n      var invUpMag = 1.0 / Cartesian3.magnitudeSquared(up);\n      var scalar = Cartesian3.dot(up, direction) * invUpMag;\n      var w0 = Cartesian3.multiplyByScalar(direction, scalar, scratchCartesian);\n      up = Cartesian3.normalize(Cartesian3.subtract(up, w0, camera._up), camera._up);\n      Cartesian3.clone(up, camera.up);\n      right = Cartesian3.cross(direction, up, camera._right);\n      Cartesian3.clone(right, camera.right);\n    }\n  }\n\n  if (directionChanged || transformChanged) {\n    camera._directionWC = Matrix4.multiplyByPointAsVector(transform, direction, camera._directionWC);\n    Cartesian3.normalize(camera._directionWC, camera._directionWC);\n  }\n\n  if (upChanged || transformChanged) {\n    camera._upWC = Matrix4.multiplyByPointAsVector(transform, up, camera._upWC);\n    Cartesian3.normalize(camera._upWC, camera._upWC);\n  }\n\n  if (rightChanged || transformChanged) {\n    camera._rightWC = Matrix4.multiplyByPointAsVector(transform, right, camera._rightWC);\n    Cartesian3.normalize(camera._rightWC, camera._rightWC);\n  }\n\n  if (positionChanged || directionChanged || upChanged || rightChanged || transformChanged) {\n    updateViewMatrix(camera);\n  }\n}\n\nfunction getHeading(direction, up) {\n  var heading;\n\n  if (!CesiumMath.equalsEpsilon(Math.abs(direction.z), 1.0, CesiumMath.EPSILON3)) {\n    heading = Math.atan2(direction.y, direction.x) - CesiumMath.PI_OVER_TWO;\n  } else {\n    heading = Math.atan2(up.y, up.x) - CesiumMath.PI_OVER_TWO;\n  }\n\n  return CesiumMath.TWO_PI - CesiumMath.zeroToTwoPi(heading);\n}\n\nfunction getPitch(direction) {\n  return CesiumMath.PI_OVER_TWO - CesiumMath.acosClamped(direction.z);\n}\n\nfunction getRoll(direction, up, right) {\n  var roll = 0.0;\n\n  if (!CesiumMath.equalsEpsilon(Math.abs(direction.z), 1.0, CesiumMath.EPSILON3)) {\n    roll = Math.atan2(-right.z, up.z);\n    roll = CesiumMath.zeroToTwoPi(roll + CesiumMath.TWO_PI);\n  }\n\n  return roll;\n}\n\nvar scratchHPRMatrix1 = new Matrix4();\nvar scratchHPRMatrix2 = new Matrix4();\nObject.defineProperties(Camera.prototype, {\n  /**\n   * Gets the camera's reference frame. The inverse of this transformation is appended to the view matrix.\n   * @memberof Camera.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @default {@link Matrix4.IDENTITY}\n   */\n  transform: {\n    get: function () {\n      return this._transform;\n    }\n  },\n\n  /**\n   * Gets the inverse camera transform.\n   * @memberof Camera.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @default {@link Matrix4.IDENTITY}\n   */\n  inverseTransform: {\n    get: function () {\n      updateMembers(this);\n      return this._invTransform;\n    }\n  },\n\n  /**\n   * Gets the view matrix.\n   * @memberof Camera.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see Camera#inverseViewMatrix\n   */\n  viewMatrix: {\n    get: function () {\n      updateMembers(this);\n      return this._viewMatrix;\n    }\n  },\n\n  /**\n   * Gets the inverse view matrix.\n   * @memberof Camera.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see Camera#viewMatrix\n   */\n  inverseViewMatrix: {\n    get: function () {\n      updateMembers(this);\n      return this._invViewMatrix;\n    }\n  },\n\n  /**\n   * Gets the {@link Cartographic} position of the camera, with longitude and latitude\n   * expressed in radians and height in meters.  In 2D and Columbus View, it is possible\n   * for the returned longitude and latitude to be outside the range of valid longitudes\n   * and latitudes when the camera is outside the map.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartographic}\n   * @readonly\n   */\n  positionCartographic: {\n    get: function () {\n      updateMembers(this);\n      return this._positionCartographic;\n    }\n  },\n\n  /**\n   * Gets the position of the camera in world coordinates.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  positionWC: {\n    get: function () {\n      updateMembers(this);\n      return this._positionWC;\n    }\n  },\n\n  /**\n   * Gets the view direction of the camera in world coordinates.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  directionWC: {\n    get: function () {\n      updateMembers(this);\n      return this._directionWC;\n    }\n  },\n\n  /**\n   * Gets the up direction of the camera in world coordinates.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  upWC: {\n    get: function () {\n      updateMembers(this);\n      return this._upWC;\n    }\n  },\n\n  /**\n   * Gets the right direction of the camera in world coordinates.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  rightWC: {\n    get: function () {\n      updateMembers(this);\n      return this._rightWC;\n    }\n  },\n\n  /**\n   * Gets the camera heading in radians.\n   * @memberof Camera.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  heading: {\n    get: function () {\n      if (this._mode !== SceneMode.MORPHING) {\n        var ellipsoid = this._projection.ellipsoid;\n        var oldTransform = Matrix4.clone(this._transform, scratchHPRMatrix1);\n        var transform = Transforms.eastNorthUpToFixedFrame(this.positionWC, ellipsoid, scratchHPRMatrix2);\n\n        this._setTransform(transform);\n\n        var heading = getHeading(this.direction, this.up);\n\n        this._setTransform(oldTransform);\n\n        return heading;\n      }\n\n      return undefined;\n    }\n  },\n\n  /**\n   * Gets the camera pitch in radians.\n   * @memberof Camera.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  pitch: {\n    get: function () {\n      if (this._mode !== SceneMode.MORPHING) {\n        var ellipsoid = this._projection.ellipsoid;\n        var oldTransform = Matrix4.clone(this._transform, scratchHPRMatrix1);\n        var transform = Transforms.eastNorthUpToFixedFrame(this.positionWC, ellipsoid, scratchHPRMatrix2);\n\n        this._setTransform(transform);\n\n        var pitch = getPitch(this.direction);\n\n        this._setTransform(oldTransform);\n\n        return pitch;\n      }\n\n      return undefined;\n    }\n  },\n\n  /**\n   * Gets the camera roll in radians.\n   * @memberof Camera.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  roll: {\n    get: function () {\n      if (this._mode !== SceneMode.MORPHING) {\n        var ellipsoid = this._projection.ellipsoid;\n        var oldTransform = Matrix4.clone(this._transform, scratchHPRMatrix1);\n        var transform = Transforms.eastNorthUpToFixedFrame(this.positionWC, ellipsoid, scratchHPRMatrix2);\n\n        this._setTransform(transform);\n\n        var roll = getRoll(this.direction, this.up, this.right);\n\n        this._setTransform(oldTransform);\n\n        return roll;\n      }\n\n      return undefined;\n    }\n  },\n\n  /**\n   * Gets the event that will be raised at when the camera starts to move.\n   * @memberof Camera.prototype\n   * @type {Event}\n   * @readonly\n   */\n  moveStart: {\n    get: function () {\n      return this._moveStart;\n    }\n  },\n\n  /**\n   * Gets the event that will be raised when the camera has stopped moving.\n   * @memberof Camera.prototype\n   * @type {Event}\n   * @readonly\n   */\n  moveEnd: {\n    get: function () {\n      return this._moveEnd;\n    }\n  },\n\n  /**\n   * Gets the event that will be raised when the camera has changed by <code>percentageChanged</code>.\n   * @memberof Camera.prototype\n   * @type {Event}\n   * @readonly\n   */\n  changed: {\n    get: function () {\n      return this._changed;\n    }\n  }\n});\n/**\n * @private\n */\n\nCamera.prototype.update = function (mode) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(mode)) {\n    throw new DeveloperError(\"mode is required.\");\n  }\n\n  if (mode === SceneMode.SCENE2D && !(this.frustum instanceof OrthographicOffCenterFrustum)) {\n    throw new DeveloperError(\"An OrthographicOffCenterFrustum is required in 2D.\");\n  }\n\n  if ((mode === SceneMode.SCENE3D || mode === SceneMode.COLUMBUS_VIEW) && !(this.frustum instanceof PerspectiveFrustum) && !(this.frustum instanceof OrthographicFrustum)) {\n    throw new DeveloperError(\"A PerspectiveFrustum or OrthographicFrustum is required in 3D and Columbus view\");\n  } //>>includeEnd('debug');\n\n\n  var updateFrustum = false;\n\n  if (mode !== this._mode) {\n    this._mode = mode;\n    this._modeChanged = mode !== SceneMode.MORPHING;\n    updateFrustum = this._mode === SceneMode.SCENE2D;\n  }\n\n  if (updateFrustum) {\n    var frustum = this._max2Dfrustum = this.frustum.clone(); //>>includeStart('debug', pragmas.debug);\n\n    if (!(frustum instanceof OrthographicOffCenterFrustum)) {\n      throw new DeveloperError(\"The camera frustum is expected to be orthographic for 2D camera control.\");\n    } //>>includeEnd('debug');\n\n\n    var maxZoomOut = 2.0;\n    var ratio = frustum.top / frustum.right;\n    frustum.right = this._maxCoord.x * maxZoomOut;\n    frustum.left = -frustum.right;\n    frustum.top = ratio * frustum.right;\n    frustum.bottom = -frustum.top;\n  }\n\n  if (this._mode === SceneMode.SCENE2D) {\n    clampMove2D(this, this.position);\n  }\n};\n\nvar setTransformPosition = new Cartesian3();\nvar setTransformUp = new Cartesian3();\nvar setTransformDirection = new Cartesian3();\n\nCamera.prototype._setTransform = function (transform) {\n  var position = Cartesian3.clone(this.positionWC, setTransformPosition);\n  var up = Cartesian3.clone(this.upWC, setTransformUp);\n  var direction = Cartesian3.clone(this.directionWC, setTransformDirection);\n  Matrix4.clone(transform, this._transform);\n  this._transformChanged = true;\n  updateMembers(this);\n  var inverse = this._actualInvTransform;\n  Matrix4.multiplyByPoint(inverse, position, this.position);\n  Matrix4.multiplyByPointAsVector(inverse, direction, this.direction);\n  Matrix4.multiplyByPointAsVector(inverse, up, this.up);\n  Cartesian3.cross(this.direction, this.up, this.right);\n  updateMembers(this);\n};\n\nvar scratchAdjustOrthographicFrustumMousePosition = new Cartesian2();\nvar scratchPickRay = new Ray();\nvar scratchRayIntersection = new Cartesian3();\nvar scratchDepthIntersection = new Cartesian3();\n\nfunction calculateOrthographicFrustumWidth(camera) {\n  // Camera is fixed to an object, so keep frustum width constant.\n  if (!Matrix4.equals(Matrix4.IDENTITY, camera.transform)) {\n    return Cartesian3.magnitude(camera.position);\n  }\n\n  var scene = camera._scene;\n  var globe = scene.globe;\n  var mousePosition = scratchAdjustOrthographicFrustumMousePosition;\n  mousePosition.x = scene.drawingBufferWidth / 2.0;\n  mousePosition.y = scene.drawingBufferHeight / 2.0;\n  var rayIntersection;\n\n  if (defined(globe)) {\n    var ray = camera.getPickRay(mousePosition, scratchPickRay);\n    rayIntersection = globe.pickWorldCoordinates(ray, scene, true, scratchRayIntersection);\n  }\n\n  var depthIntersection;\n\n  if (scene.pickPositionSupported) {\n    depthIntersection = scene.pickPositionWorldCoordinates(mousePosition, scratchDepthIntersection);\n  }\n\n  var distance;\n\n  if (defined(rayIntersection) || defined(depthIntersection)) {\n    var depthDistance = defined(depthIntersection) ? Cartesian3.distance(depthIntersection, camera.positionWC) : Number.POSITIVE_INFINITY;\n    var rayDistance = defined(rayIntersection) ? Cartesian3.distance(rayIntersection, camera.positionWC) : Number.POSITIVE_INFINITY;\n    distance = Math.min(depthDistance, rayDistance);\n  } else {\n    distance = Math.max(camera.positionCartographic.height, 0.0);\n  }\n\n  return distance;\n}\n\nCamera.prototype._adjustOrthographicFrustum = function (zooming) {\n  if (!(this.frustum instanceof OrthographicFrustum)) {\n    return;\n  }\n\n  if (!zooming && this._positionCartographic.height < 150000.0) {\n    return;\n  }\n\n  this.frustum.width = calculateOrthographicFrustumWidth(this);\n};\n\nvar scratchSetViewCartesian = new Cartesian3();\nvar scratchSetViewTransform1 = new Matrix4();\nvar scratchSetViewTransform2 = new Matrix4();\nvar scratchSetViewQuaternion = new Quaternion();\nvar scratchSetViewMatrix3 = new Matrix3();\nvar scratchSetViewCartographic = new Cartographic();\n\nfunction setView3D(camera, position, hpr) {\n  var currentTransform = Matrix4.clone(camera.transform, scratchSetViewTransform1);\n  var localTransform = Transforms.eastNorthUpToFixedFrame(position, camera._projection.ellipsoid, scratchSetViewTransform2);\n\n  camera._setTransform(localTransform);\n\n  Cartesian3.clone(Cartesian3.ZERO, camera.position);\n  hpr.heading = hpr.heading - CesiumMath.PI_OVER_TWO;\n  var rotQuat = Quaternion.fromHeadingPitchRoll(hpr, scratchSetViewQuaternion);\n  var rotMat = Matrix3.fromQuaternion(rotQuat, scratchSetViewMatrix3);\n  Matrix3.getColumn(rotMat, 0, camera.direction);\n  Matrix3.getColumn(rotMat, 2, camera.up);\n  Cartesian3.cross(camera.direction, camera.up, camera.right);\n\n  camera._setTransform(currentTransform);\n\n  camera._adjustOrthographicFrustum(true);\n}\n\nfunction setViewCV(camera, position, hpr, convert) {\n  var currentTransform = Matrix4.clone(camera.transform, scratchSetViewTransform1);\n\n  camera._setTransform(Matrix4.IDENTITY);\n\n  if (!Cartesian3.equals(position, camera.positionWC)) {\n    if (convert) {\n      var projection = camera._projection;\n      var cartographic = projection.ellipsoid.cartesianToCartographic(position, scratchSetViewCartographic);\n      position = projection.project(cartographic, scratchSetViewCartesian);\n    }\n\n    Cartesian3.clone(position, camera.position);\n  }\n\n  hpr.heading = hpr.heading - CesiumMath.PI_OVER_TWO;\n  var rotQuat = Quaternion.fromHeadingPitchRoll(hpr, scratchSetViewQuaternion);\n  var rotMat = Matrix3.fromQuaternion(rotQuat, scratchSetViewMatrix3);\n  Matrix3.getColumn(rotMat, 0, camera.direction);\n  Matrix3.getColumn(rotMat, 2, camera.up);\n  Cartesian3.cross(camera.direction, camera.up, camera.right);\n\n  camera._setTransform(currentTransform);\n\n  camera._adjustOrthographicFrustum(true);\n}\n\nfunction setView2D(camera, position, hpr, convert) {\n  var currentTransform = Matrix4.clone(camera.transform, scratchSetViewTransform1);\n\n  camera._setTransform(Matrix4.IDENTITY);\n\n  if (!Cartesian3.equals(position, camera.positionWC)) {\n    if (convert) {\n      var projection = camera._projection;\n      var cartographic = projection.ellipsoid.cartesianToCartographic(position, scratchSetViewCartographic);\n      position = projection.project(cartographic, scratchSetViewCartesian);\n    }\n\n    Cartesian2.clone(position, camera.position);\n    var newLeft = -position.z * 0.5;\n    var newRight = -newLeft;\n    var frustum = camera.frustum;\n\n    if (newRight > newLeft) {\n      var ratio = frustum.top / frustum.right;\n      frustum.right = newRight;\n      frustum.left = newLeft;\n      frustum.top = frustum.right * ratio;\n      frustum.bottom = -frustum.top;\n    }\n  }\n\n  if (camera._scene.mapMode2D === MapMode2D.ROTATE) {\n    hpr.heading = hpr.heading - CesiumMath.PI_OVER_TWO;\n    hpr.pitch = -CesiumMath.PI_OVER_TWO;\n    hpr.roll = 0.0;\n    var rotQuat = Quaternion.fromHeadingPitchRoll(hpr, scratchSetViewQuaternion);\n    var rotMat = Matrix3.fromQuaternion(rotQuat, scratchSetViewMatrix3);\n    Matrix3.getColumn(rotMat, 2, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n  }\n\n  camera._setTransform(currentTransform);\n}\n\nvar scratchToHPRDirection = new Cartesian3();\nvar scratchToHPRUp = new Cartesian3();\nvar scratchToHPRRight = new Cartesian3();\n\nfunction directionUpToHeadingPitchRoll(camera, position, orientation, result) {\n  var direction = Cartesian3.clone(orientation.direction, scratchToHPRDirection);\n  var up = Cartesian3.clone(orientation.up, scratchToHPRUp);\n\n  if (camera._scene.mode === SceneMode.SCENE3D) {\n    var ellipsoid = camera._projection.ellipsoid;\n    var transform = Transforms.eastNorthUpToFixedFrame(position, ellipsoid, scratchHPRMatrix1);\n    var invTransform = Matrix4.inverseTransformation(transform, scratchHPRMatrix2);\n    Matrix4.multiplyByPointAsVector(invTransform, direction, direction);\n    Matrix4.multiplyByPointAsVector(invTransform, up, up);\n  }\n\n  var right = Cartesian3.cross(direction, up, scratchToHPRRight);\n  result.heading = getHeading(direction, up);\n  result.pitch = getPitch(direction);\n  result.roll = getRoll(direction, up, right);\n  return result;\n}\n\nvar scratchSetViewOptions = {\n  destination: undefined,\n  orientation: {\n    direction: undefined,\n    up: undefined,\n    heading: undefined,\n    pitch: undefined,\n    roll: undefined\n  },\n  convert: undefined,\n  endTransform: undefined\n};\nvar scratchHpr = new HeadingPitchRoll();\n/**\n * Sets the camera position, orientation and transform.\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3|Rectangle} [options.destination] The final position of the camera in WGS84 (world) coordinates or a rectangle that would be visible from a top-down view.\n * @param {Object} [options.orientation] An object that contains either direction and up properties or heading, pitch and roll properties. By default, the direction will point\n * towards the center of the frame in 3D and in the negative z direction in Columbus view. The up direction will point towards local north in 3D and in the positive\n * y direction in Columbus view. Orientation is not used in 2D when in infinite scrolling mode.\n * @param {Matrix4} [options.endTransform] Transform matrix representing the reference frame of the camera.\n * @param {Boolean} [options.convert] Whether to convert the destination from world coordinates to scene coordinates (only relevant when not using 3D). Defaults to <code>true</code>.\n *\n * @example\n * // 1. Set position with a top-down view\n * viewer.camera.setView({\n *     destination : Cesium.Cartesian3.fromDegrees(-117.16, 32.71, 15000.0)\n * });\n *\n * // 2 Set view with heading, pitch and roll\n * viewer.camera.setView({\n *     destination : cartesianPosition,\n *     orientation: {\n *         heading : Cesium.Math.toRadians(90.0), // east, default value is 0.0 (north)\n *         pitch : Cesium.Math.toRadians(-90),    // default value (looking down)\n *         roll : 0.0                             // default value\n *     }\n * });\n *\n * // 3. Change heading, pitch and roll with the camera position remaining the same.\n * viewer.camera.setView({\n *     orientation: {\n *         heading : Cesium.Math.toRadians(90.0), // east, default value is 0.0 (north)\n *         pitch : Cesium.Math.toRadians(-90),    // default value (looking down)\n *         roll : 0.0                             // default value\n *     }\n * });\n *\n *\n * // 4. View rectangle with a top-down view\n * viewer.camera.setView({\n *     destination : Cesium.Rectangle.fromDegrees(west, south, east, north)\n * });\n *\n * // 5. Set position with an orientation using unit vectors.\n * viewer.camera.setView({\n *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),\n *     orientation : {\n *         direction : new Cesium.Cartesian3(-0.04231243104240401, -0.20123236049443421, -0.97862924300734),\n *         up : new Cesium.Cartesian3(-0.47934589305293746, -0.8553216253114552, 0.1966022179118339)\n *     }\n * });\n */\n\nCamera.prototype.setView = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var orientation = defaultValue(options.orientation, defaultValue.EMPTY_OBJECT);\n  var mode = this._mode;\n\n  if (mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  if (defined(options.endTransform)) {\n    this._setTransform(options.endTransform);\n  }\n\n  var convert = defaultValue(options.convert, true);\n  var destination = defaultValue(options.destination, Cartesian3.clone(this.positionWC, scratchSetViewCartesian));\n\n  if (defined(destination) && defined(destination.west)) {\n    destination = this.getRectangleCameraCoordinates(destination, scratchSetViewCartesian);\n    convert = false;\n  }\n\n  if (defined(orientation.direction)) {\n    orientation = directionUpToHeadingPitchRoll(this, destination, orientation, scratchSetViewOptions.orientation);\n  }\n\n  scratchHpr.heading = defaultValue(orientation.heading, 0.0);\n  scratchHpr.pitch = defaultValue(orientation.pitch, -CesiumMath.PI_OVER_TWO);\n  scratchHpr.roll = defaultValue(orientation.roll, 0.0);\n\n  if (mode === SceneMode.SCENE3D) {\n    setView3D(this, destination, scratchHpr);\n  } else if (mode === SceneMode.SCENE2D) {\n    setView2D(this, destination, scratchHpr, convert);\n  } else {\n    setViewCV(this, destination, scratchHpr, convert);\n  }\n};\n\nvar pitchScratch = new Cartesian3();\n/**\n * Fly the camera to the home view.  Use {@link Camera#.DEFAULT_VIEW_RECTANGLE} to set\n * the default view for the 3D scene.  The home view for 2D and columbus view shows the\n * entire map.\n *\n * @param {Number} [duration] The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight. See {@link Camera#flyTo}\n */\n\nCamera.prototype.flyHome = function (duration) {\n  var mode = this._mode;\n\n  if (mode === SceneMode.MORPHING) {\n    this._scene.completeMorph();\n  }\n\n  if (mode === SceneMode.SCENE2D) {\n    this.flyTo({\n      destination: Camera.DEFAULT_VIEW_RECTANGLE,\n      duration: duration,\n      endTransform: Matrix4.IDENTITY\n    });\n  } else if (mode === SceneMode.SCENE3D) {\n    var destination = this.getRectangleCameraCoordinates(Camera.DEFAULT_VIEW_RECTANGLE);\n    var mag = Cartesian3.magnitude(destination);\n    mag += mag * Camera.DEFAULT_VIEW_FACTOR;\n    Cartesian3.normalize(destination, destination);\n    Cartesian3.multiplyByScalar(destination, mag, destination);\n    this.flyTo({\n      destination: destination,\n      duration: duration,\n      endTransform: Matrix4.IDENTITY\n    });\n  } else if (mode === SceneMode.COLUMBUS_VIEW) {\n    var maxRadii = this._projection.ellipsoid.maximumRadius;\n    var position = new Cartesian3(0.0, -1.0, 1.0);\n    position = Cartesian3.multiplyByScalar(Cartesian3.normalize(position, position), 5.0 * maxRadii, position);\n    this.flyTo({\n      destination: position,\n      duration: duration,\n      orientation: {\n        heading: 0.0,\n        pitch: -Math.acos(Cartesian3.normalize(position, pitchScratch).z),\n        roll: 0.0\n      },\n      endTransform: Matrix4.IDENTITY,\n      convert: false\n    });\n  }\n};\n/**\n * Transform a vector or point from world coordinates to the camera's reference frame.\n *\n * @param {Cartesian4} cartesian The vector or point to transform.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The transformed vector or point.\n */\n\n\nCamera.prototype.worldToCameraCoordinates = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  } //>>includeEnd('debug');\n\n\n  if (!defined(result)) {\n    result = new Cartesian4();\n  }\n\n  updateMembers(this);\n  return Matrix4.multiplyByVector(this._actualInvTransform, cartesian, result);\n};\n/**\n * Transform a point from world coordinates to the camera's reference frame.\n *\n * @param {Cartesian3} cartesian The point to transform.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The transformed point.\n */\n\n\nCamera.prototype.worldToCameraCoordinatesPoint = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  } //>>includeEnd('debug');\n\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  updateMembers(this);\n  return Matrix4.multiplyByPoint(this._actualInvTransform, cartesian, result);\n};\n/**\n * Transform a vector from world coordinates to the camera's reference frame.\n *\n * @param {Cartesian3} cartesian The vector to transform.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The transformed vector.\n */\n\n\nCamera.prototype.worldToCameraCoordinatesVector = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  } //>>includeEnd('debug');\n\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  updateMembers(this);\n  return Matrix4.multiplyByPointAsVector(this._actualInvTransform, cartesian, result);\n};\n/**\n * Transform a vector or point from the camera's reference frame to world coordinates.\n *\n * @param {Cartesian4} cartesian The vector or point to transform.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The transformed vector or point.\n */\n\n\nCamera.prototype.cameraToWorldCoordinates = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  } //>>includeEnd('debug');\n\n\n  if (!defined(result)) {\n    result = new Cartesian4();\n  }\n\n  updateMembers(this);\n  return Matrix4.multiplyByVector(this._actualTransform, cartesian, result);\n};\n/**\n * Transform a point from the camera's reference frame to world coordinates.\n *\n * @param {Cartesian3} cartesian The point to transform.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The transformed point.\n */\n\n\nCamera.prototype.cameraToWorldCoordinatesPoint = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  } //>>includeEnd('debug');\n\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  updateMembers(this);\n  return Matrix4.multiplyByPoint(this._actualTransform, cartesian, result);\n};\n/**\n * Transform a vector from the camera's reference frame to world coordinates.\n *\n * @param {Cartesian3} cartesian The vector to transform.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The transformed vector.\n */\n\n\nCamera.prototype.cameraToWorldCoordinatesVector = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  } //>>includeEnd('debug');\n\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  updateMembers(this);\n  return Matrix4.multiplyByPointAsVector(this._actualTransform, cartesian, result);\n};\n\nfunction clampMove2D(camera, position) {\n  var rotatable2D = camera._scene.mapMode2D === MapMode2D.ROTATE;\n  var maxProjectedX = camera._maxCoord.x;\n  var maxProjectedY = camera._maxCoord.y;\n  var minX;\n  var maxX;\n\n  if (rotatable2D) {\n    maxX = maxProjectedX;\n    minX = -maxX;\n  } else {\n    maxX = position.x - maxProjectedX * 2.0;\n    minX = position.x + maxProjectedX * 2.0;\n  }\n\n  if (position.x > maxProjectedX) {\n    position.x = maxX;\n  }\n\n  if (position.x < -maxProjectedX) {\n    position.x = minX;\n  }\n\n  if (position.y > maxProjectedY) {\n    position.y = maxProjectedY;\n  }\n\n  if (position.y < -maxProjectedY) {\n    position.y = -maxProjectedY;\n  }\n}\n\nvar moveScratch = new Cartesian3();\n/**\n * Translates the camera's position by <code>amount</code> along <code>direction</code>.\n *\n * @param {Cartesian3} direction The direction to move.\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveBackward\n * @see Camera#moveForward\n * @see Camera#moveLeft\n * @see Camera#moveRight\n * @see Camera#moveUp\n * @see Camera#moveDown\n */\n\nCamera.prototype.move = function (direction, amount) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(direction)) {\n    throw new DeveloperError(\"direction is required.\");\n  } //>>includeEnd('debug');\n\n\n  var cameraPosition = this.position;\n  Cartesian3.multiplyByScalar(direction, amount, moveScratch);\n  Cartesian3.add(cameraPosition, moveScratch, cameraPosition);\n\n  if (this._mode === SceneMode.SCENE2D) {\n    clampMove2D(this, cameraPosition);\n  }\n\n  this._adjustOrthographicFrustum(true);\n};\n/**\n * Translates the camera's position by <code>amount</code> along the camera's view vector.\n * When in 2D mode, this will zoom in the camera instead of translating the camera's position.\n *\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveBackward\n */\n\n\nCamera.prototype.moveForward = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n\n  if (this._mode === SceneMode.SCENE2D) {\n    // 2D mode\n    zoom2D(this, amount);\n  } else {\n    // 3D or Columbus view mode\n    this.move(this.direction, amount);\n  }\n};\n/**\n * Translates the camera's position by <code>amount</code> along the opposite direction\n * of the camera's view vector.\n * When in 2D mode, this will zoom out the camera instead of translating the camera's position.\n *\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveForward\n */\n\n\nCamera.prototype.moveBackward = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n\n  if (this._mode === SceneMode.SCENE2D) {\n    // 2D mode\n    zoom2D(this, -amount);\n  } else {\n    // 3D or Columbus view mode\n    this.move(this.direction, -amount);\n  }\n};\n/**\n * Translates the camera's position by <code>amount</code> along the camera's up vector.\n *\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveDown\n */\n\n\nCamera.prototype.moveUp = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n  this.move(this.up, amount);\n};\n/**\n * Translates the camera's position by <code>amount</code> along the opposite direction\n * of the camera's up vector.\n *\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveUp\n */\n\n\nCamera.prototype.moveDown = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n  this.move(this.up, -amount);\n};\n/**\n * Translates the camera's position by <code>amount</code> along the camera's right vector.\n *\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveLeft\n */\n\n\nCamera.prototype.moveRight = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n  this.move(this.right, amount);\n};\n/**\n * Translates the camera's position by <code>amount</code> along the opposite direction\n * of the camera's right vector.\n *\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveRight\n */\n\n\nCamera.prototype.moveLeft = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n  this.move(this.right, -amount);\n};\n/**\n * Rotates the camera around its up vector by amount, in radians, in the opposite direction\n * of its right vector if not in 2D mode.\n *\n * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookRight\n */\n\n\nCamera.prototype.lookLeft = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount); // only want view of map to change in 3D mode, 2D visual is incorrect when look changes\n\n  if (this._mode !== SceneMode.SCENE2D) {\n    this.look(this.up, -amount);\n  }\n};\n/**\n * Rotates the camera around its up vector by amount, in radians, in the direction\n * of its right vector if not in 2D mode.\n *\n * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookLeft\n */\n\n\nCamera.prototype.lookRight = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount); // only want view of map to change in 3D mode, 2D visual is incorrect when look changes\n\n  if (this._mode !== SceneMode.SCENE2D) {\n    this.look(this.up, amount);\n  }\n};\n/**\n * Rotates the camera around its right vector by amount, in radians, in the direction\n * of its up vector if not in 2D mode.\n *\n * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookDown\n */\n\n\nCamera.prototype.lookUp = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount); // only want view of map to change in 3D mode, 2D visual is incorrect when look changes\n\n  if (this._mode !== SceneMode.SCENE2D) {\n    this.look(this.right, -amount);\n  }\n};\n/**\n * Rotates the camera around its right vector by amount, in radians, in the opposite direction\n * of its up vector if not in 2D mode.\n *\n * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookUp\n */\n\n\nCamera.prototype.lookDown = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount); // only want view of map to change in 3D mode, 2D visual is incorrect when look changes\n\n  if (this._mode !== SceneMode.SCENE2D) {\n    this.look(this.right, amount);\n  }\n};\n\nvar lookScratchQuaternion = new Quaternion();\nvar lookScratchMatrix = new Matrix3();\n/**\n * Rotate each of the camera's orientation vectors around <code>axis</code> by <code>angle</code>\n *\n * @param {Cartesian3} axis The axis to rotate around.\n * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookUp\n * @see Camera#lookDown\n * @see Camera#lookLeft\n * @see Camera#lookRight\n */\n\nCamera.prototype.look = function (axis, angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(axis)) {\n    throw new DeveloperError(\"axis is required.\");\n  } //>>includeEnd('debug');\n\n\n  var turnAngle = defaultValue(angle, this.defaultLookAmount);\n  var quaternion = Quaternion.fromAxisAngle(axis, -turnAngle, lookScratchQuaternion);\n  var rotation = Matrix3.fromQuaternion(quaternion, lookScratchMatrix);\n  var direction = this.direction;\n  var up = this.up;\n  var right = this.right;\n  Matrix3.multiplyByVector(rotation, direction, direction);\n  Matrix3.multiplyByVector(rotation, up, up);\n  Matrix3.multiplyByVector(rotation, right, right);\n};\n/**\n * Rotate the camera counter-clockwise around its direction vector by amount, in radians.\n *\n * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#twistRight\n */\n\n\nCamera.prototype.twistLeft = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount);\n  this.look(this.direction, amount);\n};\n/**\n * Rotate the camera clockwise around its direction vector by amount, in radians.\n *\n * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#twistLeft\n */\n\n\nCamera.prototype.twistRight = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount);\n  this.look(this.direction, -amount);\n};\n\nvar rotateScratchQuaternion = new Quaternion();\nvar rotateScratchMatrix = new Matrix3();\n/**\n * Rotates the camera around <code>axis</code> by <code>angle</code>. The distance\n * of the camera's position to the center of the camera's reference frame remains the same.\n *\n * @param {Cartesian3} axis The axis to rotate around given in world coordinates.\n * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateUp\n * @see Camera#rotateDown\n * @see Camera#rotateLeft\n * @see Camera#rotateRight\n */\n\nCamera.prototype.rotate = function (axis, angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(axis)) {\n    throw new DeveloperError(\"axis is required.\");\n  } //>>includeEnd('debug');\n\n\n  var turnAngle = defaultValue(angle, this.defaultRotateAmount);\n  var quaternion = Quaternion.fromAxisAngle(axis, -turnAngle, rotateScratchQuaternion);\n  var rotation = Matrix3.fromQuaternion(quaternion, rotateScratchMatrix);\n  Matrix3.multiplyByVector(rotation, this.position, this.position);\n  Matrix3.multiplyByVector(rotation, this.direction, this.direction);\n  Matrix3.multiplyByVector(rotation, this.up, this.up);\n  Cartesian3.cross(this.direction, this.up, this.right);\n  Cartesian3.cross(this.right, this.direction, this.up);\n\n  this._adjustOrthographicFrustum(false);\n};\n/**\n * Rotates the camera around the center of the camera's reference frame by angle downwards.\n *\n * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateUp\n * @see Camera#rotate\n */\n\n\nCamera.prototype.rotateDown = function (angle) {\n  angle = defaultValue(angle, this.defaultRotateAmount);\n  rotateVertical(this, angle);\n};\n/**\n * Rotates the camera around the center of the camera's reference frame by angle upwards.\n *\n * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateDown\n * @see Camera#rotate\n */\n\n\nCamera.prototype.rotateUp = function (angle) {\n  angle = defaultValue(angle, this.defaultRotateAmount);\n  rotateVertical(this, -angle);\n};\n\nvar rotateVertScratchP = new Cartesian3();\nvar rotateVertScratchA = new Cartesian3();\nvar rotateVertScratchTan = new Cartesian3();\nvar rotateVertScratchNegate = new Cartesian3();\n\nfunction rotateVertical(camera, angle) {\n  var position = camera.position;\n\n  if (defined(camera.constrainedAxis) && !Cartesian3.equalsEpsilon(camera.position, Cartesian3.ZERO, CesiumMath.EPSILON2)) {\n    var p = Cartesian3.normalize(position, rotateVertScratchP);\n    var northParallel = Cartesian3.equalsEpsilon(p, camera.constrainedAxis, CesiumMath.EPSILON2);\n    var southParallel = Cartesian3.equalsEpsilon(p, Cartesian3.negate(camera.constrainedAxis, rotateVertScratchNegate), CesiumMath.EPSILON2);\n\n    if (!northParallel && !southParallel) {\n      var constrainedAxis = Cartesian3.normalize(camera.constrainedAxis, rotateVertScratchA);\n      var dot = Cartesian3.dot(p, constrainedAxis);\n      var angleToAxis = CesiumMath.acosClamped(dot);\n\n      if (angle > 0 && angle > angleToAxis) {\n        angle = angleToAxis - CesiumMath.EPSILON4;\n      }\n\n      dot = Cartesian3.dot(p, Cartesian3.negate(constrainedAxis, rotateVertScratchNegate));\n      angleToAxis = CesiumMath.acosClamped(dot);\n\n      if (angle < 0 && -angle > angleToAxis) {\n        angle = -angleToAxis + CesiumMath.EPSILON4;\n      }\n\n      var tangent = Cartesian3.cross(constrainedAxis, p, rotateVertScratchTan);\n      camera.rotate(tangent, angle);\n    } else if (northParallel && angle < 0 || southParallel && angle > 0) {\n      camera.rotate(camera.right, angle);\n    }\n  } else {\n    camera.rotate(camera.right, angle);\n  }\n}\n/**\n * Rotates the camera around the center of the camera's reference frame by angle to the right.\n *\n * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateLeft\n * @see Camera#rotate\n */\n\n\nCamera.prototype.rotateRight = function (angle) {\n  angle = defaultValue(angle, this.defaultRotateAmount);\n  rotateHorizontal(this, -angle);\n};\n/**\n * Rotates the camera around the center of the camera's reference frame by angle to the left.\n *\n * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateRight\n * @see Camera#rotate\n */\n\n\nCamera.prototype.rotateLeft = function (angle) {\n  angle = defaultValue(angle, this.defaultRotateAmount);\n  rotateHorizontal(this, angle);\n};\n\nfunction rotateHorizontal(camera, angle) {\n  if (defined(camera.constrainedAxis)) {\n    camera.rotate(camera.constrainedAxis, angle);\n  } else {\n    camera.rotate(camera.up, angle);\n  }\n}\n\nfunction zoom2D(camera, amount) {\n  var frustum = camera.frustum; //>>includeStart('debug', pragmas.debug);\n\n  if (!(frustum instanceof OrthographicOffCenterFrustum) || !defined(frustum.left) || !defined(frustum.right) || !defined(frustum.bottom) || !defined(frustum.top)) {\n    throw new DeveloperError(\"The camera frustum is expected to be orthographic for 2D camera control.\");\n  } //>>includeEnd('debug');\n\n\n  var ratio;\n  amount = amount * 0.5;\n\n  if (Math.abs(frustum.top) + Math.abs(frustum.bottom) > Math.abs(frustum.left) + Math.abs(frustum.right)) {\n    var newTop = frustum.top - amount;\n    var newBottom = frustum.bottom + amount;\n    var maxBottom = camera._maxCoord.y;\n\n    if (camera._scene.mapMode2D === MapMode2D.ROTATE) {\n      maxBottom *= camera.maximumZoomFactor;\n    }\n\n    if (newBottom > maxBottom) {\n      newBottom = maxBottom;\n      newTop = -maxBottom;\n    }\n\n    if (newTop <= newBottom) {\n      newTop = 1.0;\n      newBottom = -1.0;\n    }\n\n    ratio = frustum.right / frustum.top;\n    frustum.top = newTop;\n    frustum.bottom = newBottom;\n    frustum.right = frustum.top * ratio;\n    frustum.left = -frustum.right;\n  } else {\n    var newRight = frustum.right - amount;\n    var newLeft = frustum.left + amount;\n    var maxRight = camera._maxCoord.x;\n\n    if (camera._scene.mapMode2D === MapMode2D.ROTATE) {\n      maxRight *= camera.maximumZoomFactor;\n    }\n\n    if (newRight > maxRight) {\n      newRight = maxRight;\n      newLeft = -maxRight;\n    }\n\n    if (newRight <= newLeft) {\n      newRight = 1.0;\n      newLeft = -1.0;\n    }\n\n    ratio = frustum.top / frustum.right;\n    frustum.right = newRight;\n    frustum.left = newLeft;\n    frustum.top = frustum.right * ratio;\n    frustum.bottom = -frustum.top;\n  }\n}\n\nfunction zoom3D(camera, amount) {\n  camera.move(camera.direction, amount);\n}\n/**\n * Zooms <code>amount</code> along the camera's view vector.\n *\n * @param {Number} [amount] The amount to move. Defaults to <code>defaultZoomAmount</code>.\n *\n * @see Camera#zoomOut\n */\n\n\nCamera.prototype.zoomIn = function (amount) {\n  amount = defaultValue(amount, this.defaultZoomAmount);\n\n  if (this._mode === SceneMode.SCENE2D) {\n    zoom2D(this, amount);\n  } else {\n    zoom3D(this, amount);\n  }\n};\n/**\n * Zooms <code>amount</code> along the opposite direction of\n * the camera's view vector.\n *\n * @param {Number} [amount] The amount to move. Defaults to <code>defaultZoomAmount</code>.\n *\n * @see Camera#zoomIn\n */\n\n\nCamera.prototype.zoomOut = function (amount) {\n  amount = defaultValue(amount, this.defaultZoomAmount);\n\n  if (this._mode === SceneMode.SCENE2D) {\n    zoom2D(this, -amount);\n  } else {\n    zoom3D(this, -amount);\n  }\n};\n/**\n * Gets the magnitude of the camera position. In 3D, this is the vector magnitude. In 2D and\n * Columbus view, this is the distance to the map.\n *\n * @returns {Number} The magnitude of the position.\n */\n\n\nCamera.prototype.getMagnitude = function () {\n  if (this._mode === SceneMode.SCENE3D) {\n    return Cartesian3.magnitude(this.position);\n  } else if (this._mode === SceneMode.COLUMBUS_VIEW) {\n    return Math.abs(this.position.z);\n  } else if (this._mode === SceneMode.SCENE2D) {\n    return Math.max(this.frustum.right - this.frustum.left, this.frustum.top - this.frustum.bottom);\n  }\n};\n\nvar scratchLookAtMatrix4 = new Matrix4();\n/**\n * Sets the camera position and orientation using a target and offset. The target must be given in\n * world coordinates. The offset can be either a cartesian or heading/pitch/range in the local east-north-up reference frame centered at the target.\n * If the offset is a cartesian, then it is an offset from the center of the reference frame defined by the transformation matrix. If the offset\n * is heading/pitch/range, then the heading and the pitch angles are defined in the reference frame defined by the transformation matrix.\n * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch\n * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center.\n *\n * In 2D, there must be a top down view. The camera will be placed above the target looking down. The height above the\n * target will be the magnitude of the offset. The heading will be determined from the offset. If the heading cannot be\n * determined from the offset, the heading will be north.\n *\n * @param {Cartesian3} target The target position in world coordinates.\n * @param {Cartesian3|HeadingPitchRange} offset The offset from the target in the local east-north-up reference frame centered at the target.\n *\n * @exception {DeveloperError} lookAt is not supported while morphing.\n *\n * @example\n * // 1. Using a cartesian offset\n * var center = Cesium.Cartesian3.fromDegrees(-98.0, 40.0);\n * viewer.camera.lookAt(center, new Cesium.Cartesian3(0.0, -4790000.0, 3930000.0));\n *\n * // 2. Using a HeadingPitchRange offset\n * var center = Cesium.Cartesian3.fromDegrees(-72.0, 40.0);\n * var heading = Cesium.Math.toRadians(50.0);\n * var pitch = Cesium.Math.toRadians(-20.0);\n * var range = 5000.0;\n * viewer.camera.lookAt(center, new Cesium.HeadingPitchRange(heading, pitch, range));\n */\n\nCamera.prototype.lookAt = function (target, offset) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(target)) {\n    throw new DeveloperError(\"target is required\");\n  }\n\n  if (!defined(offset)) {\n    throw new DeveloperError(\"offset is required\");\n  }\n\n  if (this._mode === SceneMode.MORPHING) {\n    throw new DeveloperError(\"lookAt is not supported while morphing.\");\n  } //>>includeEnd('debug');\n\n\n  var transform = Transforms.eastNorthUpToFixedFrame(target, Ellipsoid.WGS84, scratchLookAtMatrix4);\n  this.lookAtTransform(transform, offset);\n};\n\nvar scratchLookAtHeadingPitchRangeOffset = new Cartesian3();\nvar scratchLookAtHeadingPitchRangeQuaternion1 = new Quaternion();\nvar scratchLookAtHeadingPitchRangeQuaternion2 = new Quaternion();\nvar scratchHeadingPitchRangeMatrix3 = new Matrix3();\n\nfunction offsetFromHeadingPitchRange(heading, pitch, range) {\n  pitch = CesiumMath.clamp(pitch, -CesiumMath.PI_OVER_TWO, CesiumMath.PI_OVER_TWO);\n  heading = CesiumMath.zeroToTwoPi(heading) - CesiumMath.PI_OVER_TWO;\n  var pitchQuat = Quaternion.fromAxisAngle(Cartesian3.UNIT_Y, -pitch, scratchLookAtHeadingPitchRangeQuaternion1);\n  var headingQuat = Quaternion.fromAxisAngle(Cartesian3.UNIT_Z, -heading, scratchLookAtHeadingPitchRangeQuaternion2);\n  var rotQuat = Quaternion.multiply(headingQuat, pitchQuat, headingQuat);\n  var rotMatrix = Matrix3.fromQuaternion(rotQuat, scratchHeadingPitchRangeMatrix3);\n  var offset = Cartesian3.clone(Cartesian3.UNIT_X, scratchLookAtHeadingPitchRangeOffset);\n  Matrix3.multiplyByVector(rotMatrix, offset, offset);\n  Cartesian3.negate(offset, offset);\n  Cartesian3.multiplyByScalar(offset, range, offset);\n  return offset;\n}\n/**\n * Sets the camera position and orientation using a target and transformation matrix. The offset can be either a cartesian or heading/pitch/range.\n * If the offset is a cartesian, then it is an offset from the center of the reference frame defined by the transformation matrix. If the offset\n * is heading/pitch/range, then the heading and the pitch angles are defined in the reference frame defined by the transformation matrix.\n * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch\n * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center.\n *\n * In 2D, there must be a top down view. The camera will be placed above the center of the reference frame. The height above the\n * target will be the magnitude of the offset. The heading will be determined from the offset. If the heading cannot be\n * determined from the offset, the heading will be north.\n *\n * @param {Matrix4} transform The transformation matrix defining the reference frame.\n * @param {Cartesian3|HeadingPitchRange} [offset] The offset from the target in a reference frame centered at the target.\n *\n * @exception {DeveloperError} lookAtTransform is not supported while morphing.\n *\n * @example\n * // 1. Using a cartesian offset\n * var transform = Cesium.Transforms.eastNorthUpToFixedFrame(Cesium.Cartesian3.fromDegrees(-98.0, 40.0));\n * viewer.camera.lookAtTransform(transform, new Cesium.Cartesian3(0.0, -4790000.0, 3930000.0));\n *\n * // 2. Using a HeadingPitchRange offset\n * var transform = Cesium.Transforms.eastNorthUpToFixedFrame(Cesium.Cartesian3.fromDegrees(-72.0, 40.0));\n * var heading = Cesium.Math.toRadians(50.0);\n * var pitch = Cesium.Math.toRadians(-20.0);\n * var range = 5000.0;\n * viewer.camera.lookAtTransform(transform, new Cesium.HeadingPitchRange(heading, pitch, range));\n */\n\n\nCamera.prototype.lookAtTransform = function (transform, offset) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(transform)) {\n    throw new DeveloperError(\"transform is required\");\n  }\n\n  if (this._mode === SceneMode.MORPHING) {\n    throw new DeveloperError(\"lookAtTransform is not supported while morphing.\");\n  } //>>includeEnd('debug');\n\n\n  this._setTransform(transform);\n\n  if (!defined(offset)) {\n    return;\n  }\n\n  var cartesianOffset;\n\n  if (defined(offset.heading)) {\n    cartesianOffset = offsetFromHeadingPitchRange(offset.heading, offset.pitch, offset.range);\n  } else {\n    cartesianOffset = offset;\n  }\n\n  if (this._mode === SceneMode.SCENE2D) {\n    Cartesian2.clone(Cartesian2.ZERO, this.position);\n    Cartesian3.negate(cartesianOffset, this.up);\n    this.up.z = 0.0;\n\n    if (Cartesian3.magnitudeSquared(this.up) < CesiumMath.EPSILON10) {\n      Cartesian3.clone(Cartesian3.UNIT_Y, this.up);\n    }\n\n    Cartesian3.normalize(this.up, this.up);\n\n    this._setTransform(Matrix4.IDENTITY);\n\n    Cartesian3.negate(Cartesian3.UNIT_Z, this.direction);\n    Cartesian3.cross(this.direction, this.up, this.right);\n    Cartesian3.normalize(this.right, this.right);\n    var frustum = this.frustum;\n    var ratio = frustum.top / frustum.right;\n    frustum.right = Cartesian3.magnitude(cartesianOffset) * 0.5;\n    frustum.left = -frustum.right;\n    frustum.top = ratio * frustum.right;\n    frustum.bottom = -frustum.top;\n\n    this._setTransform(transform);\n\n    return;\n  }\n\n  Cartesian3.clone(cartesianOffset, this.position);\n  Cartesian3.negate(this.position, this.direction);\n  Cartesian3.normalize(this.direction, this.direction);\n  Cartesian3.cross(this.direction, Cartesian3.UNIT_Z, this.right);\n\n  if (Cartesian3.magnitudeSquared(this.right) < CesiumMath.EPSILON10) {\n    Cartesian3.clone(Cartesian3.UNIT_X, this.right);\n  }\n\n  Cartesian3.normalize(this.right, this.right);\n  Cartesian3.cross(this.right, this.direction, this.up);\n  Cartesian3.normalize(this.up, this.up);\n\n  this._adjustOrthographicFrustum(true);\n};\n\nvar viewRectangle3DCartographic1 = new Cartographic();\nvar viewRectangle3DCartographic2 = new Cartographic();\nvar viewRectangle3DNorthEast = new Cartesian3();\nvar viewRectangle3DSouthWest = new Cartesian3();\nvar viewRectangle3DNorthWest = new Cartesian3();\nvar viewRectangle3DSouthEast = new Cartesian3();\nvar viewRectangle3DNorthCenter = new Cartesian3();\nvar viewRectangle3DSouthCenter = new Cartesian3();\nvar viewRectangle3DCenter = new Cartesian3();\nvar viewRectangle3DEquator = new Cartesian3();\nvar defaultRF = {\n  direction: new Cartesian3(),\n  right: new Cartesian3(),\n  up: new Cartesian3()\n};\nvar viewRectangle3DEllipsoidGeodesic;\n\nfunction computeD(direction, upOrRight, corner, tanThetaOrPhi) {\n  var opposite = Math.abs(Cartesian3.dot(upOrRight, corner));\n  return opposite / tanThetaOrPhi - Cartesian3.dot(direction, corner);\n}\n\nfunction rectangleCameraPosition3D(camera, rectangle, result, updateCamera) {\n  var ellipsoid = camera._projection.ellipsoid;\n  var cameraRF = updateCamera ? camera : defaultRF;\n  var north = rectangle.north;\n  var south = rectangle.south;\n  var east = rectangle.east;\n  var west = rectangle.west; // If we go across the International Date Line\n\n  if (west > east) {\n    east += CesiumMath.TWO_PI;\n  } // Find the midpoint latitude.\n  //\n  // EllipsoidGeodesic will fail if the north and south edges are very close to being on opposite sides of the ellipsoid.\n  // Ideally we'd just call EllipsoidGeodesic.setEndPoints and let it throw when it detects this case, but sadly it doesn't\n  // even look for this case in optimized builds, so we have to test for it here instead.\n  //\n  // Fortunately, this case can only happen (here) when north is very close to the north pole and south is very close to the south pole,\n  // so handle it just by using 0 latitude as the center.  It's certainliy possible to use a smaller tolerance\n  // than one degree here, but one degree is safe and putting the center at 0 latitude should be good enough for any\n  // rectangle that spans 178+ of the 180 degrees of latitude.\n\n\n  var longitude = (west + east) * 0.5;\n  var latitude;\n\n  if (south < -CesiumMath.PI_OVER_TWO + CesiumMath.RADIANS_PER_DEGREE && north > CesiumMath.PI_OVER_TWO - CesiumMath.RADIANS_PER_DEGREE) {\n    latitude = 0.0;\n  } else {\n    var northCartographic = viewRectangle3DCartographic1;\n    northCartographic.longitude = longitude;\n    northCartographic.latitude = north;\n    northCartographic.height = 0.0;\n    var southCartographic = viewRectangle3DCartographic2;\n    southCartographic.longitude = longitude;\n    southCartographic.latitude = south;\n    southCartographic.height = 0.0;\n    var ellipsoidGeodesic = viewRectangle3DEllipsoidGeodesic;\n\n    if (!defined(ellipsoidGeodesic) || ellipsoidGeodesic.ellipsoid !== ellipsoid) {\n      viewRectangle3DEllipsoidGeodesic = ellipsoidGeodesic = new EllipsoidGeodesic(undefined, undefined, ellipsoid);\n    }\n\n    ellipsoidGeodesic.setEndPoints(northCartographic, southCartographic);\n    latitude = ellipsoidGeodesic.interpolateUsingFraction(0.5, viewRectangle3DCartographic1).latitude;\n  }\n\n  var centerCartographic = viewRectangle3DCartographic1;\n  centerCartographic.longitude = longitude;\n  centerCartographic.latitude = latitude;\n  centerCartographic.height = 0.0;\n  var center = ellipsoid.cartographicToCartesian(centerCartographic, viewRectangle3DCenter);\n  var cart = viewRectangle3DCartographic1;\n  cart.longitude = east;\n  cart.latitude = north;\n  var northEast = ellipsoid.cartographicToCartesian(cart, viewRectangle3DNorthEast);\n  cart.longitude = west;\n  var northWest = ellipsoid.cartographicToCartesian(cart, viewRectangle3DNorthWest);\n  cart.longitude = longitude;\n  var northCenter = ellipsoid.cartographicToCartesian(cart, viewRectangle3DNorthCenter);\n  cart.latitude = south;\n  var southCenter = ellipsoid.cartographicToCartesian(cart, viewRectangle3DSouthCenter);\n  cart.longitude = east;\n  var southEast = ellipsoid.cartographicToCartesian(cart, viewRectangle3DSouthEast);\n  cart.longitude = west;\n  var southWest = ellipsoid.cartographicToCartesian(cart, viewRectangle3DSouthWest);\n  Cartesian3.subtract(northWest, center, northWest);\n  Cartesian3.subtract(southEast, center, southEast);\n  Cartesian3.subtract(northEast, center, northEast);\n  Cartesian3.subtract(southWest, center, southWest);\n  Cartesian3.subtract(northCenter, center, northCenter);\n  Cartesian3.subtract(southCenter, center, southCenter);\n  var direction = ellipsoid.geodeticSurfaceNormal(center, cameraRF.direction);\n  Cartesian3.negate(direction, direction);\n  var right = Cartesian3.cross(direction, Cartesian3.UNIT_Z, cameraRF.right);\n  Cartesian3.normalize(right, right);\n  var up = Cartesian3.cross(right, direction, cameraRF.up);\n  var d;\n\n  if (camera.frustum instanceof OrthographicFrustum) {\n    var width = Math.max(Cartesian3.distance(northEast, northWest), Cartesian3.distance(southEast, southWest));\n    var height = Math.max(Cartesian3.distance(northEast, southEast), Cartesian3.distance(northWest, southWest));\n    var rightScalar;\n    var topScalar;\n    var ratio = camera.frustum._offCenterFrustum.right / camera.frustum._offCenterFrustum.top;\n    var heightRatio = height * ratio;\n\n    if (width > heightRatio) {\n      rightScalar = width;\n      topScalar = rightScalar / ratio;\n    } else {\n      topScalar = height;\n      rightScalar = heightRatio;\n    }\n\n    d = Math.max(rightScalar, topScalar);\n  } else {\n    var tanPhi = Math.tan(camera.frustum.fovy * 0.5);\n    var tanTheta = camera.frustum.aspectRatio * tanPhi;\n    d = Math.max(computeD(direction, up, northWest, tanPhi), computeD(direction, up, southEast, tanPhi), computeD(direction, up, northEast, tanPhi), computeD(direction, up, southWest, tanPhi), computeD(direction, up, northCenter, tanPhi), computeD(direction, up, southCenter, tanPhi), computeD(direction, right, northWest, tanTheta), computeD(direction, right, southEast, tanTheta), computeD(direction, right, northEast, tanTheta), computeD(direction, right, southWest, tanTheta), computeD(direction, right, northCenter, tanTheta), computeD(direction, right, southCenter, tanTheta)); // If the rectangle crosses the equator, compute D at the equator, too, because that's the\n    // widest part of the rectangle when projected onto the globe.\n\n    if (south < 0 && north > 0) {\n      var equatorCartographic = viewRectangle3DCartographic1;\n      equatorCartographic.longitude = west;\n      equatorCartographic.latitude = 0.0;\n      equatorCartographic.height = 0.0;\n      var equatorPosition = ellipsoid.cartographicToCartesian(equatorCartographic, viewRectangle3DEquator);\n      Cartesian3.subtract(equatorPosition, center, equatorPosition);\n      d = Math.max(d, computeD(direction, up, equatorPosition, tanPhi), computeD(direction, right, equatorPosition, tanTheta));\n      equatorCartographic.longitude = east;\n      equatorPosition = ellipsoid.cartographicToCartesian(equatorCartographic, viewRectangle3DEquator);\n      Cartesian3.subtract(equatorPosition, center, equatorPosition);\n      d = Math.max(d, computeD(direction, up, equatorPosition, tanPhi), computeD(direction, right, equatorPosition, tanTheta));\n    }\n  }\n\n  return Cartesian3.add(center, Cartesian3.multiplyByScalar(direction, -d, viewRectangle3DEquator), result);\n}\n\nvar viewRectangleCVCartographic = new Cartographic();\nvar viewRectangleCVNorthEast = new Cartesian3();\nvar viewRectangleCVSouthWest = new Cartesian3();\n\nfunction rectangleCameraPositionColumbusView(camera, rectangle, result) {\n  var projection = camera._projection;\n\n  if (rectangle.west > rectangle.east) {\n    rectangle = Rectangle.MAX_VALUE;\n  }\n\n  var transform = camera._actualTransform;\n  var invTransform = camera._actualInvTransform;\n  var cart = viewRectangleCVCartographic;\n  cart.longitude = rectangle.east;\n  cart.latitude = rectangle.north;\n  var northEast = projection.project(cart, viewRectangleCVNorthEast);\n  Matrix4.multiplyByPoint(transform, northEast, northEast);\n  Matrix4.multiplyByPoint(invTransform, northEast, northEast);\n  cart.longitude = rectangle.west;\n  cart.latitude = rectangle.south;\n  var southWest = projection.project(cart, viewRectangleCVSouthWest);\n  Matrix4.multiplyByPoint(transform, southWest, southWest);\n  Matrix4.multiplyByPoint(invTransform, southWest, southWest);\n  result.x = (northEast.x - southWest.x) * 0.5 + southWest.x;\n  result.y = (northEast.y - southWest.y) * 0.5 + southWest.y;\n\n  if (defined(camera.frustum.fovy)) {\n    var tanPhi = Math.tan(camera.frustum.fovy * 0.5);\n    var tanTheta = camera.frustum.aspectRatio * tanPhi;\n    result.z = Math.max((northEast.x - southWest.x) / tanTheta, (northEast.y - southWest.y) / tanPhi) * 0.5;\n  } else {\n    var width = northEast.x - southWest.x;\n    var height = northEast.y - southWest.y;\n    result.z = Math.max(width, height);\n  }\n\n  return result;\n}\n\nvar viewRectangle2DCartographic = new Cartographic();\nvar viewRectangle2DNorthEast = new Cartesian3();\nvar viewRectangle2DSouthWest = new Cartesian3();\n\nfunction rectangleCameraPosition2D(camera, rectangle, result) {\n  var projection = camera._projection; // Account for the rectangle crossing the International Date Line in 2D mode\n\n  var east = rectangle.east;\n\n  if (rectangle.west > rectangle.east) {\n    if (camera._scene.mapMode2D === MapMode2D.INFINITE_SCROLL) {\n      east += CesiumMath.TWO_PI;\n    } else {\n      rectangle = Rectangle.MAX_VALUE;\n      east = rectangle.east;\n    }\n  }\n\n  var cart = viewRectangle2DCartographic;\n  cart.longitude = east;\n  cart.latitude = rectangle.north;\n  var northEast = projection.project(cart, viewRectangle2DNorthEast);\n  cart.longitude = rectangle.west;\n  cart.latitude = rectangle.south;\n  var southWest = projection.project(cart, viewRectangle2DSouthWest);\n  var width = Math.abs(northEast.x - southWest.x) * 0.5;\n  var height = Math.abs(northEast.y - southWest.y) * 0.5;\n  var right, top;\n  var ratio = camera.frustum.right / camera.frustum.top;\n  var heightRatio = height * ratio;\n\n  if (width > heightRatio) {\n    right = width;\n    top = right / ratio;\n  } else {\n    top = height;\n    right = heightRatio;\n  }\n\n  height = Math.max(2.0 * right, 2.0 * top);\n  result.x = (northEast.x - southWest.x) * 0.5 + southWest.x;\n  result.y = (northEast.y - southWest.y) * 0.5 + southWest.y;\n  cart = projection.unproject(result, cart);\n  cart.height = height;\n  result = projection.project(cart, result);\n  return result;\n}\n/**\n * Get the camera position needed to view a rectangle on an ellipsoid or map\n *\n * @param {Rectangle} rectangle The rectangle to view.\n * @param {Cartesian3} [result] The camera position needed to view the rectangle\n * @returns {Cartesian3} The camera position needed to view the rectangle\n */\n\n\nCamera.prototype.getRectangleCameraCoordinates = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(rectangle)) {\n    throw new DeveloperError(\"rectangle is required\");\n  } //>>includeEnd('debug');\n\n\n  var mode = this._mode;\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  if (mode === SceneMode.SCENE3D) {\n    return rectangleCameraPosition3D(this, rectangle, result);\n  } else if (mode === SceneMode.COLUMBUS_VIEW) {\n    return rectangleCameraPositionColumbusView(this, rectangle, result);\n  } else if (mode === SceneMode.SCENE2D) {\n    return rectangleCameraPosition2D(this, rectangle, result);\n  }\n\n  return undefined;\n};\n\nvar pickEllipsoid3DRay = new Ray();\n\nfunction pickEllipsoid3D(camera, windowPosition, ellipsoid, result) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  var ray = camera.getPickRay(windowPosition, pickEllipsoid3DRay);\n  var intersection = IntersectionTests.rayEllipsoid(ray, ellipsoid);\n\n  if (!intersection) {\n    return undefined;\n  }\n\n  var t = intersection.start > 0.0 ? intersection.start : intersection.stop;\n  return Ray.getPoint(ray, t, result);\n}\n\nvar pickEllipsoid2DRay = new Ray();\n\nfunction pickMap2D(camera, windowPosition, projection, result) {\n  var ray = camera.getPickRay(windowPosition, pickEllipsoid2DRay);\n  var position = ray.origin;\n  position = Cartesian3.fromElements(position.y, position.z, 0.0, position);\n  var cart = projection.unproject(position);\n\n  if (cart.latitude < -CesiumMath.PI_OVER_TWO || cart.latitude > CesiumMath.PI_OVER_TWO) {\n    return undefined;\n  }\n\n  return projection.ellipsoid.cartographicToCartesian(cart, result);\n}\n\nvar pickEllipsoidCVRay = new Ray();\n\nfunction pickMapColumbusView(camera, windowPosition, projection, result) {\n  var ray = camera.getPickRay(windowPosition, pickEllipsoidCVRay);\n  var scalar = -ray.origin.x / ray.direction.x;\n  Ray.getPoint(ray, scalar, result);\n  var cart = projection.unproject(new Cartesian3(result.y, result.z, 0.0));\n\n  if (cart.latitude < -CesiumMath.PI_OVER_TWO || cart.latitude > CesiumMath.PI_OVER_TWO || cart.longitude < -Math.PI || cart.longitude > Math.PI) {\n    return undefined;\n  }\n\n  return projection.ellipsoid.cartographicToCartesian(cart, result);\n}\n/**\n * Pick an ellipsoid or map.\n *\n * @param {Cartesian2} windowPosition The x and y coordinates of a pixel.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to pick.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3 | undefined} If the ellipsoid or map was picked,\n * returns the point on the surface of the ellipsoid or map in world\n * coordinates. If the ellipsoid or map was not picked, returns undefined.\n *\n * @example\n * var canvas = viewer.scene.canvas;\n * var center = new Cesium.Cartesian2(canvas.clientWidth / 2.0, canvas.clientHeight / 2.0);\n * var ellipsoid = viewer.scene.globe.ellipsoid;\n * var result = viewer.camera.pickEllipsoid(center, ellipsoid);\n */\n\n\nCamera.prototype.pickEllipsoid = function (windowPosition, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(windowPosition)) {\n    throw new DeveloperError(\"windowPosition is required.\");\n  } //>>includeEnd('debug');\n\n\n  var canvas = this._scene.canvas;\n\n  if (canvas.clientWidth === 0 || canvas.clientHeight === 0) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n\n  if (this._mode === SceneMode.SCENE3D) {\n    result = pickEllipsoid3D(this, windowPosition, ellipsoid, result);\n  } else if (this._mode === SceneMode.SCENE2D) {\n    result = pickMap2D(this, windowPosition, this._projection, result);\n  } else if (this._mode === SceneMode.COLUMBUS_VIEW) {\n    result = pickMapColumbusView(this, windowPosition, this._projection, result);\n  } else {\n    return undefined;\n  }\n\n  return result;\n};\n\nvar pickPerspCenter = new Cartesian3();\nvar pickPerspXDir = new Cartesian3();\nvar pickPerspYDir = new Cartesian3();\n\nfunction getPickRayPerspective(camera, windowPosition, result) {\n  var canvas = camera._scene.canvas;\n  var width = canvas.clientWidth;\n  var height = canvas.clientHeight;\n  var tanPhi = Math.tan(camera.frustum.fovy * 0.5);\n  var tanTheta = camera.frustum.aspectRatio * tanPhi;\n  var near = camera.frustum.near;\n  var x = 2.0 / width * windowPosition.x - 1.0;\n  var y = 2.0 / height * (height - windowPosition.y) - 1.0;\n  var position = camera.positionWC;\n  Cartesian3.clone(position, result.origin);\n  var nearCenter = Cartesian3.multiplyByScalar(camera.directionWC, near, pickPerspCenter);\n  Cartesian3.add(position, nearCenter, nearCenter);\n  var xDir = Cartesian3.multiplyByScalar(camera.rightWC, x * near * tanTheta, pickPerspXDir);\n  var yDir = Cartesian3.multiplyByScalar(camera.upWC, y * near * tanPhi, pickPerspYDir);\n  var direction = Cartesian3.add(nearCenter, xDir, result.direction);\n  Cartesian3.add(direction, yDir, direction);\n  Cartesian3.subtract(direction, position, direction);\n  Cartesian3.normalize(direction, direction);\n  return result;\n}\n\nvar scratchDirection = new Cartesian3();\n\nfunction getPickRayOrthographic(camera, windowPosition, result) {\n  var canvas = camera._scene.canvas;\n  var width = canvas.clientWidth;\n  var height = canvas.clientHeight;\n  var frustum = camera.frustum;\n\n  if (defined(frustum._offCenterFrustum)) {\n    frustum = frustum._offCenterFrustum;\n  }\n\n  var x = 2.0 / width * windowPosition.x - 1.0;\n  x *= (frustum.right - frustum.left) * 0.5;\n  var y = 2.0 / height * (height - windowPosition.y) - 1.0;\n  y *= (frustum.top - frustum.bottom) * 0.5;\n  var origin = result.origin;\n  Cartesian3.clone(camera.position, origin);\n  Cartesian3.multiplyByScalar(camera.right, x, scratchDirection);\n  Cartesian3.add(scratchDirection, origin, origin);\n  Cartesian3.multiplyByScalar(camera.up, y, scratchDirection);\n  Cartesian3.add(scratchDirection, origin, origin);\n  Cartesian3.clone(camera.directionWC, result.direction);\n\n  if (camera._mode === SceneMode.COLUMBUS_VIEW || camera._mode === SceneMode.SCENE2D) {\n    Cartesian3.fromElements(result.origin.z, result.origin.x, result.origin.y, result.origin);\n  }\n\n  return result;\n}\n/**\n * Create a ray from the camera position through the pixel at <code>windowPosition</code>\n * in world coordinates.\n *\n * @param {Cartesian2} windowPosition The x and y coordinates of a pixel.\n * @param {Ray} [result] The object onto which to store the result.\n * @returns {Ray} Returns the {@link Cartesian3} position and direction of the ray.\n */\n\n\nCamera.prototype.getPickRay = function (windowPosition, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(windowPosition)) {\n    throw new DeveloperError(\"windowPosition is required.\");\n  } //>>includeEnd('debug');\n\n\n  if (!defined(result)) {\n    result = new Ray();\n  }\n\n  var frustum = this.frustum;\n\n  if (defined(frustum.aspectRatio) && defined(frustum.fov) && defined(frustum.near)) {\n    return getPickRayPerspective(this, windowPosition, result);\n  }\n\n  return getPickRayOrthographic(this, windowPosition, result);\n};\n\nvar scratchToCenter = new Cartesian3();\nvar scratchProj = new Cartesian3();\n/**\n * Return the distance from the camera to the front of the bounding sphere.\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere in world coordinates.\n * @returns {Number} The distance to the bounding sphere.\n */\n\nCamera.prototype.distanceToBoundingSphere = function (boundingSphere) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  } //>>includeEnd('debug');\n\n\n  var toCenter = Cartesian3.subtract(this.positionWC, boundingSphere.center, scratchToCenter);\n  var proj = Cartesian3.multiplyByScalar(this.directionWC, Cartesian3.dot(toCenter, this.directionWC), scratchProj);\n  return Math.max(0.0, Cartesian3.magnitude(proj) - boundingSphere.radius);\n};\n\nvar scratchPixelSize = new Cartesian2();\n/**\n * Return the pixel size in meters.\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere in world coordinates.\n * @param {Number} drawingBufferWidth The drawing buffer width.\n * @param {Number} drawingBufferHeight The drawing buffer height.\n * @returns {Number} The pixel size in meters.\n */\n\nCamera.prototype.getPixelSize = function (boundingSphere, drawingBufferWidth, drawingBufferHeight) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  }\n\n  if (!defined(drawingBufferWidth)) {\n    throw new DeveloperError(\"drawingBufferWidth is required.\");\n  }\n\n  if (!defined(drawingBufferHeight)) {\n    throw new DeveloperError(\"drawingBufferHeight is required.\");\n  } //>>includeEnd('debug');\n\n\n  var distance = this.distanceToBoundingSphere(boundingSphere);\n  var pixelSize = this.frustum.getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance, this._scene.pixelRatio, scratchPixelSize);\n  return Math.max(pixelSize.x, pixelSize.y);\n};\n\nfunction createAnimationTemplateCV(camera, position, center, maxX, maxY, duration) {\n  var newPosition = Cartesian3.clone(position);\n\n  if (center.y > maxX) {\n    newPosition.y -= center.y - maxX;\n  } else if (center.y < -maxX) {\n    newPosition.y += -maxX - center.y;\n  }\n\n  if (center.z > maxY) {\n    newPosition.z -= center.z - maxY;\n  } else if (center.z < -maxY) {\n    newPosition.z += -maxY - center.z;\n  }\n\n  function updateCV(value) {\n    var interp = Cartesian3.lerp(position, newPosition, value.time, new Cartesian3());\n    camera.worldToCameraCoordinatesPoint(interp, camera.position);\n  }\n\n  return {\n    easingFunction: EasingFunction.EXPONENTIAL_OUT,\n    startObject: {\n      time: 0.0\n    },\n    stopObject: {\n      time: 1.0\n    },\n    duration: duration,\n    update: updateCV\n  };\n}\n\nvar normalScratch = new Cartesian3();\nvar centerScratch = new Cartesian3();\nvar posScratch = new Cartesian3();\nvar scratchCartesian3Subtract = new Cartesian3();\n\nfunction createAnimationCV(camera, duration) {\n  var position = camera.position;\n  var direction = camera.direction;\n  var normal = camera.worldToCameraCoordinatesVector(Cartesian3.UNIT_X, normalScratch);\n  var scalar = -Cartesian3.dot(normal, position) / Cartesian3.dot(normal, direction);\n  var center = Cartesian3.add(position, Cartesian3.multiplyByScalar(direction, scalar, centerScratch), centerScratch);\n  camera.cameraToWorldCoordinatesPoint(center, center);\n  position = camera.cameraToWorldCoordinatesPoint(camera.position, posScratch);\n  var tanPhi = Math.tan(camera.frustum.fovy * 0.5);\n  var tanTheta = camera.frustum.aspectRatio * tanPhi;\n  var distToC = Cartesian3.magnitude(Cartesian3.subtract(position, center, scratchCartesian3Subtract));\n  var dWidth = tanTheta * distToC;\n  var dHeight = tanPhi * distToC;\n  var mapWidth = camera._maxCoord.x;\n  var mapHeight = camera._maxCoord.y;\n  var maxX = Math.max(dWidth - mapWidth, mapWidth);\n  var maxY = Math.max(dHeight - mapHeight, mapHeight);\n\n  if (position.z < -maxX || position.z > maxX || position.y < -maxY || position.y > maxY) {\n    var translateX = center.y < -maxX || center.y > maxX;\n    var translateY = center.z < -maxY || center.z > maxY;\n\n    if (translateX || translateY) {\n      return createAnimationTemplateCV(camera, position, center, maxX, maxY, duration);\n    }\n  }\n\n  return undefined;\n}\n/**\n * Create an animation to move the map into view. This method is only valid for 2D and Columbus modes.\n *\n * @param {Number} duration The duration, in seconds, of the animation.\n * @returns {Object} The animation or undefined if the scene mode is 3D or the map is already ion view.\n *\n * @private\n */\n\n\nCamera.prototype.createCorrectPositionTween = function (duration) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(duration)) {\n    throw new DeveloperError(\"duration is required.\");\n  } //>>includeEnd('debug');\n\n\n  if (this._mode === SceneMode.COLUMBUS_VIEW) {\n    return createAnimationCV(this, duration);\n  }\n\n  return undefined;\n};\n\nvar scratchFlyToDestination = new Cartesian3();\nvar newOptions = {\n  destination: undefined,\n  heading: undefined,\n  pitch: undefined,\n  roll: undefined,\n  duration: undefined,\n  complete: undefined,\n  cancel: undefined,\n  endTransform: undefined,\n  maximumHeight: undefined,\n  easingFunction: undefined\n};\n/**\n * Cancels the current camera flight and leaves the camera at its current location.\n * If no flight is in progress, this this function does nothing.\n */\n\nCamera.prototype.cancelFlight = function () {\n  if (defined(this._currentFlight)) {\n    this._currentFlight.cancelTween();\n\n    this._currentFlight = undefined;\n  }\n};\n/**\n * Completes the current camera flight and moves the camera immediately to its final destination.\n * If no flight is in progress, this this function does nothing.\n */\n\n\nCamera.prototype.completeFlight = function () {\n  if (defined(this._currentFlight)) {\n    this._currentFlight.cancelTween();\n\n    var options = {\n      destination: undefined,\n      orientation: {\n        heading: undefined,\n        pitch: undefined,\n        roll: undefined\n      }\n    };\n    options.destination = newOptions.destination;\n    options.orientation.heading = newOptions.heading;\n    options.orientation.pitch = newOptions.pitch;\n    options.orientation.roll = newOptions.roll;\n    this.setView(options);\n\n    if (defined(this._currentFlight.complete)) {\n      this._currentFlight.complete();\n    }\n\n    this._currentFlight = undefined;\n  }\n};\n/**\n * Flies the camera from its current position to a new position.\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3|Rectangle} options.destination The final position of the camera in WGS84 (world) coordinates or a rectangle that would be visible from a top-down view.\n * @param {Object} [options.orientation] An object that contains either direction and up properties or heading, pitch and roll properties. By default, the direction will point\n * towards the center of the frame in 3D and in the negative z direction in Columbus view. The up direction will point towards local north in 3D and in the positive\n * y direction in Columbus view.  Orientation is not used in 2D when in infinite scrolling mode.\n * @param {Number} [options.duration] The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight.\n * @param {Camera.FlightCompleteCallback} [options.complete] The function to execute when the flight is complete.\n * @param {Camera.FlightCancelledCallback} [options.cancel] The function to execute if the flight is cancelled.\n * @param {Matrix4} [options.endTransform] Transform matrix representing the reference frame the camera will be in when the flight is completed.\n * @param {Number} [options.maximumHeight] The maximum height at the peak of the flight.\n * @param {Number} [options.pitchAdjustHeight] If camera flyes higher than that value, adjust pitch duiring the flight to look down, and keep Earth in viewport.\n * @param {Number} [options.flyOverLongitude] There are always two ways between 2 points on globe. This option force camera to choose fight direction to fly over that longitude.\n * @param {Number} [options.flyOverLongitudeWeight] Fly over the lon specifyed via flyOverLongitude only if that way is not longer than short way times flyOverLongitudeWeight.\n * @param {Boolean} [options.convert] Whether to convert the destination from world coordinates to scene coordinates (only relevant when not using 3D). Defaults to <code>true</code>.\n * @param {EasingFunction.Callback} [options.easingFunction] Controls how the time is interpolated over the duration of the flight.\n *\n * @exception {DeveloperError} If either direction or up is given, then both are required.\n *\n * @example\n * // 1. Fly to a position with a top-down view\n * viewer.camera.flyTo({\n *     destination : Cesium.Cartesian3.fromDegrees(-117.16, 32.71, 15000.0)\n * });\n *\n * // 2. Fly to a Rectangle with a top-down view\n * viewer.camera.flyTo({\n *     destination : Cesium.Rectangle.fromDegrees(west, south, east, north)\n * });\n *\n * // 3. Fly to a position with an orientation using unit vectors.\n * viewer.camera.flyTo({\n *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),\n *     orientation : {\n *         direction : new Cesium.Cartesian3(-0.04231243104240401, -0.20123236049443421, -0.97862924300734),\n *         up : new Cesium.Cartesian3(-0.47934589305293746, -0.8553216253114552, 0.1966022179118339)\n *     }\n * });\n *\n * // 4. Fly to a position with an orientation using heading, pitch and roll.\n * viewer.camera.flyTo({\n *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),\n *     orientation : {\n *         heading : Cesium.Math.toRadians(175.0),\n *         pitch : Cesium.Math.toRadians(-35.0),\n *         roll : 0.0\n *     }\n * });\n */\n\n\nCamera.prototype.flyTo = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var destination = options.destination; //>>includeStart('debug', pragmas.debug);\n\n  if (!defined(destination)) {\n    throw new DeveloperError(\"destination is required.\");\n  } //>>includeEnd('debug');\n\n\n  var mode = this._mode;\n\n  if (mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  this.cancelFlight();\n  var orientation = defaultValue(options.orientation, defaultValue.EMPTY_OBJECT);\n\n  if (defined(orientation.direction)) {\n    orientation = directionUpToHeadingPitchRoll(this, destination, orientation, scratchSetViewOptions.orientation);\n  }\n\n  if (defined(options.duration) && options.duration <= 0.0) {\n    var setViewOptions = scratchSetViewOptions;\n    setViewOptions.destination = options.destination;\n    setViewOptions.orientation.heading = orientation.heading;\n    setViewOptions.orientation.pitch = orientation.pitch;\n    setViewOptions.orientation.roll = orientation.roll;\n    setViewOptions.convert = options.convert;\n    setViewOptions.endTransform = options.endTransform;\n    this.setView(setViewOptions);\n\n    if (typeof options.complete === \"function\") {\n      options.complete();\n    }\n\n    return;\n  }\n\n  var isRectangle = defined(destination.west);\n\n  if (isRectangle) {\n    destination = this.getRectangleCameraCoordinates(destination, scratchFlyToDestination);\n  }\n\n  var that = this;\n  var flightTween;\n  newOptions.destination = destination;\n  newOptions.heading = orientation.heading;\n  newOptions.pitch = orientation.pitch;\n  newOptions.roll = orientation.roll;\n  newOptions.duration = options.duration;\n\n  newOptions.complete = function () {\n    if (flightTween === that._currentFlight) {\n      that._currentFlight = undefined;\n    }\n\n    if (defined(options.complete)) {\n      options.complete();\n    }\n  };\n\n  newOptions.cancel = options.cancel;\n  newOptions.endTransform = options.endTransform;\n  newOptions.convert = isRectangle ? false : options.convert;\n  newOptions.maximumHeight = options.maximumHeight;\n  newOptions.pitchAdjustHeight = options.pitchAdjustHeight;\n  newOptions.flyOverLongitude = options.flyOverLongitude;\n  newOptions.flyOverLongitudeWeight = options.flyOverLongitudeWeight;\n  newOptions.easingFunction = options.easingFunction;\n  var scene = this._scene;\n  var tweenOptions = CameraFlightPath.createTween(scene, newOptions); // If the camera doesn't actually need to go anywhere, duration\n  // will be 0 and we can just complete the current flight.\n\n  if (tweenOptions.duration === 0) {\n    if (typeof tweenOptions.complete === \"function\") {\n      tweenOptions.complete();\n    }\n\n    return;\n  }\n\n  flightTween = scene.tweens.add(tweenOptions);\n  this._currentFlight = flightTween; // Save the final destination view information for the PRELOAD_FLIGHT pass.\n\n  var preloadFlightCamera = this._scene.preloadFlightCamera;\n\n  if (this._mode !== SceneMode.SCENE2D) {\n    if (!defined(preloadFlightCamera)) {\n      preloadFlightCamera = Camera.clone(this);\n    }\n\n    preloadFlightCamera.setView({\n      destination: destination,\n      orientation: orientation\n    });\n    this._scene.preloadFlightCullingVolume = preloadFlightCamera.frustum.computeCullingVolume(preloadFlightCamera.positionWC, preloadFlightCamera.directionWC, preloadFlightCamera.upWC);\n  }\n};\n\nfunction distanceToBoundingSphere3D(camera, radius) {\n  var frustum = camera.frustum;\n  var tanPhi = Math.tan(frustum.fovy * 0.5);\n  var tanTheta = frustum.aspectRatio * tanPhi;\n  return Math.max(radius / tanTheta, radius / tanPhi);\n}\n\nfunction distanceToBoundingSphere2D(camera, radius) {\n  var frustum = camera.frustum;\n\n  if (defined(frustum._offCenterFrustum)) {\n    frustum = frustum._offCenterFrustum;\n  }\n\n  var right, top;\n  var ratio = frustum.right / frustum.top;\n  var heightRatio = radius * ratio;\n\n  if (radius > heightRatio) {\n    right = radius;\n    top = right / ratio;\n  } else {\n    top = radius;\n    right = heightRatio;\n  }\n\n  return Math.max(right, top) * 1.5;\n}\n\nvar MINIMUM_ZOOM = 100.0;\n\nfunction adjustBoundingSphereOffset(camera, boundingSphere, offset) {\n  offset = HeadingPitchRange.clone(defined(offset) ? offset : Camera.DEFAULT_OFFSET);\n  var minimumZoom = camera._scene.screenSpaceCameraController.minimumZoomDistance;\n  var maximumZoom = camera._scene.screenSpaceCameraController.maximumZoomDistance;\n  var range = offset.range;\n\n  if (!defined(range) || range === 0.0) {\n    var radius = boundingSphere.radius;\n\n    if (radius === 0.0) {\n      offset.range = MINIMUM_ZOOM;\n    } else if (camera.frustum instanceof OrthographicFrustum || camera._mode === SceneMode.SCENE2D) {\n      offset.range = distanceToBoundingSphere2D(camera, radius);\n    } else {\n      offset.range = distanceToBoundingSphere3D(camera, radius);\n    }\n\n    offset.range = CesiumMath.clamp(offset.range, minimumZoom, maximumZoom);\n  }\n\n  return offset;\n}\n/**\n * Sets the camera so that the current view contains the provided bounding sphere.\n *\n * <p>The offset is heading/pitch/range in the local east-north-up reference frame centered at the center of the bounding sphere.\n * The heading and the pitch angles are defined in the local east-north-up reference frame.\n * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch\n * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center. If the range is\n * zero, a range will be computed such that the whole bounding sphere is visible.</p>\n *\n * <p>In 2D, there must be a top down view. The camera will be placed above the target looking down. The height above the\n * target will be the range. The heading will be determined from the offset. If the heading cannot be\n * determined from the offset, the heading will be north.</p>\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere to view, in world coordinates.\n * @param {HeadingPitchRange} [offset] The offset from the target in the local east-north-up reference frame centered at the target.\n *\n * @exception {DeveloperError} viewBoundingSphere is not supported while morphing.\n */\n\n\nCamera.prototype.viewBoundingSphere = function (boundingSphere, offset) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  }\n\n  if (this._mode === SceneMode.MORPHING) {\n    throw new DeveloperError(\"viewBoundingSphere is not supported while morphing.\");\n  } //>>includeEnd('debug');\n\n\n  offset = adjustBoundingSphereOffset(this, boundingSphere, offset);\n  this.lookAt(boundingSphere.center, offset);\n};\n\nvar scratchflyToBoundingSphereTransform = new Matrix4();\nvar scratchflyToBoundingSphereDestination = new Cartesian3();\nvar scratchflyToBoundingSphereDirection = new Cartesian3();\nvar scratchflyToBoundingSphereUp = new Cartesian3();\nvar scratchflyToBoundingSphereRight = new Cartesian3();\nvar scratchFlyToBoundingSphereCart4 = new Cartesian4();\nvar scratchFlyToBoundingSphereQuaternion = new Quaternion();\nvar scratchFlyToBoundingSphereMatrix3 = new Matrix3();\n/**\n * Flies the camera to a location where the current view contains the provided bounding sphere.\n *\n * <p> The offset is heading/pitch/range in the local east-north-up reference frame centered at the center of the bounding sphere.\n * The heading and the pitch angles are defined in the local east-north-up reference frame.\n * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch\n * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center. If the range is\n * zero, a range will be computed such that the whole bounding sphere is visible.</p>\n *\n * <p>In 2D and Columbus View, there must be a top down view. The camera will be placed above the target looking down. The height above the\n * target will be the range. The heading will be aligned to local north.</p>\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere to view, in world coordinates.\n * @param {Object} [options] Object with the following properties:\n * @param {Number} [options.duration] The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight.\n * @param {HeadingPitchRange} [options.offset] The offset from the target in the local east-north-up reference frame centered at the target.\n * @param {Camera.FlightCompleteCallback} [options.complete] The function to execute when the flight is complete.\n * @param {Camera.FlightCancelledCallback} [options.cancel] The function to execute if the flight is cancelled.\n * @param {Matrix4} [options.endTransform] Transform matrix representing the reference frame the camera will be in when the flight is completed.\n * @param {Number} [options.maximumHeight] The maximum height at the peak of the flight.\n * @param {Number} [options.pitchAdjustHeight] If camera flyes higher than that value, adjust pitch duiring the flight to look down, and keep Earth in viewport.\n * @param {Number} [options.flyOverLongitude] There are always two ways between 2 points on globe. This option force camera to choose fight direction to fly over that longitude.\n * @param {Number} [options.flyOverLongitudeWeight] Fly over the lon specifyed via flyOverLongitude only if that way is not longer than short way times flyOverLongitudeWeight.\n * @param {EasingFunction.Callback} [options.easingFunction] Controls how the time is interpolated over the duration of the flight.\n */\n\nCamera.prototype.flyToBoundingSphere = function (boundingSphere, options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  } //>>includeEnd('debug');\n\n\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var scene2D = this._mode === SceneMode.SCENE2D || this._mode === SceneMode.COLUMBUS_VIEW;\n\n  this._setTransform(Matrix4.IDENTITY);\n\n  var offset = adjustBoundingSphereOffset(this, boundingSphere, options.offset);\n  var position;\n\n  if (scene2D) {\n    position = Cartesian3.multiplyByScalar(Cartesian3.UNIT_Z, offset.range, scratchflyToBoundingSphereDestination);\n  } else {\n    position = offsetFromHeadingPitchRange(offset.heading, offset.pitch, offset.range);\n  }\n\n  var transform = Transforms.eastNorthUpToFixedFrame(boundingSphere.center, Ellipsoid.WGS84, scratchflyToBoundingSphereTransform);\n  Matrix4.multiplyByPoint(transform, position, position);\n  var direction;\n  var up;\n\n  if (!scene2D) {\n    direction = Cartesian3.subtract(boundingSphere.center, position, scratchflyToBoundingSphereDirection);\n    Cartesian3.normalize(direction, direction);\n    up = Matrix4.multiplyByPointAsVector(transform, Cartesian3.UNIT_Z, scratchflyToBoundingSphereUp);\n\n    if (1.0 - Math.abs(Cartesian3.dot(direction, up)) < CesiumMath.EPSILON6) {\n      var rotateQuat = Quaternion.fromAxisAngle(direction, offset.heading, scratchFlyToBoundingSphereQuaternion);\n      var rotation = Matrix3.fromQuaternion(rotateQuat, scratchFlyToBoundingSphereMatrix3);\n      Cartesian3.fromCartesian4(Matrix4.getColumn(transform, 1, scratchFlyToBoundingSphereCart4), up);\n      Matrix3.multiplyByVector(rotation, up, up);\n    }\n\n    var right = Cartesian3.cross(direction, up, scratchflyToBoundingSphereRight);\n    Cartesian3.cross(right, direction, up);\n    Cartesian3.normalize(up, up);\n  }\n\n  this.flyTo({\n    destination: position,\n    orientation: {\n      direction: direction,\n      up: up\n    },\n    duration: options.duration,\n    complete: options.complete,\n    cancel: options.cancel,\n    endTransform: options.endTransform,\n    maximumHeight: options.maximumHeight,\n    easingFunction: options.easingFunction,\n    flyOverLongitude: options.flyOverLongitude,\n    flyOverLongitudeWeight: options.flyOverLongitudeWeight,\n    pitchAdjustHeight: options.pitchAdjustHeight\n  });\n};\n\nvar scratchCartesian3_1 = new Cartesian3();\nvar scratchCartesian3_2 = new Cartesian3();\nvar scratchCartesian3_3 = new Cartesian3();\nvar scratchCartesian3_4 = new Cartesian3();\nvar horizonPoints = [new Cartesian3(), new Cartesian3(), new Cartesian3(), new Cartesian3()];\n\nfunction computeHorizonQuad(camera, ellipsoid) {\n  var radii = ellipsoid.radii;\n  var p = camera.positionWC; // Find the corresponding position in the scaled space of the ellipsoid.\n\n  var q = Cartesian3.multiplyComponents(ellipsoid.oneOverRadii, p, scratchCartesian3_1);\n  var qMagnitude = Cartesian3.magnitude(q);\n  var qUnit = Cartesian3.normalize(q, scratchCartesian3_2); // Determine the east and north directions at q.\n\n  var eUnit;\n  var nUnit;\n\n  if (Cartesian3.equalsEpsilon(qUnit, Cartesian3.UNIT_Z, CesiumMath.EPSILON10)) {\n    eUnit = new Cartesian3(0, 1, 0);\n    nUnit = new Cartesian3(0, 0, 1);\n  } else {\n    eUnit = Cartesian3.normalize(Cartesian3.cross(Cartesian3.UNIT_Z, qUnit, scratchCartesian3_3), scratchCartesian3_3);\n    nUnit = Cartesian3.normalize(Cartesian3.cross(qUnit, eUnit, scratchCartesian3_4), scratchCartesian3_4);\n  } // Determine the radius of the 'limb' of the ellipsoid.\n\n\n  var wMagnitude = Math.sqrt(Cartesian3.magnitudeSquared(q) - 1.0); // Compute the center and offsets.\n\n  var center = Cartesian3.multiplyByScalar(qUnit, 1.0 / qMagnitude, scratchCartesian3_1);\n  var scalar = wMagnitude / qMagnitude;\n  var eastOffset = Cartesian3.multiplyByScalar(eUnit, scalar, scratchCartesian3_2);\n  var northOffset = Cartesian3.multiplyByScalar(nUnit, scalar, scratchCartesian3_3); // A conservative measure for the longitudes would be to use the min/max longitudes of the bounding frustum.\n\n  var upperLeft = Cartesian3.add(center, northOffset, horizonPoints[0]);\n  Cartesian3.subtract(upperLeft, eastOffset, upperLeft);\n  Cartesian3.multiplyComponents(radii, upperLeft, upperLeft);\n  var lowerLeft = Cartesian3.subtract(center, northOffset, horizonPoints[1]);\n  Cartesian3.subtract(lowerLeft, eastOffset, lowerLeft);\n  Cartesian3.multiplyComponents(radii, lowerLeft, lowerLeft);\n  var lowerRight = Cartesian3.subtract(center, northOffset, horizonPoints[2]);\n  Cartesian3.add(lowerRight, eastOffset, lowerRight);\n  Cartesian3.multiplyComponents(radii, lowerRight, lowerRight);\n  var upperRight = Cartesian3.add(center, northOffset, horizonPoints[3]);\n  Cartesian3.add(upperRight, eastOffset, upperRight);\n  Cartesian3.multiplyComponents(radii, upperRight, upperRight);\n  return horizonPoints;\n}\n\nvar scratchPickCartesian2 = new Cartesian2();\nvar scratchRectCartesian = new Cartesian3();\nvar cartoArray = [new Cartographic(), new Cartographic(), new Cartographic(), new Cartographic()];\n\nfunction addToResult(x, y, index, camera, ellipsoid, computedHorizonQuad) {\n  scratchPickCartesian2.x = x;\n  scratchPickCartesian2.y = y;\n  var r = camera.pickEllipsoid(scratchPickCartesian2, ellipsoid, scratchRectCartesian);\n\n  if (defined(r)) {\n    cartoArray[index] = ellipsoid.cartesianToCartographic(r, cartoArray[index]);\n    return 1;\n  }\n\n  cartoArray[index] = ellipsoid.cartesianToCartographic(computedHorizonQuad[index], cartoArray[index]);\n  return 0;\n}\n/**\n * Computes the approximate visible rectangle on the ellipsoid.\n *\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid that you want to know the visible region.\n * @param {Rectangle} [result] The rectangle in which to store the result\n *\n * @returns {Rectangle|undefined} The visible rectangle or undefined if the ellipsoid isn't visible at all.\n */\n\n\nCamera.prototype.computeViewRectangle = function (ellipsoid, result) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  var cullingVolume = this.frustum.computeCullingVolume(this.positionWC, this.directionWC, this.upWC);\n  var boundingSphere = new BoundingSphere(Cartesian3.ZERO, ellipsoid.maximumRadius);\n  var visibility = cullingVolume.computeVisibility(boundingSphere);\n\n  if (visibility === Intersect.OUTSIDE) {\n    return undefined;\n  }\n\n  var canvas = this._scene.canvas;\n  var width = canvas.clientWidth;\n  var height = canvas.clientHeight;\n  var successfulPickCount = 0;\n  var computedHorizonQuad = computeHorizonQuad(this, ellipsoid);\n  successfulPickCount += addToResult(0, 0, 0, this, ellipsoid, computedHorizonQuad);\n  successfulPickCount += addToResult(0, height, 1, this, ellipsoid, computedHorizonQuad);\n  successfulPickCount += addToResult(width, height, 2, this, ellipsoid, computedHorizonQuad);\n  successfulPickCount += addToResult(width, 0, 3, this, ellipsoid, computedHorizonQuad);\n\n  if (successfulPickCount < 2) {\n    // If we have space non-globe in 3 or 4 corners then return the whole globe\n    return Rectangle.MAX_VALUE;\n  }\n\n  result = Rectangle.fromCartographicArray(cartoArray, result); // Detect if we go over the poles\n\n  var distance = 0;\n  var lastLon = cartoArray[3].longitude;\n\n  for (var i = 0; i < 4; ++i) {\n    var lon = cartoArray[i].longitude;\n    var diff = Math.abs(lon - lastLon);\n\n    if (diff > CesiumMath.PI) {\n      // Crossed the dateline\n      distance += CesiumMath.TWO_PI - diff;\n    } else {\n      distance += diff;\n    }\n\n    lastLon = lon;\n  } // We are over one of the poles so adjust the rectangle accordingly\n\n\n  if (CesiumMath.equalsEpsilon(Math.abs(distance), CesiumMath.TWO_PI, CesiumMath.EPSILON9)) {\n    result.west = -CesiumMath.PI;\n    result.east = CesiumMath.PI;\n\n    if (cartoArray[0].latitude >= 0.0) {\n      result.north = CesiumMath.PI_OVER_TWO;\n    } else {\n      result.south = -CesiumMath.PI_OVER_TWO;\n    }\n  }\n\n  return result;\n};\n/**\n * Switches the frustum/projection to perspective.\n *\n * This function is a no-op in 2D which must always be orthographic.\n */\n\n\nCamera.prototype.switchToPerspectiveFrustum = function () {\n  if (this._mode === SceneMode.SCENE2D || this.frustum instanceof PerspectiveFrustum) {\n    return;\n  }\n\n  var scene = this._scene;\n  this.frustum = new PerspectiveFrustum();\n  this.frustum.aspectRatio = scene.drawingBufferWidth / scene.drawingBufferHeight;\n  this.frustum.fov = CesiumMath.toRadians(60.0);\n};\n/**\n * Switches the frustum/projection to orthographic.\n *\n * This function is a no-op in 2D which will always be orthographic.\n */\n\n\nCamera.prototype.switchToOrthographicFrustum = function () {\n  if (this._mode === SceneMode.SCENE2D || this.frustum instanceof OrthographicFrustum) {\n    return;\n  } // This must be called before changing the frustum because it uses the previous\n  // frustum to reconstruct the world space position from the depth buffer.\n\n\n  var frustumWidth = calculateOrthographicFrustumWidth(this);\n  var scene = this._scene;\n  this.frustum = new OrthographicFrustum();\n  this.frustum.aspectRatio = scene.drawingBufferWidth / scene.drawingBufferHeight;\n  this.frustum.width = frustumWidth;\n};\n/**\n * @private\n */\n\n\nCamera.clone = function (camera, result) {\n  if (!defined(result)) {\n    result = new Camera(camera._scene);\n  }\n\n  Cartesian3.clone(camera.position, result.position);\n  Cartesian3.clone(camera.direction, result.direction);\n  Cartesian3.clone(camera.up, result.up);\n  Cartesian3.clone(camera.right, result.right);\n  Matrix4.clone(camera._transform, result.transform);\n  result._transformChanged = true;\n  result.frustum = camera.frustum.clone();\n  return result;\n};\n/**\n * A function that will execute when a flight completes.\n * @callback Camera.FlightCompleteCallback\n */\n\n/**\n * A function that will execute when a flight is cancelled.\n * @callback Camera.FlightCancelledCallback\n */\n\n\nexport default Camera;","map":{"version":3,"sources":["/home/usuario/davi/thalamus/wms/3dmaptestes/leaflet_cesium/client/node_modules/cesium/Source/Scene/Camera.js"],"names":["BoundingSphere","Cartesian2","Cartesian3","Cartesian4","Cartographic","defaultValue","defined","DeveloperError","EasingFunction","Ellipsoid","EllipsoidGeodesic","Event","getTimestamp","HeadingPitchRange","HeadingPitchRoll","Intersect","IntersectionTests","CesiumMath","Matrix3","Matrix4","OrthographicFrustum","OrthographicOffCenterFrustum","PerspectiveFrustum","Quaternion","Ray","Rectangle","Transforms","CameraFlightPath","MapMode2D","SceneMode","Camera","scene","_scene","_transform","clone","IDENTITY","_invTransform","_actualTransform","_actualInvTransform","_transformChanged","position","_position","_positionWC","_positionCartographic","_oldPositionWC","undefined","positionWCDeltaMagnitude","positionWCDeltaMagnitudeLastFrame","timeSinceMoved","_lastMovedTimestamp","direction","_direction","_directionWC","up","_up","_upWC","right","_right","_rightWC","frustum","aspectRatio","drawingBufferWidth","drawingBufferHeight","fov","toRadians","defaultMoveAmount","defaultLookAmount","Math","PI","defaultRotateAmount","defaultZoomAmount","constrainedAxis","maximumZoomFactor","_moveStart","_moveEnd","_changed","_changedPosition","_changedDirection","_changedFrustum","percentageChanged","_viewMatrix","_invViewMatrix","updateViewMatrix","_mode","SCENE3D","_modeChanged","projection","mapProjection","_projection","_maxCoord","project","PI_OVER_TWO","_max2Dfrustum","rectangleCameraPosition3D","DEFAULT_VIEW_RECTANGLE","mag","magnitude","DEFAULT_VIEW_FACTOR","normalize","multiplyByScalar","TRANSFORM_2D","TRANSFORM_2D_INVERSE","inverseTransformation","fromDegrees","DEFAULT_OFFSET","PI_OVER_FOUR","camera","computeView","multiply","updateCameraDeltas","positionWC","delta","subtract","max","prototype","canPreloadFlight","_currentFlight","SCENE2D","_updateCameraChanged","numberOfListeners","lastPosition","lastFrustum","x0","x","left","x1","x2","x3","y0","y","bottom","y1","top","y2","y3","leftX","rightX","min","bottomY","topY","areaPercentage","areaRef","raiseEvent","directionWC","dirAngle","acosClamped","dot","dirPercentage","fovy","distance","heightPercentage","positionCartographic","height","convertTransformForColumbusView","basisTo2D","scratchCartographic","scratchCartesian3Projection","scratchCartesian3","scratchCartesian4Origin","scratchCartesian4NewOrigin","scratchCartesian4NewXAxis","scratchCartesian4NewYAxis","scratchCartesian4NewZAxis","convertTransformFor2D","ellipsoid","origin","getColumn","cartographic","cartesianToCartographic","projectedPosition","newOrigin","z","w","newZAxis","UNIT_X","xAxis","add","newXAxis","newYAxis","magnitudeSquared","EPSILON10","cross","yAxis","UNIT_Y","UNIT_Z","setColumn","scratchCartesian","updateMembers","mode","heightChanged","positionChanged","equals","directionChanged","upChanged","rightChanged","transformChanged","COLUMBUS_VIEW","transform","multiplyByPoint","MORPHING","positionENU","unproject","det","abs","EPSILON2","invUpMag","scalar","w0","multiplyByPointAsVector","getHeading","heading","equalsEpsilon","EPSILON3","atan2","TWO_PI","zeroToTwoPi","getPitch","getRoll","roll","scratchHPRMatrix1","scratchHPRMatrix2","Object","defineProperties","get","inverseTransform","viewMatrix","inverseViewMatrix","upWC","rightWC","oldTransform","eastNorthUpToFixedFrame","_setTransform","pitch","moveStart","moveEnd","changed","update","updateFrustum","maxZoomOut","ratio","clampMove2D","setTransformPosition","setTransformUp","setTransformDirection","inverse","scratchAdjustOrthographicFrustumMousePosition","scratchPickRay","scratchRayIntersection","scratchDepthIntersection","calculateOrthographicFrustumWidth","globe","mousePosition","rayIntersection","ray","getPickRay","pickWorldCoordinates","depthIntersection","pickPositionSupported","pickPositionWorldCoordinates","depthDistance","Number","POSITIVE_INFINITY","rayDistance","_adjustOrthographicFrustum","zooming","width","scratchSetViewCartesian","scratchSetViewTransform1","scratchSetViewTransform2","scratchSetViewQuaternion","scratchSetViewMatrix3","scratchSetViewCartographic","setView3D","hpr","currentTransform","localTransform","ZERO","rotQuat","fromHeadingPitchRoll","rotMat","fromQuaternion","setViewCV","convert","setView2D","newLeft","newRight","mapMode2D","ROTATE","scratchToHPRDirection","scratchToHPRUp","scratchToHPRRight","directionUpToHeadingPitchRoll","orientation","result","invTransform","scratchSetViewOptions","destination","endTransform","scratchHpr","setView","options","EMPTY_OBJECT","west","getRectangleCameraCoordinates","pitchScratch","flyHome","duration","completeMorph","flyTo","maxRadii","maximumRadius","acos","worldToCameraCoordinates","cartesian","multiplyByVector","worldToCameraCoordinatesPoint","worldToCameraCoordinatesVector","cameraToWorldCoordinates","cameraToWorldCoordinatesPoint","cameraToWorldCoordinatesVector","rotatable2D","maxProjectedX","maxProjectedY","minX","maxX","moveScratch","move","amount","cameraPosition","moveForward","zoom2D","moveBackward","moveUp","moveDown","moveRight","moveLeft","lookLeft","look","lookRight","lookUp","lookDown","lookScratchQuaternion","lookScratchMatrix","axis","angle","turnAngle","quaternion","fromAxisAngle","rotation","twistLeft","twistRight","rotateScratchQuaternion","rotateScratchMatrix","rotate","rotateDown","rotateVertical","rotateUp","rotateVertScratchP","rotateVertScratchA","rotateVertScratchTan","rotateVertScratchNegate","p","northParallel","southParallel","negate","angleToAxis","EPSILON4","tangent","rotateRight","rotateHorizontal","rotateLeft","newTop","newBottom","maxBottom","maxRight","zoom3D","zoomIn","zoomOut","getMagnitude","scratchLookAtMatrix4","lookAt","target","offset","WGS84","lookAtTransform","scratchLookAtHeadingPitchRangeOffset","scratchLookAtHeadingPitchRangeQuaternion1","scratchLookAtHeadingPitchRangeQuaternion2","scratchHeadingPitchRangeMatrix3","offsetFromHeadingPitchRange","range","clamp","pitchQuat","headingQuat","rotMatrix","cartesianOffset","viewRectangle3DCartographic1","viewRectangle3DCartographic2","viewRectangle3DNorthEast","viewRectangle3DSouthWest","viewRectangle3DNorthWest","viewRectangle3DSouthEast","viewRectangle3DNorthCenter","viewRectangle3DSouthCenter","viewRectangle3DCenter","viewRectangle3DEquator","defaultRF","viewRectangle3DEllipsoidGeodesic","computeD","upOrRight","corner","tanThetaOrPhi","opposite","rectangle","updateCamera","cameraRF","north","south","east","longitude","latitude","RADIANS_PER_DEGREE","northCartographic","southCartographic","ellipsoidGeodesic","setEndPoints","interpolateUsingFraction","centerCartographic","center","cartographicToCartesian","cart","northEast","northWest","northCenter","southCenter","southEast","southWest","geodeticSurfaceNormal","d","rightScalar","topScalar","_offCenterFrustum","heightRatio","tanPhi","tan","tanTheta","equatorCartographic","equatorPosition","viewRectangleCVCartographic","viewRectangleCVNorthEast","viewRectangleCVSouthWest","rectangleCameraPositionColumbusView","MAX_VALUE","viewRectangle2DCartographic","viewRectangle2DNorthEast","viewRectangle2DSouthWest","rectangleCameraPosition2D","INFINITE_SCROLL","pickEllipsoid3DRay","pickEllipsoid3D","windowPosition","intersection","rayEllipsoid","t","start","stop","getPoint","pickEllipsoid2DRay","pickMap2D","fromElements","pickEllipsoidCVRay","pickMapColumbusView","pickEllipsoid","canvas","clientWidth","clientHeight","pickPerspCenter","pickPerspXDir","pickPerspYDir","getPickRayPerspective","near","nearCenter","xDir","yDir","scratchDirection","getPickRayOrthographic","scratchToCenter","scratchProj","distanceToBoundingSphere","boundingSphere","toCenter","proj","radius","scratchPixelSize","getPixelSize","pixelSize","getPixelDimensions","pixelRatio","createAnimationTemplateCV","maxY","newPosition","updateCV","value","interp","lerp","time","easingFunction","EXPONENTIAL_OUT","startObject","stopObject","normalScratch","centerScratch","posScratch","scratchCartesian3Subtract","createAnimationCV","normal","distToC","dWidth","dHeight","mapWidth","mapHeight","translateX","translateY","createCorrectPositionTween","scratchFlyToDestination","newOptions","complete","cancel","maximumHeight","cancelFlight","cancelTween","completeFlight","setViewOptions","isRectangle","that","flightTween","pitchAdjustHeight","flyOverLongitude","flyOverLongitudeWeight","tweenOptions","createTween","tweens","preloadFlightCamera","preloadFlightCullingVolume","computeCullingVolume","distanceToBoundingSphere3D","distanceToBoundingSphere2D","MINIMUM_ZOOM","adjustBoundingSphereOffset","minimumZoom","screenSpaceCameraController","minimumZoomDistance","maximumZoom","maximumZoomDistance","viewBoundingSphere","scratchflyToBoundingSphereTransform","scratchflyToBoundingSphereDestination","scratchflyToBoundingSphereDirection","scratchflyToBoundingSphereUp","scratchflyToBoundingSphereRight","scratchFlyToBoundingSphereCart4","scratchFlyToBoundingSphereQuaternion","scratchFlyToBoundingSphereMatrix3","flyToBoundingSphere","scene2D","EPSILON6","rotateQuat","fromCartesian4","scratchCartesian3_1","scratchCartesian3_2","scratchCartesian3_3","scratchCartesian3_4","horizonPoints","computeHorizonQuad","radii","q","multiplyComponents","oneOverRadii","qMagnitude","qUnit","eUnit","nUnit","wMagnitude","sqrt","eastOffset","northOffset","upperLeft","lowerLeft","lowerRight","upperRight","scratchPickCartesian2","scratchRectCartesian","cartoArray","addToResult","index","computedHorizonQuad","r","computeViewRectangle","cullingVolume","visibility","computeVisibility","OUTSIDE","successfulPickCount","fromCartographicArray","lastLon","i","lon","diff","EPSILON9","switchToPerspectiveFrustum","switchToOrthographicFrustum","frustumWidth"],"mappings":"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","sourcesContent":["import BoundingSphere from \"../Core/BoundingSphere.js\";\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Cartesian4 from \"../Core/Cartesian4.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport EasingFunction from \"../Core/EasingFunction.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport EllipsoidGeodesic from \"../Core/EllipsoidGeodesic.js\";\nimport Event from \"../Core/Event.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport HeadingPitchRange from \"../Core/HeadingPitchRange.js\";\nimport HeadingPitchRoll from \"../Core/HeadingPitchRoll.js\";\nimport Intersect from \"../Core/Intersect.js\";\nimport IntersectionTests from \"../Core/IntersectionTests.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport OrthographicFrustum from \"../Core/OrthographicFrustum.js\";\nimport OrthographicOffCenterFrustum from \"../Core/OrthographicOffCenterFrustum.js\";\nimport PerspectiveFrustum from \"../Core/PerspectiveFrustum.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport Ray from \"../Core/Ray.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport CameraFlightPath from \"./CameraFlightPath.js\";\nimport MapMode2D from \"./MapMode2D.js\";\nimport SceneMode from \"./SceneMode.js\";\n\n/**\n * The camera is defined by a position, orientation, and view frustum.\n * <br /><br />\n * The orientation forms an orthonormal basis with a view, up and right = view x up unit vectors.\n * <br /><br />\n * The viewing frustum is defined by 6 planes.\n * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components\n * define the unit vector normal to the plane, and the w component is the distance of the\n * plane from the origin/camera position.\n *\n * @alias Camera\n *\n * @constructor\n *\n * @param {Scene} scene The scene.\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Camera.html|Cesium Sandcastle Camera Demo}\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Camera%20Tutorial.html|Cesium Sandcastle Camera Tutorial Example}\n * @demo {@link https://cesium.com/docs/tutorials/camera/|Camera Tutorial}\n *\n * @example\n * // Create a camera looking down the negative z-axis, positioned at the origin,\n * // with a field of view of 60 degrees, and 1:1 aspect ratio.\n * var camera = new Cesium.Camera(scene);\n * camera.position = new Cesium.Cartesian3();\n * camera.direction = Cesium.Cartesian3.negate(Cesium.Cartesian3.UNIT_Z, new Cesium.Cartesian3());\n * camera.up = Cesium.Cartesian3.clone(Cesium.Cartesian3.UNIT_Y);\n * camera.frustum.fov = Cesium.Math.PI_OVER_THREE;\n * camera.frustum.near = 1.0;\n * camera.frustum.far = 2.0;\n */\nfunction Camera(scene) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(scene)) {\n    throw new DeveloperError(\"scene is required.\");\n  }\n  //>>includeEnd('debug');\n  this._scene = scene;\n\n  this._transform = Matrix4.clone(Matrix4.IDENTITY);\n  this._invTransform = Matrix4.clone(Matrix4.IDENTITY);\n  this._actualTransform = Matrix4.clone(Matrix4.IDENTITY);\n  this._actualInvTransform = Matrix4.clone(Matrix4.IDENTITY);\n  this._transformChanged = false;\n\n  /**\n   * The position of the camera.\n   *\n   * @type {Cartesian3}\n   */\n  this.position = new Cartesian3();\n  this._position = new Cartesian3();\n  this._positionWC = new Cartesian3();\n  this._positionCartographic = new Cartographic();\n  this._oldPositionWC = undefined;\n\n  /**\n   * The position delta magnitude.\n   *\n   * @private\n   */\n  this.positionWCDeltaMagnitude = 0.0;\n\n  /**\n   * The position delta magnitude last frame.\n   *\n   * @private\n   */\n  this.positionWCDeltaMagnitudeLastFrame = 0.0;\n\n  /**\n   * How long in seconds since the camera has stopped moving\n   *\n   * @private\n   */\n  this.timeSinceMoved = 0.0;\n  this._lastMovedTimestamp = 0.0;\n\n  /**\n   * The view direction of the camera.\n   *\n   * @type {Cartesian3}\n   */\n  this.direction = new Cartesian3();\n  this._direction = new Cartesian3();\n  this._directionWC = new Cartesian3();\n\n  /**\n   * The up direction of the camera.\n   *\n   * @type {Cartesian3}\n   */\n  this.up = new Cartesian3();\n  this._up = new Cartesian3();\n  this._upWC = new Cartesian3();\n\n  /**\n   * The right direction of the camera.\n   *\n   * @type {Cartesian3}\n   */\n  this.right = new Cartesian3();\n  this._right = new Cartesian3();\n  this._rightWC = new Cartesian3();\n\n  /**\n   * The region of space in view.\n   *\n   * @type {PerspectiveFrustum|PerspectiveOffCenterFrustum|OrthographicFrustum}\n   * @default PerspectiveFrustum()\n   *\n   * @see PerspectiveFrustum\n   * @see PerspectiveOffCenterFrustum\n   * @see OrthographicFrustum\n   */\n  this.frustum = new PerspectiveFrustum();\n  this.frustum.aspectRatio =\n    scene.drawingBufferWidth / scene.drawingBufferHeight;\n  this.frustum.fov = CesiumMath.toRadians(60.0);\n\n  /**\n   * The default amount to move the camera when an argument is not\n   * provided to the move methods.\n   * @type {Number}\n   * @default 100000.0;\n   */\n  this.defaultMoveAmount = 100000.0;\n  /**\n   * The default amount to rotate the camera when an argument is not\n   * provided to the look methods.\n   * @type {Number}\n   * @default Math.PI / 60.0\n   */\n  this.defaultLookAmount = Math.PI / 60.0;\n  /**\n   * The default amount to rotate the camera when an argument is not\n   * provided to the rotate methods.\n   * @type {Number}\n   * @default Math.PI / 3600.0\n   */\n  this.defaultRotateAmount = Math.PI / 3600.0;\n  /**\n   * The default amount to move the camera when an argument is not\n   * provided to the zoom methods.\n   * @type {Number}\n   * @default 100000.0;\n   */\n  this.defaultZoomAmount = 100000.0;\n  /**\n   * If set, the camera will not be able to rotate past this axis in either direction.\n   * @type {Cartesian3}\n   * @default undefined\n   */\n  this.constrainedAxis = undefined;\n  /**\n   * The factor multiplied by the the map size used to determine where to clamp the camera position\n   * when zooming out from the surface. The default is 1.5. Only valid for 2D and the map is rotatable.\n   * @type {Number}\n   * @default 1.5\n   */\n  this.maximumZoomFactor = 1.5;\n\n  this._moveStart = new Event();\n  this._moveEnd = new Event();\n\n  this._changed = new Event();\n  this._changedPosition = undefined;\n  this._changedDirection = undefined;\n  this._changedFrustum = undefined;\n\n  /**\n   * The amount the camera has to change before the <code>changed</code> event is raised. The value is a percentage in the [0, 1] range.\n   * @type {number}\n   * @default 0.5\n   */\n  this.percentageChanged = 0.5;\n\n  this._viewMatrix = new Matrix4();\n  this._invViewMatrix = new Matrix4();\n  updateViewMatrix(this);\n\n  this._mode = SceneMode.SCENE3D;\n  this._modeChanged = true;\n  var projection = scene.mapProjection;\n  this._projection = projection;\n  this._maxCoord = projection.project(\n    new Cartographic(Math.PI, CesiumMath.PI_OVER_TWO)\n  );\n  this._max2Dfrustum = undefined;\n\n  // set default view\n  rectangleCameraPosition3D(\n    this,\n    Camera.DEFAULT_VIEW_RECTANGLE,\n    this.position,\n    true\n  );\n\n  var mag = Cartesian3.magnitude(this.position);\n  mag += mag * Camera.DEFAULT_VIEW_FACTOR;\n  Cartesian3.normalize(this.position, this.position);\n  Cartesian3.multiplyByScalar(this.position, mag, this.position);\n}\n\n/**\n * @private\n */\nCamera.TRANSFORM_2D = new Matrix4(\n  0.0,\n  0.0,\n  1.0,\n  0.0,\n  1.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  1.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  0.0,\n  1.0\n);\n\n/**\n * @private\n */\nCamera.TRANSFORM_2D_INVERSE = Matrix4.inverseTransformation(\n  Camera.TRANSFORM_2D,\n  new Matrix4()\n);\n\n/**\n * The default rectangle the camera will view on creation.\n * @type Rectangle\n */\nCamera.DEFAULT_VIEW_RECTANGLE = Rectangle.fromDegrees(\n  -95.0,\n  -20.0,\n  -70.0,\n  90.0\n);\n\n/**\n * A scalar to multiply to the camera position and add it back after setting the camera to view the rectangle.\n * A value of zero means the camera will view the entire {@link Camera#DEFAULT_VIEW_RECTANGLE}, a value greater than zero\n * will move it further away from the extent, and a value less than zero will move it close to the extent.\n * @type Number\n */\nCamera.DEFAULT_VIEW_FACTOR = 0.5;\n\n/**\n * The default heading/pitch/range that is used when the camera flies to a location that contains a bounding sphere.\n * @type HeadingPitchRange\n */\nCamera.DEFAULT_OFFSET = new HeadingPitchRange(\n  0.0,\n  -CesiumMath.PI_OVER_FOUR,\n  0.0\n);\n\nfunction updateViewMatrix(camera) {\n  Matrix4.computeView(\n    camera._position,\n    camera._direction,\n    camera._up,\n    camera._right,\n    camera._viewMatrix\n  );\n  Matrix4.multiply(\n    camera._viewMatrix,\n    camera._actualInvTransform,\n    camera._viewMatrix\n  );\n  Matrix4.inverseTransformation(camera._viewMatrix, camera._invViewMatrix);\n}\n\nfunction updateCameraDeltas(camera) {\n  if (!defined(camera._oldPositionWC)) {\n    camera._oldPositionWC = Cartesian3.clone(\n      camera.positionWC,\n      camera._oldPositionWC\n    );\n  } else {\n    camera.positionWCDeltaMagnitudeLastFrame = camera.positionWCDeltaMagnitude;\n    var delta = Cartesian3.subtract(\n      camera.positionWC,\n      camera._oldPositionWC,\n      camera._oldPositionWC\n    );\n    camera.positionWCDeltaMagnitude = Cartesian3.magnitude(delta);\n    camera._oldPositionWC = Cartesian3.clone(\n      camera.positionWC,\n      camera._oldPositionWC\n    );\n\n    // Update move timers\n    if (camera.positionWCDeltaMagnitude > 0.0) {\n      camera.timeSinceMoved = 0.0;\n      camera._lastMovedTimestamp = getTimestamp();\n    } else {\n      camera.timeSinceMoved =\n        Math.max(getTimestamp() - camera._lastMovedTimestamp, 0.0) / 1000.0;\n    }\n  }\n}\n\n/**\n * Checks if there's a camera flight with preload for this camera.\n *\n * @returns {Boolean} Whether or not this camera has a current flight with a valid preloadFlightCamera in scene.\n *\n * @private\n *\n */\nCamera.prototype.canPreloadFlight = function () {\n  return defined(this._currentFlight) && this._mode !== SceneMode.SCENE2D;\n};\n\nCamera.prototype._updateCameraChanged = function () {\n  var camera = this;\n\n  updateCameraDeltas(camera);\n\n  if (camera._changed.numberOfListeners === 0) {\n    return;\n  }\n\n  var percentageChanged = camera.percentageChanged;\n\n  if (camera._mode === SceneMode.SCENE2D) {\n    if (!defined(camera._changedFrustum)) {\n      camera._changedPosition = Cartesian3.clone(\n        camera.position,\n        camera._changedPosition\n      );\n      camera._changedFrustum = camera.frustum.clone();\n      return;\n    }\n\n    var position = camera.position;\n    var lastPosition = camera._changedPosition;\n\n    var frustum = camera.frustum;\n    var lastFrustum = camera._changedFrustum;\n\n    var x0 = position.x + frustum.left;\n    var x1 = position.x + frustum.right;\n    var x2 = lastPosition.x + lastFrustum.left;\n    var x3 = lastPosition.x + lastFrustum.right;\n\n    var y0 = position.y + frustum.bottom;\n    var y1 = position.y + frustum.top;\n    var y2 = lastPosition.y + lastFrustum.bottom;\n    var y3 = lastPosition.y + lastFrustum.top;\n\n    var leftX = Math.max(x0, x2);\n    var rightX = Math.min(x1, x3);\n    var bottomY = Math.max(y0, y2);\n    var topY = Math.min(y1, y3);\n\n    var areaPercentage;\n    if (leftX >= rightX || bottomY >= y1) {\n      areaPercentage = 1.0;\n    } else {\n      var areaRef = lastFrustum;\n      if (x0 < x2 && x1 > x3 && y0 < y2 && y1 > y3) {\n        areaRef = frustum;\n      }\n      areaPercentage =\n        1.0 -\n        ((rightX - leftX) * (topY - bottomY)) /\n          ((areaRef.right - areaRef.left) * (areaRef.top - areaRef.bottom));\n    }\n\n    if (areaPercentage > percentageChanged) {\n      camera._changed.raiseEvent(areaPercentage);\n      camera._changedPosition = Cartesian3.clone(\n        camera.position,\n        camera._changedPosition\n      );\n      camera._changedFrustum = camera.frustum.clone(camera._changedFrustum);\n    }\n    return;\n  }\n\n  if (!defined(camera._changedDirection)) {\n    camera._changedPosition = Cartesian3.clone(\n      camera.positionWC,\n      camera._changedPosition\n    );\n    camera._changedDirection = Cartesian3.clone(\n      camera.directionWC,\n      camera._changedDirection\n    );\n    return;\n  }\n\n  var dirAngle = CesiumMath.acosClamped(\n    Cartesian3.dot(camera.directionWC, camera._changedDirection)\n  );\n\n  var dirPercentage;\n  if (defined(camera.frustum.fovy)) {\n    dirPercentage = dirAngle / (camera.frustum.fovy * 0.5);\n  } else {\n    dirPercentage = dirAngle;\n  }\n\n  var distance = Cartesian3.distance(\n    camera.positionWC,\n    camera._changedPosition\n  );\n  var heightPercentage = distance / camera.positionCartographic.height;\n\n  if (\n    dirPercentage > percentageChanged ||\n    heightPercentage > percentageChanged\n  ) {\n    camera._changed.raiseEvent(Math.max(dirPercentage, heightPercentage));\n    camera._changedPosition = Cartesian3.clone(\n      camera.positionWC,\n      camera._changedPosition\n    );\n    camera._changedDirection = Cartesian3.clone(\n      camera.directionWC,\n      camera._changedDirection\n    );\n  }\n};\n\nfunction convertTransformForColumbusView(camera) {\n  Transforms.basisTo2D(\n    camera._projection,\n    camera._transform,\n    camera._actualTransform\n  );\n}\n\nvar scratchCartographic = new Cartographic();\nvar scratchCartesian3Projection = new Cartesian3();\nvar scratchCartesian3 = new Cartesian3();\nvar scratchCartesian4Origin = new Cartesian4();\nvar scratchCartesian4NewOrigin = new Cartesian4();\nvar scratchCartesian4NewXAxis = new Cartesian4();\nvar scratchCartesian4NewYAxis = new Cartesian4();\nvar scratchCartesian4NewZAxis = new Cartesian4();\n\nfunction convertTransformFor2D(camera) {\n  var projection = camera._projection;\n  var ellipsoid = projection.ellipsoid;\n\n  var origin = Matrix4.getColumn(camera._transform, 3, scratchCartesian4Origin);\n  var cartographic = ellipsoid.cartesianToCartographic(\n    origin,\n    scratchCartographic\n  );\n\n  var projectedPosition = projection.project(\n    cartographic,\n    scratchCartesian3Projection\n  );\n  var newOrigin = scratchCartesian4NewOrigin;\n  newOrigin.x = projectedPosition.z;\n  newOrigin.y = projectedPosition.x;\n  newOrigin.z = projectedPosition.y;\n  newOrigin.w = 1.0;\n\n  var newZAxis = Cartesian4.clone(Cartesian4.UNIT_X, scratchCartesian4NewZAxis);\n\n  var xAxis = Cartesian4.add(\n    Matrix4.getColumn(camera._transform, 0, scratchCartesian3),\n    origin,\n    scratchCartesian3\n  );\n  ellipsoid.cartesianToCartographic(xAxis, cartographic);\n\n  projection.project(cartographic, projectedPosition);\n  var newXAxis = scratchCartesian4NewXAxis;\n  newXAxis.x = projectedPosition.z;\n  newXAxis.y = projectedPosition.x;\n  newXAxis.z = projectedPosition.y;\n  newXAxis.w = 0.0;\n\n  Cartesian3.subtract(newXAxis, newOrigin, newXAxis);\n  newXAxis.x = 0.0;\n\n  var newYAxis = scratchCartesian4NewYAxis;\n  if (Cartesian3.magnitudeSquared(newXAxis) > CesiumMath.EPSILON10) {\n    Cartesian3.cross(newZAxis, newXAxis, newYAxis);\n  } else {\n    var yAxis = Cartesian4.add(\n      Matrix4.getColumn(camera._transform, 1, scratchCartesian3),\n      origin,\n      scratchCartesian3\n    );\n    ellipsoid.cartesianToCartographic(yAxis, cartographic);\n\n    projection.project(cartographic, projectedPosition);\n    newYAxis.x = projectedPosition.z;\n    newYAxis.y = projectedPosition.x;\n    newYAxis.z = projectedPosition.y;\n    newYAxis.w = 0.0;\n\n    Cartesian3.subtract(newYAxis, newOrigin, newYAxis);\n    newYAxis.x = 0.0;\n\n    if (Cartesian3.magnitudeSquared(newYAxis) < CesiumMath.EPSILON10) {\n      Cartesian4.clone(Cartesian4.UNIT_Y, newXAxis);\n      Cartesian4.clone(Cartesian4.UNIT_Z, newYAxis);\n    }\n  }\n\n  Cartesian3.cross(newYAxis, newZAxis, newXAxis);\n  Cartesian3.normalize(newXAxis, newXAxis);\n  Cartesian3.cross(newZAxis, newXAxis, newYAxis);\n  Cartesian3.normalize(newYAxis, newYAxis);\n\n  Matrix4.setColumn(\n    camera._actualTransform,\n    0,\n    newXAxis,\n    camera._actualTransform\n  );\n  Matrix4.setColumn(\n    camera._actualTransform,\n    1,\n    newYAxis,\n    camera._actualTransform\n  );\n  Matrix4.setColumn(\n    camera._actualTransform,\n    2,\n    newZAxis,\n    camera._actualTransform\n  );\n  Matrix4.setColumn(\n    camera._actualTransform,\n    3,\n    newOrigin,\n    camera._actualTransform\n  );\n}\n\nvar scratchCartesian = new Cartesian3();\n\nfunction updateMembers(camera) {\n  var mode = camera._mode;\n\n  var heightChanged = false;\n  var height = 0.0;\n  if (mode === SceneMode.SCENE2D) {\n    height = camera.frustum.right - camera.frustum.left;\n    heightChanged = height !== camera._positionCartographic.height;\n  }\n\n  var position = camera._position;\n  var positionChanged =\n    !Cartesian3.equals(position, camera.position) || heightChanged;\n  if (positionChanged) {\n    position = Cartesian3.clone(camera.position, camera._position);\n  }\n\n  var direction = camera._direction;\n  var directionChanged = !Cartesian3.equals(direction, camera.direction);\n  if (directionChanged) {\n    Cartesian3.normalize(camera.direction, camera.direction);\n    direction = Cartesian3.clone(camera.direction, camera._direction);\n  }\n\n  var up = camera._up;\n  var upChanged = !Cartesian3.equals(up, camera.up);\n  if (upChanged) {\n    Cartesian3.normalize(camera.up, camera.up);\n    up = Cartesian3.clone(camera.up, camera._up);\n  }\n\n  var right = camera._right;\n  var rightChanged = !Cartesian3.equals(right, camera.right);\n  if (rightChanged) {\n    Cartesian3.normalize(camera.right, camera.right);\n    right = Cartesian3.clone(camera.right, camera._right);\n  }\n\n  var transformChanged = camera._transformChanged || camera._modeChanged;\n  camera._transformChanged = false;\n\n  if (transformChanged) {\n    Matrix4.inverseTransformation(camera._transform, camera._invTransform);\n\n    if (\n      camera._mode === SceneMode.COLUMBUS_VIEW ||\n      camera._mode === SceneMode.SCENE2D\n    ) {\n      if (Matrix4.equals(Matrix4.IDENTITY, camera._transform)) {\n        Matrix4.clone(Camera.TRANSFORM_2D, camera._actualTransform);\n      } else if (camera._mode === SceneMode.COLUMBUS_VIEW) {\n        convertTransformForColumbusView(camera);\n      } else {\n        convertTransformFor2D(camera);\n      }\n    } else {\n      Matrix4.clone(camera._transform, camera._actualTransform);\n    }\n\n    Matrix4.inverseTransformation(\n      camera._actualTransform,\n      camera._actualInvTransform\n    );\n\n    camera._modeChanged = false;\n  }\n\n  var transform = camera._actualTransform;\n\n  if (positionChanged || transformChanged) {\n    camera._positionWC = Matrix4.multiplyByPoint(\n      transform,\n      position,\n      camera._positionWC\n    );\n\n    // Compute the Cartographic position of the camera.\n    if (mode === SceneMode.SCENE3D || mode === SceneMode.MORPHING) {\n      camera._positionCartographic = camera._projection.ellipsoid.cartesianToCartographic(\n        camera._positionWC,\n        camera._positionCartographic\n      );\n    } else {\n      // The camera position is expressed in the 2D coordinate system where the Y axis is to the East,\n      // the Z axis is to the North, and the X axis is out of the map.  Express them instead in the ENU axes where\n      // X is to the East, Y is to the North, and Z is out of the local horizontal plane.\n      var positionENU = scratchCartesian;\n      positionENU.x = camera._positionWC.y;\n      positionENU.y = camera._positionWC.z;\n      positionENU.z = camera._positionWC.x;\n\n      // In 2D, the camera height is always 12.7 million meters.\n      // The apparent height is equal to half the frustum width.\n      if (mode === SceneMode.SCENE2D) {\n        positionENU.z = height;\n      }\n\n      camera._projection.unproject(positionENU, camera._positionCartographic);\n    }\n  }\n\n  if (directionChanged || upChanged || rightChanged) {\n    var det = Cartesian3.dot(\n      direction,\n      Cartesian3.cross(up, right, scratchCartesian)\n    );\n    if (Math.abs(1.0 - det) > CesiumMath.EPSILON2) {\n      //orthonormalize axes\n      var invUpMag = 1.0 / Cartesian3.magnitudeSquared(up);\n      var scalar = Cartesian3.dot(up, direction) * invUpMag;\n      var w0 = Cartesian3.multiplyByScalar(direction, scalar, scratchCartesian);\n      up = Cartesian3.normalize(\n        Cartesian3.subtract(up, w0, camera._up),\n        camera._up\n      );\n      Cartesian3.clone(up, camera.up);\n\n      right = Cartesian3.cross(direction, up, camera._right);\n      Cartesian3.clone(right, camera.right);\n    }\n  }\n\n  if (directionChanged || transformChanged) {\n    camera._directionWC = Matrix4.multiplyByPointAsVector(\n      transform,\n      direction,\n      camera._directionWC\n    );\n    Cartesian3.normalize(camera._directionWC, camera._directionWC);\n  }\n\n  if (upChanged || transformChanged) {\n    camera._upWC = Matrix4.multiplyByPointAsVector(transform, up, camera._upWC);\n    Cartesian3.normalize(camera._upWC, camera._upWC);\n  }\n\n  if (rightChanged || transformChanged) {\n    camera._rightWC = Matrix4.multiplyByPointAsVector(\n      transform,\n      right,\n      camera._rightWC\n    );\n    Cartesian3.normalize(camera._rightWC, camera._rightWC);\n  }\n\n  if (\n    positionChanged ||\n    directionChanged ||\n    upChanged ||\n    rightChanged ||\n    transformChanged\n  ) {\n    updateViewMatrix(camera);\n  }\n}\n\nfunction getHeading(direction, up) {\n  var heading;\n  if (\n    !CesiumMath.equalsEpsilon(Math.abs(direction.z), 1.0, CesiumMath.EPSILON3)\n  ) {\n    heading = Math.atan2(direction.y, direction.x) - CesiumMath.PI_OVER_TWO;\n  } else {\n    heading = Math.atan2(up.y, up.x) - CesiumMath.PI_OVER_TWO;\n  }\n\n  return CesiumMath.TWO_PI - CesiumMath.zeroToTwoPi(heading);\n}\n\nfunction getPitch(direction) {\n  return CesiumMath.PI_OVER_TWO - CesiumMath.acosClamped(direction.z);\n}\n\nfunction getRoll(direction, up, right) {\n  var roll = 0.0;\n  if (\n    !CesiumMath.equalsEpsilon(Math.abs(direction.z), 1.0, CesiumMath.EPSILON3)\n  ) {\n    roll = Math.atan2(-right.z, up.z);\n    roll = CesiumMath.zeroToTwoPi(roll + CesiumMath.TWO_PI);\n  }\n\n  return roll;\n}\n\nvar scratchHPRMatrix1 = new Matrix4();\nvar scratchHPRMatrix2 = new Matrix4();\n\nObject.defineProperties(Camera.prototype, {\n  /**\n   * Gets the camera's reference frame. The inverse of this transformation is appended to the view matrix.\n   * @memberof Camera.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @default {@link Matrix4.IDENTITY}\n   */\n  transform: {\n    get: function () {\n      return this._transform;\n    },\n  },\n\n  /**\n   * Gets the inverse camera transform.\n   * @memberof Camera.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @default {@link Matrix4.IDENTITY}\n   */\n  inverseTransform: {\n    get: function () {\n      updateMembers(this);\n      return this._invTransform;\n    },\n  },\n\n  /**\n   * Gets the view matrix.\n   * @memberof Camera.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see Camera#inverseViewMatrix\n   */\n  viewMatrix: {\n    get: function () {\n      updateMembers(this);\n      return this._viewMatrix;\n    },\n  },\n\n  /**\n   * Gets the inverse view matrix.\n   * @memberof Camera.prototype\n   *\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see Camera#viewMatrix\n   */\n  inverseViewMatrix: {\n    get: function () {\n      updateMembers(this);\n      return this._invViewMatrix;\n    },\n  },\n\n  /**\n   * Gets the {@link Cartographic} position of the camera, with longitude and latitude\n   * expressed in radians and height in meters.  In 2D and Columbus View, it is possible\n   * for the returned longitude and latitude to be outside the range of valid longitudes\n   * and latitudes when the camera is outside the map.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartographic}\n   * @readonly\n   */\n  positionCartographic: {\n    get: function () {\n      updateMembers(this);\n      return this._positionCartographic;\n    },\n  },\n\n  /**\n   * Gets the position of the camera in world coordinates.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  positionWC: {\n    get: function () {\n      updateMembers(this);\n      return this._positionWC;\n    },\n  },\n\n  /**\n   * Gets the view direction of the camera in world coordinates.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  directionWC: {\n    get: function () {\n      updateMembers(this);\n      return this._directionWC;\n    },\n  },\n\n  /**\n   * Gets the up direction of the camera in world coordinates.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  upWC: {\n    get: function () {\n      updateMembers(this);\n      return this._upWC;\n    },\n  },\n\n  /**\n   * Gets the right direction of the camera in world coordinates.\n   * @memberof Camera.prototype\n   *\n   * @type {Cartesian3}\n   * @readonly\n   */\n  rightWC: {\n    get: function () {\n      updateMembers(this);\n      return this._rightWC;\n    },\n  },\n\n  /**\n   * Gets the camera heading in radians.\n   * @memberof Camera.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  heading: {\n    get: function () {\n      if (this._mode !== SceneMode.MORPHING) {\n        var ellipsoid = this._projection.ellipsoid;\n\n        var oldTransform = Matrix4.clone(this._transform, scratchHPRMatrix1);\n        var transform = Transforms.eastNorthUpToFixedFrame(\n          this.positionWC,\n          ellipsoid,\n          scratchHPRMatrix2\n        );\n        this._setTransform(transform);\n\n        var heading = getHeading(this.direction, this.up);\n\n        this._setTransform(oldTransform);\n\n        return heading;\n      }\n\n      return undefined;\n    },\n  },\n\n  /**\n   * Gets the camera pitch in radians.\n   * @memberof Camera.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  pitch: {\n    get: function () {\n      if (this._mode !== SceneMode.MORPHING) {\n        var ellipsoid = this._projection.ellipsoid;\n\n        var oldTransform = Matrix4.clone(this._transform, scratchHPRMatrix1);\n        var transform = Transforms.eastNorthUpToFixedFrame(\n          this.positionWC,\n          ellipsoid,\n          scratchHPRMatrix2\n        );\n        this._setTransform(transform);\n\n        var pitch = getPitch(this.direction);\n\n        this._setTransform(oldTransform);\n\n        return pitch;\n      }\n\n      return undefined;\n    },\n  },\n\n  /**\n   * Gets the camera roll in radians.\n   * @memberof Camera.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  roll: {\n    get: function () {\n      if (this._mode !== SceneMode.MORPHING) {\n        var ellipsoid = this._projection.ellipsoid;\n\n        var oldTransform = Matrix4.clone(this._transform, scratchHPRMatrix1);\n        var transform = Transforms.eastNorthUpToFixedFrame(\n          this.positionWC,\n          ellipsoid,\n          scratchHPRMatrix2\n        );\n        this._setTransform(transform);\n\n        var roll = getRoll(this.direction, this.up, this.right);\n\n        this._setTransform(oldTransform);\n\n        return roll;\n      }\n\n      return undefined;\n    },\n  },\n\n  /**\n   * Gets the event that will be raised at when the camera starts to move.\n   * @memberof Camera.prototype\n   * @type {Event}\n   * @readonly\n   */\n  moveStart: {\n    get: function () {\n      return this._moveStart;\n    },\n  },\n\n  /**\n   * Gets the event that will be raised when the camera has stopped moving.\n   * @memberof Camera.prototype\n   * @type {Event}\n   * @readonly\n   */\n  moveEnd: {\n    get: function () {\n      return this._moveEnd;\n    },\n  },\n\n  /**\n   * Gets the event that will be raised when the camera has changed by <code>percentageChanged</code>.\n   * @memberof Camera.prototype\n   * @type {Event}\n   * @readonly\n   */\n  changed: {\n    get: function () {\n      return this._changed;\n    },\n  },\n});\n\n/**\n * @private\n */\nCamera.prototype.update = function (mode) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(mode)) {\n    throw new DeveloperError(\"mode is required.\");\n  }\n  if (\n    mode === SceneMode.SCENE2D &&\n    !(this.frustum instanceof OrthographicOffCenterFrustum)\n  ) {\n    throw new DeveloperError(\n      \"An OrthographicOffCenterFrustum is required in 2D.\"\n    );\n  }\n  if (\n    (mode === SceneMode.SCENE3D || mode === SceneMode.COLUMBUS_VIEW) &&\n    !(this.frustum instanceof PerspectiveFrustum) &&\n    !(this.frustum instanceof OrthographicFrustum)\n  ) {\n    throw new DeveloperError(\n      \"A PerspectiveFrustum or OrthographicFrustum is required in 3D and Columbus view\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var updateFrustum = false;\n  if (mode !== this._mode) {\n    this._mode = mode;\n    this._modeChanged = mode !== SceneMode.MORPHING;\n    updateFrustum = this._mode === SceneMode.SCENE2D;\n  }\n\n  if (updateFrustum) {\n    var frustum = (this._max2Dfrustum = this.frustum.clone());\n\n    //>>includeStart('debug', pragmas.debug);\n    if (!(frustum instanceof OrthographicOffCenterFrustum)) {\n      throw new DeveloperError(\n        \"The camera frustum is expected to be orthographic for 2D camera control.\"\n      );\n    }\n    //>>includeEnd('debug');\n\n    var maxZoomOut = 2.0;\n    var ratio = frustum.top / frustum.right;\n    frustum.right = this._maxCoord.x * maxZoomOut;\n    frustum.left = -frustum.right;\n    frustum.top = ratio * frustum.right;\n    frustum.bottom = -frustum.top;\n  }\n\n  if (this._mode === SceneMode.SCENE2D) {\n    clampMove2D(this, this.position);\n  }\n};\n\nvar setTransformPosition = new Cartesian3();\nvar setTransformUp = new Cartesian3();\nvar setTransformDirection = new Cartesian3();\n\nCamera.prototype._setTransform = function (transform) {\n  var position = Cartesian3.clone(this.positionWC, setTransformPosition);\n  var up = Cartesian3.clone(this.upWC, setTransformUp);\n  var direction = Cartesian3.clone(this.directionWC, setTransformDirection);\n\n  Matrix4.clone(transform, this._transform);\n  this._transformChanged = true;\n  updateMembers(this);\n  var inverse = this._actualInvTransform;\n\n  Matrix4.multiplyByPoint(inverse, position, this.position);\n  Matrix4.multiplyByPointAsVector(inverse, direction, this.direction);\n  Matrix4.multiplyByPointAsVector(inverse, up, this.up);\n  Cartesian3.cross(this.direction, this.up, this.right);\n\n  updateMembers(this);\n};\n\nvar scratchAdjustOrthographicFrustumMousePosition = new Cartesian2();\nvar scratchPickRay = new Ray();\nvar scratchRayIntersection = new Cartesian3();\nvar scratchDepthIntersection = new Cartesian3();\n\nfunction calculateOrthographicFrustumWidth(camera) {\n  // Camera is fixed to an object, so keep frustum width constant.\n  if (!Matrix4.equals(Matrix4.IDENTITY, camera.transform)) {\n    return Cartesian3.magnitude(camera.position);\n  }\n\n  var scene = camera._scene;\n  var globe = scene.globe;\n\n  var mousePosition = scratchAdjustOrthographicFrustumMousePosition;\n  mousePosition.x = scene.drawingBufferWidth / 2.0;\n  mousePosition.y = scene.drawingBufferHeight / 2.0;\n\n  var rayIntersection;\n  if (defined(globe)) {\n    var ray = camera.getPickRay(mousePosition, scratchPickRay);\n    rayIntersection = globe.pickWorldCoordinates(\n      ray,\n      scene,\n      true,\n      scratchRayIntersection\n    );\n  }\n\n  var depthIntersection;\n  if (scene.pickPositionSupported) {\n    depthIntersection = scene.pickPositionWorldCoordinates(\n      mousePosition,\n      scratchDepthIntersection\n    );\n  }\n\n  var distance;\n  if (defined(rayIntersection) || defined(depthIntersection)) {\n    var depthDistance = defined(depthIntersection)\n      ? Cartesian3.distance(depthIntersection, camera.positionWC)\n      : Number.POSITIVE_INFINITY;\n    var rayDistance = defined(rayIntersection)\n      ? Cartesian3.distance(rayIntersection, camera.positionWC)\n      : Number.POSITIVE_INFINITY;\n    distance = Math.min(depthDistance, rayDistance);\n  } else {\n    distance = Math.max(camera.positionCartographic.height, 0.0);\n  }\n  return distance;\n}\n\nCamera.prototype._adjustOrthographicFrustum = function (zooming) {\n  if (!(this.frustum instanceof OrthographicFrustum)) {\n    return;\n  }\n\n  if (!zooming && this._positionCartographic.height < 150000.0) {\n    return;\n  }\n\n  this.frustum.width = calculateOrthographicFrustumWidth(this);\n};\n\nvar scratchSetViewCartesian = new Cartesian3();\nvar scratchSetViewTransform1 = new Matrix4();\nvar scratchSetViewTransform2 = new Matrix4();\nvar scratchSetViewQuaternion = new Quaternion();\nvar scratchSetViewMatrix3 = new Matrix3();\nvar scratchSetViewCartographic = new Cartographic();\n\nfunction setView3D(camera, position, hpr) {\n  var currentTransform = Matrix4.clone(\n    camera.transform,\n    scratchSetViewTransform1\n  );\n  var localTransform = Transforms.eastNorthUpToFixedFrame(\n    position,\n    camera._projection.ellipsoid,\n    scratchSetViewTransform2\n  );\n  camera._setTransform(localTransform);\n\n  Cartesian3.clone(Cartesian3.ZERO, camera.position);\n  hpr.heading = hpr.heading - CesiumMath.PI_OVER_TWO;\n\n  var rotQuat = Quaternion.fromHeadingPitchRoll(hpr, scratchSetViewQuaternion);\n  var rotMat = Matrix3.fromQuaternion(rotQuat, scratchSetViewMatrix3);\n\n  Matrix3.getColumn(rotMat, 0, camera.direction);\n  Matrix3.getColumn(rotMat, 2, camera.up);\n  Cartesian3.cross(camera.direction, camera.up, camera.right);\n\n  camera._setTransform(currentTransform);\n\n  camera._adjustOrthographicFrustum(true);\n}\n\nfunction setViewCV(camera, position, hpr, convert) {\n  var currentTransform = Matrix4.clone(\n    camera.transform,\n    scratchSetViewTransform1\n  );\n  camera._setTransform(Matrix4.IDENTITY);\n\n  if (!Cartesian3.equals(position, camera.positionWC)) {\n    if (convert) {\n      var projection = camera._projection;\n      var cartographic = projection.ellipsoid.cartesianToCartographic(\n        position,\n        scratchSetViewCartographic\n      );\n      position = projection.project(cartographic, scratchSetViewCartesian);\n    }\n    Cartesian3.clone(position, camera.position);\n  }\n  hpr.heading = hpr.heading - CesiumMath.PI_OVER_TWO;\n\n  var rotQuat = Quaternion.fromHeadingPitchRoll(hpr, scratchSetViewQuaternion);\n  var rotMat = Matrix3.fromQuaternion(rotQuat, scratchSetViewMatrix3);\n\n  Matrix3.getColumn(rotMat, 0, camera.direction);\n  Matrix3.getColumn(rotMat, 2, camera.up);\n  Cartesian3.cross(camera.direction, camera.up, camera.right);\n\n  camera._setTransform(currentTransform);\n\n  camera._adjustOrthographicFrustum(true);\n}\n\nfunction setView2D(camera, position, hpr, convert) {\n  var currentTransform = Matrix4.clone(\n    camera.transform,\n    scratchSetViewTransform1\n  );\n  camera._setTransform(Matrix4.IDENTITY);\n\n  if (!Cartesian3.equals(position, camera.positionWC)) {\n    if (convert) {\n      var projection = camera._projection;\n      var cartographic = projection.ellipsoid.cartesianToCartographic(\n        position,\n        scratchSetViewCartographic\n      );\n      position = projection.project(cartographic, scratchSetViewCartesian);\n    }\n\n    Cartesian2.clone(position, camera.position);\n\n    var newLeft = -position.z * 0.5;\n    var newRight = -newLeft;\n\n    var frustum = camera.frustum;\n    if (newRight > newLeft) {\n      var ratio = frustum.top / frustum.right;\n      frustum.right = newRight;\n      frustum.left = newLeft;\n      frustum.top = frustum.right * ratio;\n      frustum.bottom = -frustum.top;\n    }\n  }\n\n  if (camera._scene.mapMode2D === MapMode2D.ROTATE) {\n    hpr.heading = hpr.heading - CesiumMath.PI_OVER_TWO;\n    hpr.pitch = -CesiumMath.PI_OVER_TWO;\n    hpr.roll = 0.0;\n    var rotQuat = Quaternion.fromHeadingPitchRoll(\n      hpr,\n      scratchSetViewQuaternion\n    );\n    var rotMat = Matrix3.fromQuaternion(rotQuat, scratchSetViewMatrix3);\n\n    Matrix3.getColumn(rotMat, 2, camera.up);\n    Cartesian3.cross(camera.direction, camera.up, camera.right);\n  }\n\n  camera._setTransform(currentTransform);\n}\n\nvar scratchToHPRDirection = new Cartesian3();\nvar scratchToHPRUp = new Cartesian3();\nvar scratchToHPRRight = new Cartesian3();\n\nfunction directionUpToHeadingPitchRoll(camera, position, orientation, result) {\n  var direction = Cartesian3.clone(\n    orientation.direction,\n    scratchToHPRDirection\n  );\n  var up = Cartesian3.clone(orientation.up, scratchToHPRUp);\n\n  if (camera._scene.mode === SceneMode.SCENE3D) {\n    var ellipsoid = camera._projection.ellipsoid;\n    var transform = Transforms.eastNorthUpToFixedFrame(\n      position,\n      ellipsoid,\n      scratchHPRMatrix1\n    );\n    var invTransform = Matrix4.inverseTransformation(\n      transform,\n      scratchHPRMatrix2\n    );\n\n    Matrix4.multiplyByPointAsVector(invTransform, direction, direction);\n    Matrix4.multiplyByPointAsVector(invTransform, up, up);\n  }\n\n  var right = Cartesian3.cross(direction, up, scratchToHPRRight);\n\n  result.heading = getHeading(direction, up);\n  result.pitch = getPitch(direction);\n  result.roll = getRoll(direction, up, right);\n\n  return result;\n}\n\nvar scratchSetViewOptions = {\n  destination: undefined,\n  orientation: {\n    direction: undefined,\n    up: undefined,\n    heading: undefined,\n    pitch: undefined,\n    roll: undefined,\n  },\n  convert: undefined,\n  endTransform: undefined,\n};\n\nvar scratchHpr = new HeadingPitchRoll();\n/**\n * Sets the camera position, orientation and transform.\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3|Rectangle} [options.destination] The final position of the camera in WGS84 (world) coordinates or a rectangle that would be visible from a top-down view.\n * @param {Object} [options.orientation] An object that contains either direction and up properties or heading, pitch and roll properties. By default, the direction will point\n * towards the center of the frame in 3D and in the negative z direction in Columbus view. The up direction will point towards local north in 3D and in the positive\n * y direction in Columbus view. Orientation is not used in 2D when in infinite scrolling mode.\n * @param {Matrix4} [options.endTransform] Transform matrix representing the reference frame of the camera.\n * @param {Boolean} [options.convert] Whether to convert the destination from world coordinates to scene coordinates (only relevant when not using 3D). Defaults to <code>true</code>.\n *\n * @example\n * // 1. Set position with a top-down view\n * viewer.camera.setView({\n *     destination : Cesium.Cartesian3.fromDegrees(-117.16, 32.71, 15000.0)\n * });\n *\n * // 2 Set view with heading, pitch and roll\n * viewer.camera.setView({\n *     destination : cartesianPosition,\n *     orientation: {\n *         heading : Cesium.Math.toRadians(90.0), // east, default value is 0.0 (north)\n *         pitch : Cesium.Math.toRadians(-90),    // default value (looking down)\n *         roll : 0.0                             // default value\n *     }\n * });\n *\n * // 3. Change heading, pitch and roll with the camera position remaining the same.\n * viewer.camera.setView({\n *     orientation: {\n *         heading : Cesium.Math.toRadians(90.0), // east, default value is 0.0 (north)\n *         pitch : Cesium.Math.toRadians(-90),    // default value (looking down)\n *         roll : 0.0                             // default value\n *     }\n * });\n *\n *\n * // 4. View rectangle with a top-down view\n * viewer.camera.setView({\n *     destination : Cesium.Rectangle.fromDegrees(west, south, east, north)\n * });\n *\n * // 5. Set position with an orientation using unit vectors.\n * viewer.camera.setView({\n *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),\n *     orientation : {\n *         direction : new Cesium.Cartesian3(-0.04231243104240401, -0.20123236049443421, -0.97862924300734),\n *         up : new Cesium.Cartesian3(-0.47934589305293746, -0.8553216253114552, 0.1966022179118339)\n *     }\n * });\n */\nCamera.prototype.setView = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var orientation = defaultValue(\n    options.orientation,\n    defaultValue.EMPTY_OBJECT\n  );\n\n  var mode = this._mode;\n  if (mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  if (defined(options.endTransform)) {\n    this._setTransform(options.endTransform);\n  }\n\n  var convert = defaultValue(options.convert, true);\n  var destination = defaultValue(\n    options.destination,\n    Cartesian3.clone(this.positionWC, scratchSetViewCartesian)\n  );\n  if (defined(destination) && defined(destination.west)) {\n    destination = this.getRectangleCameraCoordinates(\n      destination,\n      scratchSetViewCartesian\n    );\n    convert = false;\n  }\n\n  if (defined(orientation.direction)) {\n    orientation = directionUpToHeadingPitchRoll(\n      this,\n      destination,\n      orientation,\n      scratchSetViewOptions.orientation\n    );\n  }\n\n  scratchHpr.heading = defaultValue(orientation.heading, 0.0);\n  scratchHpr.pitch = defaultValue(orientation.pitch, -CesiumMath.PI_OVER_TWO);\n  scratchHpr.roll = defaultValue(orientation.roll, 0.0);\n\n  if (mode === SceneMode.SCENE3D) {\n    setView3D(this, destination, scratchHpr);\n  } else if (mode === SceneMode.SCENE2D) {\n    setView2D(this, destination, scratchHpr, convert);\n  } else {\n    setViewCV(this, destination, scratchHpr, convert);\n  }\n};\n\nvar pitchScratch = new Cartesian3();\n/**\n * Fly the camera to the home view.  Use {@link Camera#.DEFAULT_VIEW_RECTANGLE} to set\n * the default view for the 3D scene.  The home view for 2D and columbus view shows the\n * entire map.\n *\n * @param {Number} [duration] The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight. See {@link Camera#flyTo}\n */\nCamera.prototype.flyHome = function (duration) {\n  var mode = this._mode;\n\n  if (mode === SceneMode.MORPHING) {\n    this._scene.completeMorph();\n  }\n\n  if (mode === SceneMode.SCENE2D) {\n    this.flyTo({\n      destination: Camera.DEFAULT_VIEW_RECTANGLE,\n      duration: duration,\n      endTransform: Matrix4.IDENTITY,\n    });\n  } else if (mode === SceneMode.SCENE3D) {\n    var destination = this.getRectangleCameraCoordinates(\n      Camera.DEFAULT_VIEW_RECTANGLE\n    );\n\n    var mag = Cartesian3.magnitude(destination);\n    mag += mag * Camera.DEFAULT_VIEW_FACTOR;\n    Cartesian3.normalize(destination, destination);\n    Cartesian3.multiplyByScalar(destination, mag, destination);\n\n    this.flyTo({\n      destination: destination,\n      duration: duration,\n      endTransform: Matrix4.IDENTITY,\n    });\n  } else if (mode === SceneMode.COLUMBUS_VIEW) {\n    var maxRadii = this._projection.ellipsoid.maximumRadius;\n    var position = new Cartesian3(0.0, -1.0, 1.0);\n    position = Cartesian3.multiplyByScalar(\n      Cartesian3.normalize(position, position),\n      5.0 * maxRadii,\n      position\n    );\n    this.flyTo({\n      destination: position,\n      duration: duration,\n      orientation: {\n        heading: 0.0,\n        pitch: -Math.acos(Cartesian3.normalize(position, pitchScratch).z),\n        roll: 0.0,\n      },\n      endTransform: Matrix4.IDENTITY,\n      convert: false,\n    });\n  }\n};\n\n/**\n * Transform a vector or point from world coordinates to the camera's reference frame.\n *\n * @param {Cartesian4} cartesian The vector or point to transform.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The transformed vector or point.\n */\nCamera.prototype.worldToCameraCoordinates = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian4();\n  }\n  updateMembers(this);\n  return Matrix4.multiplyByVector(this._actualInvTransform, cartesian, result);\n};\n\n/**\n * Transform a point from world coordinates to the camera's reference frame.\n *\n * @param {Cartesian3} cartesian The point to transform.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The transformed point.\n */\nCamera.prototype.worldToCameraCoordinatesPoint = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  updateMembers(this);\n  return Matrix4.multiplyByPoint(this._actualInvTransform, cartesian, result);\n};\n\n/**\n * Transform a vector from world coordinates to the camera's reference frame.\n *\n * @param {Cartesian3} cartesian The vector to transform.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The transformed vector.\n */\nCamera.prototype.worldToCameraCoordinatesVector = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  updateMembers(this);\n  return Matrix4.multiplyByPointAsVector(\n    this._actualInvTransform,\n    cartesian,\n    result\n  );\n};\n\n/**\n * Transform a vector or point from the camera's reference frame to world coordinates.\n *\n * @param {Cartesian4} cartesian The vector or point to transform.\n * @param {Cartesian4} [result] The object onto which to store the result.\n * @returns {Cartesian4} The transformed vector or point.\n */\nCamera.prototype.cameraToWorldCoordinates = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian4();\n  }\n  updateMembers(this);\n  return Matrix4.multiplyByVector(this._actualTransform, cartesian, result);\n};\n\n/**\n * Transform a point from the camera's reference frame to world coordinates.\n *\n * @param {Cartesian3} cartesian The point to transform.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The transformed point.\n */\nCamera.prototype.cameraToWorldCoordinatesPoint = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  updateMembers(this);\n  return Matrix4.multiplyByPoint(this._actualTransform, cartesian, result);\n};\n\n/**\n * Transform a vector from the camera's reference frame to world coordinates.\n *\n * @param {Cartesian3} cartesian The vector to transform.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The transformed vector.\n */\nCamera.prototype.cameraToWorldCoordinatesVector = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(cartesian)) {\n    throw new DeveloperError(\"cartesian is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  updateMembers(this);\n  return Matrix4.multiplyByPointAsVector(\n    this._actualTransform,\n    cartesian,\n    result\n  );\n};\n\nfunction clampMove2D(camera, position) {\n  var rotatable2D = camera._scene.mapMode2D === MapMode2D.ROTATE;\n  var maxProjectedX = camera._maxCoord.x;\n  var maxProjectedY = camera._maxCoord.y;\n\n  var minX;\n  var maxX;\n  if (rotatable2D) {\n    maxX = maxProjectedX;\n    minX = -maxX;\n  } else {\n    maxX = position.x - maxProjectedX * 2.0;\n    minX = position.x + maxProjectedX * 2.0;\n  }\n\n  if (position.x > maxProjectedX) {\n    position.x = maxX;\n  }\n  if (position.x < -maxProjectedX) {\n    position.x = minX;\n  }\n\n  if (position.y > maxProjectedY) {\n    position.y = maxProjectedY;\n  }\n  if (position.y < -maxProjectedY) {\n    position.y = -maxProjectedY;\n  }\n}\n\nvar moveScratch = new Cartesian3();\n/**\n * Translates the camera's position by <code>amount</code> along <code>direction</code>.\n *\n * @param {Cartesian3} direction The direction to move.\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveBackward\n * @see Camera#moveForward\n * @see Camera#moveLeft\n * @see Camera#moveRight\n * @see Camera#moveUp\n * @see Camera#moveDown\n */\nCamera.prototype.move = function (direction, amount) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(direction)) {\n    throw new DeveloperError(\"direction is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var cameraPosition = this.position;\n  Cartesian3.multiplyByScalar(direction, amount, moveScratch);\n  Cartesian3.add(cameraPosition, moveScratch, cameraPosition);\n\n  if (this._mode === SceneMode.SCENE2D) {\n    clampMove2D(this, cameraPosition);\n  }\n  this._adjustOrthographicFrustum(true);\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the camera's view vector.\n * When in 2D mode, this will zoom in the camera instead of translating the camera's position.\n *\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveBackward\n */\nCamera.prototype.moveForward = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n\n  if (this._mode === SceneMode.SCENE2D) {\n    // 2D mode\n    zoom2D(this, amount);\n  } else {\n    // 3D or Columbus view mode\n    this.move(this.direction, amount);\n  }\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the opposite direction\n * of the camera's view vector.\n * When in 2D mode, this will zoom out the camera instead of translating the camera's position.\n *\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveForward\n */\nCamera.prototype.moveBackward = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n\n  if (this._mode === SceneMode.SCENE2D) {\n    // 2D mode\n    zoom2D(this, -amount);\n  } else {\n    // 3D or Columbus view mode\n    this.move(this.direction, -amount);\n  }\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the camera's up vector.\n *\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveDown\n */\nCamera.prototype.moveUp = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n  this.move(this.up, amount);\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the opposite direction\n * of the camera's up vector.\n *\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveUp\n */\nCamera.prototype.moveDown = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n  this.move(this.up, -amount);\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the camera's right vector.\n *\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveLeft\n */\nCamera.prototype.moveRight = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n  this.move(this.right, amount);\n};\n\n/**\n * Translates the camera's position by <code>amount</code> along the opposite direction\n * of the camera's right vector.\n *\n * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.\n *\n * @see Camera#moveRight\n */\nCamera.prototype.moveLeft = function (amount) {\n  amount = defaultValue(amount, this.defaultMoveAmount);\n  this.move(this.right, -amount);\n};\n\n/**\n * Rotates the camera around its up vector by amount, in radians, in the opposite direction\n * of its right vector if not in 2D mode.\n *\n * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookRight\n */\nCamera.prototype.lookLeft = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount);\n\n  // only want view of map to change in 3D mode, 2D visual is incorrect when look changes\n  if (this._mode !== SceneMode.SCENE2D) {\n    this.look(this.up, -amount);\n  }\n};\n\n/**\n * Rotates the camera around its up vector by amount, in radians, in the direction\n * of its right vector if not in 2D mode.\n *\n * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookLeft\n */\nCamera.prototype.lookRight = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount);\n\n  // only want view of map to change in 3D mode, 2D visual is incorrect when look changes\n  if (this._mode !== SceneMode.SCENE2D) {\n    this.look(this.up, amount);\n  }\n};\n\n/**\n * Rotates the camera around its right vector by amount, in radians, in the direction\n * of its up vector if not in 2D mode.\n *\n * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookDown\n */\nCamera.prototype.lookUp = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount);\n\n  // only want view of map to change in 3D mode, 2D visual is incorrect when look changes\n  if (this._mode !== SceneMode.SCENE2D) {\n    this.look(this.right, -amount);\n  }\n};\n\n/**\n * Rotates the camera around its right vector by amount, in radians, in the opposite direction\n * of its up vector if not in 2D mode.\n *\n * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookUp\n */\nCamera.prototype.lookDown = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount);\n\n  // only want view of map to change in 3D mode, 2D visual is incorrect when look changes\n  if (this._mode !== SceneMode.SCENE2D) {\n    this.look(this.right, amount);\n  }\n};\n\nvar lookScratchQuaternion = new Quaternion();\nvar lookScratchMatrix = new Matrix3();\n/**\n * Rotate each of the camera's orientation vectors around <code>axis</code> by <code>angle</code>\n *\n * @param {Cartesian3} axis The axis to rotate around.\n * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#lookUp\n * @see Camera#lookDown\n * @see Camera#lookLeft\n * @see Camera#lookRight\n */\nCamera.prototype.look = function (axis, angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(axis)) {\n    throw new DeveloperError(\"axis is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var turnAngle = defaultValue(angle, this.defaultLookAmount);\n  var quaternion = Quaternion.fromAxisAngle(\n    axis,\n    -turnAngle,\n    lookScratchQuaternion\n  );\n  var rotation = Matrix3.fromQuaternion(quaternion, lookScratchMatrix);\n\n  var direction = this.direction;\n  var up = this.up;\n  var right = this.right;\n\n  Matrix3.multiplyByVector(rotation, direction, direction);\n  Matrix3.multiplyByVector(rotation, up, up);\n  Matrix3.multiplyByVector(rotation, right, right);\n};\n\n/**\n * Rotate the camera counter-clockwise around its direction vector by amount, in radians.\n *\n * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#twistRight\n */\nCamera.prototype.twistLeft = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount);\n  this.look(this.direction, amount);\n};\n\n/**\n * Rotate the camera clockwise around its direction vector by amount, in radians.\n *\n * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.\n *\n * @see Camera#twistLeft\n */\nCamera.prototype.twistRight = function (amount) {\n  amount = defaultValue(amount, this.defaultLookAmount);\n  this.look(this.direction, -amount);\n};\n\nvar rotateScratchQuaternion = new Quaternion();\nvar rotateScratchMatrix = new Matrix3();\n/**\n * Rotates the camera around <code>axis</code> by <code>angle</code>. The distance\n * of the camera's position to the center of the camera's reference frame remains the same.\n *\n * @param {Cartesian3} axis The axis to rotate around given in world coordinates.\n * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateUp\n * @see Camera#rotateDown\n * @see Camera#rotateLeft\n * @see Camera#rotateRight\n */\nCamera.prototype.rotate = function (axis, angle) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(axis)) {\n    throw new DeveloperError(\"axis is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var turnAngle = defaultValue(angle, this.defaultRotateAmount);\n  var quaternion = Quaternion.fromAxisAngle(\n    axis,\n    -turnAngle,\n    rotateScratchQuaternion\n  );\n  var rotation = Matrix3.fromQuaternion(quaternion, rotateScratchMatrix);\n  Matrix3.multiplyByVector(rotation, this.position, this.position);\n  Matrix3.multiplyByVector(rotation, this.direction, this.direction);\n  Matrix3.multiplyByVector(rotation, this.up, this.up);\n  Cartesian3.cross(this.direction, this.up, this.right);\n  Cartesian3.cross(this.right, this.direction, this.up);\n\n  this._adjustOrthographicFrustum(false);\n};\n\n/**\n * Rotates the camera around the center of the camera's reference frame by angle downwards.\n *\n * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateUp\n * @see Camera#rotate\n */\nCamera.prototype.rotateDown = function (angle) {\n  angle = defaultValue(angle, this.defaultRotateAmount);\n  rotateVertical(this, angle);\n};\n\n/**\n * Rotates the camera around the center of the camera's reference frame by angle upwards.\n *\n * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateDown\n * @see Camera#rotate\n */\nCamera.prototype.rotateUp = function (angle) {\n  angle = defaultValue(angle, this.defaultRotateAmount);\n  rotateVertical(this, -angle);\n};\n\nvar rotateVertScratchP = new Cartesian3();\nvar rotateVertScratchA = new Cartesian3();\nvar rotateVertScratchTan = new Cartesian3();\nvar rotateVertScratchNegate = new Cartesian3();\nfunction rotateVertical(camera, angle) {\n  var position = camera.position;\n  if (\n    defined(camera.constrainedAxis) &&\n    !Cartesian3.equalsEpsilon(\n      camera.position,\n      Cartesian3.ZERO,\n      CesiumMath.EPSILON2\n    )\n  ) {\n    var p = Cartesian3.normalize(position, rotateVertScratchP);\n    var northParallel = Cartesian3.equalsEpsilon(\n      p,\n      camera.constrainedAxis,\n      CesiumMath.EPSILON2\n    );\n    var southParallel = Cartesian3.equalsEpsilon(\n      p,\n      Cartesian3.negate(camera.constrainedAxis, rotateVertScratchNegate),\n      CesiumMath.EPSILON2\n    );\n    if (!northParallel && !southParallel) {\n      var constrainedAxis = Cartesian3.normalize(\n        camera.constrainedAxis,\n        rotateVertScratchA\n      );\n\n      var dot = Cartesian3.dot(p, constrainedAxis);\n      var angleToAxis = CesiumMath.acosClamped(dot);\n      if (angle > 0 && angle > angleToAxis) {\n        angle = angleToAxis - CesiumMath.EPSILON4;\n      }\n\n      dot = Cartesian3.dot(\n        p,\n        Cartesian3.negate(constrainedAxis, rotateVertScratchNegate)\n      );\n      angleToAxis = CesiumMath.acosClamped(dot);\n      if (angle < 0 && -angle > angleToAxis) {\n        angle = -angleToAxis + CesiumMath.EPSILON4;\n      }\n\n      var tangent = Cartesian3.cross(constrainedAxis, p, rotateVertScratchTan);\n      camera.rotate(tangent, angle);\n    } else if ((northParallel && angle < 0) || (southParallel && angle > 0)) {\n      camera.rotate(camera.right, angle);\n    }\n  } else {\n    camera.rotate(camera.right, angle);\n  }\n}\n\n/**\n * Rotates the camera around the center of the camera's reference frame by angle to the right.\n *\n * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateLeft\n * @see Camera#rotate\n */\nCamera.prototype.rotateRight = function (angle) {\n  angle = defaultValue(angle, this.defaultRotateAmount);\n  rotateHorizontal(this, -angle);\n};\n\n/**\n * Rotates the camera around the center of the camera's reference frame by angle to the left.\n *\n * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.\n *\n * @see Camera#rotateRight\n * @see Camera#rotate\n */\nCamera.prototype.rotateLeft = function (angle) {\n  angle = defaultValue(angle, this.defaultRotateAmount);\n  rotateHorizontal(this, angle);\n};\n\nfunction rotateHorizontal(camera, angle) {\n  if (defined(camera.constrainedAxis)) {\n    camera.rotate(camera.constrainedAxis, angle);\n  } else {\n    camera.rotate(camera.up, angle);\n  }\n}\n\nfunction zoom2D(camera, amount) {\n  var frustum = camera.frustum;\n\n  //>>includeStart('debug', pragmas.debug);\n  if (\n    !(frustum instanceof OrthographicOffCenterFrustum) ||\n    !defined(frustum.left) ||\n    !defined(frustum.right) ||\n    !defined(frustum.bottom) ||\n    !defined(frustum.top)\n  ) {\n    throw new DeveloperError(\n      \"The camera frustum is expected to be orthographic for 2D camera control.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  var ratio;\n  amount = amount * 0.5;\n\n  if (\n    Math.abs(frustum.top) + Math.abs(frustum.bottom) >\n    Math.abs(frustum.left) + Math.abs(frustum.right)\n  ) {\n    var newTop = frustum.top - amount;\n    var newBottom = frustum.bottom + amount;\n\n    var maxBottom = camera._maxCoord.y;\n    if (camera._scene.mapMode2D === MapMode2D.ROTATE) {\n      maxBottom *= camera.maximumZoomFactor;\n    }\n\n    if (newBottom > maxBottom) {\n      newBottom = maxBottom;\n      newTop = -maxBottom;\n    }\n\n    if (newTop <= newBottom) {\n      newTop = 1.0;\n      newBottom = -1.0;\n    }\n\n    ratio = frustum.right / frustum.top;\n    frustum.top = newTop;\n    frustum.bottom = newBottom;\n    frustum.right = frustum.top * ratio;\n    frustum.left = -frustum.right;\n  } else {\n    var newRight = frustum.right - amount;\n    var newLeft = frustum.left + amount;\n\n    var maxRight = camera._maxCoord.x;\n    if (camera._scene.mapMode2D === MapMode2D.ROTATE) {\n      maxRight *= camera.maximumZoomFactor;\n    }\n\n    if (newRight > maxRight) {\n      newRight = maxRight;\n      newLeft = -maxRight;\n    }\n\n    if (newRight <= newLeft) {\n      newRight = 1.0;\n      newLeft = -1.0;\n    }\n    ratio = frustum.top / frustum.right;\n    frustum.right = newRight;\n    frustum.left = newLeft;\n    frustum.top = frustum.right * ratio;\n    frustum.bottom = -frustum.top;\n  }\n}\n\nfunction zoom3D(camera, amount) {\n  camera.move(camera.direction, amount);\n}\n\n/**\n * Zooms <code>amount</code> along the camera's view vector.\n *\n * @param {Number} [amount] The amount to move. Defaults to <code>defaultZoomAmount</code>.\n *\n * @see Camera#zoomOut\n */\nCamera.prototype.zoomIn = function (amount) {\n  amount = defaultValue(amount, this.defaultZoomAmount);\n  if (this._mode === SceneMode.SCENE2D) {\n    zoom2D(this, amount);\n  } else {\n    zoom3D(this, amount);\n  }\n};\n\n/**\n * Zooms <code>amount</code> along the opposite direction of\n * the camera's view vector.\n *\n * @param {Number} [amount] The amount to move. Defaults to <code>defaultZoomAmount</code>.\n *\n * @see Camera#zoomIn\n */\nCamera.prototype.zoomOut = function (amount) {\n  amount = defaultValue(amount, this.defaultZoomAmount);\n  if (this._mode === SceneMode.SCENE2D) {\n    zoom2D(this, -amount);\n  } else {\n    zoom3D(this, -amount);\n  }\n};\n\n/**\n * Gets the magnitude of the camera position. In 3D, this is the vector magnitude. In 2D and\n * Columbus view, this is the distance to the map.\n *\n * @returns {Number} The magnitude of the position.\n */\nCamera.prototype.getMagnitude = function () {\n  if (this._mode === SceneMode.SCENE3D) {\n    return Cartesian3.magnitude(this.position);\n  } else if (this._mode === SceneMode.COLUMBUS_VIEW) {\n    return Math.abs(this.position.z);\n  } else if (this._mode === SceneMode.SCENE2D) {\n    return Math.max(\n      this.frustum.right - this.frustum.left,\n      this.frustum.top - this.frustum.bottom\n    );\n  }\n};\n\nvar scratchLookAtMatrix4 = new Matrix4();\n\n/**\n * Sets the camera position and orientation using a target and offset. The target must be given in\n * world coordinates. The offset can be either a cartesian or heading/pitch/range in the local east-north-up reference frame centered at the target.\n * If the offset is a cartesian, then it is an offset from the center of the reference frame defined by the transformation matrix. If the offset\n * is heading/pitch/range, then the heading and the pitch angles are defined in the reference frame defined by the transformation matrix.\n * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch\n * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center.\n *\n * In 2D, there must be a top down view. The camera will be placed above the target looking down. The height above the\n * target will be the magnitude of the offset. The heading will be determined from the offset. If the heading cannot be\n * determined from the offset, the heading will be north.\n *\n * @param {Cartesian3} target The target position in world coordinates.\n * @param {Cartesian3|HeadingPitchRange} offset The offset from the target in the local east-north-up reference frame centered at the target.\n *\n * @exception {DeveloperError} lookAt is not supported while morphing.\n *\n * @example\n * // 1. Using a cartesian offset\n * var center = Cesium.Cartesian3.fromDegrees(-98.0, 40.0);\n * viewer.camera.lookAt(center, new Cesium.Cartesian3(0.0, -4790000.0, 3930000.0));\n *\n * // 2. Using a HeadingPitchRange offset\n * var center = Cesium.Cartesian3.fromDegrees(-72.0, 40.0);\n * var heading = Cesium.Math.toRadians(50.0);\n * var pitch = Cesium.Math.toRadians(-20.0);\n * var range = 5000.0;\n * viewer.camera.lookAt(center, new Cesium.HeadingPitchRange(heading, pitch, range));\n */\nCamera.prototype.lookAt = function (target, offset) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(target)) {\n    throw new DeveloperError(\"target is required\");\n  }\n  if (!defined(offset)) {\n    throw new DeveloperError(\"offset is required\");\n  }\n  if (this._mode === SceneMode.MORPHING) {\n    throw new DeveloperError(\"lookAt is not supported while morphing.\");\n  }\n  //>>includeEnd('debug');\n\n  var transform = Transforms.eastNorthUpToFixedFrame(\n    target,\n    Ellipsoid.WGS84,\n    scratchLookAtMatrix4\n  );\n  this.lookAtTransform(transform, offset);\n};\n\nvar scratchLookAtHeadingPitchRangeOffset = new Cartesian3();\nvar scratchLookAtHeadingPitchRangeQuaternion1 = new Quaternion();\nvar scratchLookAtHeadingPitchRangeQuaternion2 = new Quaternion();\nvar scratchHeadingPitchRangeMatrix3 = new Matrix3();\n\nfunction offsetFromHeadingPitchRange(heading, pitch, range) {\n  pitch = CesiumMath.clamp(\n    pitch,\n    -CesiumMath.PI_OVER_TWO,\n    CesiumMath.PI_OVER_TWO\n  );\n  heading = CesiumMath.zeroToTwoPi(heading) - CesiumMath.PI_OVER_TWO;\n\n  var pitchQuat = Quaternion.fromAxisAngle(\n    Cartesian3.UNIT_Y,\n    -pitch,\n    scratchLookAtHeadingPitchRangeQuaternion1\n  );\n  var headingQuat = Quaternion.fromAxisAngle(\n    Cartesian3.UNIT_Z,\n    -heading,\n    scratchLookAtHeadingPitchRangeQuaternion2\n  );\n  var rotQuat = Quaternion.multiply(headingQuat, pitchQuat, headingQuat);\n  var rotMatrix = Matrix3.fromQuaternion(\n    rotQuat,\n    scratchHeadingPitchRangeMatrix3\n  );\n\n  var offset = Cartesian3.clone(\n    Cartesian3.UNIT_X,\n    scratchLookAtHeadingPitchRangeOffset\n  );\n  Matrix3.multiplyByVector(rotMatrix, offset, offset);\n  Cartesian3.negate(offset, offset);\n  Cartesian3.multiplyByScalar(offset, range, offset);\n  return offset;\n}\n\n/**\n * Sets the camera position and orientation using a target and transformation matrix. The offset can be either a cartesian or heading/pitch/range.\n * If the offset is a cartesian, then it is an offset from the center of the reference frame defined by the transformation matrix. If the offset\n * is heading/pitch/range, then the heading and the pitch angles are defined in the reference frame defined by the transformation matrix.\n * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch\n * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center.\n *\n * In 2D, there must be a top down view. The camera will be placed above the center of the reference frame. The height above the\n * target will be the magnitude of the offset. The heading will be determined from the offset. If the heading cannot be\n * determined from the offset, the heading will be north.\n *\n * @param {Matrix4} transform The transformation matrix defining the reference frame.\n * @param {Cartesian3|HeadingPitchRange} [offset] The offset from the target in a reference frame centered at the target.\n *\n * @exception {DeveloperError} lookAtTransform is not supported while morphing.\n *\n * @example\n * // 1. Using a cartesian offset\n * var transform = Cesium.Transforms.eastNorthUpToFixedFrame(Cesium.Cartesian3.fromDegrees(-98.0, 40.0));\n * viewer.camera.lookAtTransform(transform, new Cesium.Cartesian3(0.0, -4790000.0, 3930000.0));\n *\n * // 2. Using a HeadingPitchRange offset\n * var transform = Cesium.Transforms.eastNorthUpToFixedFrame(Cesium.Cartesian3.fromDegrees(-72.0, 40.0));\n * var heading = Cesium.Math.toRadians(50.0);\n * var pitch = Cesium.Math.toRadians(-20.0);\n * var range = 5000.0;\n * viewer.camera.lookAtTransform(transform, new Cesium.HeadingPitchRange(heading, pitch, range));\n */\nCamera.prototype.lookAtTransform = function (transform, offset) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(transform)) {\n    throw new DeveloperError(\"transform is required\");\n  }\n  if (this._mode === SceneMode.MORPHING) {\n    throw new DeveloperError(\n      \"lookAtTransform is not supported while morphing.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  this._setTransform(transform);\n  if (!defined(offset)) {\n    return;\n  }\n\n  var cartesianOffset;\n  if (defined(offset.heading)) {\n    cartesianOffset = offsetFromHeadingPitchRange(\n      offset.heading,\n      offset.pitch,\n      offset.range\n    );\n  } else {\n    cartesianOffset = offset;\n  }\n\n  if (this._mode === SceneMode.SCENE2D) {\n    Cartesian2.clone(Cartesian2.ZERO, this.position);\n\n    Cartesian3.negate(cartesianOffset, this.up);\n    this.up.z = 0.0;\n\n    if (Cartesian3.magnitudeSquared(this.up) < CesiumMath.EPSILON10) {\n      Cartesian3.clone(Cartesian3.UNIT_Y, this.up);\n    }\n\n    Cartesian3.normalize(this.up, this.up);\n\n    this._setTransform(Matrix4.IDENTITY);\n\n    Cartesian3.negate(Cartesian3.UNIT_Z, this.direction);\n    Cartesian3.cross(this.direction, this.up, this.right);\n    Cartesian3.normalize(this.right, this.right);\n\n    var frustum = this.frustum;\n    var ratio = frustum.top / frustum.right;\n    frustum.right = Cartesian3.magnitude(cartesianOffset) * 0.5;\n    frustum.left = -frustum.right;\n    frustum.top = ratio * frustum.right;\n    frustum.bottom = -frustum.top;\n\n    this._setTransform(transform);\n\n    return;\n  }\n\n  Cartesian3.clone(cartesianOffset, this.position);\n  Cartesian3.negate(this.position, this.direction);\n  Cartesian3.normalize(this.direction, this.direction);\n  Cartesian3.cross(this.direction, Cartesian3.UNIT_Z, this.right);\n\n  if (Cartesian3.magnitudeSquared(this.right) < CesiumMath.EPSILON10) {\n    Cartesian3.clone(Cartesian3.UNIT_X, this.right);\n  }\n\n  Cartesian3.normalize(this.right, this.right);\n  Cartesian3.cross(this.right, this.direction, this.up);\n  Cartesian3.normalize(this.up, this.up);\n\n  this._adjustOrthographicFrustum(true);\n};\n\nvar viewRectangle3DCartographic1 = new Cartographic();\nvar viewRectangle3DCartographic2 = new Cartographic();\nvar viewRectangle3DNorthEast = new Cartesian3();\nvar viewRectangle3DSouthWest = new Cartesian3();\nvar viewRectangle3DNorthWest = new Cartesian3();\nvar viewRectangle3DSouthEast = new Cartesian3();\nvar viewRectangle3DNorthCenter = new Cartesian3();\nvar viewRectangle3DSouthCenter = new Cartesian3();\nvar viewRectangle3DCenter = new Cartesian3();\nvar viewRectangle3DEquator = new Cartesian3();\nvar defaultRF = {\n  direction: new Cartesian3(),\n  right: new Cartesian3(),\n  up: new Cartesian3(),\n};\nvar viewRectangle3DEllipsoidGeodesic;\n\nfunction computeD(direction, upOrRight, corner, tanThetaOrPhi) {\n  var opposite = Math.abs(Cartesian3.dot(upOrRight, corner));\n  return opposite / tanThetaOrPhi - Cartesian3.dot(direction, corner);\n}\n\nfunction rectangleCameraPosition3D(camera, rectangle, result, updateCamera) {\n  var ellipsoid = camera._projection.ellipsoid;\n  var cameraRF = updateCamera ? camera : defaultRF;\n\n  var north = rectangle.north;\n  var south = rectangle.south;\n  var east = rectangle.east;\n  var west = rectangle.west;\n\n  // If we go across the International Date Line\n  if (west > east) {\n    east += CesiumMath.TWO_PI;\n  }\n\n  // Find the midpoint latitude.\n  //\n  // EllipsoidGeodesic will fail if the north and south edges are very close to being on opposite sides of the ellipsoid.\n  // Ideally we'd just call EllipsoidGeodesic.setEndPoints and let it throw when it detects this case, but sadly it doesn't\n  // even look for this case in optimized builds, so we have to test for it here instead.\n  //\n  // Fortunately, this case can only happen (here) when north is very close to the north pole and south is very close to the south pole,\n  // so handle it just by using 0 latitude as the center.  It's certainliy possible to use a smaller tolerance\n  // than one degree here, but one degree is safe and putting the center at 0 latitude should be good enough for any\n  // rectangle that spans 178+ of the 180 degrees of latitude.\n  var longitude = (west + east) * 0.5;\n  var latitude;\n  if (\n    south < -CesiumMath.PI_OVER_TWO + CesiumMath.RADIANS_PER_DEGREE &&\n    north > CesiumMath.PI_OVER_TWO - CesiumMath.RADIANS_PER_DEGREE\n  ) {\n    latitude = 0.0;\n  } else {\n    var northCartographic = viewRectangle3DCartographic1;\n    northCartographic.longitude = longitude;\n    northCartographic.latitude = north;\n    northCartographic.height = 0.0;\n\n    var southCartographic = viewRectangle3DCartographic2;\n    southCartographic.longitude = longitude;\n    southCartographic.latitude = south;\n    southCartographic.height = 0.0;\n\n    var ellipsoidGeodesic = viewRectangle3DEllipsoidGeodesic;\n    if (\n      !defined(ellipsoidGeodesic) ||\n      ellipsoidGeodesic.ellipsoid !== ellipsoid\n    ) {\n      viewRectangle3DEllipsoidGeodesic = ellipsoidGeodesic = new EllipsoidGeodesic(\n        undefined,\n        undefined,\n        ellipsoid\n      );\n    }\n\n    ellipsoidGeodesic.setEndPoints(northCartographic, southCartographic);\n    latitude = ellipsoidGeodesic.interpolateUsingFraction(\n      0.5,\n      viewRectangle3DCartographic1\n    ).latitude;\n  }\n\n  var centerCartographic = viewRectangle3DCartographic1;\n  centerCartographic.longitude = longitude;\n  centerCartographic.latitude = latitude;\n  centerCartographic.height = 0.0;\n\n  var center = ellipsoid.cartographicToCartesian(\n    centerCartographic,\n    viewRectangle3DCenter\n  );\n\n  var cart = viewRectangle3DCartographic1;\n  cart.longitude = east;\n  cart.latitude = north;\n  var northEast = ellipsoid.cartographicToCartesian(\n    cart,\n    viewRectangle3DNorthEast\n  );\n  cart.longitude = west;\n  var northWest = ellipsoid.cartographicToCartesian(\n    cart,\n    viewRectangle3DNorthWest\n  );\n  cart.longitude = longitude;\n  var northCenter = ellipsoid.cartographicToCartesian(\n    cart,\n    viewRectangle3DNorthCenter\n  );\n  cart.latitude = south;\n  var southCenter = ellipsoid.cartographicToCartesian(\n    cart,\n    viewRectangle3DSouthCenter\n  );\n  cart.longitude = east;\n  var southEast = ellipsoid.cartographicToCartesian(\n    cart,\n    viewRectangle3DSouthEast\n  );\n  cart.longitude = west;\n  var southWest = ellipsoid.cartographicToCartesian(\n    cart,\n    viewRectangle3DSouthWest\n  );\n\n  Cartesian3.subtract(northWest, center, northWest);\n  Cartesian3.subtract(southEast, center, southEast);\n  Cartesian3.subtract(northEast, center, northEast);\n  Cartesian3.subtract(southWest, center, southWest);\n  Cartesian3.subtract(northCenter, center, northCenter);\n  Cartesian3.subtract(southCenter, center, southCenter);\n\n  var direction = ellipsoid.geodeticSurfaceNormal(center, cameraRF.direction);\n  Cartesian3.negate(direction, direction);\n  var right = Cartesian3.cross(direction, Cartesian3.UNIT_Z, cameraRF.right);\n  Cartesian3.normalize(right, right);\n  var up = Cartesian3.cross(right, direction, cameraRF.up);\n\n  var d;\n  if (camera.frustum instanceof OrthographicFrustum) {\n    var width = Math.max(\n      Cartesian3.distance(northEast, northWest),\n      Cartesian3.distance(southEast, southWest)\n    );\n    var height = Math.max(\n      Cartesian3.distance(northEast, southEast),\n      Cartesian3.distance(northWest, southWest)\n    );\n\n    var rightScalar;\n    var topScalar;\n    var ratio =\n      camera.frustum._offCenterFrustum.right /\n      camera.frustum._offCenterFrustum.top;\n    var heightRatio = height * ratio;\n    if (width > heightRatio) {\n      rightScalar = width;\n      topScalar = rightScalar / ratio;\n    } else {\n      topScalar = height;\n      rightScalar = heightRatio;\n    }\n\n    d = Math.max(rightScalar, topScalar);\n  } else {\n    var tanPhi = Math.tan(camera.frustum.fovy * 0.5);\n    var tanTheta = camera.frustum.aspectRatio * tanPhi;\n\n    d = Math.max(\n      computeD(direction, up, northWest, tanPhi),\n      computeD(direction, up, southEast, tanPhi),\n      computeD(direction, up, northEast, tanPhi),\n      computeD(direction, up, southWest, tanPhi),\n      computeD(direction, up, northCenter, tanPhi),\n      computeD(direction, up, southCenter, tanPhi),\n      computeD(direction, right, northWest, tanTheta),\n      computeD(direction, right, southEast, tanTheta),\n      computeD(direction, right, northEast, tanTheta),\n      computeD(direction, right, southWest, tanTheta),\n      computeD(direction, right, northCenter, tanTheta),\n      computeD(direction, right, southCenter, tanTheta)\n    );\n\n    // If the rectangle crosses the equator, compute D at the equator, too, because that's the\n    // widest part of the rectangle when projected onto the globe.\n    if (south < 0 && north > 0) {\n      var equatorCartographic = viewRectangle3DCartographic1;\n      equatorCartographic.longitude = west;\n      equatorCartographic.latitude = 0.0;\n      equatorCartographic.height = 0.0;\n      var equatorPosition = ellipsoid.cartographicToCartesian(\n        equatorCartographic,\n        viewRectangle3DEquator\n      );\n      Cartesian3.subtract(equatorPosition, center, equatorPosition);\n      d = Math.max(\n        d,\n        computeD(direction, up, equatorPosition, tanPhi),\n        computeD(direction, right, equatorPosition, tanTheta)\n      );\n\n      equatorCartographic.longitude = east;\n      equatorPosition = ellipsoid.cartographicToCartesian(\n        equatorCartographic,\n        viewRectangle3DEquator\n      );\n      Cartesian3.subtract(equatorPosition, center, equatorPosition);\n      d = Math.max(\n        d,\n        computeD(direction, up, equatorPosition, tanPhi),\n        computeD(direction, right, equatorPosition, tanTheta)\n      );\n    }\n  }\n\n  return Cartesian3.add(\n    center,\n    Cartesian3.multiplyByScalar(direction, -d, viewRectangle3DEquator),\n    result\n  );\n}\n\nvar viewRectangleCVCartographic = new Cartographic();\nvar viewRectangleCVNorthEast = new Cartesian3();\nvar viewRectangleCVSouthWest = new Cartesian3();\nfunction rectangleCameraPositionColumbusView(camera, rectangle, result) {\n  var projection = camera._projection;\n  if (rectangle.west > rectangle.east) {\n    rectangle = Rectangle.MAX_VALUE;\n  }\n  var transform = camera._actualTransform;\n  var invTransform = camera._actualInvTransform;\n\n  var cart = viewRectangleCVCartographic;\n  cart.longitude = rectangle.east;\n  cart.latitude = rectangle.north;\n  var northEast = projection.project(cart, viewRectangleCVNorthEast);\n  Matrix4.multiplyByPoint(transform, northEast, northEast);\n  Matrix4.multiplyByPoint(invTransform, northEast, northEast);\n\n  cart.longitude = rectangle.west;\n  cart.latitude = rectangle.south;\n  var southWest = projection.project(cart, viewRectangleCVSouthWest);\n  Matrix4.multiplyByPoint(transform, southWest, southWest);\n  Matrix4.multiplyByPoint(invTransform, southWest, southWest);\n\n  result.x = (northEast.x - southWest.x) * 0.5 + southWest.x;\n  result.y = (northEast.y - southWest.y) * 0.5 + southWest.y;\n\n  if (defined(camera.frustum.fovy)) {\n    var tanPhi = Math.tan(camera.frustum.fovy * 0.5);\n    var tanTheta = camera.frustum.aspectRatio * tanPhi;\n    result.z =\n      Math.max(\n        (northEast.x - southWest.x) / tanTheta,\n        (northEast.y - southWest.y) / tanPhi\n      ) * 0.5;\n  } else {\n    var width = northEast.x - southWest.x;\n    var height = northEast.y - southWest.y;\n    result.z = Math.max(width, height);\n  }\n\n  return result;\n}\n\nvar viewRectangle2DCartographic = new Cartographic();\nvar viewRectangle2DNorthEast = new Cartesian3();\nvar viewRectangle2DSouthWest = new Cartesian3();\nfunction rectangleCameraPosition2D(camera, rectangle, result) {\n  var projection = camera._projection;\n\n  // Account for the rectangle crossing the International Date Line in 2D mode\n  var east = rectangle.east;\n  if (rectangle.west > rectangle.east) {\n    if (camera._scene.mapMode2D === MapMode2D.INFINITE_SCROLL) {\n      east += CesiumMath.TWO_PI;\n    } else {\n      rectangle = Rectangle.MAX_VALUE;\n      east = rectangle.east;\n    }\n  }\n\n  var cart = viewRectangle2DCartographic;\n  cart.longitude = east;\n  cart.latitude = rectangle.north;\n  var northEast = projection.project(cart, viewRectangle2DNorthEast);\n  cart.longitude = rectangle.west;\n  cart.latitude = rectangle.south;\n  var southWest = projection.project(cart, viewRectangle2DSouthWest);\n\n  var width = Math.abs(northEast.x - southWest.x) * 0.5;\n  var height = Math.abs(northEast.y - southWest.y) * 0.5;\n\n  var right, top;\n  var ratio = camera.frustum.right / camera.frustum.top;\n  var heightRatio = height * ratio;\n  if (width > heightRatio) {\n    right = width;\n    top = right / ratio;\n  } else {\n    top = height;\n    right = heightRatio;\n  }\n\n  height = Math.max(2.0 * right, 2.0 * top);\n\n  result.x = (northEast.x - southWest.x) * 0.5 + southWest.x;\n  result.y = (northEast.y - southWest.y) * 0.5 + southWest.y;\n\n  cart = projection.unproject(result, cart);\n  cart.height = height;\n  result = projection.project(cart, result);\n\n  return result;\n}\n\n/**\n * Get the camera position needed to view a rectangle on an ellipsoid or map\n *\n * @param {Rectangle} rectangle The rectangle to view.\n * @param {Cartesian3} [result] The camera position needed to view the rectangle\n * @returns {Cartesian3} The camera position needed to view the rectangle\n */\nCamera.prototype.getRectangleCameraCoordinates = function (rectangle, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(rectangle)) {\n    throw new DeveloperError(\"rectangle is required\");\n  }\n  //>>includeEnd('debug');\n  var mode = this._mode;\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  if (mode === SceneMode.SCENE3D) {\n    return rectangleCameraPosition3D(this, rectangle, result);\n  } else if (mode === SceneMode.COLUMBUS_VIEW) {\n    return rectangleCameraPositionColumbusView(this, rectangle, result);\n  } else if (mode === SceneMode.SCENE2D) {\n    return rectangleCameraPosition2D(this, rectangle, result);\n  }\n\n  return undefined;\n};\n\nvar pickEllipsoid3DRay = new Ray();\nfunction pickEllipsoid3D(camera, windowPosition, ellipsoid, result) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  var ray = camera.getPickRay(windowPosition, pickEllipsoid3DRay);\n  var intersection = IntersectionTests.rayEllipsoid(ray, ellipsoid);\n  if (!intersection) {\n    return undefined;\n  }\n\n  var t = intersection.start > 0.0 ? intersection.start : intersection.stop;\n  return Ray.getPoint(ray, t, result);\n}\n\nvar pickEllipsoid2DRay = new Ray();\nfunction pickMap2D(camera, windowPosition, projection, result) {\n  var ray = camera.getPickRay(windowPosition, pickEllipsoid2DRay);\n  var position = ray.origin;\n  position = Cartesian3.fromElements(position.y, position.z, 0.0, position);\n  var cart = projection.unproject(position);\n\n  if (\n    cart.latitude < -CesiumMath.PI_OVER_TWO ||\n    cart.latitude > CesiumMath.PI_OVER_TWO\n  ) {\n    return undefined;\n  }\n\n  return projection.ellipsoid.cartographicToCartesian(cart, result);\n}\n\nvar pickEllipsoidCVRay = new Ray();\nfunction pickMapColumbusView(camera, windowPosition, projection, result) {\n  var ray = camera.getPickRay(windowPosition, pickEllipsoidCVRay);\n  var scalar = -ray.origin.x / ray.direction.x;\n  Ray.getPoint(ray, scalar, result);\n\n  var cart = projection.unproject(new Cartesian3(result.y, result.z, 0.0));\n\n  if (\n    cart.latitude < -CesiumMath.PI_OVER_TWO ||\n    cart.latitude > CesiumMath.PI_OVER_TWO ||\n    cart.longitude < -Math.PI ||\n    cart.longitude > Math.PI\n  ) {\n    return undefined;\n  }\n\n  return projection.ellipsoid.cartographicToCartesian(cart, result);\n}\n\n/**\n * Pick an ellipsoid or map.\n *\n * @param {Cartesian2} windowPosition The x and y coordinates of a pixel.\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to pick.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3 | undefined} If the ellipsoid or map was picked,\n * returns the point on the surface of the ellipsoid or map in world\n * coordinates. If the ellipsoid or map was not picked, returns undefined.\n *\n * @example\n * var canvas = viewer.scene.canvas;\n * var center = new Cesium.Cartesian2(canvas.clientWidth / 2.0, canvas.clientHeight / 2.0);\n * var ellipsoid = viewer.scene.globe.ellipsoid;\n * var result = viewer.camera.pickEllipsoid(center, ellipsoid);\n */\nCamera.prototype.pickEllipsoid = function (windowPosition, ellipsoid, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(windowPosition)) {\n    throw new DeveloperError(\"windowPosition is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var canvas = this._scene.canvas;\n  if (canvas.clientWidth === 0 || canvas.clientHeight === 0) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n\n  if (this._mode === SceneMode.SCENE3D) {\n    result = pickEllipsoid3D(this, windowPosition, ellipsoid, result);\n  } else if (this._mode === SceneMode.SCENE2D) {\n    result = pickMap2D(this, windowPosition, this._projection, result);\n  } else if (this._mode === SceneMode.COLUMBUS_VIEW) {\n    result = pickMapColumbusView(\n      this,\n      windowPosition,\n      this._projection,\n      result\n    );\n  } else {\n    return undefined;\n  }\n\n  return result;\n};\n\nvar pickPerspCenter = new Cartesian3();\nvar pickPerspXDir = new Cartesian3();\nvar pickPerspYDir = new Cartesian3();\nfunction getPickRayPerspective(camera, windowPosition, result) {\n  var canvas = camera._scene.canvas;\n  var width = canvas.clientWidth;\n  var height = canvas.clientHeight;\n\n  var tanPhi = Math.tan(camera.frustum.fovy * 0.5);\n  var tanTheta = camera.frustum.aspectRatio * tanPhi;\n  var near = camera.frustum.near;\n\n  var x = (2.0 / width) * windowPosition.x - 1.0;\n  var y = (2.0 / height) * (height - windowPosition.y) - 1.0;\n\n  var position = camera.positionWC;\n  Cartesian3.clone(position, result.origin);\n\n  var nearCenter = Cartesian3.multiplyByScalar(\n    camera.directionWC,\n    near,\n    pickPerspCenter\n  );\n  Cartesian3.add(position, nearCenter, nearCenter);\n  var xDir = Cartesian3.multiplyByScalar(\n    camera.rightWC,\n    x * near * tanTheta,\n    pickPerspXDir\n  );\n  var yDir = Cartesian3.multiplyByScalar(\n    camera.upWC,\n    y * near * tanPhi,\n    pickPerspYDir\n  );\n  var direction = Cartesian3.add(nearCenter, xDir, result.direction);\n  Cartesian3.add(direction, yDir, direction);\n  Cartesian3.subtract(direction, position, direction);\n  Cartesian3.normalize(direction, direction);\n\n  return result;\n}\n\nvar scratchDirection = new Cartesian3();\n\nfunction getPickRayOrthographic(camera, windowPosition, result) {\n  var canvas = camera._scene.canvas;\n  var width = canvas.clientWidth;\n  var height = canvas.clientHeight;\n\n  var frustum = camera.frustum;\n  if (defined(frustum._offCenterFrustum)) {\n    frustum = frustum._offCenterFrustum;\n  }\n  var x = (2.0 / width) * windowPosition.x - 1.0;\n  x *= (frustum.right - frustum.left) * 0.5;\n  var y = (2.0 / height) * (height - windowPosition.y) - 1.0;\n  y *= (frustum.top - frustum.bottom) * 0.5;\n\n  var origin = result.origin;\n  Cartesian3.clone(camera.position, origin);\n\n  Cartesian3.multiplyByScalar(camera.right, x, scratchDirection);\n  Cartesian3.add(scratchDirection, origin, origin);\n  Cartesian3.multiplyByScalar(camera.up, y, scratchDirection);\n  Cartesian3.add(scratchDirection, origin, origin);\n\n  Cartesian3.clone(camera.directionWC, result.direction);\n\n  if (\n    camera._mode === SceneMode.COLUMBUS_VIEW ||\n    camera._mode === SceneMode.SCENE2D\n  ) {\n    Cartesian3.fromElements(\n      result.origin.z,\n      result.origin.x,\n      result.origin.y,\n      result.origin\n    );\n  }\n\n  return result;\n}\n\n/**\n * Create a ray from the camera position through the pixel at <code>windowPosition</code>\n * in world coordinates.\n *\n * @param {Cartesian2} windowPosition The x and y coordinates of a pixel.\n * @param {Ray} [result] The object onto which to store the result.\n * @returns {Ray} Returns the {@link Cartesian3} position and direction of the ray.\n */\nCamera.prototype.getPickRay = function (windowPosition, result) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(windowPosition)) {\n    throw new DeveloperError(\"windowPosition is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Ray();\n  }\n\n  var frustum = this.frustum;\n  if (\n    defined(frustum.aspectRatio) &&\n    defined(frustum.fov) &&\n    defined(frustum.near)\n  ) {\n    return getPickRayPerspective(this, windowPosition, result);\n  }\n\n  return getPickRayOrthographic(this, windowPosition, result);\n};\n\nvar scratchToCenter = new Cartesian3();\nvar scratchProj = new Cartesian3();\n\n/**\n * Return the distance from the camera to the front of the bounding sphere.\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere in world coordinates.\n * @returns {Number} The distance to the bounding sphere.\n */\nCamera.prototype.distanceToBoundingSphere = function (boundingSphere) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var toCenter = Cartesian3.subtract(\n    this.positionWC,\n    boundingSphere.center,\n    scratchToCenter\n  );\n  var proj = Cartesian3.multiplyByScalar(\n    this.directionWC,\n    Cartesian3.dot(toCenter, this.directionWC),\n    scratchProj\n  );\n  return Math.max(0.0, Cartesian3.magnitude(proj) - boundingSphere.radius);\n};\n\nvar scratchPixelSize = new Cartesian2();\n\n/**\n * Return the pixel size in meters.\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere in world coordinates.\n * @param {Number} drawingBufferWidth The drawing buffer width.\n * @param {Number} drawingBufferHeight The drawing buffer height.\n * @returns {Number} The pixel size in meters.\n */\nCamera.prototype.getPixelSize = function (\n  boundingSphere,\n  drawingBufferWidth,\n  drawingBufferHeight\n) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  }\n  if (!defined(drawingBufferWidth)) {\n    throw new DeveloperError(\"drawingBufferWidth is required.\");\n  }\n  if (!defined(drawingBufferHeight)) {\n    throw new DeveloperError(\"drawingBufferHeight is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var distance = this.distanceToBoundingSphere(boundingSphere);\n  var pixelSize = this.frustum.getPixelDimensions(\n    drawingBufferWidth,\n    drawingBufferHeight,\n    distance,\n    this._scene.pixelRatio,\n    scratchPixelSize\n  );\n  return Math.max(pixelSize.x, pixelSize.y);\n};\n\nfunction createAnimationTemplateCV(\n  camera,\n  position,\n  center,\n  maxX,\n  maxY,\n  duration\n) {\n  var newPosition = Cartesian3.clone(position);\n\n  if (center.y > maxX) {\n    newPosition.y -= center.y - maxX;\n  } else if (center.y < -maxX) {\n    newPosition.y += -maxX - center.y;\n  }\n\n  if (center.z > maxY) {\n    newPosition.z -= center.z - maxY;\n  } else if (center.z < -maxY) {\n    newPosition.z += -maxY - center.z;\n  }\n\n  function updateCV(value) {\n    var interp = Cartesian3.lerp(\n      position,\n      newPosition,\n      value.time,\n      new Cartesian3()\n    );\n    camera.worldToCameraCoordinatesPoint(interp, camera.position);\n  }\n  return {\n    easingFunction: EasingFunction.EXPONENTIAL_OUT,\n    startObject: {\n      time: 0.0,\n    },\n    stopObject: {\n      time: 1.0,\n    },\n    duration: duration,\n    update: updateCV,\n  };\n}\n\nvar normalScratch = new Cartesian3();\nvar centerScratch = new Cartesian3();\nvar posScratch = new Cartesian3();\nvar scratchCartesian3Subtract = new Cartesian3();\n\nfunction createAnimationCV(camera, duration) {\n  var position = camera.position;\n  var direction = camera.direction;\n\n  var normal = camera.worldToCameraCoordinatesVector(\n    Cartesian3.UNIT_X,\n    normalScratch\n  );\n  var scalar =\n    -Cartesian3.dot(normal, position) / Cartesian3.dot(normal, direction);\n  var center = Cartesian3.add(\n    position,\n    Cartesian3.multiplyByScalar(direction, scalar, centerScratch),\n    centerScratch\n  );\n  camera.cameraToWorldCoordinatesPoint(center, center);\n\n  position = camera.cameraToWorldCoordinatesPoint(camera.position, posScratch);\n\n  var tanPhi = Math.tan(camera.frustum.fovy * 0.5);\n  var tanTheta = camera.frustum.aspectRatio * tanPhi;\n  var distToC = Cartesian3.magnitude(\n    Cartesian3.subtract(position, center, scratchCartesian3Subtract)\n  );\n  var dWidth = tanTheta * distToC;\n  var dHeight = tanPhi * distToC;\n\n  var mapWidth = camera._maxCoord.x;\n  var mapHeight = camera._maxCoord.y;\n\n  var maxX = Math.max(dWidth - mapWidth, mapWidth);\n  var maxY = Math.max(dHeight - mapHeight, mapHeight);\n\n  if (\n    position.z < -maxX ||\n    position.z > maxX ||\n    position.y < -maxY ||\n    position.y > maxY\n  ) {\n    var translateX = center.y < -maxX || center.y > maxX;\n    var translateY = center.z < -maxY || center.z > maxY;\n    if (translateX || translateY) {\n      return createAnimationTemplateCV(\n        camera,\n        position,\n        center,\n        maxX,\n        maxY,\n        duration\n      );\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * Create an animation to move the map into view. This method is only valid for 2D and Columbus modes.\n *\n * @param {Number} duration The duration, in seconds, of the animation.\n * @returns {Object} The animation or undefined if the scene mode is 3D or the map is already ion view.\n *\n * @private\n */\nCamera.prototype.createCorrectPositionTween = function (duration) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(duration)) {\n    throw new DeveloperError(\"duration is required.\");\n  }\n  //>>includeEnd('debug');\n\n  if (this._mode === SceneMode.COLUMBUS_VIEW) {\n    return createAnimationCV(this, duration);\n  }\n\n  return undefined;\n};\n\nvar scratchFlyToDestination = new Cartesian3();\nvar newOptions = {\n  destination: undefined,\n  heading: undefined,\n  pitch: undefined,\n  roll: undefined,\n  duration: undefined,\n  complete: undefined,\n  cancel: undefined,\n  endTransform: undefined,\n  maximumHeight: undefined,\n  easingFunction: undefined,\n};\n\n/**\n * Cancels the current camera flight and leaves the camera at its current location.\n * If no flight is in progress, this this function does nothing.\n */\nCamera.prototype.cancelFlight = function () {\n  if (defined(this._currentFlight)) {\n    this._currentFlight.cancelTween();\n    this._currentFlight = undefined;\n  }\n};\n\n/**\n * Completes the current camera flight and moves the camera immediately to its final destination.\n * If no flight is in progress, this this function does nothing.\n */\nCamera.prototype.completeFlight = function () {\n  if (defined(this._currentFlight)) {\n    this._currentFlight.cancelTween();\n\n    var options = {\n      destination: undefined,\n      orientation: {\n        heading: undefined,\n        pitch: undefined,\n        roll: undefined,\n      },\n    };\n\n    options.destination = newOptions.destination;\n    options.orientation.heading = newOptions.heading;\n    options.orientation.pitch = newOptions.pitch;\n    options.orientation.roll = newOptions.roll;\n\n    this.setView(options);\n\n    if (defined(this._currentFlight.complete)) {\n      this._currentFlight.complete();\n    }\n\n    this._currentFlight = undefined;\n  }\n};\n\n/**\n * Flies the camera from its current position to a new position.\n *\n * @param {Object} options Object with the following properties:\n * @param {Cartesian3|Rectangle} options.destination The final position of the camera in WGS84 (world) coordinates or a rectangle that would be visible from a top-down view.\n * @param {Object} [options.orientation] An object that contains either direction and up properties or heading, pitch and roll properties. By default, the direction will point\n * towards the center of the frame in 3D and in the negative z direction in Columbus view. The up direction will point towards local north in 3D and in the positive\n * y direction in Columbus view.  Orientation is not used in 2D when in infinite scrolling mode.\n * @param {Number} [options.duration] The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight.\n * @param {Camera.FlightCompleteCallback} [options.complete] The function to execute when the flight is complete.\n * @param {Camera.FlightCancelledCallback} [options.cancel] The function to execute if the flight is cancelled.\n * @param {Matrix4} [options.endTransform] Transform matrix representing the reference frame the camera will be in when the flight is completed.\n * @param {Number} [options.maximumHeight] The maximum height at the peak of the flight.\n * @param {Number} [options.pitchAdjustHeight] If camera flyes higher than that value, adjust pitch duiring the flight to look down, and keep Earth in viewport.\n * @param {Number} [options.flyOverLongitude] There are always two ways between 2 points on globe. This option force camera to choose fight direction to fly over that longitude.\n * @param {Number} [options.flyOverLongitudeWeight] Fly over the lon specifyed via flyOverLongitude only if that way is not longer than short way times flyOverLongitudeWeight.\n * @param {Boolean} [options.convert] Whether to convert the destination from world coordinates to scene coordinates (only relevant when not using 3D). Defaults to <code>true</code>.\n * @param {EasingFunction.Callback} [options.easingFunction] Controls how the time is interpolated over the duration of the flight.\n *\n * @exception {DeveloperError} If either direction or up is given, then both are required.\n *\n * @example\n * // 1. Fly to a position with a top-down view\n * viewer.camera.flyTo({\n *     destination : Cesium.Cartesian3.fromDegrees(-117.16, 32.71, 15000.0)\n * });\n *\n * // 2. Fly to a Rectangle with a top-down view\n * viewer.camera.flyTo({\n *     destination : Cesium.Rectangle.fromDegrees(west, south, east, north)\n * });\n *\n * // 3. Fly to a position with an orientation using unit vectors.\n * viewer.camera.flyTo({\n *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),\n *     orientation : {\n *         direction : new Cesium.Cartesian3(-0.04231243104240401, -0.20123236049443421, -0.97862924300734),\n *         up : new Cesium.Cartesian3(-0.47934589305293746, -0.8553216253114552, 0.1966022179118339)\n *     }\n * });\n *\n * // 4. Fly to a position with an orientation using heading, pitch and roll.\n * viewer.camera.flyTo({\n *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),\n *     orientation : {\n *         heading : Cesium.Math.toRadians(175.0),\n *         pitch : Cesium.Math.toRadians(-35.0),\n *         roll : 0.0\n *     }\n * });\n */\nCamera.prototype.flyTo = function (options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var destination = options.destination;\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(destination)) {\n    throw new DeveloperError(\"destination is required.\");\n  }\n  //>>includeEnd('debug');\n\n  var mode = this._mode;\n  if (mode === SceneMode.MORPHING) {\n    return;\n  }\n\n  this.cancelFlight();\n\n  var orientation = defaultValue(\n    options.orientation,\n    defaultValue.EMPTY_OBJECT\n  );\n  if (defined(orientation.direction)) {\n    orientation = directionUpToHeadingPitchRoll(\n      this,\n      destination,\n      orientation,\n      scratchSetViewOptions.orientation\n    );\n  }\n\n  if (defined(options.duration) && options.duration <= 0.0) {\n    var setViewOptions = scratchSetViewOptions;\n    setViewOptions.destination = options.destination;\n    setViewOptions.orientation.heading = orientation.heading;\n    setViewOptions.orientation.pitch = orientation.pitch;\n    setViewOptions.orientation.roll = orientation.roll;\n    setViewOptions.convert = options.convert;\n    setViewOptions.endTransform = options.endTransform;\n    this.setView(setViewOptions);\n    if (typeof options.complete === \"function\") {\n      options.complete();\n    }\n    return;\n  }\n\n  var isRectangle = defined(destination.west);\n  if (isRectangle) {\n    destination = this.getRectangleCameraCoordinates(\n      destination,\n      scratchFlyToDestination\n    );\n  }\n\n  var that = this;\n  var flightTween;\n\n  newOptions.destination = destination;\n  newOptions.heading = orientation.heading;\n  newOptions.pitch = orientation.pitch;\n  newOptions.roll = orientation.roll;\n  newOptions.duration = options.duration;\n  newOptions.complete = function () {\n    if (flightTween === that._currentFlight) {\n      that._currentFlight = undefined;\n    }\n    if (defined(options.complete)) {\n      options.complete();\n    }\n  };\n  newOptions.cancel = options.cancel;\n  newOptions.endTransform = options.endTransform;\n  newOptions.convert = isRectangle ? false : options.convert;\n  newOptions.maximumHeight = options.maximumHeight;\n  newOptions.pitchAdjustHeight = options.pitchAdjustHeight;\n  newOptions.flyOverLongitude = options.flyOverLongitude;\n  newOptions.flyOverLongitudeWeight = options.flyOverLongitudeWeight;\n  newOptions.easingFunction = options.easingFunction;\n\n  var scene = this._scene;\n  var tweenOptions = CameraFlightPath.createTween(scene, newOptions);\n  // If the camera doesn't actually need to go anywhere, duration\n  // will be 0 and we can just complete the current flight.\n  if (tweenOptions.duration === 0) {\n    if (typeof tweenOptions.complete === \"function\") {\n      tweenOptions.complete();\n    }\n    return;\n  }\n  flightTween = scene.tweens.add(tweenOptions);\n  this._currentFlight = flightTween;\n\n  // Save the final destination view information for the PRELOAD_FLIGHT pass.\n  var preloadFlightCamera = this._scene.preloadFlightCamera;\n  if (this._mode !== SceneMode.SCENE2D) {\n    if (!defined(preloadFlightCamera)) {\n      preloadFlightCamera = Camera.clone(this);\n    }\n    preloadFlightCamera.setView({\n      destination: destination,\n      orientation: orientation,\n    });\n\n    this._scene.preloadFlightCullingVolume = preloadFlightCamera.frustum.computeCullingVolume(\n      preloadFlightCamera.positionWC,\n      preloadFlightCamera.directionWC,\n      preloadFlightCamera.upWC\n    );\n  }\n};\n\nfunction distanceToBoundingSphere3D(camera, radius) {\n  var frustum = camera.frustum;\n  var tanPhi = Math.tan(frustum.fovy * 0.5);\n  var tanTheta = frustum.aspectRatio * tanPhi;\n  return Math.max(radius / tanTheta, radius / tanPhi);\n}\n\nfunction distanceToBoundingSphere2D(camera, radius) {\n  var frustum = camera.frustum;\n  if (defined(frustum._offCenterFrustum)) {\n    frustum = frustum._offCenterFrustum;\n  }\n\n  var right, top;\n  var ratio = frustum.right / frustum.top;\n  var heightRatio = radius * ratio;\n  if (radius > heightRatio) {\n    right = radius;\n    top = right / ratio;\n  } else {\n    top = radius;\n    right = heightRatio;\n  }\n\n  return Math.max(right, top) * 1.5;\n}\n\nvar MINIMUM_ZOOM = 100.0;\n\nfunction adjustBoundingSphereOffset(camera, boundingSphere, offset) {\n  offset = HeadingPitchRange.clone(\n    defined(offset) ? offset : Camera.DEFAULT_OFFSET\n  );\n\n  var minimumZoom =\n    camera._scene.screenSpaceCameraController.minimumZoomDistance;\n  var maximumZoom =\n    camera._scene.screenSpaceCameraController.maximumZoomDistance;\n  var range = offset.range;\n  if (!defined(range) || range === 0.0) {\n    var radius = boundingSphere.radius;\n    if (radius === 0.0) {\n      offset.range = MINIMUM_ZOOM;\n    } else if (\n      camera.frustum instanceof OrthographicFrustum ||\n      camera._mode === SceneMode.SCENE2D\n    ) {\n      offset.range = distanceToBoundingSphere2D(camera, radius);\n    } else {\n      offset.range = distanceToBoundingSphere3D(camera, radius);\n    }\n    offset.range = CesiumMath.clamp(offset.range, minimumZoom, maximumZoom);\n  }\n\n  return offset;\n}\n\n/**\n * Sets the camera so that the current view contains the provided bounding sphere.\n *\n * <p>The offset is heading/pitch/range in the local east-north-up reference frame centered at the center of the bounding sphere.\n * The heading and the pitch angles are defined in the local east-north-up reference frame.\n * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch\n * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center. If the range is\n * zero, a range will be computed such that the whole bounding sphere is visible.</p>\n *\n * <p>In 2D, there must be a top down view. The camera will be placed above the target looking down. The height above the\n * target will be the range. The heading will be determined from the offset. If the heading cannot be\n * determined from the offset, the heading will be north.</p>\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere to view, in world coordinates.\n * @param {HeadingPitchRange} [offset] The offset from the target in the local east-north-up reference frame centered at the target.\n *\n * @exception {DeveloperError} viewBoundingSphere is not supported while morphing.\n */\nCamera.prototype.viewBoundingSphere = function (boundingSphere, offset) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  }\n\n  if (this._mode === SceneMode.MORPHING) {\n    throw new DeveloperError(\n      \"viewBoundingSphere is not supported while morphing.\"\n    );\n  }\n  //>>includeEnd('debug');\n\n  offset = adjustBoundingSphereOffset(this, boundingSphere, offset);\n  this.lookAt(boundingSphere.center, offset);\n};\n\nvar scratchflyToBoundingSphereTransform = new Matrix4();\nvar scratchflyToBoundingSphereDestination = new Cartesian3();\nvar scratchflyToBoundingSphereDirection = new Cartesian3();\nvar scratchflyToBoundingSphereUp = new Cartesian3();\nvar scratchflyToBoundingSphereRight = new Cartesian3();\nvar scratchFlyToBoundingSphereCart4 = new Cartesian4();\nvar scratchFlyToBoundingSphereQuaternion = new Quaternion();\nvar scratchFlyToBoundingSphereMatrix3 = new Matrix3();\n\n/**\n * Flies the camera to a location where the current view contains the provided bounding sphere.\n *\n * <p> The offset is heading/pitch/range in the local east-north-up reference frame centered at the center of the bounding sphere.\n * The heading and the pitch angles are defined in the local east-north-up reference frame.\n * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch\n * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center. If the range is\n * zero, a range will be computed such that the whole bounding sphere is visible.</p>\n *\n * <p>In 2D and Columbus View, there must be a top down view. The camera will be placed above the target looking down. The height above the\n * target will be the range. The heading will be aligned to local north.</p>\n *\n * @param {BoundingSphere} boundingSphere The bounding sphere to view, in world coordinates.\n * @param {Object} [options] Object with the following properties:\n * @param {Number} [options.duration] The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight.\n * @param {HeadingPitchRange} [options.offset] The offset from the target in the local east-north-up reference frame centered at the target.\n * @param {Camera.FlightCompleteCallback} [options.complete] The function to execute when the flight is complete.\n * @param {Camera.FlightCancelledCallback} [options.cancel] The function to execute if the flight is cancelled.\n * @param {Matrix4} [options.endTransform] Transform matrix representing the reference frame the camera will be in when the flight is completed.\n * @param {Number} [options.maximumHeight] The maximum height at the peak of the flight.\n * @param {Number} [options.pitchAdjustHeight] If camera flyes higher than that value, adjust pitch duiring the flight to look down, and keep Earth in viewport.\n * @param {Number} [options.flyOverLongitude] There are always two ways between 2 points on globe. This option force camera to choose fight direction to fly over that longitude.\n * @param {Number} [options.flyOverLongitudeWeight] Fly over the lon specifyed via flyOverLongitude only if that way is not longer than short way times flyOverLongitudeWeight.\n * @param {EasingFunction.Callback} [options.easingFunction] Controls how the time is interpolated over the duration of the flight.\n */\nCamera.prototype.flyToBoundingSphere = function (boundingSphere, options) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(boundingSphere)) {\n    throw new DeveloperError(\"boundingSphere is required.\");\n  }\n  //>>includeEnd('debug');\n\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n  var scene2D =\n    this._mode === SceneMode.SCENE2D || this._mode === SceneMode.COLUMBUS_VIEW;\n  this._setTransform(Matrix4.IDENTITY);\n  var offset = adjustBoundingSphereOffset(this, boundingSphere, options.offset);\n\n  var position;\n  if (scene2D) {\n    position = Cartesian3.multiplyByScalar(\n      Cartesian3.UNIT_Z,\n      offset.range,\n      scratchflyToBoundingSphereDestination\n    );\n  } else {\n    position = offsetFromHeadingPitchRange(\n      offset.heading,\n      offset.pitch,\n      offset.range\n    );\n  }\n\n  var transform = Transforms.eastNorthUpToFixedFrame(\n    boundingSphere.center,\n    Ellipsoid.WGS84,\n    scratchflyToBoundingSphereTransform\n  );\n  Matrix4.multiplyByPoint(transform, position, position);\n\n  var direction;\n  var up;\n\n  if (!scene2D) {\n    direction = Cartesian3.subtract(\n      boundingSphere.center,\n      position,\n      scratchflyToBoundingSphereDirection\n    );\n    Cartesian3.normalize(direction, direction);\n\n    up = Matrix4.multiplyByPointAsVector(\n      transform,\n      Cartesian3.UNIT_Z,\n      scratchflyToBoundingSphereUp\n    );\n    if (1.0 - Math.abs(Cartesian3.dot(direction, up)) < CesiumMath.EPSILON6) {\n      var rotateQuat = Quaternion.fromAxisAngle(\n        direction,\n        offset.heading,\n        scratchFlyToBoundingSphereQuaternion\n      );\n      var rotation = Matrix3.fromQuaternion(\n        rotateQuat,\n        scratchFlyToBoundingSphereMatrix3\n      );\n\n      Cartesian3.fromCartesian4(\n        Matrix4.getColumn(transform, 1, scratchFlyToBoundingSphereCart4),\n        up\n      );\n      Matrix3.multiplyByVector(rotation, up, up);\n    }\n\n    var right = Cartesian3.cross(\n      direction,\n      up,\n      scratchflyToBoundingSphereRight\n    );\n    Cartesian3.cross(right, direction, up);\n    Cartesian3.normalize(up, up);\n  }\n\n  this.flyTo({\n    destination: position,\n    orientation: {\n      direction: direction,\n      up: up,\n    },\n    duration: options.duration,\n    complete: options.complete,\n    cancel: options.cancel,\n    endTransform: options.endTransform,\n    maximumHeight: options.maximumHeight,\n    easingFunction: options.easingFunction,\n    flyOverLongitude: options.flyOverLongitude,\n    flyOverLongitudeWeight: options.flyOverLongitudeWeight,\n    pitchAdjustHeight: options.pitchAdjustHeight,\n  });\n};\n\nvar scratchCartesian3_1 = new Cartesian3();\nvar scratchCartesian3_2 = new Cartesian3();\nvar scratchCartesian3_3 = new Cartesian3();\nvar scratchCartesian3_4 = new Cartesian3();\nvar horizonPoints = [\n  new Cartesian3(),\n  new Cartesian3(),\n  new Cartesian3(),\n  new Cartesian3(),\n];\n\nfunction computeHorizonQuad(camera, ellipsoid) {\n  var radii = ellipsoid.radii;\n  var p = camera.positionWC;\n\n  // Find the corresponding position in the scaled space of the ellipsoid.\n  var q = Cartesian3.multiplyComponents(\n    ellipsoid.oneOverRadii,\n    p,\n    scratchCartesian3_1\n  );\n\n  var qMagnitude = Cartesian3.magnitude(q);\n  var qUnit = Cartesian3.normalize(q, scratchCartesian3_2);\n\n  // Determine the east and north directions at q.\n  var eUnit;\n  var nUnit;\n  if (\n    Cartesian3.equalsEpsilon(qUnit, Cartesian3.UNIT_Z, CesiumMath.EPSILON10)\n  ) {\n    eUnit = new Cartesian3(0, 1, 0);\n    nUnit = new Cartesian3(0, 0, 1);\n  } else {\n    eUnit = Cartesian3.normalize(\n      Cartesian3.cross(Cartesian3.UNIT_Z, qUnit, scratchCartesian3_3),\n      scratchCartesian3_3\n    );\n    nUnit = Cartesian3.normalize(\n      Cartesian3.cross(qUnit, eUnit, scratchCartesian3_4),\n      scratchCartesian3_4\n    );\n  }\n\n  // Determine the radius of the 'limb' of the ellipsoid.\n  var wMagnitude = Math.sqrt(Cartesian3.magnitudeSquared(q) - 1.0);\n\n  // Compute the center and offsets.\n  var center = Cartesian3.multiplyByScalar(\n    qUnit,\n    1.0 / qMagnitude,\n    scratchCartesian3_1\n  );\n  var scalar = wMagnitude / qMagnitude;\n  var eastOffset = Cartesian3.multiplyByScalar(\n    eUnit,\n    scalar,\n    scratchCartesian3_2\n  );\n  var northOffset = Cartesian3.multiplyByScalar(\n    nUnit,\n    scalar,\n    scratchCartesian3_3\n  );\n\n  // A conservative measure for the longitudes would be to use the min/max longitudes of the bounding frustum.\n  var upperLeft = Cartesian3.add(center, northOffset, horizonPoints[0]);\n  Cartesian3.subtract(upperLeft, eastOffset, upperLeft);\n  Cartesian3.multiplyComponents(radii, upperLeft, upperLeft);\n\n  var lowerLeft = Cartesian3.subtract(center, northOffset, horizonPoints[1]);\n  Cartesian3.subtract(lowerLeft, eastOffset, lowerLeft);\n  Cartesian3.multiplyComponents(radii, lowerLeft, lowerLeft);\n\n  var lowerRight = Cartesian3.subtract(center, northOffset, horizonPoints[2]);\n  Cartesian3.add(lowerRight, eastOffset, lowerRight);\n  Cartesian3.multiplyComponents(radii, lowerRight, lowerRight);\n\n  var upperRight = Cartesian3.add(center, northOffset, horizonPoints[3]);\n  Cartesian3.add(upperRight, eastOffset, upperRight);\n  Cartesian3.multiplyComponents(radii, upperRight, upperRight);\n\n  return horizonPoints;\n}\n\nvar scratchPickCartesian2 = new Cartesian2();\nvar scratchRectCartesian = new Cartesian3();\nvar cartoArray = [\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n  new Cartographic(),\n];\nfunction addToResult(x, y, index, camera, ellipsoid, computedHorizonQuad) {\n  scratchPickCartesian2.x = x;\n  scratchPickCartesian2.y = y;\n  var r = camera.pickEllipsoid(\n    scratchPickCartesian2,\n    ellipsoid,\n    scratchRectCartesian\n  );\n  if (defined(r)) {\n    cartoArray[index] = ellipsoid.cartesianToCartographic(r, cartoArray[index]);\n    return 1;\n  }\n  cartoArray[index] = ellipsoid.cartesianToCartographic(\n    computedHorizonQuad[index],\n    cartoArray[index]\n  );\n  return 0;\n}\n/**\n * Computes the approximate visible rectangle on the ellipsoid.\n *\n * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid that you want to know the visible region.\n * @param {Rectangle} [result] The rectangle in which to store the result\n *\n * @returns {Rectangle|undefined} The visible rectangle or undefined if the ellipsoid isn't visible at all.\n */\nCamera.prototype.computeViewRectangle = function (ellipsoid, result) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n  var cullingVolume = this.frustum.computeCullingVolume(\n    this.positionWC,\n    this.directionWC,\n    this.upWC\n  );\n  var boundingSphere = new BoundingSphere(\n    Cartesian3.ZERO,\n    ellipsoid.maximumRadius\n  );\n  var visibility = cullingVolume.computeVisibility(boundingSphere);\n  if (visibility === Intersect.OUTSIDE) {\n    return undefined;\n  }\n\n  var canvas = this._scene.canvas;\n  var width = canvas.clientWidth;\n  var height = canvas.clientHeight;\n\n  var successfulPickCount = 0;\n\n  var computedHorizonQuad = computeHorizonQuad(this, ellipsoid);\n\n  successfulPickCount += addToResult(\n    0,\n    0,\n    0,\n    this,\n    ellipsoid,\n    computedHorizonQuad\n  );\n  successfulPickCount += addToResult(\n    0,\n    height,\n    1,\n    this,\n    ellipsoid,\n    computedHorizonQuad\n  );\n  successfulPickCount += addToResult(\n    width,\n    height,\n    2,\n    this,\n    ellipsoid,\n    computedHorizonQuad\n  );\n  successfulPickCount += addToResult(\n    width,\n    0,\n    3,\n    this,\n    ellipsoid,\n    computedHorizonQuad\n  );\n\n  if (successfulPickCount < 2) {\n    // If we have space non-globe in 3 or 4 corners then return the whole globe\n    return Rectangle.MAX_VALUE;\n  }\n\n  result = Rectangle.fromCartographicArray(cartoArray, result);\n\n  // Detect if we go over the poles\n  var distance = 0;\n  var lastLon = cartoArray[3].longitude;\n  for (var i = 0; i < 4; ++i) {\n    var lon = cartoArray[i].longitude;\n    var diff = Math.abs(lon - lastLon);\n    if (diff > CesiumMath.PI) {\n      // Crossed the dateline\n      distance += CesiumMath.TWO_PI - diff;\n    } else {\n      distance += diff;\n    }\n\n    lastLon = lon;\n  }\n\n  // We are over one of the poles so adjust the rectangle accordingly\n  if (\n    CesiumMath.equalsEpsilon(\n      Math.abs(distance),\n      CesiumMath.TWO_PI,\n      CesiumMath.EPSILON9\n    )\n  ) {\n    result.west = -CesiumMath.PI;\n    result.east = CesiumMath.PI;\n    if (cartoArray[0].latitude >= 0.0) {\n      result.north = CesiumMath.PI_OVER_TWO;\n    } else {\n      result.south = -CesiumMath.PI_OVER_TWO;\n    }\n  }\n\n  return result;\n};\n\n/**\n * Switches the frustum/projection to perspective.\n *\n * This function is a no-op in 2D which must always be orthographic.\n */\nCamera.prototype.switchToPerspectiveFrustum = function () {\n  if (\n    this._mode === SceneMode.SCENE2D ||\n    this.frustum instanceof PerspectiveFrustum\n  ) {\n    return;\n  }\n\n  var scene = this._scene;\n  this.frustum = new PerspectiveFrustum();\n  this.frustum.aspectRatio =\n    scene.drawingBufferWidth / scene.drawingBufferHeight;\n  this.frustum.fov = CesiumMath.toRadians(60.0);\n};\n\n/**\n * Switches the frustum/projection to orthographic.\n *\n * This function is a no-op in 2D which will always be orthographic.\n */\nCamera.prototype.switchToOrthographicFrustum = function () {\n  if (\n    this._mode === SceneMode.SCENE2D ||\n    this.frustum instanceof OrthographicFrustum\n  ) {\n    return;\n  }\n\n  // This must be called before changing the frustum because it uses the previous\n  // frustum to reconstruct the world space position from the depth buffer.\n  var frustumWidth = calculateOrthographicFrustumWidth(this);\n\n  var scene = this._scene;\n  this.frustum = new OrthographicFrustum();\n  this.frustum.aspectRatio =\n    scene.drawingBufferWidth / scene.drawingBufferHeight;\n  this.frustum.width = frustumWidth;\n};\n\n/**\n * @private\n */\nCamera.clone = function (camera, result) {\n  if (!defined(result)) {\n    result = new Camera(camera._scene);\n  }\n\n  Cartesian3.clone(camera.position, result.position);\n  Cartesian3.clone(camera.direction, result.direction);\n  Cartesian3.clone(camera.up, result.up);\n  Cartesian3.clone(camera.right, result.right);\n  Matrix4.clone(camera._transform, result.transform);\n  result._transformChanged = true;\n  result.frustum = camera.frustum.clone();\n\n  return result;\n};\n\n/**\n * A function that will execute when a flight completes.\n * @callback Camera.FlightCompleteCallback\n */\n\n/**\n * A function that will execute when a flight is cancelled.\n * @callback Camera.FlightCancelledCallback\n */\nexport default Camera;\n"]},"metadata":{},"sourceType":"module"}