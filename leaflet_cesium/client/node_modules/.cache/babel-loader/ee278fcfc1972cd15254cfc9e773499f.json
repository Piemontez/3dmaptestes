{"ast":null,"code":"import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport scaleToGeodeticSurface from \"./scaleToGeodeticSurface.js\";\n\nfunction initialize(ellipsoid, x, y, z) {\n  x = defaultValue(x, 0.0);\n  y = defaultValue(y, 0.0);\n  z = defaultValue(z, 0.0); //>>includeStart('debug', pragmas.debug);\n\n  Check.typeOf.number.greaterThanOrEquals(\"x\", x, 0.0);\n  Check.typeOf.number.greaterThanOrEquals(\"y\", y, 0.0);\n  Check.typeOf.number.greaterThanOrEquals(\"z\", z, 0.0); //>>includeEnd('debug');\n\n  ellipsoid._radii = new Cartesian3(x, y, z);\n  ellipsoid._radiiSquared = new Cartesian3(x * x, y * y, z * z);\n  ellipsoid._radiiToTheFourth = new Cartesian3(x * x * x * x, y * y * y * y, z * z * z * z);\n  ellipsoid._oneOverRadii = new Cartesian3(x === 0.0 ? 0.0 : 1.0 / x, y === 0.0 ? 0.0 : 1.0 / y, z === 0.0 ? 0.0 : 1.0 / z);\n  ellipsoid._oneOverRadiiSquared = new Cartesian3(x === 0.0 ? 0.0 : 1.0 / (x * x), y === 0.0 ? 0.0 : 1.0 / (y * y), z === 0.0 ? 0.0 : 1.0 / (z * z));\n  ellipsoid._minimumRadius = Math.min(x, y, z);\n  ellipsoid._maximumRadius = Math.max(x, y, z);\n  ellipsoid._centerToleranceSquared = CesiumMath.EPSILON1;\n\n  if (ellipsoid._radiiSquared.z !== 0) {\n    ellipsoid._squaredXOverSquaredZ = ellipsoid._radiiSquared.x / ellipsoid._radiiSquared.z;\n  }\n}\n/**\n * A quadratic surface defined in Cartesian coordinates by the equation\n * <code>(x / a)^2 + (y / b)^2 + (z / c)^2 = 1</code>.  Primarily used\n * by Cesium to represent the shape of planetary bodies.\n *\n * Rather than constructing this object directly, one of the provided\n * constants is normally used.\n * @alias Ellipsoid\n * @constructor\n *\n * @param {Number} [x=0] The radius in the x direction.\n * @param {Number} [y=0] The radius in the y direction.\n * @param {Number} [z=0] The radius in the z direction.\n *\n * @exception {DeveloperError} All radii components must be greater than or equal to zero.\n *\n * @see Ellipsoid.fromCartesian3\n * @see Ellipsoid.WGS84\n * @see Ellipsoid.UNIT_SPHERE\n */\n\n\nfunction Ellipsoid(x, y, z) {\n  this._radii = undefined;\n  this._radiiSquared = undefined;\n  this._radiiToTheFourth = undefined;\n  this._oneOverRadii = undefined;\n  this._oneOverRadiiSquared = undefined;\n  this._minimumRadius = undefined;\n  this._maximumRadius = undefined;\n  this._centerToleranceSquared = undefined;\n  this._squaredXOverSquaredZ = undefined;\n  initialize(this, x, y, z);\n}\n\nObject.defineProperties(Ellipsoid.prototype, {\n  /**\n   * Gets the radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  radii: {\n    get: function () {\n      return this._radii;\n    }\n  },\n\n  /**\n   * Gets the squared radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  radiiSquared: {\n    get: function () {\n      return this._radiiSquared;\n    }\n  },\n\n  /**\n   * Gets the radii of the ellipsoid raise to the fourth power.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  radiiToTheFourth: {\n    get: function () {\n      return this._radiiToTheFourth;\n    }\n  },\n\n  /**\n   * Gets one over the radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  oneOverRadii: {\n    get: function () {\n      return this._oneOverRadii;\n    }\n  },\n\n  /**\n   * Gets one over the squared radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  oneOverRadiiSquared: {\n    get: function () {\n      return this._oneOverRadiiSquared;\n    }\n  },\n\n  /**\n   * Gets the minimum radius of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Number}\n   * @readonly\n   */\n  minimumRadius: {\n    get: function () {\n      return this._minimumRadius;\n    }\n  },\n\n  /**\n   * Gets the maximum radius of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Number}\n   * @readonly\n   */\n  maximumRadius: {\n    get: function () {\n      return this._maximumRadius;\n    }\n  }\n});\n/**\n * Duplicates an Ellipsoid instance.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid to duplicate.\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n *                    instance should be created.\n * @returns {Ellipsoid} The cloned Ellipsoid. (Returns undefined if ellipsoid is undefined)\n */\n\nEllipsoid.clone = function (ellipsoid, result) {\n  if (!defined(ellipsoid)) {\n    return undefined;\n  }\n\n  var radii = ellipsoid._radii;\n\n  if (!defined(result)) {\n    return new Ellipsoid(radii.x, radii.y, radii.z);\n  }\n\n  Cartesian3.clone(radii, result._radii);\n  Cartesian3.clone(ellipsoid._radiiSquared, result._radiiSquared);\n  Cartesian3.clone(ellipsoid._radiiToTheFourth, result._radiiToTheFourth);\n  Cartesian3.clone(ellipsoid._oneOverRadii, result._oneOverRadii);\n  Cartesian3.clone(ellipsoid._oneOverRadiiSquared, result._oneOverRadiiSquared);\n  result._minimumRadius = ellipsoid._minimumRadius;\n  result._maximumRadius = ellipsoid._maximumRadius;\n  result._centerToleranceSquared = ellipsoid._centerToleranceSquared;\n  return result;\n};\n/**\n * Computes an Ellipsoid from a Cartesian specifying the radii in x, y, and z directions.\n *\n * @param {Cartesian3} [cartesian=Cartesian3.ZERO] The ellipsoid's radius in the x, y, and z directions.\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n *                    instance should be created.\n * @returns {Ellipsoid} A new Ellipsoid instance.\n *\n * @exception {DeveloperError} All radii components must be greater than or equal to zero.\n *\n * @see Ellipsoid.WGS84\n * @see Ellipsoid.UNIT_SPHERE\n */\n\n\nEllipsoid.fromCartesian3 = function (cartesian, result) {\n  if (!defined(result)) {\n    result = new Ellipsoid();\n  }\n\n  if (!defined(cartesian)) {\n    return result;\n  }\n\n  initialize(result, cartesian.x, cartesian.y, cartesian.z);\n  return result;\n};\n/**\n * An Ellipsoid instance initialized to the WGS84 standard.\n *\n * @type {Ellipsoid}\n * @constant\n */\n\n\nEllipsoid.WGS84 = Object.freeze(new Ellipsoid(6378137.0, 6378137.0, 6356752.3142451793));\n/**\n * An Ellipsoid instance initialized to radii of (1.0, 1.0, 1.0).\n *\n * @type {Ellipsoid}\n * @constant\n */\n\nEllipsoid.UNIT_SPHERE = Object.freeze(new Ellipsoid(1.0, 1.0, 1.0));\n/**\n * An Ellipsoid instance initialized to a sphere with the lunar radius.\n *\n * @type {Ellipsoid}\n * @constant\n */\n\nEllipsoid.MOON = Object.freeze(new Ellipsoid(CesiumMath.LUNAR_RADIUS, CesiumMath.LUNAR_RADIUS, CesiumMath.LUNAR_RADIUS));\n/**\n * Duplicates an Ellipsoid instance.\n *\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n *                    instance should be created.\n * @returns {Ellipsoid} The cloned Ellipsoid.\n */\n\nEllipsoid.prototype.clone = function (result) {\n  return Ellipsoid.clone(this, result);\n};\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\n\n\nEllipsoid.packedLength = Cartesian3.packedLength;\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Ellipsoid} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\n\nEllipsoid.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  Cartesian3.pack(value._radii, array, startingIndex);\n  return array;\n};\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Ellipsoid} [result] The object into which to store the result.\n * @returns {Ellipsoid} The modified result parameter or a new Ellipsoid instance if one was not provided.\n */\n\n\nEllipsoid.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array); //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n  var radii = Cartesian3.unpack(array, startingIndex);\n  return Ellipsoid.fromCartesian3(radii, result);\n};\n/**\n * Computes the unit vector directed from the center of this ellipsoid toward the provided Cartesian position.\n * @function\n *\n * @param {Cartesian3} cartesian The Cartesian for which to to determine the geocentric normal.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\n\n\nEllipsoid.prototype.geocentricSurfaceNormal = Cartesian3.normalize;\n/**\n * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\n *\n * @param {Cartographic} cartographic The cartographic position for which to to determine the geodetic normal.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\n\nEllipsoid.prototype.geodeticSurfaceNormalCartographic = function (cartographic, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartographic\", cartographic); //>>includeEnd('debug');\n\n  var longitude = cartographic.longitude;\n  var latitude = cartographic.latitude;\n  var cosLatitude = Math.cos(latitude);\n  var x = cosLatitude * Math.cos(longitude);\n  var y = cosLatitude * Math.sin(longitude);\n  var z = Math.sin(latitude);\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return Cartesian3.normalize(result, result);\n};\n/**\n * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\n *\n * @param {Cartesian3} cartesian The Cartesian position for which to to determine the surface normal.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided, or undefined if a normal cannot be found.\n */\n\n\nEllipsoid.prototype.geodeticSurfaceNormal = function (cartesian, result) {\n  if (Cartesian3.equalsEpsilon(cartesian, Cartesian3.ZERO, CesiumMath.EPSILON14)) {\n    return undefined;\n  }\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  result = Cartesian3.multiplyComponents(cartesian, this._oneOverRadiiSquared, result);\n  return Cartesian3.normalize(result, result);\n};\n\nvar cartographicToCartesianNormal = new Cartesian3();\nvar cartographicToCartesianK = new Cartesian3();\n/**\n * Converts the provided cartographic to Cartesian representation.\n *\n * @param {Cartographic} cartographic The cartographic position.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n *\n * @example\n * //Create a Cartographic and determine it's Cartesian representation on a WGS84 ellipsoid.\n * var position = new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 5000);\n * var cartesianPosition = Cesium.Ellipsoid.WGS84.cartographicToCartesian(position);\n */\n\nEllipsoid.prototype.cartographicToCartesian = function (cartographic, result) {\n  //`cartographic is required` is thrown from geodeticSurfaceNormalCartographic.\n  var n = cartographicToCartesianNormal;\n  var k = cartographicToCartesianK;\n  this.geodeticSurfaceNormalCartographic(cartographic, n);\n  Cartesian3.multiplyComponents(this._radiiSquared, n, k);\n  var gamma = Math.sqrt(Cartesian3.dot(n, k));\n  Cartesian3.divideByScalar(k, gamma, k);\n  Cartesian3.multiplyByScalar(n, cartographic.height, n);\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  return Cartesian3.add(k, n, result);\n};\n/**\n * Converts the provided array of cartographics to an array of Cartesians.\n *\n * @param {Cartographic[]} cartographics An array of cartographic positions.\n * @param {Cartesian3[]} [result] The object onto which to store the result.\n * @returns {Cartesian3[]} The modified result parameter or a new Array instance if none was provided.\n *\n * @example\n * //Convert an array of Cartographics and determine their Cartesian representation on a WGS84 ellipsoid.\n * var positions = [new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 0),\n *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.321), Cesium.Math.toRadians(78.123), 100),\n *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.645), Cesium.Math.toRadians(78.456), 250)];\n * var cartesianPositions = Cesium.Ellipsoid.WGS84.cartographicArrayToCartesianArray(positions);\n */\n\n\nEllipsoid.prototype.cartographicArrayToCartesianArray = function (cartographics, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartographics\", cartographics); //>>includeEnd('debug')\n\n  var length = cartographics.length;\n\n  if (!defined(result)) {\n    result = new Array(length);\n  } else {\n    result.length = length;\n  }\n\n  for (var i = 0; i < length; i++) {\n    result[i] = this.cartographicToCartesian(cartographics[i], result[i]);\n  }\n\n  return result;\n};\n\nvar cartesianToCartographicN = new Cartesian3();\nvar cartesianToCartographicP = new Cartesian3();\nvar cartesianToCartographicH = new Cartesian3();\n/**\n * Converts the provided cartesian to cartographic representation.\n * The cartesian is undefined at the center of the ellipsoid.\n *\n * @param {Cartesian3} cartesian The Cartesian position to convert to cartographic representation.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.\n *\n * @example\n * //Create a Cartesian and determine it's Cartographic representation on a WGS84 ellipsoid.\n * var position = new Cesium.Cartesian3(17832.12, 83234.52, 952313.73);\n * var cartographicPosition = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);\n */\n\nEllipsoid.prototype.cartesianToCartographic = function (cartesian, result) {\n  //`cartesian is required.` is thrown from scaleToGeodeticSurface\n  var p = this.scaleToGeodeticSurface(cartesian, cartesianToCartographicP);\n\n  if (!defined(p)) {\n    return undefined;\n  }\n\n  var n = this.geodeticSurfaceNormal(p, cartesianToCartographicN);\n  var h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH);\n  var longitude = Math.atan2(n.y, n.x);\n  var latitude = Math.asin(n.z);\n  var height = CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);\n\n  if (!defined(result)) {\n    return new Cartographic(longitude, latitude, height);\n  }\n\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = height;\n  return result;\n};\n/**\n * Converts the provided array of cartesians to an array of cartographics.\n *\n * @param {Cartesian3[]} cartesians An array of Cartesian positions.\n * @param {Cartographic[]} [result] The object onto which to store the result.\n * @returns {Cartographic[]} The modified result parameter or a new Array instance if none was provided.\n *\n * @example\n * //Create an array of Cartesians and determine their Cartographic representation on a WGS84 ellipsoid.\n * var positions = [new Cesium.Cartesian3(17832.12, 83234.52, 952313.73),\n *                  new Cesium.Cartesian3(17832.13, 83234.53, 952313.73),\n *                  new Cesium.Cartesian3(17832.14, 83234.54, 952313.73)]\n * var cartographicPositions = Cesium.Ellipsoid.WGS84.cartesianArrayToCartographicArray(positions);\n */\n\n\nEllipsoid.prototype.cartesianArrayToCartographicArray = function (cartesians, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians); //>>includeEnd('debug');\n\n  var length = cartesians.length;\n\n  if (!defined(result)) {\n    result = new Array(length);\n  } else {\n    result.length = length;\n  }\n\n  for (var i = 0; i < length; ++i) {\n    result[i] = this.cartesianToCartographic(cartesians[i], result[i]);\n  }\n\n  return result;\n};\n/**\n * Scales the provided Cartesian position along the geodetic surface normal\n * so that it is on the surface of this ellipsoid.  If the position is\n * at the center of the ellipsoid, this function returns undefined.\n *\n * @param {Cartesian3} cartesian The Cartesian position to scale.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.\n */\n\n\nEllipsoid.prototype.scaleToGeodeticSurface = function (cartesian, result) {\n  return scaleToGeodeticSurface(cartesian, this._oneOverRadii, this._oneOverRadiiSquared, this._centerToleranceSquared, result);\n};\n/**\n * Scales the provided Cartesian position along the geocentric surface normal\n * so that it is on the surface of this ellipsoid.\n *\n * @param {Cartesian3} cartesian The Cartesian position to scale.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\n\n\nEllipsoid.prototype.scaleToGeocentricSurface = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian); //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  var positionX = cartesian.x;\n  var positionY = cartesian.y;\n  var positionZ = cartesian.z;\n  var oneOverRadiiSquared = this._oneOverRadiiSquared;\n  var beta = 1.0 / Math.sqrt(positionX * positionX * oneOverRadiiSquared.x + positionY * positionY * oneOverRadiiSquared.y + positionZ * positionZ * oneOverRadiiSquared.z);\n  return Cartesian3.multiplyByScalar(cartesian, beta, result);\n};\n/**\n * Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying\n * its components by the result of {@link Ellipsoid#oneOverRadii}.\n *\n * @param {Cartesian3} position The position to transform.\n * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and\n *        return a new instance.\n * @returns {Cartesian3} The position expressed in the scaled space.  The returned instance is the\n *          one passed as the result parameter if it is not undefined, or a new instance of it is.\n */\n\n\nEllipsoid.prototype.transformPositionToScaledSpace = function (position, result) {\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  return Cartesian3.multiplyComponents(position, this._oneOverRadii, result);\n};\n/**\n * Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying\n * its components by the result of {@link Ellipsoid#radii}.\n *\n * @param {Cartesian3} position The position to transform.\n * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and\n *        return a new instance.\n * @returns {Cartesian3} The position expressed in the unscaled space.  The returned instance is the\n *          one passed as the result parameter if it is not undefined, or a new instance of it is.\n */\n\n\nEllipsoid.prototype.transformPositionFromScaledSpace = function (position, result) {\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  return Cartesian3.multiplyComponents(position, this._radii, result);\n};\n/**\n * Compares this Ellipsoid against the provided Ellipsoid componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Ellipsoid} [right] The other Ellipsoid.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\n\n\nEllipsoid.prototype.equals = function (right) {\n  return this === right || defined(right) && Cartesian3.equals(this._radii, right._radii);\n};\n/**\n * Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'.\n *\n * @returns {String} A string representing this ellipsoid in the format '(radii.x, radii.y, radii.z)'.\n */\n\n\nEllipsoid.prototype.toString = function () {\n  return this._radii.toString();\n};\n/**\n * Computes a point which is the intersection of the surface normal with the z-axis.\n *\n * @param {Cartesian3} position the position. must be on the surface of the ellipsoid.\n * @param {Number} [buffer = 0.0] A buffer to subtract from the ellipsoid size when checking if the point is inside the ellipsoid.\n *                                In earth case, with common earth datums, there is no need for this buffer since the intersection point is always (relatively) very close to the center.\n *                                In WGS84 datum, intersection point is at max z = +-42841.31151331382 (0.673% of z-axis).\n *                                Intersection point could be outside the ellipsoid if the ratio of MajorAxis / AxisOfRotation is bigger than the square root of 2\n * @param {Cartesian3} [result] The cartesian to which to copy the result, or undefined to create and\n *        return a new instance.\n * @returns {Cartesian3 | undefined} the intersection point if it's inside the ellipsoid, undefined otherwise\n *\n * @exception {DeveloperError} position is required.\n * @exception {DeveloperError} Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y).\n * @exception {DeveloperError} Ellipsoid.radii.z must be greater than 0.\n */\n\n\nEllipsoid.prototype.getSurfaceNormalIntersectionWithZAxis = function (position, buffer, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"position\", position);\n\n  if (!CesiumMath.equalsEpsilon(this._radii.x, this._radii.y, CesiumMath.EPSILON15)) {\n    throw new DeveloperError(\"Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\");\n  }\n\n  Check.typeOf.number.greaterThan(\"Ellipsoid.radii.z\", this._radii.z, 0); //>>includeEnd('debug');\n\n  buffer = defaultValue(buffer, 0.0);\n  var squaredXOverSquaredZ = this._squaredXOverSquaredZ;\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  result.x = 0.0;\n  result.y = 0.0;\n  result.z = position.z * (1 - squaredXOverSquaredZ);\n\n  if (Math.abs(result.z) >= this._radii.z - buffer) {\n    return undefined;\n  }\n\n  return result;\n};\n\nvar abscissas = [0.14887433898163, 0.43339539412925, 0.67940956829902, 0.86506336668898, 0.97390652851717, 0.0];\nvar weights = [0.29552422471475, 0.26926671930999, 0.21908636251598, 0.14945134915058, 0.066671344308684, 0.0];\n/**\n * Compute the 10th order Gauss-Legendre Quadrature of the given definite integral.\n *\n * @param {Number} a The lower bound for the integration.\n * @param {Number} b The upper bound for the integration.\n * @param {Ellipsoid~RealValuedScalarFunction} func The function to integrate.\n * @returns {Number} The value of the integral of the given function over the given domain.\n *\n * @private\n */\n\nfunction gaussLegendreQuadrature(a, b, func) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"a\", a);\n  Check.typeOf.number(\"b\", b);\n  Check.typeOf.func(\"func\", func); //>>includeEnd('debug');\n  // The range is half of the normal range since the five weights add to one (ten weights add to two).\n  // The values of the abscissas are multiplied by two to account for this.\n\n  var xMean = 0.5 * (b + a);\n  var xRange = 0.5 * (b - a);\n  var sum = 0.0;\n\n  for (var i = 0; i < 5; i++) {\n    var dx = xRange * abscissas[i];\n    sum += weights[i] * (func(xMean + dx) + func(xMean - dx));\n  } // Scale the sum to the range of x.\n\n\n  sum *= xRange;\n  return sum;\n}\n/**\n * A real valued scalar function.\n * @callback Ellipsoid~RealValuedScalarFunction\n *\n * @param {Number} x The value used to evaluate the function.\n * @returns {Number} The value of the function at x.\n *\n * @private\n */\n\n/**\n * Computes an approximation of the surface area of a rectangle on the surface of an ellipsoid using\n * Gauss-Legendre 10th order quadrature.\n *\n * @param {Rectangle} rectangle The rectangle used for computing the surface area.\n * @returns {Number} The approximate area of the rectangle on the surface of this ellipsoid.\n */\n\n\nEllipsoid.prototype.surfaceArea = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle); //>>includeEnd('debug');\n\n  var minLongitude = rectangle.west;\n  var maxLongitude = rectangle.east;\n  var minLatitude = rectangle.south;\n  var maxLatitude = rectangle.north;\n\n  while (maxLongitude < minLongitude) {\n    maxLongitude += CesiumMath.TWO_PI;\n  }\n\n  var radiiSquared = this._radiiSquared;\n  var a2 = radiiSquared.x;\n  var b2 = radiiSquared.y;\n  var c2 = radiiSquared.z;\n  var a2b2 = a2 * b2;\n  return gaussLegendreQuadrature(minLatitude, maxLatitude, function (lat) {\n    // phi represents the angle measured from the north pole\n    // sin(phi) = sin(pi / 2 - lat) = cos(lat), cos(phi) is similar\n    var sinPhi = Math.cos(lat);\n    var cosPhi = Math.sin(lat);\n    return Math.cos(lat) * gaussLegendreQuadrature(minLongitude, maxLongitude, function (lon) {\n      var cosTheta = Math.cos(lon);\n      var sinTheta = Math.sin(lon);\n      return Math.sqrt(a2b2 * cosPhi * cosPhi + c2 * (b2 * cosTheta * cosTheta + a2 * sinTheta * sinTheta) * sinPhi * sinPhi);\n    });\n  });\n};\n\nexport default Ellipsoid;","map":{"version":3,"sources":["/home/usuario/davi/thalamus/wms/3dmaptestes/leaflet_cesium/client/node_modules/cesium/Source/Core/Ellipsoid.js"],"names":["Cartesian3","Cartographic","Check","defaultValue","defined","DeveloperError","CesiumMath","scaleToGeodeticSurface","initialize","ellipsoid","x","y","z","typeOf","number","greaterThanOrEquals","_radii","_radiiSquared","_radiiToTheFourth","_oneOverRadii","_oneOverRadiiSquared","_minimumRadius","Math","min","_maximumRadius","max","_centerToleranceSquared","EPSILON1","_squaredXOverSquaredZ","Ellipsoid","undefined","Object","defineProperties","prototype","radii","get","radiiSquared","radiiToTheFourth","oneOverRadii","oneOverRadiiSquared","minimumRadius","maximumRadius","clone","result","fromCartesian3","cartesian","WGS84","freeze","UNIT_SPHERE","MOON","LUNAR_RADIUS","packedLength","pack","value","array","startingIndex","object","unpack","geocentricSurfaceNormal","normalize","geodeticSurfaceNormalCartographic","cartographic","longitude","latitude","cosLatitude","cos","sin","geodeticSurfaceNormal","equalsEpsilon","ZERO","EPSILON14","multiplyComponents","cartographicToCartesianNormal","cartographicToCartesianK","cartographicToCartesian","n","k","gamma","sqrt","dot","divideByScalar","multiplyByScalar","height","add","cartographicArrayToCartesianArray","cartographics","length","Array","i","cartesianToCartographicN","cartesianToCartographicP","cartesianToCartographicH","cartesianToCartographic","p","h","subtract","atan2","asin","sign","magnitude","cartesianArrayToCartographicArray","cartesians","scaleToGeocentricSurface","positionX","positionY","positionZ","beta","transformPositionToScaledSpace","position","transformPositionFromScaledSpace","equals","right","toString","getSurfaceNormalIntersectionWithZAxis","buffer","EPSILON15","greaterThan","squaredXOverSquaredZ","abs","abscissas","weights","gaussLegendreQuadrature","a","b","func","xMean","xRange","sum","dx","surfaceArea","rectangle","minLongitude","west","maxLongitude","east","minLatitude","south","maxLatitude","north","TWO_PI","a2","b2","c2","a2b2","lat","sinPhi","cosPhi","lon","cosTheta","sinTheta"],"mappings":"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","sourcesContent":["import Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport Check from \"./Check.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport CesiumMath from \"./Math.js\";\nimport scaleToGeodeticSurface from \"./scaleToGeodeticSurface.js\";\n\nfunction initialize(ellipsoid, x, y, z) {\n  x = defaultValue(x, 0.0);\n  y = defaultValue(y, 0.0);\n  z = defaultValue(z, 0.0);\n\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number.greaterThanOrEquals(\"x\", x, 0.0);\n  Check.typeOf.number.greaterThanOrEquals(\"y\", y, 0.0);\n  Check.typeOf.number.greaterThanOrEquals(\"z\", z, 0.0);\n  //>>includeEnd('debug');\n\n  ellipsoid._radii = new Cartesian3(x, y, z);\n\n  ellipsoid._radiiSquared = new Cartesian3(x * x, y * y, z * z);\n\n  ellipsoid._radiiToTheFourth = new Cartesian3(\n    x * x * x * x,\n    y * y * y * y,\n    z * z * z * z\n  );\n\n  ellipsoid._oneOverRadii = new Cartesian3(\n    x === 0.0 ? 0.0 : 1.0 / x,\n    y === 0.0 ? 0.0 : 1.0 / y,\n    z === 0.0 ? 0.0 : 1.0 / z\n  );\n\n  ellipsoid._oneOverRadiiSquared = new Cartesian3(\n    x === 0.0 ? 0.0 : 1.0 / (x * x),\n    y === 0.0 ? 0.0 : 1.0 / (y * y),\n    z === 0.0 ? 0.0 : 1.0 / (z * z)\n  );\n\n  ellipsoid._minimumRadius = Math.min(x, y, z);\n\n  ellipsoid._maximumRadius = Math.max(x, y, z);\n\n  ellipsoid._centerToleranceSquared = CesiumMath.EPSILON1;\n\n  if (ellipsoid._radiiSquared.z !== 0) {\n    ellipsoid._squaredXOverSquaredZ =\n      ellipsoid._radiiSquared.x / ellipsoid._radiiSquared.z;\n  }\n}\n\n/**\n * A quadratic surface defined in Cartesian coordinates by the equation\n * <code>(x / a)^2 + (y / b)^2 + (z / c)^2 = 1</code>.  Primarily used\n * by Cesium to represent the shape of planetary bodies.\n *\n * Rather than constructing this object directly, one of the provided\n * constants is normally used.\n * @alias Ellipsoid\n * @constructor\n *\n * @param {Number} [x=0] The radius in the x direction.\n * @param {Number} [y=0] The radius in the y direction.\n * @param {Number} [z=0] The radius in the z direction.\n *\n * @exception {DeveloperError} All radii components must be greater than or equal to zero.\n *\n * @see Ellipsoid.fromCartesian3\n * @see Ellipsoid.WGS84\n * @see Ellipsoid.UNIT_SPHERE\n */\nfunction Ellipsoid(x, y, z) {\n  this._radii = undefined;\n  this._radiiSquared = undefined;\n  this._radiiToTheFourth = undefined;\n  this._oneOverRadii = undefined;\n  this._oneOverRadiiSquared = undefined;\n  this._minimumRadius = undefined;\n  this._maximumRadius = undefined;\n  this._centerToleranceSquared = undefined;\n  this._squaredXOverSquaredZ = undefined;\n\n  initialize(this, x, y, z);\n}\n\nObject.defineProperties(Ellipsoid.prototype, {\n  /**\n   * Gets the radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  radii: {\n    get: function () {\n      return this._radii;\n    },\n  },\n  /**\n   * Gets the squared radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  radiiSquared: {\n    get: function () {\n      return this._radiiSquared;\n    },\n  },\n  /**\n   * Gets the radii of the ellipsoid raise to the fourth power.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  radiiToTheFourth: {\n    get: function () {\n      return this._radiiToTheFourth;\n    },\n  },\n  /**\n   * Gets one over the radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  oneOverRadii: {\n    get: function () {\n      return this._oneOverRadii;\n    },\n  },\n  /**\n   * Gets one over the squared radii of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Cartesian3}\n   * @readonly\n   */\n  oneOverRadiiSquared: {\n    get: function () {\n      return this._oneOverRadiiSquared;\n    },\n  },\n  /**\n   * Gets the minimum radius of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Number}\n   * @readonly\n   */\n  minimumRadius: {\n    get: function () {\n      return this._minimumRadius;\n    },\n  },\n  /**\n   * Gets the maximum radius of the ellipsoid.\n   * @memberof Ellipsoid.prototype\n   * @type {Number}\n   * @readonly\n   */\n  maximumRadius: {\n    get: function () {\n      return this._maximumRadius;\n    },\n  },\n});\n\n/**\n * Duplicates an Ellipsoid instance.\n *\n * @param {Ellipsoid} ellipsoid The ellipsoid to duplicate.\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n *                    instance should be created.\n * @returns {Ellipsoid} The cloned Ellipsoid. (Returns undefined if ellipsoid is undefined)\n */\nEllipsoid.clone = function (ellipsoid, result) {\n  if (!defined(ellipsoid)) {\n    return undefined;\n  }\n  var radii = ellipsoid._radii;\n\n  if (!defined(result)) {\n    return new Ellipsoid(radii.x, radii.y, radii.z);\n  }\n\n  Cartesian3.clone(radii, result._radii);\n  Cartesian3.clone(ellipsoid._radiiSquared, result._radiiSquared);\n  Cartesian3.clone(ellipsoid._radiiToTheFourth, result._radiiToTheFourth);\n  Cartesian3.clone(ellipsoid._oneOverRadii, result._oneOverRadii);\n  Cartesian3.clone(ellipsoid._oneOverRadiiSquared, result._oneOverRadiiSquared);\n  result._minimumRadius = ellipsoid._minimumRadius;\n  result._maximumRadius = ellipsoid._maximumRadius;\n  result._centerToleranceSquared = ellipsoid._centerToleranceSquared;\n\n  return result;\n};\n\n/**\n * Computes an Ellipsoid from a Cartesian specifying the radii in x, y, and z directions.\n *\n * @param {Cartesian3} [cartesian=Cartesian3.ZERO] The ellipsoid's radius in the x, y, and z directions.\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n *                    instance should be created.\n * @returns {Ellipsoid} A new Ellipsoid instance.\n *\n * @exception {DeveloperError} All radii components must be greater than or equal to zero.\n *\n * @see Ellipsoid.WGS84\n * @see Ellipsoid.UNIT_SPHERE\n */\nEllipsoid.fromCartesian3 = function (cartesian, result) {\n  if (!defined(result)) {\n    result = new Ellipsoid();\n  }\n\n  if (!defined(cartesian)) {\n    return result;\n  }\n\n  initialize(result, cartesian.x, cartesian.y, cartesian.z);\n  return result;\n};\n\n/**\n * An Ellipsoid instance initialized to the WGS84 standard.\n *\n * @type {Ellipsoid}\n * @constant\n */\nEllipsoid.WGS84 = Object.freeze(\n  new Ellipsoid(6378137.0, 6378137.0, 6356752.3142451793)\n);\n\n/**\n * An Ellipsoid instance initialized to radii of (1.0, 1.0, 1.0).\n *\n * @type {Ellipsoid}\n * @constant\n */\nEllipsoid.UNIT_SPHERE = Object.freeze(new Ellipsoid(1.0, 1.0, 1.0));\n\n/**\n * An Ellipsoid instance initialized to a sphere with the lunar radius.\n *\n * @type {Ellipsoid}\n * @constant\n */\nEllipsoid.MOON = Object.freeze(\n  new Ellipsoid(\n    CesiumMath.LUNAR_RADIUS,\n    CesiumMath.LUNAR_RADIUS,\n    CesiumMath.LUNAR_RADIUS\n  )\n);\n\n/**\n * Duplicates an Ellipsoid instance.\n *\n * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new\n *                    instance should be created.\n * @returns {Ellipsoid} The cloned Ellipsoid.\n */\nEllipsoid.prototype.clone = function (result) {\n  return Ellipsoid.clone(this, result);\n};\n\n/**\n * The number of elements used to pack the object into an array.\n * @type {Number}\n */\nEllipsoid.packedLength = Cartesian3.packedLength;\n\n/**\n * Stores the provided instance into the provided array.\n *\n * @param {Ellipsoid} value The value to pack.\n * @param {Number[]} array The array to pack into.\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n *\n * @returns {Number[]} The array that was packed into\n */\nEllipsoid.pack = function (value, array, startingIndex) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"value\", value);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  Cartesian3.pack(value._radii, array, startingIndex);\n\n  return array;\n};\n\n/**\n * Retrieves an instance from a packed array.\n *\n * @param {Number[]} array The packed array.\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n * @param {Ellipsoid} [result] The object into which to store the result.\n * @returns {Ellipsoid} The modified result parameter or a new Ellipsoid instance if one was not provided.\n */\nEllipsoid.unpack = function (array, startingIndex, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"array\", array);\n  //>>includeEnd('debug');\n\n  startingIndex = defaultValue(startingIndex, 0);\n\n  var radii = Cartesian3.unpack(array, startingIndex);\n  return Ellipsoid.fromCartesian3(radii, result);\n};\n\n/**\n * Computes the unit vector directed from the center of this ellipsoid toward the provided Cartesian position.\n * @function\n *\n * @param {Cartesian3} cartesian The Cartesian for which to to determine the geocentric normal.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoid.prototype.geocentricSurfaceNormal = Cartesian3.normalize;\n\n/**\n * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\n *\n * @param {Cartographic} cartographic The cartographic position for which to to determine the geodetic normal.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoid.prototype.geodeticSurfaceNormalCartographic = function (\n  cartographic,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartographic\", cartographic);\n  //>>includeEnd('debug');\n\n  var longitude = cartographic.longitude;\n  var latitude = cartographic.latitude;\n  var cosLatitude = Math.cos(latitude);\n\n  var x = cosLatitude * Math.cos(longitude);\n  var y = cosLatitude * Math.sin(longitude);\n  var z = Math.sin(latitude);\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  result.x = x;\n  result.y = y;\n  result.z = z;\n  return Cartesian3.normalize(result, result);\n};\n\n/**\n * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\n *\n * @param {Cartesian3} cartesian The Cartesian position for which to to determine the surface normal.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided, or undefined if a normal cannot be found.\n */\nEllipsoid.prototype.geodeticSurfaceNormal = function (cartesian, result) {\n  if (\n    Cartesian3.equalsEpsilon(cartesian, Cartesian3.ZERO, CesiumMath.EPSILON14)\n  ) {\n    return undefined;\n  }\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  result = Cartesian3.multiplyComponents(\n    cartesian,\n    this._oneOverRadiiSquared,\n    result\n  );\n  return Cartesian3.normalize(result, result);\n};\n\nvar cartographicToCartesianNormal = new Cartesian3();\nvar cartographicToCartesianK = new Cartesian3();\n\n/**\n * Converts the provided cartographic to Cartesian representation.\n *\n * @param {Cartographic} cartographic The cartographic position.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n *\n * @example\n * //Create a Cartographic and determine it's Cartesian representation on a WGS84 ellipsoid.\n * var position = new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 5000);\n * var cartesianPosition = Cesium.Ellipsoid.WGS84.cartographicToCartesian(position);\n */\nEllipsoid.prototype.cartographicToCartesian = function (cartographic, result) {\n  //`cartographic is required` is thrown from geodeticSurfaceNormalCartographic.\n  var n = cartographicToCartesianNormal;\n  var k = cartographicToCartesianK;\n  this.geodeticSurfaceNormalCartographic(cartographic, n);\n  Cartesian3.multiplyComponents(this._radiiSquared, n, k);\n  var gamma = Math.sqrt(Cartesian3.dot(n, k));\n  Cartesian3.divideByScalar(k, gamma, k);\n  Cartesian3.multiplyByScalar(n, cartographic.height, n);\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n  return Cartesian3.add(k, n, result);\n};\n\n/**\n * Converts the provided array of cartographics to an array of Cartesians.\n *\n * @param {Cartographic[]} cartographics An array of cartographic positions.\n * @param {Cartesian3[]} [result] The object onto which to store the result.\n * @returns {Cartesian3[]} The modified result parameter or a new Array instance if none was provided.\n *\n * @example\n * //Convert an array of Cartographics and determine their Cartesian representation on a WGS84 ellipsoid.\n * var positions = [new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 0),\n *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.321), Cesium.Math.toRadians(78.123), 100),\n *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.645), Cesium.Math.toRadians(78.456), 250)];\n * var cartesianPositions = Cesium.Ellipsoid.WGS84.cartographicArrayToCartesianArray(positions);\n */\nEllipsoid.prototype.cartographicArrayToCartesianArray = function (\n  cartographics,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartographics\", cartographics);\n  //>>includeEnd('debug')\n\n  var length = cartographics.length;\n  if (!defined(result)) {\n    result = new Array(length);\n  } else {\n    result.length = length;\n  }\n  for (var i = 0; i < length; i++) {\n    result[i] = this.cartographicToCartesian(cartographics[i], result[i]);\n  }\n  return result;\n};\n\nvar cartesianToCartographicN = new Cartesian3();\nvar cartesianToCartographicP = new Cartesian3();\nvar cartesianToCartographicH = new Cartesian3();\n\n/**\n * Converts the provided cartesian to cartographic representation.\n * The cartesian is undefined at the center of the ellipsoid.\n *\n * @param {Cartesian3} cartesian The Cartesian position to convert to cartographic representation.\n * @param {Cartographic} [result] The object onto which to store the result.\n * @returns {Cartographic} The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.\n *\n * @example\n * //Create a Cartesian and determine it's Cartographic representation on a WGS84 ellipsoid.\n * var position = new Cesium.Cartesian3(17832.12, 83234.52, 952313.73);\n * var cartographicPosition = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);\n */\nEllipsoid.prototype.cartesianToCartographic = function (cartesian, result) {\n  //`cartesian is required.` is thrown from scaleToGeodeticSurface\n  var p = this.scaleToGeodeticSurface(cartesian, cartesianToCartographicP);\n\n  if (!defined(p)) {\n    return undefined;\n  }\n\n  var n = this.geodeticSurfaceNormal(p, cartesianToCartographicN);\n  var h = Cartesian3.subtract(cartesian, p, cartesianToCartographicH);\n\n  var longitude = Math.atan2(n.y, n.x);\n  var latitude = Math.asin(n.z);\n  var height =\n    CesiumMath.sign(Cartesian3.dot(h, cartesian)) * Cartesian3.magnitude(h);\n\n  if (!defined(result)) {\n    return new Cartographic(longitude, latitude, height);\n  }\n  result.longitude = longitude;\n  result.latitude = latitude;\n  result.height = height;\n  return result;\n};\n\n/**\n * Converts the provided array of cartesians to an array of cartographics.\n *\n * @param {Cartesian3[]} cartesians An array of Cartesian positions.\n * @param {Cartographic[]} [result] The object onto which to store the result.\n * @returns {Cartographic[]} The modified result parameter or a new Array instance if none was provided.\n *\n * @example\n * //Create an array of Cartesians and determine their Cartographic representation on a WGS84 ellipsoid.\n * var positions = [new Cesium.Cartesian3(17832.12, 83234.52, 952313.73),\n *                  new Cesium.Cartesian3(17832.13, 83234.53, 952313.73),\n *                  new Cesium.Cartesian3(17832.14, 83234.54, 952313.73)]\n * var cartographicPositions = Cesium.Ellipsoid.WGS84.cartesianArrayToCartographicArray(positions);\n */\nEllipsoid.prototype.cartesianArrayToCartographicArray = function (\n  cartesians,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"cartesians\", cartesians);\n  //>>includeEnd('debug');\n\n  var length = cartesians.length;\n  if (!defined(result)) {\n    result = new Array(length);\n  } else {\n    result.length = length;\n  }\n  for (var i = 0; i < length; ++i) {\n    result[i] = this.cartesianToCartographic(cartesians[i], result[i]);\n  }\n  return result;\n};\n\n/**\n * Scales the provided Cartesian position along the geodetic surface normal\n * so that it is on the surface of this ellipsoid.  If the position is\n * at the center of the ellipsoid, this function returns undefined.\n *\n * @param {Cartesian3} cartesian The Cartesian position to scale.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.\n */\nEllipsoid.prototype.scaleToGeodeticSurface = function (cartesian, result) {\n  return scaleToGeodeticSurface(\n    cartesian,\n    this._oneOverRadii,\n    this._oneOverRadiiSquared,\n    this._centerToleranceSquared,\n    result\n  );\n};\n\n/**\n * Scales the provided Cartesian position along the geocentric surface normal\n * so that it is on the surface of this ellipsoid.\n *\n * @param {Cartesian3} cartesian The Cartesian position to scale.\n * @param {Cartesian3} [result] The object onto which to store the result.\n * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.\n */\nEllipsoid.prototype.scaleToGeocentricSurface = function (cartesian, result) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"cartesian\", cartesian);\n  //>>includeEnd('debug');\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  var positionX = cartesian.x;\n  var positionY = cartesian.y;\n  var positionZ = cartesian.z;\n  var oneOverRadiiSquared = this._oneOverRadiiSquared;\n\n  var beta =\n    1.0 /\n    Math.sqrt(\n      positionX * positionX * oneOverRadiiSquared.x +\n        positionY * positionY * oneOverRadiiSquared.y +\n        positionZ * positionZ * oneOverRadiiSquared.z\n    );\n\n  return Cartesian3.multiplyByScalar(cartesian, beta, result);\n};\n\n/**\n * Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying\n * its components by the result of {@link Ellipsoid#oneOverRadii}.\n *\n * @param {Cartesian3} position The position to transform.\n * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and\n *        return a new instance.\n * @returns {Cartesian3} The position expressed in the scaled space.  The returned instance is the\n *          one passed as the result parameter if it is not undefined, or a new instance of it is.\n */\nEllipsoid.prototype.transformPositionToScaledSpace = function (\n  position,\n  result\n) {\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  return Cartesian3.multiplyComponents(position, this._oneOverRadii, result);\n};\n\n/**\n * Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying\n * its components by the result of {@link Ellipsoid#radii}.\n *\n * @param {Cartesian3} position The position to transform.\n * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and\n *        return a new instance.\n * @returns {Cartesian3} The position expressed in the unscaled space.  The returned instance is the\n *          one passed as the result parameter if it is not undefined, or a new instance of it is.\n */\nEllipsoid.prototype.transformPositionFromScaledSpace = function (\n  position,\n  result\n) {\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  return Cartesian3.multiplyComponents(position, this._radii, result);\n};\n\n/**\n * Compares this Ellipsoid against the provided Ellipsoid componentwise and returns\n * <code>true</code> if they are equal, <code>false</code> otherwise.\n *\n * @param {Ellipsoid} [right] The other Ellipsoid.\n * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n */\nEllipsoid.prototype.equals = function (right) {\n  return (\n    this === right ||\n    (defined(right) && Cartesian3.equals(this._radii, right._radii))\n  );\n};\n\n/**\n * Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'.\n *\n * @returns {String} A string representing this ellipsoid in the format '(radii.x, radii.y, radii.z)'.\n */\nEllipsoid.prototype.toString = function () {\n  return this._radii.toString();\n};\n\n/**\n * Computes a point which is the intersection of the surface normal with the z-axis.\n *\n * @param {Cartesian3} position the position. must be on the surface of the ellipsoid.\n * @param {Number} [buffer = 0.0] A buffer to subtract from the ellipsoid size when checking if the point is inside the ellipsoid.\n *                                In earth case, with common earth datums, there is no need for this buffer since the intersection point is always (relatively) very close to the center.\n *                                In WGS84 datum, intersection point is at max z = +-42841.31151331382 (0.673% of z-axis).\n *                                Intersection point could be outside the ellipsoid if the ratio of MajorAxis / AxisOfRotation is bigger than the square root of 2\n * @param {Cartesian3} [result] The cartesian to which to copy the result, or undefined to create and\n *        return a new instance.\n * @returns {Cartesian3 | undefined} the intersection point if it's inside the ellipsoid, undefined otherwise\n *\n * @exception {DeveloperError} position is required.\n * @exception {DeveloperError} Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y).\n * @exception {DeveloperError} Ellipsoid.radii.z must be greater than 0.\n */\nEllipsoid.prototype.getSurfaceNormalIntersectionWithZAxis = function (\n  position,\n  buffer,\n  result\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"position\", position);\n\n  if (\n    !CesiumMath.equalsEpsilon(\n      this._radii.x,\n      this._radii.y,\n      CesiumMath.EPSILON15\n    )\n  ) {\n    throw new DeveloperError(\n      \"Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\"\n    );\n  }\n\n  Check.typeOf.number.greaterThan(\"Ellipsoid.radii.z\", this._radii.z, 0);\n  //>>includeEnd('debug');\n\n  buffer = defaultValue(buffer, 0.0);\n\n  var squaredXOverSquaredZ = this._squaredXOverSquaredZ;\n\n  if (!defined(result)) {\n    result = new Cartesian3();\n  }\n\n  result.x = 0.0;\n  result.y = 0.0;\n  result.z = position.z * (1 - squaredXOverSquaredZ);\n\n  if (Math.abs(result.z) >= this._radii.z - buffer) {\n    return undefined;\n  }\n\n  return result;\n};\n\nvar abscissas = [\n  0.14887433898163,\n  0.43339539412925,\n  0.67940956829902,\n  0.86506336668898,\n  0.97390652851717,\n  0.0,\n];\nvar weights = [\n  0.29552422471475,\n  0.26926671930999,\n  0.21908636251598,\n  0.14945134915058,\n  0.066671344308684,\n  0.0,\n];\n\n/**\n * Compute the 10th order Gauss-Legendre Quadrature of the given definite integral.\n *\n * @param {Number} a The lower bound for the integration.\n * @param {Number} b The upper bound for the integration.\n * @param {Ellipsoid~RealValuedScalarFunction} func The function to integrate.\n * @returns {Number} The value of the integral of the given function over the given domain.\n *\n * @private\n */\nfunction gaussLegendreQuadrature(a, b, func) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.number(\"a\", a);\n  Check.typeOf.number(\"b\", b);\n  Check.typeOf.func(\"func\", func);\n  //>>includeEnd('debug');\n\n  // The range is half of the normal range since the five weights add to one (ten weights add to two).\n  // The values of the abscissas are multiplied by two to account for this.\n  var xMean = 0.5 * (b + a);\n  var xRange = 0.5 * (b - a);\n\n  var sum = 0.0;\n  for (var i = 0; i < 5; i++) {\n    var dx = xRange * abscissas[i];\n    sum += weights[i] * (func(xMean + dx) + func(xMean - dx));\n  }\n\n  // Scale the sum to the range of x.\n  sum *= xRange;\n  return sum;\n}\n\n/**\n * A real valued scalar function.\n * @callback Ellipsoid~RealValuedScalarFunction\n *\n * @param {Number} x The value used to evaluate the function.\n * @returns {Number} The value of the function at x.\n *\n * @private\n */\n\n/**\n * Computes an approximation of the surface area of a rectangle on the surface of an ellipsoid using\n * Gauss-Legendre 10th order quadrature.\n *\n * @param {Rectangle} rectangle The rectangle used for computing the surface area.\n * @returns {Number} The approximate area of the rectangle on the surface of this ellipsoid.\n */\nEllipsoid.prototype.surfaceArea = function (rectangle) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.object(\"rectangle\", rectangle);\n  //>>includeEnd('debug');\n  var minLongitude = rectangle.west;\n  var maxLongitude = rectangle.east;\n  var minLatitude = rectangle.south;\n  var maxLatitude = rectangle.north;\n\n  while (maxLongitude < minLongitude) {\n    maxLongitude += CesiumMath.TWO_PI;\n  }\n\n  var radiiSquared = this._radiiSquared;\n  var a2 = radiiSquared.x;\n  var b2 = radiiSquared.y;\n  var c2 = radiiSquared.z;\n  var a2b2 = a2 * b2;\n  return gaussLegendreQuadrature(minLatitude, maxLatitude, function (lat) {\n    // phi represents the angle measured from the north pole\n    // sin(phi) = sin(pi / 2 - lat) = cos(lat), cos(phi) is similar\n    var sinPhi = Math.cos(lat);\n    var cosPhi = Math.sin(lat);\n    return (\n      Math.cos(lat) *\n      gaussLegendreQuadrature(minLongitude, maxLongitude, function (lon) {\n        var cosTheta = Math.cos(lon);\n        var sinTheta = Math.sin(lon);\n        return Math.sqrt(\n          a2b2 * cosPhi * cosPhi +\n            c2 *\n              (b2 * cosTheta * cosTheta + a2 * sinTheta * sinTheta) *\n              sinPhi *\n              sinPhi\n        );\n      })\n    );\n  });\n};\n\nexport default Ellipsoid;\n"]},"metadata":{},"sourceType":"module"}