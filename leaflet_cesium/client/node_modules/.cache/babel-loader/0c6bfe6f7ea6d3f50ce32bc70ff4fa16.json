{"ast":null,"code":"import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport CullingVolume from \"../Core/CullingVolume.js\";\nimport defined from \"../Core/defined.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport Interval from \"../Core/Interval.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport ClearCommand from \"../Renderer/ClearCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport PassState from \"../Renderer/PassState.js\";\nimport Camera from \"./Camera.js\";\nimport FrustumCommands from \"./FrustumCommands.js\";\nimport GlobeDepth from \"./GlobeDepth.js\";\nimport GlobeTranslucencyFramebuffer from \"./GlobeTranslucencyFramebuffer.js\";\nimport OIT from \"./OIT.js\";\nimport PickDepthFramebuffer from \"./PickDepthFramebuffer.js\";\nimport PickFramebuffer from \"./PickFramebuffer.js\";\nimport SceneFramebuffer from \"./SceneFramebuffer.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMap from \"./ShadowMap.js\";\n\nfunction CommandExtent() {\n  this.command = undefined;\n  this.near = undefined;\n  this.far = undefined;\n}\n/**\n * @private\n */\n\n\nfunction View(scene, camera, viewport) {\n  var context = scene.context;\n  var globeDepth;\n\n  if (context.depthTexture) {\n    globeDepth = new GlobeDepth();\n  }\n\n  var oit;\n\n  if (scene._useOIT && context.depthTexture) {\n    oit = new OIT(context);\n  }\n\n  var passState = new PassState(context);\n  passState.viewport = BoundingRectangle.clone(viewport);\n  this.camera = camera;\n  this._cameraClone = Camera.clone(camera);\n  this._cameraStartFired = false;\n  this._cameraMovedTime = undefined;\n  this.viewport = viewport;\n  this.passState = passState;\n  this.pickFramebuffer = new PickFramebuffer(context);\n  this.pickDepthFramebuffer = new PickDepthFramebuffer();\n  this.sceneFramebuffer = new SceneFramebuffer();\n  this.globeDepth = globeDepth;\n  this.globeTranslucencyFramebuffer = new GlobeTranslucencyFramebuffer();\n  this.oit = oit;\n  this.pickDepths = [];\n  this.debugGlobeDepths = [];\n  this.frustumCommandsList = [];\n  this.debugFrustumStatistics = undefined; // Array of all commands that get rendered into frustums along with their near / far values.\n  // Acts similar to a ManagedArray.\n\n  this._commandExtents = [];\n}\n\nvar scratchPosition0 = new Cartesian3();\nvar scratchPosition1 = new Cartesian3();\n\nfunction maxComponent(a, b) {\n  var x = Math.max(Math.abs(a.x), Math.abs(b.x));\n  var y = Math.max(Math.abs(a.y), Math.abs(b.y));\n  var z = Math.max(Math.abs(a.z), Math.abs(b.z));\n  return Math.max(Math.max(x, y), z);\n}\n\nfunction cameraEqual(camera0, camera1, epsilon) {\n  var scalar = 1 / Math.max(1, maxComponent(camera0.position, camera1.position));\n  Cartesian3.multiplyByScalar(camera0.position, scalar, scratchPosition0);\n  Cartesian3.multiplyByScalar(camera1.position, scalar, scratchPosition1);\n  return Cartesian3.equalsEpsilon(scratchPosition0, scratchPosition1, epsilon) && Cartesian3.equalsEpsilon(camera0.direction, camera1.direction, epsilon) && Cartesian3.equalsEpsilon(camera0.up, camera1.up, epsilon) && Cartesian3.equalsEpsilon(camera0.right, camera1.right, epsilon) && Matrix4.equalsEpsilon(camera0.transform, camera1.transform, epsilon) && camera0.frustum.equalsEpsilon(camera1.frustum, epsilon);\n}\n\nView.prototype.checkForCameraUpdates = function (scene) {\n  var camera = this.camera;\n  var cameraClone = this._cameraClone;\n\n  if (!cameraEqual(camera, cameraClone, CesiumMath.EPSILON15)) {\n    if (!this._cameraStartFired) {\n      camera.moveStart.raiseEvent();\n      this._cameraStartFired = true;\n    }\n\n    this._cameraMovedTime = getTimestamp();\n    Camera.clone(camera, cameraClone);\n    return true;\n  }\n\n  if (this._cameraStartFired && getTimestamp() - this._cameraMovedTime > scene.cameraEventWaitTime) {\n    camera.moveEnd.raiseEvent();\n    this._cameraStartFired = false;\n  }\n\n  return false;\n};\n\nfunction updateFrustums(view, scene, near, far) {\n  var frameState = scene.frameState;\n  var camera = frameState.camera;\n  var farToNearRatio = frameState.useLogDepth ? scene.logarithmicDepthFarToNearRatio : scene.farToNearRatio;\n  var is2D = scene.mode === SceneMode.SCENE2D;\n  var nearToFarDistance2D = scene.nearToFarDistance2D; // Extend the far plane slightly further to prevent geometry clipping against the far plane.\n\n  far *= 1.0 + CesiumMath.EPSILON2; // The computed near plane must be between the user defined near and far planes.\n  // The computed far plane must between the user defined far and computed near.\n  // This will handle the case where the computed near plane is further than the user defined far plane.\n\n  near = Math.min(Math.max(near, camera.frustum.near), camera.frustum.far);\n  far = Math.max(Math.min(far, camera.frustum.far), near);\n  var numFrustums;\n\n  if (is2D) {\n    // The multifrustum for 2D is uniformly distributed. To avoid z-fighting in 2D,\n    // the camera is moved to just before the frustum and the frustum depth is scaled\n    // to be in [1.0, nearToFarDistance2D].\n    far = Math.min(far, camera.position.z + scene.nearToFarDistance2D);\n    near = Math.min(near, far);\n    numFrustums = Math.ceil(Math.max(1.0, far - near) / scene.nearToFarDistance2D);\n  } else {\n    // The multifrustum for 3D/CV is non-uniformly distributed.\n    numFrustums = Math.ceil(Math.log(far / near) / Math.log(farToNearRatio));\n  }\n\n  var frustumCommandsList = view.frustumCommandsList;\n  frustumCommandsList.length = numFrustums;\n\n  for (var m = 0; m < numFrustums; ++m) {\n    var curNear;\n    var curFar;\n\n    if (is2D) {\n      curNear = Math.min(far - nearToFarDistance2D, near + m * nearToFarDistance2D);\n      curFar = Math.min(far, curNear + nearToFarDistance2D);\n    } else {\n      curNear = Math.max(near, Math.pow(farToNearRatio, m) * near);\n      curFar = Math.min(far, farToNearRatio * curNear);\n    }\n\n    var frustumCommands = frustumCommandsList[m];\n\n    if (!defined(frustumCommands)) {\n      frustumCommands = frustumCommandsList[m] = new FrustumCommands(curNear, curFar);\n    } else {\n      frustumCommands.near = curNear;\n      frustumCommands.far = curFar;\n    }\n  }\n}\n\nfunction insertIntoBin(view, scene, command, commandNear, commandFar) {\n  if (scene.debugShowFrustums) {\n    command.debugOverlappingFrustums = 0;\n  }\n\n  var frustumCommandsList = view.frustumCommandsList;\n  var length = frustumCommandsList.length;\n\n  for (var i = 0; i < length; ++i) {\n    var frustumCommands = frustumCommandsList[i];\n    var curNear = frustumCommands.near;\n    var curFar = frustumCommands.far;\n\n    if (commandNear > curFar) {\n      continue;\n    }\n\n    if (commandFar < curNear) {\n      break;\n    }\n\n    var pass = command.pass;\n    var index = frustumCommands.indices[pass]++;\n    frustumCommands.commands[pass][index] = command;\n\n    if (scene.debugShowFrustums) {\n      command.debugOverlappingFrustums |= 1 << i;\n    }\n\n    if (command.executeInClosestFrustum) {\n      break;\n    }\n  }\n\n  if (scene.debugShowFrustums) {\n    var cf = view.debugFrustumStatistics.commandsInFrustums;\n    cf[command.debugOverlappingFrustums] = defined(cf[command.debugOverlappingFrustums]) ? cf[command.debugOverlappingFrustums] + 1 : 1;\n    ++view.debugFrustumStatistics.totalCommands;\n  }\n\n  scene.updateDerivedCommands(command);\n}\n\nvar scratchCullingVolume = new CullingVolume();\nvar scratchNearFarInterval = new Interval();\n\nView.prototype.createPotentiallyVisibleSet = function (scene) {\n  var frameState = scene.frameState;\n  var camera = frameState.camera;\n  var direction = camera.directionWC;\n  var position = camera.positionWC;\n  var computeList = scene._computeCommandList;\n  var overlayList = scene._overlayCommandList;\n  var commandList = frameState.commandList;\n\n  if (scene.debugShowFrustums) {\n    this.debugFrustumStatistics = {\n      totalCommands: 0,\n      commandsInFrustums: {}\n    };\n  }\n\n  var frustumCommandsList = this.frustumCommandsList;\n  var numberOfFrustums = frustumCommandsList.length;\n  var numberOfPasses = Pass.NUMBER_OF_PASSES;\n\n  for (var n = 0; n < numberOfFrustums; ++n) {\n    for (var p = 0; p < numberOfPasses; ++p) {\n      frustumCommandsList[n].indices[p] = 0;\n    }\n  }\n\n  computeList.length = 0;\n  overlayList.length = 0;\n  var commandExtents = this._commandExtents;\n  var commandExtentCapacity = commandExtents.length;\n  var commandExtentCount = 0;\n  var near = +Number.MAX_VALUE;\n  var far = -Number.MAX_VALUE;\n  var shadowsEnabled = frameState.shadowState.shadowsEnabled;\n  var shadowNear = +Number.MAX_VALUE;\n  var shadowFar = -Number.MAX_VALUE;\n  var shadowClosestObjectSize = Number.MAX_VALUE;\n  var occluder = frameState.mode === SceneMode.SCENE3D ? frameState.occluder : undefined;\n  var cullingVolume = frameState.cullingVolume; // get user culling volume minus the far plane.\n\n  var planes = scratchCullingVolume.planes;\n\n  for (var k = 0; k < 5; ++k) {\n    planes[k] = cullingVolume.planes[k];\n  }\n\n  cullingVolume = scratchCullingVolume;\n  var length = commandList.length;\n\n  for (var i = 0; i < length; ++i) {\n    var command = commandList[i];\n    var pass = command.pass;\n\n    if (pass === Pass.COMPUTE) {\n      computeList.push(command);\n    } else if (pass === Pass.OVERLAY) {\n      overlayList.push(command);\n    } else {\n      var commandNear;\n      var commandFar;\n      var boundingVolume = command.boundingVolume;\n\n      if (defined(boundingVolume)) {\n        if (!scene.isVisible(command, cullingVolume, occluder)) {\n          continue;\n        }\n\n        var nearFarInterval = boundingVolume.computePlaneDistances(position, direction, scratchNearFarInterval);\n        commandNear = nearFarInterval.start;\n        commandFar = nearFarInterval.stop;\n        near = Math.min(near, commandNear);\n        far = Math.max(far, commandFar); // Compute a tight near and far plane for commands that receive shadows. This helps compute\n        // good splits for cascaded shadow maps. Ignore commands that exceed the maximum distance.\n        // When moving the camera low LOD globe tiles begin to load, whose bounding volumes\n        // throw off the near/far fitting for the shadow map. Only update for globe tiles that the\n        // camera isn't inside.\n\n        if (shadowsEnabled && command.receiveShadows && commandNear < ShadowMap.MAXIMUM_DISTANCE && !(pass === Pass.GLOBE && commandNear < -100.0 && commandFar > 100.0)) {\n          // Get the smallest bounding volume the camera is near. This is used to place more shadow detail near the object.\n          var size = commandFar - commandNear;\n\n          if (pass !== Pass.GLOBE && commandNear < 100.0) {\n            shadowClosestObjectSize = Math.min(shadowClosestObjectSize, size);\n          }\n\n          shadowNear = Math.min(shadowNear, commandNear);\n          shadowFar = Math.max(shadowFar, commandFar);\n        }\n      } else if (command instanceof ClearCommand) {\n        // Clear commands don't need a bounding volume - just add the clear to all frustums.\n        commandNear = camera.frustum.near;\n        commandFar = camera.frustum.far;\n      } else {\n        // If command has no bounding volume we need to use the camera's\n        // worst-case near and far planes to avoid clipping something important.\n        commandNear = camera.frustum.near;\n        commandFar = camera.frustum.far;\n        near = Math.min(near, commandNear);\n        far = Math.max(far, commandFar);\n      }\n\n      var extent = commandExtents[commandExtentCount];\n\n      if (!defined(extent)) {\n        extent = commandExtents[commandExtentCount] = new CommandExtent();\n      }\n\n      extent.command = command;\n      extent.near = commandNear;\n      extent.far = commandFar;\n      commandExtentCount++;\n    }\n  }\n\n  if (shadowsEnabled) {\n    shadowNear = Math.min(Math.max(shadowNear, camera.frustum.near), camera.frustum.far);\n    shadowFar = Math.max(Math.min(shadowFar, camera.frustum.far), shadowNear);\n  } // Use the computed near and far for shadows\n\n\n  if (shadowsEnabled) {\n    frameState.shadowState.nearPlane = shadowNear;\n    frameState.shadowState.farPlane = shadowFar;\n    frameState.shadowState.closestObjectSize = shadowClosestObjectSize;\n  }\n\n  updateFrustums(this, scene, near, far);\n  var c;\n  var ce;\n\n  for (c = 0; c < commandExtentCount; c++) {\n    ce = commandExtents[c];\n    insertIntoBin(this, scene, ce.command, ce.near, ce.far);\n  } // Dereference old commands\n\n\n  if (commandExtentCount < commandExtentCapacity) {\n    for (c = commandExtentCount; c < commandExtentCapacity; c++) {\n      ce = commandExtents[c];\n\n      if (!defined(ce.command)) {\n        // If the command is undefined, it's assumed that all\n        // subsequent commmands were set to undefined as well,\n        // so no need to loop over them all\n        break;\n      }\n\n      ce.command = undefined;\n    }\n  }\n\n  var numFrustums = frustumCommandsList.length;\n  var frustumSplits = frameState.frustumSplits;\n  frustumSplits.length = numFrustums + 1;\n\n  for (var j = 0; j < numFrustums; ++j) {\n    frustumSplits[j] = frustumCommandsList[j].near;\n\n    if (j === numFrustums - 1) {\n      frustumSplits[j + 1] = frustumCommandsList[j].far;\n    }\n  }\n};\n\nView.prototype.destroy = function () {\n  this.pickFramebuffer = this.pickFramebuffer && this.pickFramebuffer.destroy();\n  this.pickDepthFramebuffer = this.pickDepthFramebuffer && this.pickDepthFramebuffer.destroy();\n  this.sceneFramebuffer = this.sceneFramebuffer && this.sceneFramebuffer.destroy();\n  this.globeDepth = this.globeDepth && this.globeDepth.destroy();\n  this.oit = this.oit && this.oit.destroy();\n  this.globeTranslucencyFramebuffer = this.globeTranslucencyFramebuffer && this.globeTranslucencyFramebuffer.destroy();\n  var i;\n  var length;\n  var pickDepths = this.pickDepths;\n  var debugGlobeDepths = this.debugGlobeDepths;\n  length = pickDepths.length;\n\n  for (i = 0; i < length; ++i) {\n    pickDepths[i].destroy();\n  }\n\n  length = debugGlobeDepths.length;\n\n  for (i = 0; i < length; ++i) {\n    debugGlobeDepths[i].destroy();\n  }\n};\n\nexport default View;","map":{"version":3,"sources":["/home/usuario/davi/thalamus/wms/3dmaptestes/leaflet_cesium/client/node_modules/cesium/Source/Scene/View.js"],"names":["BoundingRectangle","Cartesian3","CullingVolume","defined","getTimestamp","Interval","CesiumMath","Matrix4","ClearCommand","Pass","PassState","Camera","FrustumCommands","GlobeDepth","GlobeTranslucencyFramebuffer","OIT","PickDepthFramebuffer","PickFramebuffer","SceneFramebuffer","SceneMode","ShadowMap","CommandExtent","command","undefined","near","far","View","scene","camera","viewport","context","globeDepth","depthTexture","oit","_useOIT","passState","clone","_cameraClone","_cameraStartFired","_cameraMovedTime","pickFramebuffer","pickDepthFramebuffer","sceneFramebuffer","globeTranslucencyFramebuffer","pickDepths","debugGlobeDepths","frustumCommandsList","debugFrustumStatistics","_commandExtents","scratchPosition0","scratchPosition1","maxComponent","a","b","x","Math","max","abs","y","z","cameraEqual","camera0","camera1","epsilon","scalar","position","multiplyByScalar","equalsEpsilon","direction","up","right","transform","frustum","prototype","checkForCameraUpdates","cameraClone","EPSILON15","moveStart","raiseEvent","cameraEventWaitTime","moveEnd","updateFrustums","view","frameState","farToNearRatio","useLogDepth","logarithmicDepthFarToNearRatio","is2D","mode","SCENE2D","nearToFarDistance2D","EPSILON2","min","numFrustums","ceil","log","length","m","curNear","curFar","pow","frustumCommands","insertIntoBin","commandNear","commandFar","debugShowFrustums","debugOverlappingFrustums","i","pass","index","indices","commands","executeInClosestFrustum","cf","commandsInFrustums","totalCommands","updateDerivedCommands","scratchCullingVolume","scratchNearFarInterval","createPotentiallyVisibleSet","directionWC","positionWC","computeList","_computeCommandList","overlayList","_overlayCommandList","commandList","numberOfFrustums","numberOfPasses","NUMBER_OF_PASSES","n","p","commandExtents","commandExtentCapacity","commandExtentCount","Number","MAX_VALUE","shadowsEnabled","shadowState","shadowNear","shadowFar","shadowClosestObjectSize","occluder","SCENE3D","cullingVolume","planes","k","COMPUTE","push","OVERLAY","boundingVolume","isVisible","nearFarInterval","computePlaneDistances","start","stop","receiveShadows","MAXIMUM_DISTANCE","GLOBE","size","extent","nearPlane","farPlane","closestObjectSize","c","ce","frustumSplits","j","destroy"],"mappings":"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","sourcesContent":["import BoundingRectangle from \"../Core/BoundingRectangle.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport CullingVolume from \"../Core/CullingVolume.js\";\nimport defined from \"../Core/defined.js\";\nimport getTimestamp from \"../Core/getTimestamp.js\";\nimport Interval from \"../Core/Interval.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport ClearCommand from \"../Renderer/ClearCommand.js\";\nimport Pass from \"../Renderer/Pass.js\";\nimport PassState from \"../Renderer/PassState.js\";\nimport Camera from \"./Camera.js\";\nimport FrustumCommands from \"./FrustumCommands.js\";\nimport GlobeDepth from \"./GlobeDepth.js\";\nimport GlobeTranslucencyFramebuffer from \"./GlobeTranslucencyFramebuffer.js\";\nimport OIT from \"./OIT.js\";\nimport PickDepthFramebuffer from \"./PickDepthFramebuffer.js\";\nimport PickFramebuffer from \"./PickFramebuffer.js\";\nimport SceneFramebuffer from \"./SceneFramebuffer.js\";\nimport SceneMode from \"./SceneMode.js\";\nimport ShadowMap from \"./ShadowMap.js\";\n\nfunction CommandExtent() {\n  this.command = undefined;\n  this.near = undefined;\n  this.far = undefined;\n}\n\n/**\n * @private\n */\nfunction View(scene, camera, viewport) {\n  var context = scene.context;\n\n  var globeDepth;\n  if (context.depthTexture) {\n    globeDepth = new GlobeDepth();\n  }\n\n  var oit;\n  if (scene._useOIT && context.depthTexture) {\n    oit = new OIT(context);\n  }\n\n  var passState = new PassState(context);\n  passState.viewport = BoundingRectangle.clone(viewport);\n\n  this.camera = camera;\n  this._cameraClone = Camera.clone(camera);\n  this._cameraStartFired = false;\n  this._cameraMovedTime = undefined;\n\n  this.viewport = viewport;\n  this.passState = passState;\n  this.pickFramebuffer = new PickFramebuffer(context);\n  this.pickDepthFramebuffer = new PickDepthFramebuffer();\n  this.sceneFramebuffer = new SceneFramebuffer();\n  this.globeDepth = globeDepth;\n  this.globeTranslucencyFramebuffer = new GlobeTranslucencyFramebuffer();\n  this.oit = oit;\n  this.pickDepths = [];\n  this.debugGlobeDepths = [];\n  this.frustumCommandsList = [];\n  this.debugFrustumStatistics = undefined;\n\n  // Array of all commands that get rendered into frustums along with their near / far values.\n  // Acts similar to a ManagedArray.\n  this._commandExtents = [];\n}\n\nvar scratchPosition0 = new Cartesian3();\nvar scratchPosition1 = new Cartesian3();\nfunction maxComponent(a, b) {\n  var x = Math.max(Math.abs(a.x), Math.abs(b.x));\n  var y = Math.max(Math.abs(a.y), Math.abs(b.y));\n  var z = Math.max(Math.abs(a.z), Math.abs(b.z));\n  return Math.max(Math.max(x, y), z);\n}\n\nfunction cameraEqual(camera0, camera1, epsilon) {\n  var scalar =\n    1 / Math.max(1, maxComponent(camera0.position, camera1.position));\n  Cartesian3.multiplyByScalar(camera0.position, scalar, scratchPosition0);\n  Cartesian3.multiplyByScalar(camera1.position, scalar, scratchPosition1);\n  return (\n    Cartesian3.equalsEpsilon(scratchPosition0, scratchPosition1, epsilon) &&\n    Cartesian3.equalsEpsilon(camera0.direction, camera1.direction, epsilon) &&\n    Cartesian3.equalsEpsilon(camera0.up, camera1.up, epsilon) &&\n    Cartesian3.equalsEpsilon(camera0.right, camera1.right, epsilon) &&\n    Matrix4.equalsEpsilon(camera0.transform, camera1.transform, epsilon) &&\n    camera0.frustum.equalsEpsilon(camera1.frustum, epsilon)\n  );\n}\n\nView.prototype.checkForCameraUpdates = function (scene) {\n  var camera = this.camera;\n  var cameraClone = this._cameraClone;\n  if (!cameraEqual(camera, cameraClone, CesiumMath.EPSILON15)) {\n    if (!this._cameraStartFired) {\n      camera.moveStart.raiseEvent();\n      this._cameraStartFired = true;\n    }\n    this._cameraMovedTime = getTimestamp();\n    Camera.clone(camera, cameraClone);\n\n    return true;\n  }\n\n  if (\n    this._cameraStartFired &&\n    getTimestamp() - this._cameraMovedTime > scene.cameraEventWaitTime\n  ) {\n    camera.moveEnd.raiseEvent();\n    this._cameraStartFired = false;\n  }\n\n  return false;\n};\n\nfunction updateFrustums(view, scene, near, far) {\n  var frameState = scene.frameState;\n  var camera = frameState.camera;\n  var farToNearRatio = frameState.useLogDepth\n    ? scene.logarithmicDepthFarToNearRatio\n    : scene.farToNearRatio;\n  var is2D = scene.mode === SceneMode.SCENE2D;\n  var nearToFarDistance2D = scene.nearToFarDistance2D;\n\n  // Extend the far plane slightly further to prevent geometry clipping against the far plane.\n  far *= 1.0 + CesiumMath.EPSILON2;\n\n  // The computed near plane must be between the user defined near and far planes.\n  // The computed far plane must between the user defined far and computed near.\n  // This will handle the case where the computed near plane is further than the user defined far plane.\n  near = Math.min(Math.max(near, camera.frustum.near), camera.frustum.far);\n  far = Math.max(Math.min(far, camera.frustum.far), near);\n\n  var numFrustums;\n  if (is2D) {\n    // The multifrustum for 2D is uniformly distributed. To avoid z-fighting in 2D,\n    // the camera is moved to just before the frustum and the frustum depth is scaled\n    // to be in [1.0, nearToFarDistance2D].\n    far = Math.min(far, camera.position.z + scene.nearToFarDistance2D);\n    near = Math.min(near, far);\n    numFrustums = Math.ceil(\n      Math.max(1.0, far - near) / scene.nearToFarDistance2D\n    );\n  } else {\n    // The multifrustum for 3D/CV is non-uniformly distributed.\n    numFrustums = Math.ceil(Math.log(far / near) / Math.log(farToNearRatio));\n  }\n\n  var frustumCommandsList = view.frustumCommandsList;\n  frustumCommandsList.length = numFrustums;\n  for (var m = 0; m < numFrustums; ++m) {\n    var curNear;\n    var curFar;\n\n    if (is2D) {\n      curNear = Math.min(\n        far - nearToFarDistance2D,\n        near + m * nearToFarDistance2D\n      );\n      curFar = Math.min(far, curNear + nearToFarDistance2D);\n    } else {\n      curNear = Math.max(near, Math.pow(farToNearRatio, m) * near);\n      curFar = Math.min(far, farToNearRatio * curNear);\n    }\n    var frustumCommands = frustumCommandsList[m];\n    if (!defined(frustumCommands)) {\n      frustumCommands = frustumCommandsList[m] = new FrustumCommands(\n        curNear,\n        curFar\n      );\n    } else {\n      frustumCommands.near = curNear;\n      frustumCommands.far = curFar;\n    }\n  }\n}\n\nfunction insertIntoBin(view, scene, command, commandNear, commandFar) {\n  if (scene.debugShowFrustums) {\n    command.debugOverlappingFrustums = 0;\n  }\n\n  var frustumCommandsList = view.frustumCommandsList;\n  var length = frustumCommandsList.length;\n\n  for (var i = 0; i < length; ++i) {\n    var frustumCommands = frustumCommandsList[i];\n    var curNear = frustumCommands.near;\n    var curFar = frustumCommands.far;\n\n    if (commandNear > curFar) {\n      continue;\n    }\n\n    if (commandFar < curNear) {\n      break;\n    }\n\n    var pass = command.pass;\n    var index = frustumCommands.indices[pass]++;\n    frustumCommands.commands[pass][index] = command;\n\n    if (scene.debugShowFrustums) {\n      command.debugOverlappingFrustums |= 1 << i;\n    }\n\n    if (command.executeInClosestFrustum) {\n      break;\n    }\n  }\n\n  if (scene.debugShowFrustums) {\n    var cf = view.debugFrustumStatistics.commandsInFrustums;\n    cf[command.debugOverlappingFrustums] = defined(\n      cf[command.debugOverlappingFrustums]\n    )\n      ? cf[command.debugOverlappingFrustums] + 1\n      : 1;\n    ++view.debugFrustumStatistics.totalCommands;\n  }\n\n  scene.updateDerivedCommands(command);\n}\n\nvar scratchCullingVolume = new CullingVolume();\nvar scratchNearFarInterval = new Interval();\n\nView.prototype.createPotentiallyVisibleSet = function (scene) {\n  var frameState = scene.frameState;\n  var camera = frameState.camera;\n  var direction = camera.directionWC;\n  var position = camera.positionWC;\n\n  var computeList = scene._computeCommandList;\n  var overlayList = scene._overlayCommandList;\n  var commandList = frameState.commandList;\n\n  if (scene.debugShowFrustums) {\n    this.debugFrustumStatistics = {\n      totalCommands: 0,\n      commandsInFrustums: {},\n    };\n  }\n\n  var frustumCommandsList = this.frustumCommandsList;\n  var numberOfFrustums = frustumCommandsList.length;\n  var numberOfPasses = Pass.NUMBER_OF_PASSES;\n  for (var n = 0; n < numberOfFrustums; ++n) {\n    for (var p = 0; p < numberOfPasses; ++p) {\n      frustumCommandsList[n].indices[p] = 0;\n    }\n  }\n\n  computeList.length = 0;\n  overlayList.length = 0;\n\n  var commandExtents = this._commandExtents;\n  var commandExtentCapacity = commandExtents.length;\n  var commandExtentCount = 0;\n\n  var near = +Number.MAX_VALUE;\n  var far = -Number.MAX_VALUE;\n\n  var shadowsEnabled = frameState.shadowState.shadowsEnabled;\n  var shadowNear = +Number.MAX_VALUE;\n  var shadowFar = -Number.MAX_VALUE;\n  var shadowClosestObjectSize = Number.MAX_VALUE;\n\n  var occluder =\n    frameState.mode === SceneMode.SCENE3D ? frameState.occluder : undefined;\n  var cullingVolume = frameState.cullingVolume;\n\n  // get user culling volume minus the far plane.\n  var planes = scratchCullingVolume.planes;\n  for (var k = 0; k < 5; ++k) {\n    planes[k] = cullingVolume.planes[k];\n  }\n  cullingVolume = scratchCullingVolume;\n\n  var length = commandList.length;\n  for (var i = 0; i < length; ++i) {\n    var command = commandList[i];\n    var pass = command.pass;\n\n    if (pass === Pass.COMPUTE) {\n      computeList.push(command);\n    } else if (pass === Pass.OVERLAY) {\n      overlayList.push(command);\n    } else {\n      var commandNear;\n      var commandFar;\n\n      var boundingVolume = command.boundingVolume;\n      if (defined(boundingVolume)) {\n        if (!scene.isVisible(command, cullingVolume, occluder)) {\n          continue;\n        }\n\n        var nearFarInterval = boundingVolume.computePlaneDistances(\n          position,\n          direction,\n          scratchNearFarInterval\n        );\n        commandNear = nearFarInterval.start;\n        commandFar = nearFarInterval.stop;\n        near = Math.min(near, commandNear);\n        far = Math.max(far, commandFar);\n\n        // Compute a tight near and far plane for commands that receive shadows. This helps compute\n        // good splits for cascaded shadow maps. Ignore commands that exceed the maximum distance.\n        // When moving the camera low LOD globe tiles begin to load, whose bounding volumes\n        // throw off the near/far fitting for the shadow map. Only update for globe tiles that the\n        // camera isn't inside.\n        if (\n          shadowsEnabled &&\n          command.receiveShadows &&\n          commandNear < ShadowMap.MAXIMUM_DISTANCE &&\n          !(pass === Pass.GLOBE && commandNear < -100.0 && commandFar > 100.0)\n        ) {\n          // Get the smallest bounding volume the camera is near. This is used to place more shadow detail near the object.\n          var size = commandFar - commandNear;\n          if (pass !== Pass.GLOBE && commandNear < 100.0) {\n            shadowClosestObjectSize = Math.min(shadowClosestObjectSize, size);\n          }\n          shadowNear = Math.min(shadowNear, commandNear);\n          shadowFar = Math.max(shadowFar, commandFar);\n        }\n      } else if (command instanceof ClearCommand) {\n        // Clear commands don't need a bounding volume - just add the clear to all frustums.\n        commandNear = camera.frustum.near;\n        commandFar = camera.frustum.far;\n      } else {\n        // If command has no bounding volume we need to use the camera's\n        // worst-case near and far planes to avoid clipping something important.\n        commandNear = camera.frustum.near;\n        commandFar = camera.frustum.far;\n        near = Math.min(near, commandNear);\n        far = Math.max(far, commandFar);\n      }\n\n      var extent = commandExtents[commandExtentCount];\n      if (!defined(extent)) {\n        extent = commandExtents[commandExtentCount] = new CommandExtent();\n      }\n      extent.command = command;\n      extent.near = commandNear;\n      extent.far = commandFar;\n      commandExtentCount++;\n    }\n  }\n\n  if (shadowsEnabled) {\n    shadowNear = Math.min(\n      Math.max(shadowNear, camera.frustum.near),\n      camera.frustum.far\n    );\n    shadowFar = Math.max(Math.min(shadowFar, camera.frustum.far), shadowNear);\n  }\n\n  // Use the computed near and far for shadows\n  if (shadowsEnabled) {\n    frameState.shadowState.nearPlane = shadowNear;\n    frameState.shadowState.farPlane = shadowFar;\n    frameState.shadowState.closestObjectSize = shadowClosestObjectSize;\n  }\n\n  updateFrustums(this, scene, near, far);\n\n  var c;\n  var ce;\n\n  for (c = 0; c < commandExtentCount; c++) {\n    ce = commandExtents[c];\n    insertIntoBin(this, scene, ce.command, ce.near, ce.far);\n  }\n\n  // Dereference old commands\n  if (commandExtentCount < commandExtentCapacity) {\n    for (c = commandExtentCount; c < commandExtentCapacity; c++) {\n      ce = commandExtents[c];\n      if (!defined(ce.command)) {\n        // If the command is undefined, it's assumed that all\n        // subsequent commmands were set to undefined as well,\n        // so no need to loop over them all\n        break;\n      }\n      ce.command = undefined;\n    }\n  }\n\n  var numFrustums = frustumCommandsList.length;\n  var frustumSplits = frameState.frustumSplits;\n  frustumSplits.length = numFrustums + 1;\n  for (var j = 0; j < numFrustums; ++j) {\n    frustumSplits[j] = frustumCommandsList[j].near;\n    if (j === numFrustums - 1) {\n      frustumSplits[j + 1] = frustumCommandsList[j].far;\n    }\n  }\n};\n\nView.prototype.destroy = function () {\n  this.pickFramebuffer = this.pickFramebuffer && this.pickFramebuffer.destroy();\n  this.pickDepthFramebuffer =\n    this.pickDepthFramebuffer && this.pickDepthFramebuffer.destroy();\n  this.sceneFramebuffer =\n    this.sceneFramebuffer && this.sceneFramebuffer.destroy();\n  this.globeDepth = this.globeDepth && this.globeDepth.destroy();\n  this.oit = this.oit && this.oit.destroy();\n  this.globeTranslucencyFramebuffer =\n    this.globeTranslucencyFramebuffer &&\n    this.globeTranslucencyFramebuffer.destroy();\n\n  var i;\n  var length;\n\n  var pickDepths = this.pickDepths;\n  var debugGlobeDepths = this.debugGlobeDepths;\n\n  length = pickDepths.length;\n  for (i = 0; i < length; ++i) {\n    pickDepths[i].destroy();\n  }\n\n  length = debugGlobeDepths.length;\n  for (i = 0; i < length; ++i) {\n    debugGlobeDepths[i].destroy();\n  }\n};\nexport default View;\n"]},"metadata":{},"sourceType":"module"}